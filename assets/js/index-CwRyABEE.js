const __vite__mapDeps=(i,m=__vite__mapDeps,d=(m.f||(m.f=["assets/js/dagre-2BBEFEWP-BpOF0skn.js","assets/js/graph-gNtU06-_.js","assets/js/_baseUniq-Dqp_F468.js","assets/js/layout-DdAOpML2.js","assets/js/_basePickBy-ma-e3TRJ.js","assets/js/clone-B2U_zqWP.js","assets/js/vendor-BNIKZRna.js","assets/js/router-DEK2SYKc.js","assets/js/icons-C1NP5l6E.js","assets/js/markdown-GVWbr1Yw.js","assets/js/c4Diagram-AAMF2YG6-GtbPM5hH.js","assets/js/chunk-OMD6QJNC-CDg8znqD.js","assets/js/flowDiagram-THRYKUMA-DgLyuWgA.js","assets/js/chunk-GLLZNHP4-CFb1FE9I.js","assets/js/chunk-WVR4S24B-BNBVw7O5.js","assets/js/chunk-NRVI72HA-D5UwdMsd.js","assets/js/channel-DMrlAm77.js","assets/js/erDiagram-HZWUO2LU-BMWITxVT.js","assets/js/gitGraphDiagram-OJR772UL-CB-vYJbH.js","assets/js/chunk-ANTBXLJU-DZq-Blde.js","assets/js/chunk-FHKO5MBM-C3vfK8ao.js","assets/js/treemap-75Q7IDZK-Bxo6Yi68.js","assets/js/ganttDiagram-WV7ZQ7D5-B-W60t5T.js","assets/js/linear-C0PoRDTg.js","assets/js/init-zpY4DTin.js","assets/js/defaultLocale-BfO4jui1.js","assets/js/infoDiagram-DDUCL6P7-twrf9TCL.js","assets/js/pieDiagram-DBDJKBY4-CPEP0oyh.js","assets/js/arc-DUetqi-I.js","assets/js/ordinal-X8I8fqLF.js","assets/js/quadrantDiagram-YPSRARAO-BcMz3duU.js","assets/js/xychartDiagram-FDP5SA34-Clf4Ocy3.js","assets/js/requirementDiagram-EGVEC5DT-YwObr2ur.js","assets/js/sequenceDiagram-4MX5Z3NR-D5_lL7Fz.js","assets/js/classDiagram-3BZAVTQC-B7Zc7RLJ.js","assets/js/chunk-JBRWN2VN-Dr-xK_iQ.js","assets/js/classDiagram-v2-QTMF73CY-BB9lJ347.js","assets/js/stateDiagram-UUKSUZ4H-BozWq8CR.js","assets/js/chunk-LXBSTHXV-W-e9BuZA.js","assets/js/stateDiagram-v2-EYPG3UTE-BGW6BVNP.js","assets/js/journeyDiagram-FFXJYRFH-IjGi2LKK.js","assets/js/timeline-definition-3HZDQTIS-BUzYPNGr.js","assets/js/mindmap-definition-LNHGMQRG-RawWWEnU.js","assets/js/cytoscape.esm-DiBT2aey.js","assets/js/kanban-definition-KOZQBZVT-BJ8xaYjA.js","assets/js/sankeyDiagram-HRAUVNP4-BDeioNPw.js","assets/js/diagram-GUPCWM2R-pB1OL14D.js","assets/js/diagram-RP2FKANI-C4L0vT45.js","assets/js/blockDiagram-ZYB65J3Q-lB6y7uq8.js","assets/js/architectureDiagram-KFL7JDKH-LHehzboI.js","assets/js/diagram-4IRLE6MV-Cvf_Eytc.js"])))=>i.map(i=>d[i]);
import { r as requireReact, a as requireReactDom, g as getDefaultExportFromCjs } from './vendor-BNIKZRna.js';
import { r as reactExports, u as useLocation, L as Link, a as useNavigate, R as React, b as useParams, B as BrowserRouter, c as Routes, d as Route } from './router-DEK2SYKc.js';
import { X as X$2, M as Menu, a as Mail, b as MapPin, G as Github, L as Linkedin, E as Eye, c as ExternalLink, H as House, C as ChevronRight, T as Tag, d as Clock } from './icons-C1NP5l6E.js';
import { r as remarkGfm, a as rehypeHighlight, M as Markdown } from './markdown-GVWbr1Yw.js';

true              &&(function polyfill() {
	const relList = document.createElement("link").relList;
	if (relList && relList.supports && relList.supports("modulepreload")) return;
	for (const link of document.querySelectorAll("link[rel=\"modulepreload\"]")) processPreload(link);
	new MutationObserver((mutations) => {
		for (const mutation of mutations) {
			if (mutation.type !== "childList") continue;
			for (const node of mutation.addedNodes) if (node.tagName === "LINK" && node.rel === "modulepreload") processPreload(node);
		}
	}).observe(document, {
		childList: true,
		subtree: true
	});
	function getFetchOpts(link) {
		const fetchOpts = {};
		if (link.integrity) fetchOpts.integrity = link.integrity;
		if (link.referrerPolicy) fetchOpts.referrerPolicy = link.referrerPolicy;
		if (link.crossOrigin === "use-credentials") fetchOpts.credentials = "include";
		else if (link.crossOrigin === "anonymous") fetchOpts.credentials = "omit";
		else fetchOpts.credentials = "same-origin";
		return fetchOpts;
	}
	function processPreload(link) {
		if (link.ep) return;
		link.ep = true;
		const fetchOpts = getFetchOpts(link);
		fetch(link.href, fetchOpts);
	}
}());

var jsxDevRuntime = {exports: {}};

var reactJsxDevRuntime_development = {};

var hasRequiredReactJsxDevRuntime_development;

function requireReactJsxDevRuntime_development () {
	if (hasRequiredReactJsxDevRuntime_development) return reactJsxDevRuntime_development;
	hasRequiredReactJsxDevRuntime_development = 1;
	/**
	 * @license React
	 * react-jsx-dev-runtime.development.js
	 *
	 * Copyright (c) Meta Platforms, Inc. and affiliates.
	 *
	 * This source code is licensed under the MIT license found in the
	 * LICENSE file in the root directory of this source tree.
	 */
	(function() {
	  function getComponentNameFromType(type) {
	    if (null == type) return null;
	    if ("function" === typeof type)
	      return type.$$typeof === REACT_CLIENT_REFERENCE ? null : type.displayName || type.name || null;
	    if ("string" === typeof type) return type;
	    switch (type) {
	      case REACT_FRAGMENT_TYPE:
	        return "Fragment";
	      case REACT_PROFILER_TYPE:
	        return "Profiler";
	      case REACT_STRICT_MODE_TYPE:
	        return "StrictMode";
	      case REACT_SUSPENSE_TYPE:
	        return "Suspense";
	      case REACT_SUSPENSE_LIST_TYPE:
	        return "SuspenseList";
	      case REACT_ACTIVITY_TYPE:
	        return "Activity";
	    }
	    if ("object" === typeof type)
	      switch ("number" === typeof type.tag && console.error(
	        "Received an unexpected object in getComponentNameFromType(). This is likely a bug in React. Please file an issue."
	      ), type.$$typeof) {
	        case REACT_PORTAL_TYPE:
	          return "Portal";
	        case REACT_CONTEXT_TYPE:
	          return (type.displayName || "Context") + ".Provider";
	        case REACT_CONSUMER_TYPE:
	          return (type._context.displayName || "Context") + ".Consumer";
	        case REACT_FORWARD_REF_TYPE:
	          var innerType = type.render;
	          type = type.displayName;
	          type || (type = innerType.displayName || innerType.name || "", type = "" !== type ? "ForwardRef(" + type + ")" : "ForwardRef");
	          return type;
	        case REACT_MEMO_TYPE:
	          return innerType = type.displayName || null, null !== innerType ? innerType : getComponentNameFromType(type.type) || "Memo";
	        case REACT_LAZY_TYPE:
	          innerType = type._payload;
	          type = type._init;
	          try {
	            return getComponentNameFromType(type(innerType));
	          } catch (x) {
	          }
	      }
	    return null;
	  }
	  function testStringCoercion(value) {
	    return "" + value;
	  }
	  function checkKeyStringCoercion(value) {
	    try {
	      testStringCoercion(value);
	      var JSCompiler_inline_result = false;
	    } catch (e) {
	      JSCompiler_inline_result = true;
	    }
	    if (JSCompiler_inline_result) {
	      JSCompiler_inline_result = console;
	      var JSCompiler_temp_const = JSCompiler_inline_result.error;
	      var JSCompiler_inline_result$jscomp$0 = "function" === typeof Symbol && Symbol.toStringTag && value[Symbol.toStringTag] || value.constructor.name || "Object";
	      JSCompiler_temp_const.call(
	        JSCompiler_inline_result,
	        "The provided key is an unsupported type %s. This value must be coerced to a string before using it here.",
	        JSCompiler_inline_result$jscomp$0
	      );
	      return testStringCoercion(value);
	    }
	  }
	  function getTaskName(type) {
	    if (type === REACT_FRAGMENT_TYPE) return "<>";
	    if ("object" === typeof type && null !== type && type.$$typeof === REACT_LAZY_TYPE)
	      return "<...>";
	    try {
	      var name = getComponentNameFromType(type);
	      return name ? "<" + name + ">" : "<...>";
	    } catch (x) {
	      return "<...>";
	    }
	  }
	  function getOwner() {
	    var dispatcher = ReactSharedInternals.A;
	    return null === dispatcher ? null : dispatcher.getOwner();
	  }
	  function UnknownOwner() {
	    return Error("react-stack-top-frame");
	  }
	  function hasValidKey(config) {
	    if (hasOwnProperty.call(config, "key")) {
	      var getter = Object.getOwnPropertyDescriptor(config, "key").get;
	      if (getter && getter.isReactWarning) return false;
	    }
	    return void 0 !== config.key;
	  }
	  function defineKeyPropWarningGetter(props, displayName) {
	    function warnAboutAccessingKey() {
	      specialPropKeyWarningShown || (specialPropKeyWarningShown = true, console.error(
	        "%s: `key` is not a prop. Trying to access it will result in `undefined` being returned. If you need to access the same value within the child component, you should pass it as a different prop. (https://react.dev/link/special-props)",
	        displayName
	      ));
	    }
	    warnAboutAccessingKey.isReactWarning = true;
	    Object.defineProperty(props, "key", {
	      get: warnAboutAccessingKey,
	      configurable: true
	    });
	  }
	  function elementRefGetterWithDeprecationWarning() {
	    var componentName = getComponentNameFromType(this.type);
	    didWarnAboutElementRef[componentName] || (didWarnAboutElementRef[componentName] = true, console.error(
	      "Accessing element.ref was removed in React 19. ref is now a regular prop. It will be removed from the JSX Element type in a future release."
	    ));
	    componentName = this.props.ref;
	    return void 0 !== componentName ? componentName : null;
	  }
	  function ReactElement(type, key, self, source, owner, props, debugStack, debugTask) {
	    self = props.ref;
	    type = {
	      $$typeof: REACT_ELEMENT_TYPE,
	      type,
	      key,
	      props,
	      _owner: owner
	    };
	    null !== (void 0 !== self ? self : null) ? Object.defineProperty(type, "ref", {
	      enumerable: false,
	      get: elementRefGetterWithDeprecationWarning
	    }) : Object.defineProperty(type, "ref", { enumerable: false, value: null });
	    type._store = {};
	    Object.defineProperty(type._store, "validated", {
	      configurable: false,
	      enumerable: false,
	      writable: true,
	      value: 0
	    });
	    Object.defineProperty(type, "_debugInfo", {
	      configurable: false,
	      enumerable: false,
	      writable: true,
	      value: null
	    });
	    Object.defineProperty(type, "_debugStack", {
	      configurable: false,
	      enumerable: false,
	      writable: true,
	      value: debugStack
	    });
	    Object.defineProperty(type, "_debugTask", {
	      configurable: false,
	      enumerable: false,
	      writable: true,
	      value: debugTask
	    });
	    Object.freeze && (Object.freeze(type.props), Object.freeze(type));
	    return type;
	  }
	  function jsxDEVImpl(type, config, maybeKey, isStaticChildren, source, self, debugStack, debugTask) {
	    var children = config.children;
	    if (void 0 !== children)
	      if (isStaticChildren)
	        if (isArrayImpl(children)) {
	          for (isStaticChildren = 0; isStaticChildren < children.length; isStaticChildren++)
	            validateChildKeys(children[isStaticChildren]);
	          Object.freeze && Object.freeze(children);
	        } else
	          console.error(
	            "React.jsx: Static children should always be an array. You are likely explicitly calling React.jsxs or React.jsxDEV. Use the Babel transform instead."
	          );
	      else validateChildKeys(children);
	    if (hasOwnProperty.call(config, "key")) {
	      children = getComponentNameFromType(type);
	      var keys = Object.keys(config).filter(function(k) {
	        return "key" !== k;
	      });
	      isStaticChildren = 0 < keys.length ? "{key: someKey, " + keys.join(": ..., ") + ": ...}" : "{key: someKey}";
	      didWarnAboutKeySpread[children + isStaticChildren] || (keys = 0 < keys.length ? "{" + keys.join(": ..., ") + ": ...}" : "{}", console.error(
	        'A props object containing a "key" prop is being spread into JSX:\n  let props = %s;\n  <%s {...props} />\nReact keys must be passed directly to JSX without using spread:\n  let props = %s;\n  <%s key={someKey} {...props} />',
	        isStaticChildren,
	        children,
	        keys,
	        children
	      ), didWarnAboutKeySpread[children + isStaticChildren] = true);
	    }
	    children = null;
	    void 0 !== maybeKey && (checkKeyStringCoercion(maybeKey), children = "" + maybeKey);
	    hasValidKey(config) && (checkKeyStringCoercion(config.key), children = "" + config.key);
	    if ("key" in config) {
	      maybeKey = {};
	      for (var propName in config)
	        "key" !== propName && (maybeKey[propName] = config[propName]);
	    } else maybeKey = config;
	    children && defineKeyPropWarningGetter(
	      maybeKey,
	      "function" === typeof type ? type.displayName || type.name || "Unknown" : type
	    );
	    return ReactElement(
	      type,
	      children,
	      self,
	      source,
	      getOwner(),
	      maybeKey,
	      debugStack,
	      debugTask
	    );
	  }
	  function validateChildKeys(node) {
	    "object" === typeof node && null !== node && node.$$typeof === REACT_ELEMENT_TYPE && node._store && (node._store.validated = 1);
	  }
	  var React = requireReact(), REACT_ELEMENT_TYPE = Symbol.for("react.transitional.element"), REACT_PORTAL_TYPE = Symbol.for("react.portal"), REACT_FRAGMENT_TYPE = Symbol.for("react.fragment"), REACT_STRICT_MODE_TYPE = Symbol.for("react.strict_mode"), REACT_PROFILER_TYPE = Symbol.for("react.profiler");
	  var REACT_CONSUMER_TYPE = Symbol.for("react.consumer"), REACT_CONTEXT_TYPE = Symbol.for("react.context"), REACT_FORWARD_REF_TYPE = Symbol.for("react.forward_ref"), REACT_SUSPENSE_TYPE = Symbol.for("react.suspense"), REACT_SUSPENSE_LIST_TYPE = Symbol.for("react.suspense_list"), REACT_MEMO_TYPE = Symbol.for("react.memo"), REACT_LAZY_TYPE = Symbol.for("react.lazy"), REACT_ACTIVITY_TYPE = Symbol.for("react.activity"), REACT_CLIENT_REFERENCE = Symbol.for("react.client.reference"), ReactSharedInternals = React.__CLIENT_INTERNALS_DO_NOT_USE_OR_WARN_USERS_THEY_CANNOT_UPGRADE, hasOwnProperty = Object.prototype.hasOwnProperty, isArrayImpl = Array.isArray, createTask = console.createTask ? console.createTask : function() {
	    return null;
	  };
	  React = {
	    react_stack_bottom_frame: function(callStackForError) {
	      return callStackForError();
	    }
	  };
	  var specialPropKeyWarningShown;
	  var didWarnAboutElementRef = {};
	  var unknownOwnerDebugStack = React.react_stack_bottom_frame.bind(
	    React,
	    UnknownOwner
	  )();
	  var unknownOwnerDebugTask = createTask(getTaskName(UnknownOwner));
	  var didWarnAboutKeySpread = {};
	  reactJsxDevRuntime_development.Fragment = REACT_FRAGMENT_TYPE;
	  reactJsxDevRuntime_development.jsxDEV = function(type, config, maybeKey, isStaticChildren, source, self) {
	    var trackActualOwner = 1e4 > ReactSharedInternals.recentlyCreatedOwnerStacks++;
	    return jsxDEVImpl(
	      type,
	      config,
	      maybeKey,
	      isStaticChildren,
	      source,
	      self,
	      trackActualOwner ? Error("react-stack-top-frame") : unknownOwnerDebugStack,
	      trackActualOwner ? createTask(getTaskName(type)) : unknownOwnerDebugTask
	    );
	  };
	})();
	return reactJsxDevRuntime_development;
}

var hasRequiredJsxDevRuntime;

function requireJsxDevRuntime () {
	if (hasRequiredJsxDevRuntime) return jsxDevRuntime.exports;
	hasRequiredJsxDevRuntime = 1;
	{
	  jsxDevRuntime.exports = requireReactJsxDevRuntime_development();
	}
	return jsxDevRuntime.exports;
}

var jsxDevRuntimeExports = requireJsxDevRuntime();

var client = {exports: {}};

var reactDomClient_development = {};

var scheduler = {exports: {}};

var scheduler_development = {};

var hasRequiredScheduler_development;

function requireScheduler_development () {
	if (hasRequiredScheduler_development) return scheduler_development;
	hasRequiredScheduler_development = 1;
	(function (exports) {
		/**
		 * @license React
		 * scheduler.development.js
		 *
		 * Copyright (c) Meta Platforms, Inc. and affiliates.
		 *
		 * This source code is licensed under the MIT license found in the
		 * LICENSE file in the root directory of this source tree.
		 */
		(function() {
		  function performWorkUntilDeadline() {
		    needsPaint = false;
		    if (isMessageLoopRunning) {
		      var currentTime = exports.unstable_now();
		      startTime = currentTime;
		      var hasMoreWork = true;
		      try {
		        a: {
		          isHostCallbackScheduled = false;
		          isHostTimeoutScheduled && (isHostTimeoutScheduled = false, localClearTimeout(taskTimeoutID), taskTimeoutID = -1);
		          isPerformingWork = true;
		          var previousPriorityLevel = currentPriorityLevel;
		          try {
		            b: {
		              advanceTimers(currentTime);
		              for (currentTask = peek(taskQueue); null !== currentTask && !(currentTask.expirationTime > currentTime && shouldYieldToHost()); ) {
		                var callback = currentTask.callback;
		                if ("function" === typeof callback) {
		                  currentTask.callback = null;
		                  currentPriorityLevel = currentTask.priorityLevel;
		                  var continuationCallback = callback(
		                    currentTask.expirationTime <= currentTime
		                  );
		                  currentTime = exports.unstable_now();
		                  if ("function" === typeof continuationCallback) {
		                    currentTask.callback = continuationCallback;
		                    advanceTimers(currentTime);
		                    hasMoreWork = true;
		                    break b;
		                  }
		                  currentTask === peek(taskQueue) && pop(taskQueue);
		                  advanceTimers(currentTime);
		                } else pop(taskQueue);
		                currentTask = peek(taskQueue);
		              }
		              if (null !== currentTask) hasMoreWork = true;
		              else {
		                var firstTimer = peek(timerQueue);
		                null !== firstTimer && requestHostTimeout(
		                  handleTimeout,
		                  firstTimer.startTime - currentTime
		                );
		                hasMoreWork = false;
		              }
		            }
		            break a;
		          } finally {
		            currentTask = null, currentPriorityLevel = previousPriorityLevel, isPerformingWork = false;
		          }
		          hasMoreWork = void 0;
		        }
		      } finally {
		        hasMoreWork ? schedulePerformWorkUntilDeadline() : isMessageLoopRunning = false;
		      }
		    }
		  }
		  function push(heap, node) {
		    var index = heap.length;
		    heap.push(node);
		    a: for (; 0 < index; ) {
		      var parentIndex = index - 1 >>> 1, parent = heap[parentIndex];
		      if (0 < compare(parent, node))
		        heap[parentIndex] = node, heap[index] = parent, index = parentIndex;
		      else break a;
		    }
		  }
		  function peek(heap) {
		    return 0 === heap.length ? null : heap[0];
		  }
		  function pop(heap) {
		    if (0 === heap.length) return null;
		    var first = heap[0], last = heap.pop();
		    if (last !== first) {
		      heap[0] = last;
		      a: for (var index = 0, length = heap.length, halfLength = length >>> 1; index < halfLength; ) {
		        var leftIndex = 2 * (index + 1) - 1, left = heap[leftIndex], rightIndex = leftIndex + 1, right = heap[rightIndex];
		        if (0 > compare(left, last))
		          rightIndex < length && 0 > compare(right, left) ? (heap[index] = right, heap[rightIndex] = last, index = rightIndex) : (heap[index] = left, heap[leftIndex] = last, index = leftIndex);
		        else if (rightIndex < length && 0 > compare(right, last))
		          heap[index] = right, heap[rightIndex] = last, index = rightIndex;
		        else break a;
		      }
		    }
		    return first;
		  }
		  function compare(a, b) {
		    var diff = a.sortIndex - b.sortIndex;
		    return 0 !== diff ? diff : a.id - b.id;
		  }
		  function advanceTimers(currentTime) {
		    for (var timer = peek(timerQueue); null !== timer; ) {
		      if (null === timer.callback) pop(timerQueue);
		      else if (timer.startTime <= currentTime)
		        pop(timerQueue), timer.sortIndex = timer.expirationTime, push(taskQueue, timer);
		      else break;
		      timer = peek(timerQueue);
		    }
		  }
		  function handleTimeout(currentTime) {
		    isHostTimeoutScheduled = false;
		    advanceTimers(currentTime);
		    if (!isHostCallbackScheduled)
		      if (null !== peek(taskQueue))
		        isHostCallbackScheduled = true, isMessageLoopRunning || (isMessageLoopRunning = true, schedulePerformWorkUntilDeadline());
		      else {
		        var firstTimer = peek(timerQueue);
		        null !== firstTimer && requestHostTimeout(
		          handleTimeout,
		          firstTimer.startTime - currentTime
		        );
		      }
		  }
		  function shouldYieldToHost() {
		    return needsPaint ? true : exports.unstable_now() - startTime < frameInterval ? false : true;
		  }
		  function requestHostTimeout(callback, ms) {
		    taskTimeoutID = localSetTimeout(function() {
		      callback(exports.unstable_now());
		    }, ms);
		  }
		  "undefined" !== typeof __REACT_DEVTOOLS_GLOBAL_HOOK__ && "function" === typeof __REACT_DEVTOOLS_GLOBAL_HOOK__.registerInternalModuleStart && __REACT_DEVTOOLS_GLOBAL_HOOK__.registerInternalModuleStart(Error());
		  exports.unstable_now = void 0;
		  if ("object" === typeof performance && "function" === typeof performance.now) {
		    var localPerformance = performance;
		    exports.unstable_now = function() {
		      return localPerformance.now();
		    };
		  } else {
		    var localDate = Date, initialTime = localDate.now();
		    exports.unstable_now = function() {
		      return localDate.now() - initialTime;
		    };
		  }
		  var taskQueue = [], timerQueue = [], taskIdCounter = 1, currentTask = null, currentPriorityLevel = 3, isPerformingWork = false, isHostCallbackScheduled = false, isHostTimeoutScheduled = false, needsPaint = false, localSetTimeout = "function" === typeof setTimeout ? setTimeout : null, localClearTimeout = "function" === typeof clearTimeout ? clearTimeout : null, localSetImmediate = "undefined" !== typeof setImmediate ? setImmediate : null, isMessageLoopRunning = false, taskTimeoutID = -1, frameInterval = 5, startTime = -1;
		  if ("function" === typeof localSetImmediate)
		    var schedulePerformWorkUntilDeadline = function() {
		      localSetImmediate(performWorkUntilDeadline);
		    };
		  else if ("undefined" !== typeof MessageChannel) {
		    var channel = new MessageChannel(), port = channel.port2;
		    channel.port1.onmessage = performWorkUntilDeadline;
		    schedulePerformWorkUntilDeadline = function() {
		      port.postMessage(null);
		    };
		  } else
		    schedulePerformWorkUntilDeadline = function() {
		      localSetTimeout(performWorkUntilDeadline, 0);
		    };
		  exports.unstable_IdlePriority = 5;
		  exports.unstable_ImmediatePriority = 1;
		  exports.unstable_LowPriority = 4;
		  exports.unstable_NormalPriority = 3;
		  exports.unstable_Profiling = null;
		  exports.unstable_UserBlockingPriority = 2;
		  exports.unstable_cancelCallback = function(task) {
		    task.callback = null;
		  };
		  exports.unstable_forceFrameRate = function(fps) {
		    0 > fps || 125 < fps ? console.error(
		      "forceFrameRate takes a positive int between 0 and 125, forcing frame rates higher than 125 fps is not supported"
		    ) : frameInterval = 0 < fps ? Math.floor(1e3 / fps) : 5;
		  };
		  exports.unstable_getCurrentPriorityLevel = function() {
		    return currentPriorityLevel;
		  };
		  exports.unstable_next = function(eventHandler) {
		    switch (currentPriorityLevel) {
		      case 1:
		      case 2:
		      case 3:
		        var priorityLevel = 3;
		        break;
		      default:
		        priorityLevel = currentPriorityLevel;
		    }
		    var previousPriorityLevel = currentPriorityLevel;
		    currentPriorityLevel = priorityLevel;
		    try {
		      return eventHandler();
		    } finally {
		      currentPriorityLevel = previousPriorityLevel;
		    }
		  };
		  exports.unstable_requestPaint = function() {
		    needsPaint = true;
		  };
		  exports.unstable_runWithPriority = function(priorityLevel, eventHandler) {
		    switch (priorityLevel) {
		      case 1:
		      case 2:
		      case 3:
		      case 4:
		      case 5:
		        break;
		      default:
		        priorityLevel = 3;
		    }
		    var previousPriorityLevel = currentPriorityLevel;
		    currentPriorityLevel = priorityLevel;
		    try {
		      return eventHandler();
		    } finally {
		      currentPriorityLevel = previousPriorityLevel;
		    }
		  };
		  exports.unstable_scheduleCallback = function(priorityLevel, callback, options) {
		    var currentTime = exports.unstable_now();
		    "object" === typeof options && null !== options ? (options = options.delay, options = "number" === typeof options && 0 < options ? currentTime + options : currentTime) : options = currentTime;
		    switch (priorityLevel) {
		      case 1:
		        var timeout = -1;
		        break;
		      case 2:
		        timeout = 250;
		        break;
		      case 5:
		        timeout = 1073741823;
		        break;
		      case 4:
		        timeout = 1e4;
		        break;
		      default:
		        timeout = 5e3;
		    }
		    timeout = options + timeout;
		    priorityLevel = {
		      id: taskIdCounter++,
		      callback,
		      priorityLevel,
		      startTime: options,
		      expirationTime: timeout,
		      sortIndex: -1
		    };
		    options > currentTime ? (priorityLevel.sortIndex = options, push(timerQueue, priorityLevel), null === peek(taskQueue) && priorityLevel === peek(timerQueue) && (isHostTimeoutScheduled ? (localClearTimeout(taskTimeoutID), taskTimeoutID = -1) : isHostTimeoutScheduled = true, requestHostTimeout(handleTimeout, options - currentTime))) : (priorityLevel.sortIndex = timeout, push(taskQueue, priorityLevel), isHostCallbackScheduled || isPerformingWork || (isHostCallbackScheduled = true, isMessageLoopRunning || (isMessageLoopRunning = true, schedulePerformWorkUntilDeadline())));
		    return priorityLevel;
		  };
		  exports.unstable_shouldYield = shouldYieldToHost;
		  exports.unstable_wrapCallback = function(callback) {
		    var parentPriorityLevel = currentPriorityLevel;
		    return function() {
		      var previousPriorityLevel = currentPriorityLevel;
		      currentPriorityLevel = parentPriorityLevel;
		      try {
		        return callback.apply(this, arguments);
		      } finally {
		        currentPriorityLevel = previousPriorityLevel;
		      }
		    };
		  };
		  "undefined" !== typeof __REACT_DEVTOOLS_GLOBAL_HOOK__ && "function" === typeof __REACT_DEVTOOLS_GLOBAL_HOOK__.registerInternalModuleStop && __REACT_DEVTOOLS_GLOBAL_HOOK__.registerInternalModuleStop(Error());
		})(); 
	} (scheduler_development));
	return scheduler_development;
}

var hasRequiredScheduler;

function requireScheduler () {
	if (hasRequiredScheduler) return scheduler.exports;
	hasRequiredScheduler = 1;
	{
	  scheduler.exports = requireScheduler_development();
	}
	return scheduler.exports;
}

var hasRequiredReactDomClient_development;

function requireReactDomClient_development () {
	if (hasRequiredReactDomClient_development) return reactDomClient_development;
	hasRequiredReactDomClient_development = 1;
	/**
	 * @license React
	 * react-dom-client.development.js
	 *
	 * Copyright (c) Meta Platforms, Inc. and affiliates.
	 *
	 * This source code is licensed under the MIT license found in the
	 * LICENSE file in the root directory of this source tree.
	 */
	(function() {
	  function findHook(fiber, id) {
	    for (fiber = fiber.memoizedState; null !== fiber && 0 < id; )
	      fiber = fiber.next, id--;
	    return fiber;
	  }
	  function copyWithSetImpl(obj, path, index, value) {
	    if (index >= path.length) return value;
	    var key = path[index], updated = isArrayImpl(obj) ? obj.slice() : assign({}, obj);
	    updated[key] = copyWithSetImpl(obj[key], path, index + 1, value);
	    return updated;
	  }
	  function copyWithRename(obj, oldPath, newPath) {
	    if (oldPath.length !== newPath.length)
	      console.warn("copyWithRename() expects paths of the same length");
	    else {
	      for (var i = 0; i < newPath.length - 1; i++)
	        if (oldPath[i] !== newPath[i]) {
	          console.warn(
	            "copyWithRename() expects paths to be the same except for the deepest key"
	          );
	          return;
	        }
	      return copyWithRenameImpl(obj, oldPath, newPath, 0);
	    }
	  }
	  function copyWithRenameImpl(obj, oldPath, newPath, index) {
	    var oldKey = oldPath[index], updated = isArrayImpl(obj) ? obj.slice() : assign({}, obj);
	    index + 1 === oldPath.length ? (updated[newPath[index]] = updated[oldKey], isArrayImpl(updated) ? updated.splice(oldKey, 1) : delete updated[oldKey]) : updated[oldKey] = copyWithRenameImpl(
	      obj[oldKey],
	      oldPath,
	      newPath,
	      index + 1
	    );
	    return updated;
	  }
	  function copyWithDeleteImpl(obj, path, index) {
	    var key = path[index], updated = isArrayImpl(obj) ? obj.slice() : assign({}, obj);
	    if (index + 1 === path.length)
	      return isArrayImpl(updated) ? updated.splice(key, 1) : delete updated[key], updated;
	    updated[key] = copyWithDeleteImpl(obj[key], path, index + 1);
	    return updated;
	  }
	  function shouldSuspendImpl() {
	    return false;
	  }
	  function shouldErrorImpl() {
	    return null;
	  }
	  function warnForMissingKey() {
	  }
	  function warnInvalidHookAccess() {
	    console.error(
	      "Do not call Hooks inside useEffect(...), useMemo(...), or other built-in Hooks. You can only call Hooks at the top level of your React function. For more information, see https://react.dev/link/rules-of-hooks"
	    );
	  }
	  function warnInvalidContextAccess() {
	    console.error(
	      "Context can only be read while React is rendering. In classes, you can read it in the render method or getDerivedStateFromProps. In function components, you can read it directly in the function body, but not inside Hooks like useReducer() or useMemo()."
	    );
	  }
	  function noop$2() {
	  }
	  function setToSortedString(set) {
	    var array = [];
	    set.forEach(function(value) {
	      array.push(value);
	    });
	    return array.sort().join(", ");
	  }
	  function createFiber(tag, pendingProps, key, mode) {
	    return new FiberNode(tag, pendingProps, key, mode);
	  }
	  function scheduleRoot(root2, element) {
	    root2.context === emptyContextObject && (updateContainerImpl(root2.current, 2, element, root2, null, null), flushSyncWork$1());
	  }
	  function scheduleRefresh(root2, update) {
	    if (null !== resolveFamily) {
	      var staleFamilies = update.staleFamilies;
	      update = update.updatedFamilies;
	      flushPendingEffects();
	      scheduleFibersWithFamiliesRecursively(
	        root2.current,
	        update,
	        staleFamilies
	      );
	      flushSyncWork$1();
	    }
	  }
	  function setRefreshHandler(handler) {
	    resolveFamily = handler;
	  }
	  function isValidContainer(node) {
	    return !(!node || 1 !== node.nodeType && 9 !== node.nodeType && 11 !== node.nodeType);
	  }
	  function getNearestMountedFiber(fiber) {
	    var node = fiber, nearestMounted = fiber;
	    if (fiber.alternate) for (; node.return; ) node = node.return;
	    else {
	      fiber = node;
	      do
	        node = fiber, 0 !== (node.flags & 4098) && (nearestMounted = node.return), fiber = node.return;
	      while (fiber);
	    }
	    return 3 === node.tag ? nearestMounted : null;
	  }
	  function getSuspenseInstanceFromFiber(fiber) {
	    if (13 === fiber.tag) {
	      var suspenseState = fiber.memoizedState;
	      null === suspenseState && (fiber = fiber.alternate, null !== fiber && (suspenseState = fiber.memoizedState));
	      if (null !== suspenseState) return suspenseState.dehydrated;
	    }
	    return null;
	  }
	  function assertIsMounted(fiber) {
	    if (getNearestMountedFiber(fiber) !== fiber)
	      throw Error("Unable to find node on an unmounted component.");
	  }
	  function findCurrentFiberUsingSlowPath(fiber) {
	    var alternate = fiber.alternate;
	    if (!alternate) {
	      alternate = getNearestMountedFiber(fiber);
	      if (null === alternate)
	        throw Error("Unable to find node on an unmounted component.");
	      return alternate !== fiber ? null : fiber;
	    }
	    for (var a = fiber, b = alternate; ; ) {
	      var parentA = a.return;
	      if (null === parentA) break;
	      var parentB = parentA.alternate;
	      if (null === parentB) {
	        b = parentA.return;
	        if (null !== b) {
	          a = b;
	          continue;
	        }
	        break;
	      }
	      if (parentA.child === parentB.child) {
	        for (parentB = parentA.child; parentB; ) {
	          if (parentB === a) return assertIsMounted(parentA), fiber;
	          if (parentB === b) return assertIsMounted(parentA), alternate;
	          parentB = parentB.sibling;
	        }
	        throw Error("Unable to find node on an unmounted component.");
	      }
	      if (a.return !== b.return) a = parentA, b = parentB;
	      else {
	        for (var didFindChild = false, _child = parentA.child; _child; ) {
	          if (_child === a) {
	            didFindChild = true;
	            a = parentA;
	            b = parentB;
	            break;
	          }
	          if (_child === b) {
	            didFindChild = true;
	            b = parentA;
	            a = parentB;
	            break;
	          }
	          _child = _child.sibling;
	        }
	        if (!didFindChild) {
	          for (_child = parentB.child; _child; ) {
	            if (_child === a) {
	              didFindChild = true;
	              a = parentB;
	              b = parentA;
	              break;
	            }
	            if (_child === b) {
	              didFindChild = true;
	              b = parentB;
	              a = parentA;
	              break;
	            }
	            _child = _child.sibling;
	          }
	          if (!didFindChild)
	            throw Error(
	              "Child was not found in either parent set. This indicates a bug in React related to the return pointer. Please file an issue."
	            );
	        }
	      }
	      if (a.alternate !== b)
	        throw Error(
	          "Return fibers should always be each others' alternates. This error is likely caused by a bug in React. Please file an issue."
	        );
	    }
	    if (3 !== a.tag)
	      throw Error("Unable to find node on an unmounted component.");
	    return a.stateNode.current === a ? fiber : alternate;
	  }
	  function findCurrentHostFiberImpl(node) {
	    var tag = node.tag;
	    if (5 === tag || 26 === tag || 27 === tag || 6 === tag) return node;
	    for (node = node.child; null !== node; ) {
	      tag = findCurrentHostFiberImpl(node);
	      if (null !== tag) return tag;
	      node = node.sibling;
	    }
	    return null;
	  }
	  function getIteratorFn(maybeIterable) {
	    if (null === maybeIterable || "object" !== typeof maybeIterable)
	      return null;
	    maybeIterable = MAYBE_ITERATOR_SYMBOL && maybeIterable[MAYBE_ITERATOR_SYMBOL] || maybeIterable["@@iterator"];
	    return "function" === typeof maybeIterable ? maybeIterable : null;
	  }
	  function getComponentNameFromType(type) {
	    if (null == type) return null;
	    if ("function" === typeof type)
	      return type.$$typeof === REACT_CLIENT_REFERENCE ? null : type.displayName || type.name || null;
	    if ("string" === typeof type) return type;
	    switch (type) {
	      case REACT_FRAGMENT_TYPE:
	        return "Fragment";
	      case REACT_PROFILER_TYPE:
	        return "Profiler";
	      case REACT_STRICT_MODE_TYPE:
	        return "StrictMode";
	      case REACT_SUSPENSE_TYPE:
	        return "Suspense";
	      case REACT_SUSPENSE_LIST_TYPE:
	        return "SuspenseList";
	      case REACT_ACTIVITY_TYPE:
	        return "Activity";
	    }
	    if ("object" === typeof type)
	      switch ("number" === typeof type.tag && console.error(
	        "Received an unexpected object in getComponentNameFromType(). This is likely a bug in React. Please file an issue."
	      ), type.$$typeof) {
	        case REACT_PORTAL_TYPE:
	          return "Portal";
	        case REACT_CONTEXT_TYPE:
	          return (type.displayName || "Context") + ".Provider";
	        case REACT_CONSUMER_TYPE:
	          return (type._context.displayName || "Context") + ".Consumer";
	        case REACT_FORWARD_REF_TYPE:
	          var innerType = type.render;
	          type = type.displayName;
	          type || (type = innerType.displayName || innerType.name || "", type = "" !== type ? "ForwardRef(" + type + ")" : "ForwardRef");
	          return type;
	        case REACT_MEMO_TYPE:
	          return innerType = type.displayName || null, null !== innerType ? innerType : getComponentNameFromType(type.type) || "Memo";
	        case REACT_LAZY_TYPE:
	          innerType = type._payload;
	          type = type._init;
	          try {
	            return getComponentNameFromType(type(innerType));
	          } catch (x) {
	          }
	      }
	    return null;
	  }
	  function getComponentNameFromOwner(owner) {
	    return "number" === typeof owner.tag ? getComponentNameFromFiber(owner) : "string" === typeof owner.name ? owner.name : null;
	  }
	  function getComponentNameFromFiber(fiber) {
	    var type = fiber.type;
	    switch (fiber.tag) {
	      case 31:
	        return "Activity";
	      case 24:
	        return "Cache";
	      case 9:
	        return (type._context.displayName || "Context") + ".Consumer";
	      case 10:
	        return (type.displayName || "Context") + ".Provider";
	      case 18:
	        return "DehydratedFragment";
	      case 11:
	        return fiber = type.render, fiber = fiber.displayName || fiber.name || "", type.displayName || ("" !== fiber ? "ForwardRef(" + fiber + ")" : "ForwardRef");
	      case 7:
	        return "Fragment";
	      case 26:
	      case 27:
	      case 5:
	        return type;
	      case 4:
	        return "Portal";
	      case 3:
	        return "Root";
	      case 6:
	        return "Text";
	      case 16:
	        return getComponentNameFromType(type);
	      case 8:
	        return type === REACT_STRICT_MODE_TYPE ? "StrictMode" : "Mode";
	      case 22:
	        return "Offscreen";
	      case 12:
	        return "Profiler";
	      case 21:
	        return "Scope";
	      case 13:
	        return "Suspense";
	      case 19:
	        return "SuspenseList";
	      case 25:
	        return "TracingMarker";
	      case 1:
	      case 0:
	      case 14:
	      case 15:
	        if ("function" === typeof type)
	          return type.displayName || type.name || null;
	        if ("string" === typeof type) return type;
	        break;
	      case 29:
	        type = fiber._debugInfo;
	        if (null != type) {
	          for (var i = type.length - 1; 0 <= i; i--)
	            if ("string" === typeof type[i].name) return type[i].name;
	        }
	        if (null !== fiber.return)
	          return getComponentNameFromFiber(fiber.return);
	    }
	    return null;
	  }
	  function createCursor(defaultValue) {
	    return { current: defaultValue };
	  }
	  function pop(cursor, fiber) {
	    0 > index$jscomp$0 ? console.error("Unexpected pop.") : (fiber !== fiberStack[index$jscomp$0] && console.error("Unexpected Fiber popped."), cursor.current = valueStack[index$jscomp$0], valueStack[index$jscomp$0] = null, fiberStack[index$jscomp$0] = null, index$jscomp$0--);
	  }
	  function push(cursor, value, fiber) {
	    index$jscomp$0++;
	    valueStack[index$jscomp$0] = cursor.current;
	    fiberStack[index$jscomp$0] = fiber;
	    cursor.current = value;
	  }
	  function requiredContext(c) {
	    null === c && console.error(
	      "Expected host context to exist. This error is likely caused by a bug in React. Please file an issue."
	    );
	    return c;
	  }
	  function pushHostContainer(fiber, nextRootInstance) {
	    push(rootInstanceStackCursor, nextRootInstance, fiber);
	    push(contextFiberStackCursor, fiber, fiber);
	    push(contextStackCursor, null, fiber);
	    var nextRootContext = nextRootInstance.nodeType;
	    switch (nextRootContext) {
	      case 9:
	      case 11:
	        nextRootContext = 9 === nextRootContext ? "#document" : "#fragment";
	        nextRootInstance = (nextRootInstance = nextRootInstance.documentElement) ? (nextRootInstance = nextRootInstance.namespaceURI) ? getOwnHostContext(nextRootInstance) : HostContextNamespaceNone : HostContextNamespaceNone;
	        break;
	      default:
	        if (nextRootContext = nextRootInstance.tagName, nextRootInstance = nextRootInstance.namespaceURI)
	          nextRootInstance = getOwnHostContext(nextRootInstance), nextRootInstance = getChildHostContextProd(
	            nextRootInstance,
	            nextRootContext
	          );
	        else
	          switch (nextRootContext) {
	            case "svg":
	              nextRootInstance = HostContextNamespaceSvg;
	              break;
	            case "math":
	              nextRootInstance = HostContextNamespaceMath;
	              break;
	            default:
	              nextRootInstance = HostContextNamespaceNone;
	          }
	    }
	    nextRootContext = nextRootContext.toLowerCase();
	    nextRootContext = updatedAncestorInfoDev(null, nextRootContext);
	    nextRootContext = {
	      context: nextRootInstance,
	      ancestorInfo: nextRootContext
	    };
	    pop(contextStackCursor, fiber);
	    push(contextStackCursor, nextRootContext, fiber);
	  }
	  function popHostContainer(fiber) {
	    pop(contextStackCursor, fiber);
	    pop(contextFiberStackCursor, fiber);
	    pop(rootInstanceStackCursor, fiber);
	  }
	  function getHostContext() {
	    return requiredContext(contextStackCursor.current);
	  }
	  function pushHostContext(fiber) {
	    null !== fiber.memoizedState && push(hostTransitionProviderCursor, fiber, fiber);
	    var context = requiredContext(contextStackCursor.current);
	    var type = fiber.type;
	    var nextContext = getChildHostContextProd(context.context, type);
	    type = updatedAncestorInfoDev(context.ancestorInfo, type);
	    nextContext = { context: nextContext, ancestorInfo: type };
	    context !== nextContext && (push(contextFiberStackCursor, fiber, fiber), push(contextStackCursor, nextContext, fiber));
	  }
	  function popHostContext(fiber) {
	    contextFiberStackCursor.current === fiber && (pop(contextStackCursor, fiber), pop(contextFiberStackCursor, fiber));
	    hostTransitionProviderCursor.current === fiber && (pop(hostTransitionProviderCursor, fiber), HostTransitionContext._currentValue = NotPendingTransition);
	  }
	  function typeName(value) {
	    return "function" === typeof Symbol && Symbol.toStringTag && value[Symbol.toStringTag] || value.constructor.name || "Object";
	  }
	  function willCoercionThrow(value) {
	    try {
	      return testStringCoercion(value), false;
	    } catch (e) {
	      return true;
	    }
	  }
	  function testStringCoercion(value) {
	    return "" + value;
	  }
	  function checkAttributeStringCoercion(value, attributeName) {
	    if (willCoercionThrow(value))
	      return console.error(
	        "The provided `%s` attribute is an unsupported type %s. This value must be coerced to a string before using it here.",
	        attributeName,
	        typeName(value)
	      ), testStringCoercion(value);
	  }
	  function checkCSSPropertyStringCoercion(value, propName) {
	    if (willCoercionThrow(value))
	      return console.error(
	        "The provided `%s` CSS property is an unsupported type %s. This value must be coerced to a string before using it here.",
	        propName,
	        typeName(value)
	      ), testStringCoercion(value);
	  }
	  function checkFormFieldValueStringCoercion(value) {
	    if (willCoercionThrow(value))
	      return console.error(
	        "Form field values (value, checked, defaultValue, or defaultChecked props) must be strings, not %s. This value must be coerced to a string before using it here.",
	        typeName(value)
	      ), testStringCoercion(value);
	  }
	  function injectInternals(internals) {
	    if ("undefined" === typeof __REACT_DEVTOOLS_GLOBAL_HOOK__) return false;
	    var hook = __REACT_DEVTOOLS_GLOBAL_HOOK__;
	    if (hook.isDisabled) return true;
	    if (!hook.supportsFiber)
	      return console.error(
	        "The installed version of React DevTools is too old and will not work with the current version of React. Please update React DevTools. https://react.dev/link/react-devtools"
	      ), true;
	    try {
	      rendererID = hook.inject(internals), injectedHook = hook;
	    } catch (err) {
	      console.error("React instrumentation encountered an error: %s.", err);
	    }
	    return hook.checkDCE ? true : false;
	  }
	  function setIsStrictModeForDevtools(newIsStrictMode) {
	    "function" === typeof log$1 && unstable_setDisableYieldValue(newIsStrictMode);
	    if (injectedHook && "function" === typeof injectedHook.setStrictMode)
	      try {
	        injectedHook.setStrictMode(rendererID, newIsStrictMode);
	      } catch (err) {
	        hasLoggedError || (hasLoggedError = true, console.error(
	          "React instrumentation encountered an error: %s",
	          err
	        ));
	      }
	  }
	  function injectProfilingHooks(profilingHooks) {
	    injectedProfilingHooks = profilingHooks;
	  }
	  function markCommitStopped() {
	    null !== injectedProfilingHooks && "function" === typeof injectedProfilingHooks.markCommitStopped && injectedProfilingHooks.markCommitStopped();
	  }
	  function markComponentRenderStarted(fiber) {
	    null !== injectedProfilingHooks && "function" === typeof injectedProfilingHooks.markComponentRenderStarted && injectedProfilingHooks.markComponentRenderStarted(fiber);
	  }
	  function markComponentRenderStopped() {
	    null !== injectedProfilingHooks && "function" === typeof injectedProfilingHooks.markComponentRenderStopped && injectedProfilingHooks.markComponentRenderStopped();
	  }
	  function markRenderStarted(lanes) {
	    null !== injectedProfilingHooks && "function" === typeof injectedProfilingHooks.markRenderStarted && injectedProfilingHooks.markRenderStarted(lanes);
	  }
	  function markRenderStopped() {
	    null !== injectedProfilingHooks && "function" === typeof injectedProfilingHooks.markRenderStopped && injectedProfilingHooks.markRenderStopped();
	  }
	  function markStateUpdateScheduled(fiber, lane) {
	    null !== injectedProfilingHooks && "function" === typeof injectedProfilingHooks.markStateUpdateScheduled && injectedProfilingHooks.markStateUpdateScheduled(fiber, lane);
	  }
	  function clz32Fallback(x) {
	    x >>>= 0;
	    return 0 === x ? 32 : 31 - (log(x) / LN2 | 0) | 0;
	  }
	  function getLabelForLane(lane) {
	    if (lane & 1) return "SyncHydrationLane";
	    if (lane & 2) return "Sync";
	    if (lane & 4) return "InputContinuousHydration";
	    if (lane & 8) return "InputContinuous";
	    if (lane & 16) return "DefaultHydration";
	    if (lane & 32) return "Default";
	    if (lane & 128) return "TransitionHydration";
	    if (lane & 4194048) return "Transition";
	    if (lane & 62914560) return "Retry";
	    if (lane & 67108864) return "SelectiveHydration";
	    if (lane & 134217728) return "IdleHydration";
	    if (lane & 268435456) return "Idle";
	    if (lane & 536870912) return "Offscreen";
	    if (lane & 1073741824) return "Deferred";
	  }
	  function getHighestPriorityLanes(lanes) {
	    var pendingSyncLanes = lanes & 42;
	    if (0 !== pendingSyncLanes) return pendingSyncLanes;
	    switch (lanes & -lanes) {
	      case 1:
	        return 1;
	      case 2:
	        return 2;
	      case 4:
	        return 4;
	      case 8:
	        return 8;
	      case 16:
	        return 16;
	      case 32:
	        return 32;
	      case 64:
	        return 64;
	      case 128:
	        return 128;
	      case 256:
	      case 512:
	      case 1024:
	      case 2048:
	      case 4096:
	      case 8192:
	      case 16384:
	      case 32768:
	      case 65536:
	      case 131072:
	      case 262144:
	      case 524288:
	      case 1048576:
	      case 2097152:
	        return lanes & 4194048;
	      case 4194304:
	      case 8388608:
	      case 16777216:
	      case 33554432:
	        return lanes & 62914560;
	      case 67108864:
	        return 67108864;
	      case 134217728:
	        return 134217728;
	      case 268435456:
	        return 268435456;
	      case 536870912:
	        return 536870912;
	      case 1073741824:
	        return 0;
	      default:
	        return console.error(
	          "Should have found matching lanes. This is a bug in React."
	        ), lanes;
	    }
	  }
	  function getNextLanes(root2, wipLanes, rootHasPendingCommit) {
	    var pendingLanes = root2.pendingLanes;
	    if (0 === pendingLanes) return 0;
	    var nextLanes = 0, suspendedLanes = root2.suspendedLanes, pingedLanes = root2.pingedLanes;
	    root2 = root2.warmLanes;
	    var nonIdlePendingLanes = pendingLanes & 134217727;
	    0 !== nonIdlePendingLanes ? (pendingLanes = nonIdlePendingLanes & ~suspendedLanes, 0 !== pendingLanes ? nextLanes = getHighestPriorityLanes(pendingLanes) : (pingedLanes &= nonIdlePendingLanes, 0 !== pingedLanes ? nextLanes = getHighestPriorityLanes(pingedLanes) : rootHasPendingCommit || (rootHasPendingCommit = nonIdlePendingLanes & ~root2, 0 !== rootHasPendingCommit && (nextLanes = getHighestPriorityLanes(rootHasPendingCommit))))) : (nonIdlePendingLanes = pendingLanes & ~suspendedLanes, 0 !== nonIdlePendingLanes ? nextLanes = getHighestPriorityLanes(nonIdlePendingLanes) : 0 !== pingedLanes ? nextLanes = getHighestPriorityLanes(pingedLanes) : rootHasPendingCommit || (rootHasPendingCommit = pendingLanes & ~root2, 0 !== rootHasPendingCommit && (nextLanes = getHighestPriorityLanes(rootHasPendingCommit))));
	    return 0 === nextLanes ? 0 : 0 !== wipLanes && wipLanes !== nextLanes && 0 === (wipLanes & suspendedLanes) && (suspendedLanes = nextLanes & -nextLanes, rootHasPendingCommit = wipLanes & -wipLanes, suspendedLanes >= rootHasPendingCommit || 32 === suspendedLanes && 0 !== (rootHasPendingCommit & 4194048)) ? wipLanes : nextLanes;
	  }
	  function checkIfRootIsPrerendering(root2, renderLanes2) {
	    return 0 === (root2.pendingLanes & ~(root2.suspendedLanes & ~root2.pingedLanes) & renderLanes2);
	  }
	  function computeExpirationTime(lane, currentTime) {
	    switch (lane) {
	      case 1:
	      case 2:
	      case 4:
	      case 8:
	      case 64:
	        return currentTime + 250;
	      case 16:
	      case 32:
	      case 128:
	      case 256:
	      case 512:
	      case 1024:
	      case 2048:
	      case 4096:
	      case 8192:
	      case 16384:
	      case 32768:
	      case 65536:
	      case 131072:
	      case 262144:
	      case 524288:
	      case 1048576:
	      case 2097152:
	        return currentTime + 5e3;
	      case 4194304:
	      case 8388608:
	      case 16777216:
	      case 33554432:
	        return -1;
	      case 67108864:
	      case 134217728:
	      case 268435456:
	      case 536870912:
	      case 1073741824:
	        return -1;
	      default:
	        return console.error(
	          "Should have found matching lanes. This is a bug in React."
	        ), -1;
	    }
	  }
	  function claimNextTransitionLane() {
	    var lane = nextTransitionLane;
	    nextTransitionLane <<= 1;
	    0 === (nextTransitionLane & 4194048) && (nextTransitionLane = 256);
	    return lane;
	  }
	  function claimNextRetryLane() {
	    var lane = nextRetryLane;
	    nextRetryLane <<= 1;
	    0 === (nextRetryLane & 62914560) && (nextRetryLane = 4194304);
	    return lane;
	  }
	  function createLaneMap(initial) {
	    for (var laneMap = [], i = 0; 31 > i; i++) laneMap.push(initial);
	    return laneMap;
	  }
	  function markRootUpdated$1(root2, updateLane) {
	    root2.pendingLanes |= updateLane;
	    268435456 !== updateLane && (root2.suspendedLanes = 0, root2.pingedLanes = 0, root2.warmLanes = 0);
	  }
	  function markRootFinished(root2, finishedLanes, remainingLanes, spawnedLane, updatedLanes, suspendedRetryLanes) {
	    var previouslyPendingLanes = root2.pendingLanes;
	    root2.pendingLanes = remainingLanes;
	    root2.suspendedLanes = 0;
	    root2.pingedLanes = 0;
	    root2.warmLanes = 0;
	    root2.expiredLanes &= remainingLanes;
	    root2.entangledLanes &= remainingLanes;
	    root2.errorRecoveryDisabledLanes &= remainingLanes;
	    root2.shellSuspendCounter = 0;
	    var entanglements = root2.entanglements, expirationTimes = root2.expirationTimes, hiddenUpdates = root2.hiddenUpdates;
	    for (remainingLanes = previouslyPendingLanes & ~remainingLanes; 0 < remainingLanes; ) {
	      var index = 31 - clz32(remainingLanes), lane = 1 << index;
	      entanglements[index] = 0;
	      expirationTimes[index] = -1;
	      var hiddenUpdatesForLane = hiddenUpdates[index];
	      if (null !== hiddenUpdatesForLane)
	        for (hiddenUpdates[index] = null, index = 0; index < hiddenUpdatesForLane.length; index++) {
	          var update = hiddenUpdatesForLane[index];
	          null !== update && (update.lane &= -536870913);
	        }
	      remainingLanes &= ~lane;
	    }
	    0 !== spawnedLane && markSpawnedDeferredLane(root2, spawnedLane, 0);
	    0 !== suspendedRetryLanes && 0 === updatedLanes && 0 !== root2.tag && (root2.suspendedLanes |= suspendedRetryLanes & ~(previouslyPendingLanes & ~finishedLanes));
	  }
	  function markSpawnedDeferredLane(root2, spawnedLane, entangledLanes) {
	    root2.pendingLanes |= spawnedLane;
	    root2.suspendedLanes &= ~spawnedLane;
	    var spawnedLaneIndex = 31 - clz32(spawnedLane);
	    root2.entangledLanes |= spawnedLane;
	    root2.entanglements[spawnedLaneIndex] = root2.entanglements[spawnedLaneIndex] | 1073741824 | entangledLanes & 4194090;
	  }
	  function markRootEntangled(root2, entangledLanes) {
	    var rootEntangledLanes = root2.entangledLanes |= entangledLanes;
	    for (root2 = root2.entanglements; rootEntangledLanes; ) {
	      var index = 31 - clz32(rootEntangledLanes), lane = 1 << index;
	      lane & entangledLanes | root2[index] & entangledLanes && (root2[index] |= entangledLanes);
	      rootEntangledLanes &= ~lane;
	    }
	  }
	  function getBumpedLaneForHydrationByLane(lane) {
	    switch (lane) {
	      case 2:
	        lane = 1;
	        break;
	      case 8:
	        lane = 4;
	        break;
	      case 32:
	        lane = 16;
	        break;
	      case 256:
	      case 512:
	      case 1024:
	      case 2048:
	      case 4096:
	      case 8192:
	      case 16384:
	      case 32768:
	      case 65536:
	      case 131072:
	      case 262144:
	      case 524288:
	      case 1048576:
	      case 2097152:
	      case 4194304:
	      case 8388608:
	      case 16777216:
	      case 33554432:
	        lane = 128;
	        break;
	      case 268435456:
	        lane = 134217728;
	        break;
	      default:
	        lane = 0;
	    }
	    return lane;
	  }
	  function addFiberToLanesMap(root2, fiber, lanes) {
	    if (isDevToolsPresent)
	      for (root2 = root2.pendingUpdatersLaneMap; 0 < lanes; ) {
	        var index = 31 - clz32(lanes), lane = 1 << index;
	        root2[index].add(fiber);
	        lanes &= ~lane;
	      }
	  }
	  function movePendingFibersToMemoized(root2, lanes) {
	    if (isDevToolsPresent)
	      for (var pendingUpdatersLaneMap = root2.pendingUpdatersLaneMap, memoizedUpdaters = root2.memoizedUpdaters; 0 < lanes; ) {
	        var index = 31 - clz32(lanes);
	        root2 = 1 << index;
	        index = pendingUpdatersLaneMap[index];
	        0 < index.size && (index.forEach(function(fiber) {
	          var alternate = fiber.alternate;
	          null !== alternate && memoizedUpdaters.has(alternate) || memoizedUpdaters.add(fiber);
	        }), index.clear());
	        lanes &= ~root2;
	      }
	  }
	  function lanesToEventPriority(lanes) {
	    lanes &= -lanes;
	    return DiscreteEventPriority < lanes ? ContinuousEventPriority < lanes ? 0 !== (lanes & 134217727) ? DefaultEventPriority : IdleEventPriority : ContinuousEventPriority : DiscreteEventPriority;
	  }
	  function resolveUpdatePriority() {
	    var updatePriority = ReactDOMSharedInternals.p;
	    if (0 !== updatePriority) return updatePriority;
	    updatePriority = window.event;
	    return void 0 === updatePriority ? DefaultEventPriority : getEventPriority(updatePriority.type);
	  }
	  function runWithPriority(priority, fn) {
	    var previousPriority = ReactDOMSharedInternals.p;
	    try {
	      return ReactDOMSharedInternals.p = priority, fn();
	    } finally {
	      ReactDOMSharedInternals.p = previousPriority;
	    }
	  }
	  function detachDeletedInstance(node) {
	    delete node[internalInstanceKey];
	    delete node[internalPropsKey];
	    delete node[internalEventHandlersKey];
	    delete node[internalEventHandlerListenersKey];
	    delete node[internalEventHandlesSetKey];
	  }
	  function getClosestInstanceFromNode(targetNode) {
	    var targetInst = targetNode[internalInstanceKey];
	    if (targetInst) return targetInst;
	    for (var parentNode = targetNode.parentNode; parentNode; ) {
	      if (targetInst = parentNode[internalContainerInstanceKey] || parentNode[internalInstanceKey]) {
	        parentNode = targetInst.alternate;
	        if (null !== targetInst.child || null !== parentNode && null !== parentNode.child)
	          for (targetNode = getParentSuspenseInstance(targetNode); null !== targetNode; ) {
	            if (parentNode = targetNode[internalInstanceKey])
	              return parentNode;
	            targetNode = getParentSuspenseInstance(targetNode);
	          }
	        return targetInst;
	      }
	      targetNode = parentNode;
	      parentNode = targetNode.parentNode;
	    }
	    return null;
	  }
	  function getInstanceFromNode(node) {
	    if (node = node[internalInstanceKey] || node[internalContainerInstanceKey]) {
	      var tag = node.tag;
	      if (5 === tag || 6 === tag || 13 === tag || 26 === tag || 27 === tag || 3 === tag)
	        return node;
	    }
	    return null;
	  }
	  function getNodeFromInstance(inst) {
	    var tag = inst.tag;
	    if (5 === tag || 26 === tag || 27 === tag || 6 === tag)
	      return inst.stateNode;
	    throw Error("getNodeFromInstance: Invalid argument.");
	  }
	  function getResourcesFromRoot(root2) {
	    var resources = root2[internalRootNodeResourcesKey];
	    resources || (resources = root2[internalRootNodeResourcesKey] = { hoistableStyles: /* @__PURE__ */ new Map(), hoistableScripts: /* @__PURE__ */ new Map() });
	    return resources;
	  }
	  function markNodeAsHoistable(node) {
	    node[internalHoistableMarker] = true;
	  }
	  function registerTwoPhaseEvent(registrationName, dependencies) {
	    registerDirectEvent(registrationName, dependencies);
	    registerDirectEvent(registrationName + "Capture", dependencies);
	  }
	  function registerDirectEvent(registrationName, dependencies) {
	    registrationNameDependencies[registrationName] && console.error(
	      "EventRegistry: More than one plugin attempted to publish the same registration name, `%s`.",
	      registrationName
	    );
	    registrationNameDependencies[registrationName] = dependencies;
	    var lowerCasedName = registrationName.toLowerCase();
	    possibleRegistrationNames[lowerCasedName] = registrationName;
	    "onDoubleClick" === registrationName && (possibleRegistrationNames.ondblclick = registrationName);
	    for (registrationName = 0; registrationName < dependencies.length; registrationName++)
	      allNativeEvents.add(dependencies[registrationName]);
	  }
	  function checkControlledValueProps(tagName, props) {
	    hasReadOnlyValue[props.type] || props.onChange || props.onInput || props.readOnly || props.disabled || null == props.value || ("select" === tagName ? console.error(
	      "You provided a `value` prop to a form field without an `onChange` handler. This will render a read-only field. If the field should be mutable use `defaultValue`. Otherwise, set `onChange`."
	    ) : console.error(
	      "You provided a `value` prop to a form field without an `onChange` handler. This will render a read-only field. If the field should be mutable use `defaultValue`. Otherwise, set either `onChange` or `readOnly`."
	    ));
	    props.onChange || props.readOnly || props.disabled || null == props.checked || console.error(
	      "You provided a `checked` prop to a form field without an `onChange` handler. This will render a read-only field. If the field should be mutable use `defaultChecked`. Otherwise, set either `onChange` or `readOnly`."
	    );
	  }
	  function isAttributeNameSafe(attributeName) {
	    if (hasOwnProperty.call(validatedAttributeNameCache, attributeName))
	      return true;
	    if (hasOwnProperty.call(illegalAttributeNameCache, attributeName))
	      return false;
	    if (VALID_ATTRIBUTE_NAME_REGEX.test(attributeName))
	      return validatedAttributeNameCache[attributeName] = true;
	    illegalAttributeNameCache[attributeName] = true;
	    console.error("Invalid attribute name: `%s`", attributeName);
	    return false;
	  }
	  function getValueForAttributeOnCustomComponent(node, name, expected) {
	    if (isAttributeNameSafe(name)) {
	      if (!node.hasAttribute(name)) {
	        switch (typeof expected) {
	          case "symbol":
	          case "object":
	            return expected;
	          case "function":
	            return expected;
	          case "boolean":
	            if (false === expected) return expected;
	        }
	        return void 0 === expected ? void 0 : null;
	      }
	      node = node.getAttribute(name);
	      if ("" === node && true === expected) return true;
	      checkAttributeStringCoercion(expected, name);
	      return node === "" + expected ? expected : node;
	    }
	  }
	  function setValueForAttribute(node, name, value) {
	    if (isAttributeNameSafe(name))
	      if (null === value) node.removeAttribute(name);
	      else {
	        switch (typeof value) {
	          case "undefined":
	          case "function":
	          case "symbol":
	            node.removeAttribute(name);
	            return;
	          case "boolean":
	            var prefix2 = name.toLowerCase().slice(0, 5);
	            if ("data-" !== prefix2 && "aria-" !== prefix2) {
	              node.removeAttribute(name);
	              return;
	            }
	        }
	        checkAttributeStringCoercion(value, name);
	        node.setAttribute(name, "" + value);
	      }
	  }
	  function setValueForKnownAttribute(node, name, value) {
	    if (null === value) node.removeAttribute(name);
	    else {
	      switch (typeof value) {
	        case "undefined":
	        case "function":
	        case "symbol":
	        case "boolean":
	          node.removeAttribute(name);
	          return;
	      }
	      checkAttributeStringCoercion(value, name);
	      node.setAttribute(name, "" + value);
	    }
	  }
	  function setValueForNamespacedAttribute(node, namespace, name, value) {
	    if (null === value) node.removeAttribute(name);
	    else {
	      switch (typeof value) {
	        case "undefined":
	        case "function":
	        case "symbol":
	        case "boolean":
	          node.removeAttribute(name);
	          return;
	      }
	      checkAttributeStringCoercion(value, name);
	      node.setAttributeNS(namespace, name, "" + value);
	    }
	  }
	  function disabledLog() {
	  }
	  function disableLogs() {
	    if (0 === disabledDepth) {
	      prevLog = console.log;
	      prevInfo = console.info;
	      prevWarn = console.warn;
	      prevError = console.error;
	      prevGroup = console.group;
	      prevGroupCollapsed = console.groupCollapsed;
	      prevGroupEnd = console.groupEnd;
	      var props = {
	        configurable: true,
	        enumerable: true,
	        value: disabledLog,
	        writable: true
	      };
	      Object.defineProperties(console, {
	        info: props,
	        log: props,
	        warn: props,
	        error: props,
	        group: props,
	        groupCollapsed: props,
	        groupEnd: props
	      });
	    }
	    disabledDepth++;
	  }
	  function reenableLogs() {
	    disabledDepth--;
	    if (0 === disabledDepth) {
	      var props = { configurable: true, enumerable: true, writable: true };
	      Object.defineProperties(console, {
	        log: assign({}, props, { value: prevLog }),
	        info: assign({}, props, { value: prevInfo }),
	        warn: assign({}, props, { value: prevWarn }),
	        error: assign({}, props, { value: prevError }),
	        group: assign({}, props, { value: prevGroup }),
	        groupCollapsed: assign({}, props, { value: prevGroupCollapsed }),
	        groupEnd: assign({}, props, { value: prevGroupEnd })
	      });
	    }
	    0 > disabledDepth && console.error(
	      "disabledDepth fell below zero. This is a bug in React. Please file an issue."
	    );
	  }
	  function describeBuiltInComponentFrame(name) {
	    if (void 0 === prefix)
	      try {
	        throw Error();
	      } catch (x) {
	        var match = x.stack.trim().match(/\n( *(at )?)/);
	        prefix = match && match[1] || "";
	        suffix = -1 < x.stack.indexOf("\n    at") ? " (<anonymous>)" : -1 < x.stack.indexOf("@") ? "@unknown:0:0" : "";
	      }
	    return "\n" + prefix + name + suffix;
	  }
	  function describeNativeComponentFrame(fn, construct) {
	    if (!fn || reentry) return "";
	    var frame = componentFrameCache.get(fn);
	    if (void 0 !== frame) return frame;
	    reentry = true;
	    frame = Error.prepareStackTrace;
	    Error.prepareStackTrace = void 0;
	    var previousDispatcher2 = null;
	    previousDispatcher2 = ReactSharedInternals.H;
	    ReactSharedInternals.H = null;
	    disableLogs();
	    try {
	      var RunInRootFrame = {
	        DetermineComponentFrameRoot: function() {
	          try {
	            if (construct) {
	              var Fake = function() {
	                throw Error();
	              };
	              Object.defineProperty(Fake.prototype, "props", {
	                set: function() {
	                  throw Error();
	                }
	              });
	              if ("object" === typeof Reflect && Reflect.construct) {
	                try {
	                  Reflect.construct(Fake, []);
	                } catch (x) {
	                  var control = x;
	                }
	                Reflect.construct(fn, [], Fake);
	              } else {
	                try {
	                  Fake.call();
	                } catch (x$0) {
	                  control = x$0;
	                }
	                fn.call(Fake.prototype);
	              }
	            } else {
	              try {
	                throw Error();
	              } catch (x$1) {
	                control = x$1;
	              }
	              (Fake = fn()) && "function" === typeof Fake.catch && Fake.catch(function() {
	              });
	            }
	          } catch (sample) {
	            if (sample && control && "string" === typeof sample.stack)
	              return [sample.stack, control.stack];
	          }
	          return [null, null];
	        }
	      };
	      RunInRootFrame.DetermineComponentFrameRoot.displayName = "DetermineComponentFrameRoot";
	      var namePropDescriptor = Object.getOwnPropertyDescriptor(
	        RunInRootFrame.DetermineComponentFrameRoot,
	        "name"
	      );
	      namePropDescriptor && namePropDescriptor.configurable && Object.defineProperty(
	        RunInRootFrame.DetermineComponentFrameRoot,
	        "name",
	        { value: "DetermineComponentFrameRoot" }
	      );
	      var _RunInRootFrame$Deter = RunInRootFrame.DetermineComponentFrameRoot(), sampleStack = _RunInRootFrame$Deter[0], controlStack = _RunInRootFrame$Deter[1];
	      if (sampleStack && controlStack) {
	        var sampleLines = sampleStack.split("\n"), controlLines = controlStack.split("\n");
	        for (_RunInRootFrame$Deter = namePropDescriptor = 0; namePropDescriptor < sampleLines.length && !sampleLines[namePropDescriptor].includes(
	          "DetermineComponentFrameRoot"
	        ); )
	          namePropDescriptor++;
	        for (; _RunInRootFrame$Deter < controlLines.length && !controlLines[_RunInRootFrame$Deter].includes(
	          "DetermineComponentFrameRoot"
	        ); )
	          _RunInRootFrame$Deter++;
	        if (namePropDescriptor === sampleLines.length || _RunInRootFrame$Deter === controlLines.length)
	          for (namePropDescriptor = sampleLines.length - 1, _RunInRootFrame$Deter = controlLines.length - 1; 1 <= namePropDescriptor && 0 <= _RunInRootFrame$Deter && sampleLines[namePropDescriptor] !== controlLines[_RunInRootFrame$Deter]; )
	            _RunInRootFrame$Deter--;
	        for (; 1 <= namePropDescriptor && 0 <= _RunInRootFrame$Deter; namePropDescriptor--, _RunInRootFrame$Deter--)
	          if (sampleLines[namePropDescriptor] !== controlLines[_RunInRootFrame$Deter]) {
	            if (1 !== namePropDescriptor || 1 !== _RunInRootFrame$Deter) {
	              do
	                if (namePropDescriptor--, _RunInRootFrame$Deter--, 0 > _RunInRootFrame$Deter || sampleLines[namePropDescriptor] !== controlLines[_RunInRootFrame$Deter]) {
	                  var _frame = "\n" + sampleLines[namePropDescriptor].replace(
	                    " at new ",
	                    " at "
	                  );
	                  fn.displayName && _frame.includes("<anonymous>") && (_frame = _frame.replace("<anonymous>", fn.displayName));
	                  "function" === typeof fn && componentFrameCache.set(fn, _frame);
	                  return _frame;
	                }
	              while (1 <= namePropDescriptor && 0 <= _RunInRootFrame$Deter);
	            }
	            break;
	          }
	      }
	    } finally {
	      reentry = false, ReactSharedInternals.H = previousDispatcher2, reenableLogs(), Error.prepareStackTrace = frame;
	    }
	    sampleLines = (sampleLines = fn ? fn.displayName || fn.name : "") ? describeBuiltInComponentFrame(sampleLines) : "";
	    "function" === typeof fn && componentFrameCache.set(fn, sampleLines);
	    return sampleLines;
	  }
	  function formatOwnerStack(error) {
	    var prevPrepareStackTrace = Error.prepareStackTrace;
	    Error.prepareStackTrace = void 0;
	    error = error.stack;
	    Error.prepareStackTrace = prevPrepareStackTrace;
	    error.startsWith("Error: react-stack-top-frame\n") && (error = error.slice(29));
	    prevPrepareStackTrace = error.indexOf("\n");
	    -1 !== prevPrepareStackTrace && (error = error.slice(prevPrepareStackTrace + 1));
	    prevPrepareStackTrace = error.indexOf("react_stack_bottom_frame");
	    -1 !== prevPrepareStackTrace && (prevPrepareStackTrace = error.lastIndexOf(
	      "\n",
	      prevPrepareStackTrace
	    ));
	    if (-1 !== prevPrepareStackTrace)
	      error = error.slice(0, prevPrepareStackTrace);
	    else return "";
	    return error;
	  }
	  function describeFiber(fiber) {
	    switch (fiber.tag) {
	      case 26:
	      case 27:
	      case 5:
	        return describeBuiltInComponentFrame(fiber.type);
	      case 16:
	        return describeBuiltInComponentFrame("Lazy");
	      case 13:
	        return describeBuiltInComponentFrame("Suspense");
	      case 19:
	        return describeBuiltInComponentFrame("SuspenseList");
	      case 0:
	      case 15:
	        return describeNativeComponentFrame(fiber.type, false);
	      case 11:
	        return describeNativeComponentFrame(fiber.type.render, false);
	      case 1:
	        return describeNativeComponentFrame(fiber.type, true);
	      case 31:
	        return describeBuiltInComponentFrame("Activity");
	      default:
	        return "";
	    }
	  }
	  function getStackByFiberInDevAndProd(workInProgress2) {
	    try {
	      var info = "";
	      do {
	        info += describeFiber(workInProgress2);
	        var debugInfo = workInProgress2._debugInfo;
	        if (debugInfo)
	          for (var i = debugInfo.length - 1; 0 <= i; i--) {
	            var entry = debugInfo[i];
	            if ("string" === typeof entry.name) {
	              var JSCompiler_temp_const = info, env = entry.env;
	              var JSCompiler_inline_result = describeBuiltInComponentFrame(
	                entry.name + (env ? " [" + env + "]" : "")
	              );
	              info = JSCompiler_temp_const + JSCompiler_inline_result;
	            }
	          }
	        workInProgress2 = workInProgress2.return;
	      } while (workInProgress2);
	      return info;
	    } catch (x) {
	      return "\nError generating stack: " + x.message + "\n" + x.stack;
	    }
	  }
	  function describeFunctionComponentFrameWithoutLineNumber(fn) {
	    return (fn = fn ? fn.displayName || fn.name : "") ? describeBuiltInComponentFrame(fn) : "";
	  }
	  function getCurrentFiberOwnerNameInDevOrNull() {
	    if (null === current) return null;
	    var owner = current._debugOwner;
	    return null != owner ? getComponentNameFromOwner(owner) : null;
	  }
	  function getCurrentFiberStackInDev() {
	    if (null === current) return "";
	    var workInProgress2 = current;
	    try {
	      var info = "";
	      6 === workInProgress2.tag && (workInProgress2 = workInProgress2.return);
	      switch (workInProgress2.tag) {
	        case 26:
	        case 27:
	        case 5:
	          info += describeBuiltInComponentFrame(workInProgress2.type);
	          break;
	        case 13:
	          info += describeBuiltInComponentFrame("Suspense");
	          break;
	        case 19:
	          info += describeBuiltInComponentFrame("SuspenseList");
	          break;
	        case 31:
	          info += describeBuiltInComponentFrame("Activity");
	          break;
	        case 30:
	        case 0:
	        case 15:
	        case 1:
	          workInProgress2._debugOwner || "" !== info || (info += describeFunctionComponentFrameWithoutLineNumber(
	            workInProgress2.type
	          ));
	          break;
	        case 11:
	          workInProgress2._debugOwner || "" !== info || (info += describeFunctionComponentFrameWithoutLineNumber(
	            workInProgress2.type.render
	          ));
	      }
	      for (; workInProgress2; )
	        if ("number" === typeof workInProgress2.tag) {
	          var fiber = workInProgress2;
	          workInProgress2 = fiber._debugOwner;
	          var debugStack = fiber._debugStack;
	          workInProgress2 && debugStack && ("string" !== typeof debugStack && (fiber._debugStack = debugStack = formatOwnerStack(debugStack)), "" !== debugStack && (info += "\n" + debugStack));
	        } else if (null != workInProgress2.debugStack) {
	          var ownerStack = workInProgress2.debugStack;
	          (workInProgress2 = workInProgress2.owner) && ownerStack && (info += "\n" + formatOwnerStack(ownerStack));
	        } else break;
	      var JSCompiler_inline_result = info;
	    } catch (x) {
	      JSCompiler_inline_result = "\nError generating stack: " + x.message + "\n" + x.stack;
	    }
	    return JSCompiler_inline_result;
	  }
	  function runWithFiberInDEV(fiber, callback, arg0, arg1, arg2, arg3, arg4) {
	    var previousFiber = current;
	    setCurrentFiber(fiber);
	    try {
	      return null !== fiber && fiber._debugTask ? fiber._debugTask.run(
	        callback.bind(null, arg0, arg1, arg2, arg3, arg4)
	      ) : callback(arg0, arg1, arg2, arg3, arg4);
	    } finally {
	      setCurrentFiber(previousFiber);
	    }
	    throw Error(
	      "runWithFiberInDEV should never be called in production. This is a bug in React."
	    );
	  }
	  function setCurrentFiber(fiber) {
	    ReactSharedInternals.getCurrentStack = null === fiber ? null : getCurrentFiberStackInDev;
	    isRendering = false;
	    current = fiber;
	  }
	  function getToStringValue(value) {
	    switch (typeof value) {
	      case "bigint":
	      case "boolean":
	      case "number":
	      case "string":
	      case "undefined":
	        return value;
	      case "object":
	        return checkFormFieldValueStringCoercion(value), value;
	      default:
	        return "";
	    }
	  }
	  function isCheckable(elem) {
	    var type = elem.type;
	    return (elem = elem.nodeName) && "input" === elem.toLowerCase() && ("checkbox" === type || "radio" === type);
	  }
	  function trackValueOnNode(node) {
	    var valueField = isCheckable(node) ? "checked" : "value", descriptor = Object.getOwnPropertyDescriptor(
	      node.constructor.prototype,
	      valueField
	    );
	    checkFormFieldValueStringCoercion(node[valueField]);
	    var currentValue = "" + node[valueField];
	    if (!node.hasOwnProperty(valueField) && "undefined" !== typeof descriptor && "function" === typeof descriptor.get && "function" === typeof descriptor.set) {
	      var get = descriptor.get, set = descriptor.set;
	      Object.defineProperty(node, valueField, {
	        configurable: true,
	        get: function() {
	          return get.call(this);
	        },
	        set: function(value) {
	          checkFormFieldValueStringCoercion(value);
	          currentValue = "" + value;
	          set.call(this, value);
	        }
	      });
	      Object.defineProperty(node, valueField, {
	        enumerable: descriptor.enumerable
	      });
	      return {
	        getValue: function() {
	          return currentValue;
	        },
	        setValue: function(value) {
	          checkFormFieldValueStringCoercion(value);
	          currentValue = "" + value;
	        },
	        stopTracking: function() {
	          node._valueTracker = null;
	          delete node[valueField];
	        }
	      };
	    }
	  }
	  function track(node) {
	    node._valueTracker || (node._valueTracker = trackValueOnNode(node));
	  }
	  function updateValueIfChanged(node) {
	    if (!node) return false;
	    var tracker = node._valueTracker;
	    if (!tracker) return true;
	    var lastValue = tracker.getValue();
	    var value = "";
	    node && (value = isCheckable(node) ? node.checked ? "true" : "false" : node.value);
	    node = value;
	    return node !== lastValue ? (tracker.setValue(node), true) : false;
	  }
	  function getActiveElement(doc) {
	    doc = doc || ("undefined" !== typeof document ? document : void 0);
	    if ("undefined" === typeof doc) return null;
	    try {
	      return doc.activeElement || doc.body;
	    } catch (e) {
	      return doc.body;
	    }
	  }
	  function escapeSelectorAttributeValueInsideDoubleQuotes(value) {
	    return value.replace(
	      escapeSelectorAttributeValueInsideDoubleQuotesRegex,
	      function(ch) {
	        return "\\" + ch.charCodeAt(0).toString(16) + " ";
	      }
	    );
	  }
	  function validateInputProps(element, props) {
	    void 0 === props.checked || void 0 === props.defaultChecked || didWarnCheckedDefaultChecked || (console.error(
	      "%s contains an input of type %s with both checked and defaultChecked props. Input elements must be either controlled or uncontrolled (specify either the checked prop, or the defaultChecked prop, but not both). Decide between using a controlled or uncontrolled input element and remove one of these props. More info: https://react.dev/link/controlled-components",
	      getCurrentFiberOwnerNameInDevOrNull() || "A component",
	      props.type
	    ), didWarnCheckedDefaultChecked = true);
	    void 0 === props.value || void 0 === props.defaultValue || didWarnValueDefaultValue$1 || (console.error(
	      "%s contains an input of type %s with both value and defaultValue props. Input elements must be either controlled or uncontrolled (specify either the value prop, or the defaultValue prop, but not both). Decide between using a controlled or uncontrolled input element and remove one of these props. More info: https://react.dev/link/controlled-components",
	      getCurrentFiberOwnerNameInDevOrNull() || "A component",
	      props.type
	    ), didWarnValueDefaultValue$1 = true);
	  }
	  function updateInput(element, value, defaultValue, lastDefaultValue, checked, defaultChecked, type, name) {
	    element.name = "";
	    null != type && "function" !== typeof type && "symbol" !== typeof type && "boolean" !== typeof type ? (checkAttributeStringCoercion(type, "type"), element.type = type) : element.removeAttribute("type");
	    if (null != value)
	      if ("number" === type) {
	        if (0 === value && "" === element.value || element.value != value)
	          element.value = "" + getToStringValue(value);
	      } else
	        element.value !== "" + getToStringValue(value) && (element.value = "" + getToStringValue(value));
	    else
	      "submit" !== type && "reset" !== type || element.removeAttribute("value");
	    null != value ? setDefaultValue(element, type, getToStringValue(value)) : null != defaultValue ? setDefaultValue(element, type, getToStringValue(defaultValue)) : null != lastDefaultValue && element.removeAttribute("value");
	    null == checked && null != defaultChecked && (element.defaultChecked = !!defaultChecked);
	    null != checked && (element.checked = checked && "function" !== typeof checked && "symbol" !== typeof checked);
	    null != name && "function" !== typeof name && "symbol" !== typeof name && "boolean" !== typeof name ? (checkAttributeStringCoercion(name, "name"), element.name = "" + getToStringValue(name)) : element.removeAttribute("name");
	  }
	  function initInput(element, value, defaultValue, checked, defaultChecked, type, name, isHydrating2) {
	    null != type && "function" !== typeof type && "symbol" !== typeof type && "boolean" !== typeof type && (checkAttributeStringCoercion(type, "type"), element.type = type);
	    if (null != value || null != defaultValue) {
	      if (!("submit" !== type && "reset" !== type || void 0 !== value && null !== value))
	        return;
	      defaultValue = null != defaultValue ? "" + getToStringValue(defaultValue) : "";
	      value = null != value ? "" + getToStringValue(value) : defaultValue;
	      isHydrating2 || value === element.value || (element.value = value);
	      element.defaultValue = value;
	    }
	    checked = null != checked ? checked : defaultChecked;
	    checked = "function" !== typeof checked && "symbol" !== typeof checked && !!checked;
	    element.checked = isHydrating2 ? element.checked : !!checked;
	    element.defaultChecked = !!checked;
	    null != name && "function" !== typeof name && "symbol" !== typeof name && "boolean" !== typeof name && (checkAttributeStringCoercion(name, "name"), element.name = name);
	  }
	  function setDefaultValue(node, type, value) {
	    "number" === type && getActiveElement(node.ownerDocument) === node || node.defaultValue === "" + value || (node.defaultValue = "" + value);
	  }
	  function validateOptionProps(element, props) {
	    null == props.value && ("object" === typeof props.children && null !== props.children ? React.Children.forEach(props.children, function(child) {
	      null == child || "string" === typeof child || "number" === typeof child || "bigint" === typeof child || didWarnInvalidChild || (didWarnInvalidChild = true, console.error(
	        "Cannot infer the option value of complex children. Pass a `value` prop or use a plain string as children to <option>."
	      ));
	    }) : null == props.dangerouslySetInnerHTML || didWarnInvalidInnerHTML || (didWarnInvalidInnerHTML = true, console.error(
	      "Pass a `value` prop if you set dangerouslyInnerHTML so React knows which value should be selected."
	    )));
	    null == props.selected || didWarnSelectedSetOnOption || (console.error(
	      "Use the `defaultValue` or `value` props on <select> instead of setting `selected` on <option>."
	    ), didWarnSelectedSetOnOption = true);
	  }
	  function getDeclarationErrorAddendum() {
	    var ownerName = getCurrentFiberOwnerNameInDevOrNull();
	    return ownerName ? "\n\nCheck the render method of `" + ownerName + "`." : "";
	  }
	  function updateOptions(node, multiple, propValue, setDefaultSelected) {
	    node = node.options;
	    if (multiple) {
	      multiple = {};
	      for (var i = 0; i < propValue.length; i++)
	        multiple["$" + propValue[i]] = true;
	      for (propValue = 0; propValue < node.length; propValue++)
	        i = multiple.hasOwnProperty("$" + node[propValue].value), node[propValue].selected !== i && (node[propValue].selected = i), i && setDefaultSelected && (node[propValue].defaultSelected = true);
	    } else {
	      propValue = "" + getToStringValue(propValue);
	      multiple = null;
	      for (i = 0; i < node.length; i++) {
	        if (node[i].value === propValue) {
	          node[i].selected = true;
	          setDefaultSelected && (node[i].defaultSelected = true);
	          return;
	        }
	        null !== multiple || node[i].disabled || (multiple = node[i]);
	      }
	      null !== multiple && (multiple.selected = true);
	    }
	  }
	  function validateSelectProps(element, props) {
	    for (element = 0; element < valuePropNames.length; element++) {
	      var propName = valuePropNames[element];
	      if (null != props[propName]) {
	        var propNameIsArray = isArrayImpl(props[propName]);
	        props.multiple && !propNameIsArray ? console.error(
	          "The `%s` prop supplied to <select> must be an array if `multiple` is true.%s",
	          propName,
	          getDeclarationErrorAddendum()
	        ) : !props.multiple && propNameIsArray && console.error(
	          "The `%s` prop supplied to <select> must be a scalar value if `multiple` is false.%s",
	          propName,
	          getDeclarationErrorAddendum()
	        );
	      }
	    }
	    void 0 === props.value || void 0 === props.defaultValue || didWarnValueDefaultValue || (console.error(
	      "Select elements must be either controlled or uncontrolled (specify either the value prop, or the defaultValue prop, but not both). Decide between using a controlled or uncontrolled select element and remove one of these props. More info: https://react.dev/link/controlled-components"
	    ), didWarnValueDefaultValue = true);
	  }
	  function validateTextareaProps(element, props) {
	    void 0 === props.value || void 0 === props.defaultValue || didWarnValDefaultVal || (console.error(
	      "%s contains a textarea with both value and defaultValue props. Textarea elements must be either controlled or uncontrolled (specify either the value prop, or the defaultValue prop, but not both). Decide between using a controlled or uncontrolled textarea and remove one of these props. More info: https://react.dev/link/controlled-components",
	      getCurrentFiberOwnerNameInDevOrNull() || "A component"
	    ), didWarnValDefaultVal = true);
	    null != props.children && null == props.value && console.error(
	      "Use the `defaultValue` or `value` props instead of setting children on <textarea>."
	    );
	  }
	  function updateTextarea(element, value, defaultValue) {
	    if (null != value && (value = "" + getToStringValue(value), value !== element.value && (element.value = value), null == defaultValue)) {
	      element.defaultValue !== value && (element.defaultValue = value);
	      return;
	    }
	    element.defaultValue = null != defaultValue ? "" + getToStringValue(defaultValue) : "";
	  }
	  function initTextarea(element, value, defaultValue, children) {
	    if (null == value) {
	      if (null != children) {
	        if (null != defaultValue)
	          throw Error(
	            "If you supply `defaultValue` on a <textarea>, do not pass children."
	          );
	        if (isArrayImpl(children)) {
	          if (1 < children.length)
	            throw Error("<textarea> can only have at most one child.");
	          children = children[0];
	        }
	        defaultValue = children;
	      }
	      null == defaultValue && (defaultValue = "");
	      value = defaultValue;
	    }
	    defaultValue = getToStringValue(value);
	    element.defaultValue = defaultValue;
	    children = element.textContent;
	    children === defaultValue && "" !== children && null !== children && (element.value = children);
	  }
	  function findNotableNode(node, indent) {
	    return void 0 === node.serverProps && 0 === node.serverTail.length && 1 === node.children.length && 3 < node.distanceFromLeaf && node.distanceFromLeaf > 15 - indent ? findNotableNode(node.children[0], indent) : node;
	  }
	  function indentation(indent) {
	    return "  " + "  ".repeat(indent);
	  }
	  function added(indent) {
	    return "+ " + "  ".repeat(indent);
	  }
	  function removed(indent) {
	    return "- " + "  ".repeat(indent);
	  }
	  function describeFiberType(fiber) {
	    switch (fiber.tag) {
	      case 26:
	      case 27:
	      case 5:
	        return fiber.type;
	      case 16:
	        return "Lazy";
	      case 13:
	        return "Suspense";
	      case 19:
	        return "SuspenseList";
	      case 0:
	      case 15:
	        return fiber = fiber.type, fiber.displayName || fiber.name || null;
	      case 11:
	        return fiber = fiber.type.render, fiber.displayName || fiber.name || null;
	      case 1:
	        return fiber = fiber.type, fiber.displayName || fiber.name || null;
	      default:
	        return null;
	    }
	  }
	  function describeTextNode(content, maxLength) {
	    return needsEscaping.test(content) ? (content = JSON.stringify(content), content.length > maxLength - 2 ? 8 > maxLength ? '{"..."}' : "{" + content.slice(0, maxLength - 7) + '..."}' : "{" + content + "}") : content.length > maxLength ? 5 > maxLength ? '{"..."}' : content.slice(0, maxLength - 3) + "..." : content;
	  }
	  function describeTextDiff(clientText, serverProps, indent) {
	    var maxLength = 120 - 2 * indent;
	    if (null === serverProps)
	      return added(indent) + describeTextNode(clientText, maxLength) + "\n";
	    if ("string" === typeof serverProps) {
	      for (var firstDiff = 0; firstDiff < serverProps.length && firstDiff < clientText.length && serverProps.charCodeAt(firstDiff) === clientText.charCodeAt(firstDiff); firstDiff++) ;
	      firstDiff > maxLength - 8 && 10 < firstDiff && (clientText = "..." + clientText.slice(firstDiff - 8), serverProps = "..." + serverProps.slice(firstDiff - 8));
	      return added(indent) + describeTextNode(clientText, maxLength) + "\n" + removed(indent) + describeTextNode(serverProps, maxLength) + "\n";
	    }
	    return indentation(indent) + describeTextNode(clientText, maxLength) + "\n";
	  }
	  function objectName(object) {
	    return Object.prototype.toString.call(object).replace(/^\[object (.*)\]$/, function(m, p0) {
	      return p0;
	    });
	  }
	  function describeValue(value, maxLength) {
	    switch (typeof value) {
	      case "string":
	        return value = JSON.stringify(value), value.length > maxLength ? 5 > maxLength ? '"..."' : value.slice(0, maxLength - 4) + '..."' : value;
	      case "object":
	        if (null === value) return "null";
	        if (isArrayImpl(value)) return "[...]";
	        if (value.$$typeof === REACT_ELEMENT_TYPE)
	          return (maxLength = getComponentNameFromType(value.type)) ? "<" + maxLength + ">" : "<...>";
	        var name = objectName(value);
	        if ("Object" === name) {
	          name = "";
	          maxLength -= 2;
	          for (var propName in value)
	            if (value.hasOwnProperty(propName)) {
	              var jsonPropName = JSON.stringify(propName);
	              jsonPropName !== '"' + propName + '"' && (propName = jsonPropName);
	              maxLength -= propName.length - 2;
	              jsonPropName = describeValue(
	                value[propName],
	                15 > maxLength ? maxLength : 15
	              );
	              maxLength -= jsonPropName.length;
	              if (0 > maxLength) {
	                name += "" === name ? "..." : ", ...";
	                break;
	              }
	              name += ("" === name ? "" : ",") + propName + ":" + jsonPropName;
	            }
	          return "{" + name + "}";
	        }
	        return name;
	      case "function":
	        return (maxLength = value.displayName || value.name) ? "function " + maxLength : "function";
	      default:
	        return String(value);
	    }
	  }
	  function describePropValue(value, maxLength) {
	    return "string" !== typeof value || needsEscaping.test(value) ? "{" + describeValue(value, maxLength - 2) + "}" : value.length > maxLength - 2 ? 5 > maxLength ? '"..."' : '"' + value.slice(0, maxLength - 5) + '..."' : '"' + value + '"';
	  }
	  function describeExpandedElement(type, props, rowPrefix) {
	    var remainingRowLength = 120 - rowPrefix.length - type.length, properties = [], propName;
	    for (propName in props)
	      if (props.hasOwnProperty(propName) && "children" !== propName) {
	        var propValue = describePropValue(
	          props[propName],
	          120 - rowPrefix.length - propName.length - 1
	        );
	        remainingRowLength -= propName.length + propValue.length + 2;
	        properties.push(propName + "=" + propValue);
	      }
	    return 0 === properties.length ? rowPrefix + "<" + type + ">\n" : 0 < remainingRowLength ? rowPrefix + "<" + type + " " + properties.join(" ") + ">\n" : rowPrefix + "<" + type + "\n" + rowPrefix + "  " + properties.join("\n" + rowPrefix + "  ") + "\n" + rowPrefix + ">\n";
	  }
	  function describePropertiesDiff(clientObject, serverObject, indent) {
	    var properties = "", remainingServerProperties = assign({}, serverObject), propName;
	    for (propName in clientObject)
	      if (clientObject.hasOwnProperty(propName)) {
	        delete remainingServerProperties[propName];
	        var maxLength = 120 - 2 * indent - propName.length - 2, clientPropValue = describeValue(clientObject[propName], maxLength);
	        serverObject.hasOwnProperty(propName) ? (maxLength = describeValue(serverObject[propName], maxLength), properties += added(indent) + propName + ": " + clientPropValue + "\n", properties += removed(indent) + propName + ": " + maxLength + "\n") : properties += added(indent) + propName + ": " + clientPropValue + "\n";
	      }
	    for (var _propName in remainingServerProperties)
	      remainingServerProperties.hasOwnProperty(_propName) && (clientObject = describeValue(
	        remainingServerProperties[_propName],
	        120 - 2 * indent - _propName.length - 2
	      ), properties += removed(indent) + _propName + ": " + clientObject + "\n");
	    return properties;
	  }
	  function describeElementDiff(type, clientProps, serverProps, indent) {
	    var content = "", serverPropNames = /* @__PURE__ */ new Map();
	    for (propName$jscomp$0 in serverProps)
	      serverProps.hasOwnProperty(propName$jscomp$0) && serverPropNames.set(
	        propName$jscomp$0.toLowerCase(),
	        propName$jscomp$0
	      );
	    if (1 === serverPropNames.size && serverPropNames.has("children"))
	      content += describeExpandedElement(
	        type,
	        clientProps,
	        indentation(indent)
	      );
	    else {
	      for (var _propName2 in clientProps)
	        if (clientProps.hasOwnProperty(_propName2) && "children" !== _propName2) {
	          var maxLength$jscomp$0 = 120 - 2 * (indent + 1) - _propName2.length - 1, serverPropName = serverPropNames.get(_propName2.toLowerCase());
	          if (void 0 !== serverPropName) {
	            serverPropNames.delete(_propName2.toLowerCase());
	            var propName$jscomp$0 = clientProps[_propName2];
	            serverPropName = serverProps[serverPropName];
	            var clientPropValue = describePropValue(
	              propName$jscomp$0,
	              maxLength$jscomp$0
	            );
	            maxLength$jscomp$0 = describePropValue(
	              serverPropName,
	              maxLength$jscomp$0
	            );
	            "object" === typeof propName$jscomp$0 && null !== propName$jscomp$0 && "object" === typeof serverPropName && null !== serverPropName && "Object" === objectName(propName$jscomp$0) && "Object" === objectName(serverPropName) && (2 < Object.keys(propName$jscomp$0).length || 2 < Object.keys(serverPropName).length || -1 < clientPropValue.indexOf("...") || -1 < maxLength$jscomp$0.indexOf("...")) ? content += indentation(indent + 1) + _propName2 + "={{\n" + describePropertiesDiff(
	              propName$jscomp$0,
	              serverPropName,
	              indent + 2
	            ) + indentation(indent + 1) + "}}\n" : (content += added(indent + 1) + _propName2 + "=" + clientPropValue + "\n", content += removed(indent + 1) + _propName2 + "=" + maxLength$jscomp$0 + "\n");
	          } else
	            content += indentation(indent + 1) + _propName2 + "=" + describePropValue(clientProps[_propName2], maxLength$jscomp$0) + "\n";
	        }
	      serverPropNames.forEach(function(propName) {
	        if ("children" !== propName) {
	          var maxLength = 120 - 2 * (indent + 1) - propName.length - 1;
	          content += removed(indent + 1) + propName + "=" + describePropValue(serverProps[propName], maxLength) + "\n";
	        }
	      });
	      content = "" === content ? indentation(indent) + "<" + type + ">\n" : indentation(indent) + "<" + type + "\n" + content + indentation(indent) + ">\n";
	    }
	    type = serverProps.children;
	    clientProps = clientProps.children;
	    if ("string" === typeof type || "number" === typeof type || "bigint" === typeof type) {
	      serverPropNames = "";
	      if ("string" === typeof clientProps || "number" === typeof clientProps || "bigint" === typeof clientProps)
	        serverPropNames = "" + clientProps;
	      content += describeTextDiff(serverPropNames, "" + type, indent + 1);
	    } else if ("string" === typeof clientProps || "number" === typeof clientProps || "bigint" === typeof clientProps)
	      content = null == type ? content + describeTextDiff("" + clientProps, null, indent + 1) : content + describeTextDiff("" + clientProps, void 0, indent + 1);
	    return content;
	  }
	  function describeSiblingFiber(fiber, indent) {
	    var type = describeFiberType(fiber);
	    if (null === type) {
	      type = "";
	      for (fiber = fiber.child; fiber; )
	        type += describeSiblingFiber(fiber, indent), fiber = fiber.sibling;
	      return type;
	    }
	    return indentation(indent) + "<" + type + ">\n";
	  }
	  function describeNode(node, indent) {
	    var skipToNode = findNotableNode(node, indent);
	    if (skipToNode !== node && (1 !== node.children.length || node.children[0] !== skipToNode))
	      return indentation(indent) + "...\n" + describeNode(skipToNode, indent + 1);
	    skipToNode = "";
	    var debugInfo = node.fiber._debugInfo;
	    if (debugInfo)
	      for (var i = 0; i < debugInfo.length; i++) {
	        var serverComponentName = debugInfo[i].name;
	        "string" === typeof serverComponentName && (skipToNode += indentation(indent) + "<" + serverComponentName + ">\n", indent++);
	      }
	    debugInfo = "";
	    i = node.fiber.pendingProps;
	    if (6 === node.fiber.tag)
	      debugInfo = describeTextDiff(i, node.serverProps, indent), indent++;
	    else if (serverComponentName = describeFiberType(node.fiber), null !== serverComponentName)
	      if (void 0 === node.serverProps) {
	        debugInfo = indent;
	        var maxLength = 120 - 2 * debugInfo - serverComponentName.length - 2, content = "";
	        for (propName in i)
	          if (i.hasOwnProperty(propName) && "children" !== propName) {
	            var propValue = describePropValue(i[propName], 15);
	            maxLength -= propName.length + propValue.length + 2;
	            if (0 > maxLength) {
	              content += " ...";
	              break;
	            }
	            content += " " + propName + "=" + propValue;
	          }
	        debugInfo = indentation(debugInfo) + "<" + serverComponentName + content + ">\n";
	        indent++;
	      } else
	        null === node.serverProps ? (debugInfo = describeExpandedElement(
	          serverComponentName,
	          i,
	          added(indent)
	        ), indent++) : "string" === typeof node.serverProps ? console.error(
	          "Should not have matched a non HostText fiber to a Text node. This is a bug in React."
	        ) : (debugInfo = describeElementDiff(
	          serverComponentName,
	          i,
	          node.serverProps,
	          indent
	        ), indent++);
	    var propName = "";
	    i = node.fiber.child;
	    for (serverComponentName = 0; i && serverComponentName < node.children.length; )
	      maxLength = node.children[serverComponentName], maxLength.fiber === i ? (propName += describeNode(maxLength, indent), serverComponentName++) : propName += describeSiblingFiber(i, indent), i = i.sibling;
	    i && 0 < node.children.length && (propName += indentation(indent) + "...\n");
	    i = node.serverTail;
	    null === node.serverProps && indent--;
	    for (node = 0; node < i.length; node++)
	      serverComponentName = i[node], propName = "string" === typeof serverComponentName ? propName + (removed(indent) + describeTextNode(serverComponentName, 120 - 2 * indent) + "\n") : propName + describeExpandedElement(
	        serverComponentName.type,
	        serverComponentName.props,
	        removed(indent)
	      );
	    return skipToNode + debugInfo + propName;
	  }
	  function describeDiff(rootNode) {
	    try {
	      return "\n\n" + describeNode(rootNode, 0);
	    } catch (x) {
	      return "";
	    }
	  }
	  function describeAncestors(ancestor, child, props) {
	    for (var fiber = child, node = null, distanceFromLeaf = 0; fiber; )
	      fiber === ancestor && (distanceFromLeaf = 0), node = {
	        fiber,
	        children: null !== node ? [node] : [],
	        serverProps: fiber === child ? props : fiber === ancestor ? null : void 0,
	        serverTail: [],
	        distanceFromLeaf
	      }, distanceFromLeaf++, fiber = fiber.return;
	    return null !== node ? describeDiff(node).replaceAll(/^[+-]/gm, ">") : "";
	  }
	  function updatedAncestorInfoDev(oldInfo, tag) {
	    var ancestorInfo = assign({}, oldInfo || emptyAncestorInfoDev), info = { tag };
	    -1 !== inScopeTags.indexOf(tag) && (ancestorInfo.aTagInScope = null, ancestorInfo.buttonTagInScope = null, ancestorInfo.nobrTagInScope = null);
	    -1 !== buttonScopeTags.indexOf(tag) && (ancestorInfo.pTagInButtonScope = null);
	    -1 !== specialTags.indexOf(tag) && "address" !== tag && "div" !== tag && "p" !== tag && (ancestorInfo.listItemTagAutoclosing = null, ancestorInfo.dlItemTagAutoclosing = null);
	    ancestorInfo.current = info;
	    "form" === tag && (ancestorInfo.formTag = info);
	    "a" === tag && (ancestorInfo.aTagInScope = info);
	    "button" === tag && (ancestorInfo.buttonTagInScope = info);
	    "nobr" === tag && (ancestorInfo.nobrTagInScope = info);
	    "p" === tag && (ancestorInfo.pTagInButtonScope = info);
	    "li" === tag && (ancestorInfo.listItemTagAutoclosing = info);
	    if ("dd" === tag || "dt" === tag)
	      ancestorInfo.dlItemTagAutoclosing = info;
	    "#document" === tag || "html" === tag ? ancestorInfo.containerTagInScope = null : ancestorInfo.containerTagInScope || (ancestorInfo.containerTagInScope = info);
	    null !== oldInfo || "#document" !== tag && "html" !== tag && "body" !== tag ? true === ancestorInfo.implicitRootScope && (ancestorInfo.implicitRootScope = false) : ancestorInfo.implicitRootScope = true;
	    return ancestorInfo;
	  }
	  function isTagValidWithParent(tag, parentTag, implicitRootScope) {
	    switch (parentTag) {
	      case "select":
	        return "hr" === tag || "option" === tag || "optgroup" === tag || "script" === tag || "template" === tag || "#text" === tag;
	      case "optgroup":
	        return "option" === tag || "#text" === tag;
	      case "option":
	        return "#text" === tag;
	      case "tr":
	        return "th" === tag || "td" === tag || "style" === tag || "script" === tag || "template" === tag;
	      case "tbody":
	      case "thead":
	      case "tfoot":
	        return "tr" === tag || "style" === tag || "script" === tag || "template" === tag;
	      case "colgroup":
	        return "col" === tag || "template" === tag;
	      case "table":
	        return "caption" === tag || "colgroup" === tag || "tbody" === tag || "tfoot" === tag || "thead" === tag || "style" === tag || "script" === tag || "template" === tag;
	      case "head":
	        return "base" === tag || "basefont" === tag || "bgsound" === tag || "link" === tag || "meta" === tag || "title" === tag || "noscript" === tag || "noframes" === tag || "style" === tag || "script" === tag || "template" === tag;
	      case "html":
	        if (implicitRootScope) break;
	        return "head" === tag || "body" === tag || "frameset" === tag;
	      case "frameset":
	        return "frame" === tag;
	      case "#document":
	        if (!implicitRootScope) return "html" === tag;
	    }
	    switch (tag) {
	      case "h1":
	      case "h2":
	      case "h3":
	      case "h4":
	      case "h5":
	      case "h6":
	        return "h1" !== parentTag && "h2" !== parentTag && "h3" !== parentTag && "h4" !== parentTag && "h5" !== parentTag && "h6" !== parentTag;
	      case "rp":
	      case "rt":
	        return -1 === impliedEndTags.indexOf(parentTag);
	      case "caption":
	      case "col":
	      case "colgroup":
	      case "frameset":
	      case "frame":
	      case "tbody":
	      case "td":
	      case "tfoot":
	      case "th":
	      case "thead":
	      case "tr":
	        return null == parentTag;
	      case "head":
	        return implicitRootScope || null === parentTag;
	      case "html":
	        return implicitRootScope && "#document" === parentTag || null === parentTag;
	      case "body":
	        return implicitRootScope && ("#document" === parentTag || "html" === parentTag) || null === parentTag;
	    }
	    return true;
	  }
	  function findInvalidAncestorForTag(tag, ancestorInfo) {
	    switch (tag) {
	      case "address":
	      case "article":
	      case "aside":
	      case "blockquote":
	      case "center":
	      case "details":
	      case "dialog":
	      case "dir":
	      case "div":
	      case "dl":
	      case "fieldset":
	      case "figcaption":
	      case "figure":
	      case "footer":
	      case "header":
	      case "hgroup":
	      case "main":
	      case "menu":
	      case "nav":
	      case "ol":
	      case "p":
	      case "section":
	      case "summary":
	      case "ul":
	      case "pre":
	      case "listing":
	      case "table":
	      case "hr":
	      case "xmp":
	      case "h1":
	      case "h2":
	      case "h3":
	      case "h4":
	      case "h5":
	      case "h6":
	        return ancestorInfo.pTagInButtonScope;
	      case "form":
	        return ancestorInfo.formTag || ancestorInfo.pTagInButtonScope;
	      case "li":
	        return ancestorInfo.listItemTagAutoclosing;
	      case "dd":
	      case "dt":
	        return ancestorInfo.dlItemTagAutoclosing;
	      case "button":
	        return ancestorInfo.buttonTagInScope;
	      case "a":
	        return ancestorInfo.aTagInScope;
	      case "nobr":
	        return ancestorInfo.nobrTagInScope;
	    }
	    return null;
	  }
	  function findAncestor(parent, tagName) {
	    for (; parent; ) {
	      switch (parent.tag) {
	        case 5:
	        case 26:
	        case 27:
	          if (parent.type === tagName) return parent;
	      }
	      parent = parent.return;
	    }
	    return null;
	  }
	  function validateDOMNesting(childTag, ancestorInfo) {
	    ancestorInfo = ancestorInfo || emptyAncestorInfoDev;
	    var parentInfo = ancestorInfo.current;
	    ancestorInfo = (parentInfo = isTagValidWithParent(
	      childTag,
	      parentInfo && parentInfo.tag,
	      ancestorInfo.implicitRootScope
	    ) ? null : parentInfo) ? null : findInvalidAncestorForTag(childTag, ancestorInfo);
	    ancestorInfo = parentInfo || ancestorInfo;
	    if (!ancestorInfo) return true;
	    var ancestorTag = ancestorInfo.tag;
	    ancestorInfo = String(!!parentInfo) + "|" + childTag + "|" + ancestorTag;
	    if (didWarn[ancestorInfo]) return false;
	    didWarn[ancestorInfo] = true;
	    var ancestor = (ancestorInfo = current) ? findAncestor(ancestorInfo.return, ancestorTag) : null, ancestorDescription = null !== ancestorInfo && null !== ancestor ? describeAncestors(ancestor, ancestorInfo, null) : "", tagDisplayName = "<" + childTag + ">";
	    parentInfo ? (parentInfo = "", "table" === ancestorTag && "tr" === childTag && (parentInfo += " Add a <tbody>, <thead> or <tfoot> to your code to match the DOM tree generated by the browser."), console.error(
	      "In HTML, %s cannot be a child of <%s>.%s\nThis will cause a hydration error.%s",
	      tagDisplayName,
	      ancestorTag,
	      parentInfo,
	      ancestorDescription
	    )) : console.error(
	      "In HTML, %s cannot be a descendant of <%s>.\nThis will cause a hydration error.%s",
	      tagDisplayName,
	      ancestorTag,
	      ancestorDescription
	    );
	    ancestorInfo && (childTag = ancestorInfo.return, null === ancestor || null === childTag || ancestor === childTag && childTag._debugOwner === ancestorInfo._debugOwner || runWithFiberInDEV(ancestor, function() {
	      console.error(
	        "<%s> cannot contain a nested %s.\nSee this log for the ancestor stack trace.",
	        ancestorTag,
	        tagDisplayName
	      );
	    }));
	    return false;
	  }
	  function validateTextNesting(childText, parentTag, implicitRootScope) {
	    if (implicitRootScope || isTagValidWithParent("#text", parentTag, false))
	      return true;
	    implicitRootScope = "#text|" + parentTag;
	    if (didWarn[implicitRootScope]) return false;
	    didWarn[implicitRootScope] = true;
	    var ancestor = (implicitRootScope = current) ? findAncestor(implicitRootScope, parentTag) : null;
	    implicitRootScope = null !== implicitRootScope && null !== ancestor ? describeAncestors(
	      ancestor,
	      implicitRootScope,
	      6 !== implicitRootScope.tag ? { children: null } : null
	    ) : "";
	    /\S/.test(childText) ? console.error(
	      "In HTML, text nodes cannot be a child of <%s>.\nThis will cause a hydration error.%s",
	      parentTag,
	      implicitRootScope
	    ) : console.error(
	      "In HTML, whitespace text nodes cannot be a child of <%s>. Make sure you don't have any extra whitespace between tags on each line of your source code.\nThis will cause a hydration error.%s",
	      parentTag,
	      implicitRootScope
	    );
	    return false;
	  }
	  function setTextContent(node, text) {
	    if (text) {
	      var firstChild = node.firstChild;
	      if (firstChild && firstChild === node.lastChild && 3 === firstChild.nodeType) {
	        firstChild.nodeValue = text;
	        return;
	      }
	    }
	    node.textContent = text;
	  }
	  function camelize(string) {
	    return string.replace(hyphenPattern, function(_, character) {
	      return character.toUpperCase();
	    });
	  }
	  function setValueForStyle(style2, styleName, value) {
	    var isCustomProperty = 0 === styleName.indexOf("--");
	    isCustomProperty || (-1 < styleName.indexOf("-") ? warnedStyleNames.hasOwnProperty(styleName) && warnedStyleNames[styleName] || (warnedStyleNames[styleName] = true, console.error(
	      "Unsupported style property %s. Did you mean %s?",
	      styleName,
	      camelize(styleName.replace(msPattern, "ms-"))
	    )) : badVendoredStyleNamePattern.test(styleName) ? warnedStyleNames.hasOwnProperty(styleName) && warnedStyleNames[styleName] || (warnedStyleNames[styleName] = true, console.error(
	      "Unsupported vendor-prefixed style property %s. Did you mean %s?",
	      styleName,
	      styleName.charAt(0).toUpperCase() + styleName.slice(1)
	    )) : !badStyleValueWithSemicolonPattern.test(value) || warnedStyleValues.hasOwnProperty(value) && warnedStyleValues[value] || (warnedStyleValues[value] = true, console.error(
	      `Style property values shouldn't contain a semicolon. Try "%s: %s" instead.`,
	      styleName,
	      value.replace(badStyleValueWithSemicolonPattern, "")
	    )), "number" === typeof value && (isNaN(value) ? warnedForNaNValue || (warnedForNaNValue = true, console.error(
	      "`NaN` is an invalid value for the `%s` css style property.",
	      styleName
	    )) : isFinite(value) || warnedForInfinityValue || (warnedForInfinityValue = true, console.error(
	      "`Infinity` is an invalid value for the `%s` css style property.",
	      styleName
	    ))));
	    null == value || "boolean" === typeof value || "" === value ? isCustomProperty ? style2.setProperty(styleName, "") : "float" === styleName ? style2.cssFloat = "" : style2[styleName] = "" : isCustomProperty ? style2.setProperty(styleName, value) : "number" !== typeof value || 0 === value || unitlessNumbers.has(styleName) ? "float" === styleName ? style2.cssFloat = value : (checkCSSPropertyStringCoercion(value, styleName), style2[styleName] = ("" + value).trim()) : style2[styleName] = value + "px";
	  }
	  function setValueForStyles(node, styles, prevStyles) {
	    if (null != styles && "object" !== typeof styles)
	      throw Error(
	        "The `style` prop expects a mapping from style properties to values, not a string. For example, style={{marginRight: spacing + 'em'}} when using JSX."
	      );
	    styles && Object.freeze(styles);
	    node = node.style;
	    if (null != prevStyles) {
	      if (styles) {
	        var expandedUpdates = {};
	        if (prevStyles) {
	          for (var key in prevStyles)
	            if (prevStyles.hasOwnProperty(key) && !styles.hasOwnProperty(key))
	              for (var longhands = shorthandToLonghand[key] || [key], i = 0; i < longhands.length; i++)
	                expandedUpdates[longhands[i]] = key;
	        }
	        for (var _key in styles)
	          if (styles.hasOwnProperty(_key) && (!prevStyles || prevStyles[_key] !== styles[_key]))
	            for (key = shorthandToLonghand[_key] || [_key], longhands = 0; longhands < key.length; longhands++)
	              expandedUpdates[key[longhands]] = _key;
	        _key = {};
	        for (var key$jscomp$0 in styles)
	          for (key = shorthandToLonghand[key$jscomp$0] || [key$jscomp$0], longhands = 0; longhands < key.length; longhands++)
	            _key[key[longhands]] = key$jscomp$0;
	        key$jscomp$0 = {};
	        for (var _key2 in expandedUpdates)
	          if (key = expandedUpdates[_key2], (longhands = _key[_key2]) && key !== longhands && (i = key + "," + longhands, !key$jscomp$0[i])) {
	            key$jscomp$0[i] = true;
	            i = console;
	            var value = styles[key];
	            i.error.call(
	              i,
	              "%s a style property during rerender (%s) when a conflicting property is set (%s) can lead to styling bugs. To avoid this, don't mix shorthand and non-shorthand properties for the same value; instead, replace the shorthand with separate values.",
	              null == value || "boolean" === typeof value || "" === value ? "Removing" : "Updating",
	              key,
	              longhands
	            );
	          }
	      }
	      for (var styleName in prevStyles)
	        !prevStyles.hasOwnProperty(styleName) || null != styles && styles.hasOwnProperty(styleName) || (0 === styleName.indexOf("--") ? node.setProperty(styleName, "") : "float" === styleName ? node.cssFloat = "" : node[styleName] = "");
	      for (var _styleName in styles)
	        _key2 = styles[_styleName], styles.hasOwnProperty(_styleName) && prevStyles[_styleName] !== _key2 && setValueForStyle(node, _styleName, _key2);
	    } else
	      for (expandedUpdates in styles)
	        styles.hasOwnProperty(expandedUpdates) && setValueForStyle(node, expandedUpdates, styles[expandedUpdates]);
	  }
	  function isCustomElement(tagName) {
	    if (-1 === tagName.indexOf("-")) return false;
	    switch (tagName) {
	      case "annotation-xml":
	      case "color-profile":
	      case "font-face":
	      case "font-face-src":
	      case "font-face-uri":
	      case "font-face-format":
	      case "font-face-name":
	      case "missing-glyph":
	        return false;
	      default:
	        return true;
	    }
	  }
	  function getAttributeAlias(name) {
	    return aliases.get(name) || name;
	  }
	  function validateProperty$1(tagName, name) {
	    if (hasOwnProperty.call(warnedProperties$1, name) && warnedProperties$1[name])
	      return true;
	    if (rARIACamel$1.test(name)) {
	      tagName = "aria-" + name.slice(4).toLowerCase();
	      tagName = ariaProperties.hasOwnProperty(tagName) ? tagName : null;
	      if (null == tagName)
	        return console.error(
	          "Invalid ARIA attribute `%s`. ARIA attributes follow the pattern aria-* and must be lowercase.",
	          name
	        ), warnedProperties$1[name] = true;
	      if (name !== tagName)
	        return console.error(
	          "Invalid ARIA attribute `%s`. Did you mean `%s`?",
	          name,
	          tagName
	        ), warnedProperties$1[name] = true;
	    }
	    if (rARIA$1.test(name)) {
	      tagName = name.toLowerCase();
	      tagName = ariaProperties.hasOwnProperty(tagName) ? tagName : null;
	      if (null == tagName) return warnedProperties$1[name] = true, false;
	      name !== tagName && (console.error(
	        "Unknown ARIA attribute `%s`. Did you mean `%s`?",
	        name,
	        tagName
	      ), warnedProperties$1[name] = true);
	    }
	    return true;
	  }
	  function validateProperties$2(type, props) {
	    var invalidProps = [], key;
	    for (key in props)
	      validateProperty$1(type, key) || invalidProps.push(key);
	    props = invalidProps.map(function(prop) {
	      return "`" + prop + "`";
	    }).join(", ");
	    1 === invalidProps.length ? console.error(
	      "Invalid aria prop %s on <%s> tag. For details, see https://react.dev/link/invalid-aria-props",
	      props,
	      type
	    ) : 1 < invalidProps.length && console.error(
	      "Invalid aria props %s on <%s> tag. For details, see https://react.dev/link/invalid-aria-props",
	      props,
	      type
	    );
	  }
	  function validateProperty(tagName, name, value, eventRegistry) {
	    if (hasOwnProperty.call(warnedProperties, name) && warnedProperties[name])
	      return true;
	    var lowerCasedName = name.toLowerCase();
	    if ("onfocusin" === lowerCasedName || "onfocusout" === lowerCasedName)
	      return console.error(
	        "React uses onFocus and onBlur instead of onFocusIn and onFocusOut. All React events are normalized to bubble, so onFocusIn and onFocusOut are not needed/supported by React."
	      ), warnedProperties[name] = true;
	    if ("function" === typeof value && ("form" === tagName && "action" === name || "input" === tagName && "formAction" === name || "button" === tagName && "formAction" === name))
	      return true;
	    if (null != eventRegistry) {
	      tagName = eventRegistry.possibleRegistrationNames;
	      if (eventRegistry.registrationNameDependencies.hasOwnProperty(name))
	        return true;
	      eventRegistry = tagName.hasOwnProperty(lowerCasedName) ? tagName[lowerCasedName] : null;
	      if (null != eventRegistry)
	        return console.error(
	          "Invalid event handler property `%s`. Did you mean `%s`?",
	          name,
	          eventRegistry
	        ), warnedProperties[name] = true;
	      if (EVENT_NAME_REGEX.test(name))
	        return console.error(
	          "Unknown event handler property `%s`. It will be ignored.",
	          name
	        ), warnedProperties[name] = true;
	    } else if (EVENT_NAME_REGEX.test(name))
	      return INVALID_EVENT_NAME_REGEX.test(name) && console.error(
	        "Invalid event handler property `%s`. React events use the camelCase naming convention, for example `onClick`.",
	        name
	      ), warnedProperties[name] = true;
	    if (rARIA.test(name) || rARIACamel.test(name)) return true;
	    if ("innerhtml" === lowerCasedName)
	      return console.error(
	        "Directly setting property `innerHTML` is not permitted. For more information, lookup documentation on `dangerouslySetInnerHTML`."
	      ), warnedProperties[name] = true;
	    if ("aria" === lowerCasedName)
	      return console.error(
	        "The `aria` attribute is reserved for future use in React. Pass individual `aria-` attributes instead."
	      ), warnedProperties[name] = true;
	    if ("is" === lowerCasedName && null !== value && void 0 !== value && "string" !== typeof value)
	      return console.error(
	        "Received a `%s` for a string attribute `is`. If this is expected, cast the value to a string.",
	        typeof value
	      ), warnedProperties[name] = true;
	    if ("number" === typeof value && isNaN(value))
	      return console.error(
	        "Received NaN for the `%s` attribute. If this is expected, cast the value to a string.",
	        name
	      ), warnedProperties[name] = true;
	    if (possibleStandardNames.hasOwnProperty(lowerCasedName)) {
	      if (lowerCasedName = possibleStandardNames[lowerCasedName], lowerCasedName !== name)
	        return console.error(
	          "Invalid DOM property `%s`. Did you mean `%s`?",
	          name,
	          lowerCasedName
	        ), warnedProperties[name] = true;
	    } else if (name !== lowerCasedName)
	      return console.error(
	        "React does not recognize the `%s` prop on a DOM element. If you intentionally want it to appear in the DOM as a custom attribute, spell it as lowercase `%s` instead. If you accidentally passed it from a parent component, remove it from the DOM element.",
	        name,
	        lowerCasedName
	      ), warnedProperties[name] = true;
	    switch (name) {
	      case "dangerouslySetInnerHTML":
	      case "children":
	      case "style":
	      case "suppressContentEditableWarning":
	      case "suppressHydrationWarning":
	      case "defaultValue":
	      case "defaultChecked":
	      case "innerHTML":
	      case "ref":
	        return true;
	      case "innerText":
	      case "textContent":
	        return true;
	    }
	    switch (typeof value) {
	      case "boolean":
	        switch (name) {
	          case "autoFocus":
	          case "checked":
	          case "multiple":
	          case "muted":
	          case "selected":
	          case "contentEditable":
	          case "spellCheck":
	          case "draggable":
	          case "value":
	          case "autoReverse":
	          case "externalResourcesRequired":
	          case "focusable":
	          case "preserveAlpha":
	          case "allowFullScreen":
	          case "async":
	          case "autoPlay":
	          case "controls":
	          case "default":
	          case "defer":
	          case "disabled":
	          case "disablePictureInPicture":
	          case "disableRemotePlayback":
	          case "formNoValidate":
	          case "hidden":
	          case "loop":
	          case "noModule":
	          case "noValidate":
	          case "open":
	          case "playsInline":
	          case "readOnly":
	          case "required":
	          case "reversed":
	          case "scoped":
	          case "seamless":
	          case "itemScope":
	          case "capture":
	          case "download":
	          case "inert":
	            return true;
	          default:
	            lowerCasedName = name.toLowerCase().slice(0, 5);
	            if ("data-" === lowerCasedName || "aria-" === lowerCasedName)
	              return true;
	            value ? console.error(
	              'Received `%s` for a non-boolean attribute `%s`.\n\nIf you want to write it to the DOM, pass a string instead: %s="%s" or %s={value.toString()}.',
	              value,
	              name,
	              name,
	              value,
	              name
	            ) : console.error(
	              'Received `%s` for a non-boolean attribute `%s`.\n\nIf you want to write it to the DOM, pass a string instead: %s="%s" or %s={value.toString()}.\n\nIf you used to conditionally omit it with %s={condition && value}, pass %s={condition ? value : undefined} instead.',
	              value,
	              name,
	              name,
	              value,
	              name,
	              name,
	              name
	            );
	            return warnedProperties[name] = true;
	        }
	      case "function":
	      case "symbol":
	        return warnedProperties[name] = true, false;
	      case "string":
	        if ("false" === value || "true" === value) {
	          switch (name) {
	            case "checked":
	            case "selected":
	            case "multiple":
	            case "muted":
	            case "allowFullScreen":
	            case "async":
	            case "autoPlay":
	            case "controls":
	            case "default":
	            case "defer":
	            case "disabled":
	            case "disablePictureInPicture":
	            case "disableRemotePlayback":
	            case "formNoValidate":
	            case "hidden":
	            case "loop":
	            case "noModule":
	            case "noValidate":
	            case "open":
	            case "playsInline":
	            case "readOnly":
	            case "required":
	            case "reversed":
	            case "scoped":
	            case "seamless":
	            case "itemScope":
	            case "inert":
	              break;
	            default:
	              return true;
	          }
	          console.error(
	            "Received the string `%s` for the boolean attribute `%s`. %s Did you mean %s={%s}?",
	            value,
	            name,
	            "false" === value ? "The browser will interpret it as a truthy value." : 'Although this works, it will not work as expected if you pass the string "false".',
	            name,
	            value
	          );
	          warnedProperties[name] = true;
	        }
	    }
	    return true;
	  }
	  function warnUnknownProperties(type, props, eventRegistry) {
	    var unknownProps = [], key;
	    for (key in props)
	      validateProperty(type, key, props[key], eventRegistry) || unknownProps.push(key);
	    props = unknownProps.map(function(prop) {
	      return "`" + prop + "`";
	    }).join(", ");
	    1 === unknownProps.length ? console.error(
	      "Invalid value for prop %s on <%s> tag. Either remove it from the element, or pass a string or number value to keep it in the DOM. For details, see https://react.dev/link/attribute-behavior ",
	      props,
	      type
	    ) : 1 < unknownProps.length && console.error(
	      "Invalid values for props %s on <%s> tag. Either remove them from the element, or pass a string or number value to keep them in the DOM. For details, see https://react.dev/link/attribute-behavior ",
	      props,
	      type
	    );
	  }
	  function sanitizeURL(url) {
	    return isJavaScriptProtocol.test("" + url) ? "javascript:throw new Error('React has blocked a javascript: URL as a security precaution.')" : url;
	  }
	  function getEventTarget(nativeEvent) {
	    nativeEvent = nativeEvent.target || nativeEvent.srcElement || window;
	    nativeEvent.correspondingUseElement && (nativeEvent = nativeEvent.correspondingUseElement);
	    return 3 === nativeEvent.nodeType ? nativeEvent.parentNode : nativeEvent;
	  }
	  function restoreStateOfTarget(target) {
	    var internalInstance = getInstanceFromNode(target);
	    if (internalInstance && (target = internalInstance.stateNode)) {
	      var props = target[internalPropsKey] || null;
	      a: switch (target = internalInstance.stateNode, internalInstance.type) {
	        case "input":
	          updateInput(
	            target,
	            props.value,
	            props.defaultValue,
	            props.defaultValue,
	            props.checked,
	            props.defaultChecked,
	            props.type,
	            props.name
	          );
	          internalInstance = props.name;
	          if ("radio" === props.type && null != internalInstance) {
	            for (props = target; props.parentNode; ) props = props.parentNode;
	            checkAttributeStringCoercion(internalInstance, "name");
	            props = props.querySelectorAll(
	              'input[name="' + escapeSelectorAttributeValueInsideDoubleQuotes(
	                "" + internalInstance
	              ) + '"][type="radio"]'
	            );
	            for (internalInstance = 0; internalInstance < props.length; internalInstance++) {
	              var otherNode = props[internalInstance];
	              if (otherNode !== target && otherNode.form === target.form) {
	                var otherProps = otherNode[internalPropsKey] || null;
	                if (!otherProps)
	                  throw Error(
	                    "ReactDOMInput: Mixing React and non-React radio inputs with the same `name` is not supported."
	                  );
	                updateInput(
	                  otherNode,
	                  otherProps.value,
	                  otherProps.defaultValue,
	                  otherProps.defaultValue,
	                  otherProps.checked,
	                  otherProps.defaultChecked,
	                  otherProps.type,
	                  otherProps.name
	                );
	              }
	            }
	            for (internalInstance = 0; internalInstance < props.length; internalInstance++)
	              otherNode = props[internalInstance], otherNode.form === target.form && updateValueIfChanged(otherNode);
	          }
	          break a;
	        case "textarea":
	          updateTextarea(target, props.value, props.defaultValue);
	          break a;
	        case "select":
	          internalInstance = props.value, null != internalInstance && updateOptions(target, !!props.multiple, internalInstance, false);
	      }
	    }
	  }
	  function batchedUpdates$1(fn, a, b) {
	    if (isInsideEventHandler) return fn(a, b);
	    isInsideEventHandler = true;
	    try {
	      var JSCompiler_inline_result = fn(a);
	      return JSCompiler_inline_result;
	    } finally {
	      if (isInsideEventHandler = false, null !== restoreTarget || null !== restoreQueue) {
	        if (flushSyncWork$1(), restoreTarget && (a = restoreTarget, fn = restoreQueue, restoreQueue = restoreTarget = null, restoreStateOfTarget(a), fn))
	          for (a = 0; a < fn.length; a++) restoreStateOfTarget(fn[a]);
	      }
	    }
	  }
	  function getListener(inst, registrationName) {
	    var stateNode = inst.stateNode;
	    if (null === stateNode) return null;
	    var props = stateNode[internalPropsKey] || null;
	    if (null === props) return null;
	    stateNode = props[registrationName];
	    a: switch (registrationName) {
	      case "onClick":
	      case "onClickCapture":
	      case "onDoubleClick":
	      case "onDoubleClickCapture":
	      case "onMouseDown":
	      case "onMouseDownCapture":
	      case "onMouseMove":
	      case "onMouseMoveCapture":
	      case "onMouseUp":
	      case "onMouseUpCapture":
	      case "onMouseEnter":
	        (props = !props.disabled) || (inst = inst.type, props = !("button" === inst || "input" === inst || "select" === inst || "textarea" === inst));
	        inst = !props;
	        break a;
	      default:
	        inst = false;
	    }
	    if (inst) return null;
	    if (stateNode && "function" !== typeof stateNode)
	      throw Error(
	        "Expected `" + registrationName + "` listener to be a function, instead got a value of `" + typeof stateNode + "` type."
	      );
	    return stateNode;
	  }
	  function getData() {
	    if (fallbackText) return fallbackText;
	    var start, startValue = startText, startLength = startValue.length, end, endValue = "value" in root ? root.value : root.textContent, endLength = endValue.length;
	    for (start = 0; start < startLength && startValue[start] === endValue[start]; start++) ;
	    var minEnd = startLength - start;
	    for (end = 1; end <= minEnd && startValue[startLength - end] === endValue[endLength - end]; end++) ;
	    return fallbackText = endValue.slice(start, 1 < end ? 1 - end : void 0);
	  }
	  function getEventCharCode(nativeEvent) {
	    var keyCode = nativeEvent.keyCode;
	    "charCode" in nativeEvent ? (nativeEvent = nativeEvent.charCode, 0 === nativeEvent && 13 === keyCode && (nativeEvent = 13)) : nativeEvent = keyCode;
	    10 === nativeEvent && (nativeEvent = 13);
	    return 32 <= nativeEvent || 13 === nativeEvent ? nativeEvent : 0;
	  }
	  function functionThatReturnsTrue() {
	    return true;
	  }
	  function functionThatReturnsFalse() {
	    return false;
	  }
	  function createSyntheticEvent(Interface) {
	    function SyntheticBaseEvent(reactName, reactEventType, targetInst, nativeEvent, nativeEventTarget) {
	      this._reactName = reactName;
	      this._targetInst = targetInst;
	      this.type = reactEventType;
	      this.nativeEvent = nativeEvent;
	      this.target = nativeEventTarget;
	      this.currentTarget = null;
	      for (var propName in Interface)
	        Interface.hasOwnProperty(propName) && (reactName = Interface[propName], this[propName] = reactName ? reactName(nativeEvent) : nativeEvent[propName]);
	      this.isDefaultPrevented = (null != nativeEvent.defaultPrevented ? nativeEvent.defaultPrevented : false === nativeEvent.returnValue) ? functionThatReturnsTrue : functionThatReturnsFalse;
	      this.isPropagationStopped = functionThatReturnsFalse;
	      return this;
	    }
	    assign(SyntheticBaseEvent.prototype, {
	      preventDefault: function() {
	        this.defaultPrevented = true;
	        var event = this.nativeEvent;
	        event && (event.preventDefault ? event.preventDefault() : "unknown" !== typeof event.returnValue && (event.returnValue = false), this.isDefaultPrevented = functionThatReturnsTrue);
	      },
	      stopPropagation: function() {
	        var event = this.nativeEvent;
	        event && (event.stopPropagation ? event.stopPropagation() : "unknown" !== typeof event.cancelBubble && (event.cancelBubble = true), this.isPropagationStopped = functionThatReturnsTrue);
	      },
	      persist: function() {
	      },
	      isPersistent: functionThatReturnsTrue
	    });
	    return SyntheticBaseEvent;
	  }
	  function modifierStateGetter(keyArg) {
	    var nativeEvent = this.nativeEvent;
	    return nativeEvent.getModifierState ? nativeEvent.getModifierState(keyArg) : (keyArg = modifierKeyToProp[keyArg]) ? !!nativeEvent[keyArg] : false;
	  }
	  function getEventModifierState() {
	    return modifierStateGetter;
	  }
	  function isFallbackCompositionEnd(domEventName, nativeEvent) {
	    switch (domEventName) {
	      case "keyup":
	        return -1 !== END_KEYCODES.indexOf(nativeEvent.keyCode);
	      case "keydown":
	        return nativeEvent.keyCode !== START_KEYCODE;
	      case "keypress":
	      case "mousedown":
	      case "focusout":
	        return true;
	      default:
	        return false;
	    }
	  }
	  function getDataFromCustomEvent(nativeEvent) {
	    nativeEvent = nativeEvent.detail;
	    return "object" === typeof nativeEvent && "data" in nativeEvent ? nativeEvent.data : null;
	  }
	  function getNativeBeforeInputChars(domEventName, nativeEvent) {
	    switch (domEventName) {
	      case "compositionend":
	        return getDataFromCustomEvent(nativeEvent);
	      case "keypress":
	        if (nativeEvent.which !== SPACEBAR_CODE) return null;
	        hasSpaceKeypress = true;
	        return SPACEBAR_CHAR;
	      case "textInput":
	        return domEventName = nativeEvent.data, domEventName === SPACEBAR_CHAR && hasSpaceKeypress ? null : domEventName;
	      default:
	        return null;
	    }
	  }
	  function getFallbackBeforeInputChars(domEventName, nativeEvent) {
	    if (isComposing)
	      return "compositionend" === domEventName || !canUseCompositionEvent && isFallbackCompositionEnd(domEventName, nativeEvent) ? (domEventName = getData(), fallbackText = startText = root = null, isComposing = false, domEventName) : null;
	    switch (domEventName) {
	      case "paste":
	        return null;
	      case "keypress":
	        if (!(nativeEvent.ctrlKey || nativeEvent.altKey || nativeEvent.metaKey) || nativeEvent.ctrlKey && nativeEvent.altKey) {
	          if (nativeEvent.char && 1 < nativeEvent.char.length)
	            return nativeEvent.char;
	          if (nativeEvent.which)
	            return String.fromCharCode(nativeEvent.which);
	        }
	        return null;
	      case "compositionend":
	        return useFallbackCompositionData && "ko" !== nativeEvent.locale ? null : nativeEvent.data;
	      default:
	        return null;
	    }
	  }
	  function isTextInputElement(elem) {
	    var nodeName = elem && elem.nodeName && elem.nodeName.toLowerCase();
	    return "input" === nodeName ? !!supportedInputTypes[elem.type] : "textarea" === nodeName ? true : false;
	  }
	  function isEventSupported(eventNameSuffix) {
	    if (!canUseDOM) return false;
	    eventNameSuffix = "on" + eventNameSuffix;
	    var isSupported = eventNameSuffix in document;
	    isSupported || (isSupported = document.createElement("div"), isSupported.setAttribute(eventNameSuffix, "return;"), isSupported = "function" === typeof isSupported[eventNameSuffix]);
	    return isSupported;
	  }
	  function createAndAccumulateChangeEvent(dispatchQueue, inst, nativeEvent, target) {
	    restoreTarget ? restoreQueue ? restoreQueue.push(target) : restoreQueue = [target] : restoreTarget = target;
	    inst = accumulateTwoPhaseListeners(inst, "onChange");
	    0 < inst.length && (nativeEvent = new SyntheticEvent(
	      "onChange",
	      "change",
	      null,
	      nativeEvent,
	      target
	    ), dispatchQueue.push({ event: nativeEvent, listeners: inst }));
	  }
	  function runEventInBatch(dispatchQueue) {
	    processDispatchQueue(dispatchQueue, 0);
	  }
	  function getInstIfValueChanged(targetInst) {
	    var targetNode = getNodeFromInstance(targetInst);
	    if (updateValueIfChanged(targetNode)) return targetInst;
	  }
	  function getTargetInstForChangeEvent(domEventName, targetInst) {
	    if ("change" === domEventName) return targetInst;
	  }
	  function stopWatchingForValueChange() {
	    activeElement$1 && (activeElement$1.detachEvent("onpropertychange", handlePropertyChange), activeElementInst$1 = activeElement$1 = null);
	  }
	  function handlePropertyChange(nativeEvent) {
	    if ("value" === nativeEvent.propertyName && getInstIfValueChanged(activeElementInst$1)) {
	      var dispatchQueue = [];
	      createAndAccumulateChangeEvent(
	        dispatchQueue,
	        activeElementInst$1,
	        nativeEvent,
	        getEventTarget(nativeEvent)
	      );
	      batchedUpdates$1(runEventInBatch, dispatchQueue);
	    }
	  }
	  function handleEventsForInputEventPolyfill(domEventName, target, targetInst) {
	    "focusin" === domEventName ? (stopWatchingForValueChange(), activeElement$1 = target, activeElementInst$1 = targetInst, activeElement$1.attachEvent("onpropertychange", handlePropertyChange)) : "focusout" === domEventName && stopWatchingForValueChange();
	  }
	  function getTargetInstForInputEventPolyfill(domEventName) {
	    if ("selectionchange" === domEventName || "keyup" === domEventName || "keydown" === domEventName)
	      return getInstIfValueChanged(activeElementInst$1);
	  }
	  function getTargetInstForClickEvent(domEventName, targetInst) {
	    if ("click" === domEventName) return getInstIfValueChanged(targetInst);
	  }
	  function getTargetInstForInputOrChangeEvent(domEventName, targetInst) {
	    if ("input" === domEventName || "change" === domEventName)
	      return getInstIfValueChanged(targetInst);
	  }
	  function is(x, y) {
	    return x === y && (0 !== x || 1 / x === 1 / y) || x !== x && y !== y;
	  }
	  function shallowEqual(objA, objB) {
	    if (objectIs(objA, objB)) return true;
	    if ("object" !== typeof objA || null === objA || "object" !== typeof objB || null === objB)
	      return false;
	    var keysA = Object.keys(objA), keysB = Object.keys(objB);
	    if (keysA.length !== keysB.length) return false;
	    for (keysB = 0; keysB < keysA.length; keysB++) {
	      var currentKey = keysA[keysB];
	      if (!hasOwnProperty.call(objB, currentKey) || !objectIs(objA[currentKey], objB[currentKey]))
	        return false;
	    }
	    return true;
	  }
	  function getLeafNode(node) {
	    for (; node && node.firstChild; ) node = node.firstChild;
	    return node;
	  }
	  function getNodeForCharacterOffset(root2, offset) {
	    var node = getLeafNode(root2);
	    root2 = 0;
	    for (var nodeEnd; node; ) {
	      if (3 === node.nodeType) {
	        nodeEnd = root2 + node.textContent.length;
	        if (root2 <= offset && nodeEnd >= offset)
	          return { node, offset: offset - root2 };
	        root2 = nodeEnd;
	      }
	      a: {
	        for (; node; ) {
	          if (node.nextSibling) {
	            node = node.nextSibling;
	            break a;
	          }
	          node = node.parentNode;
	        }
	        node = void 0;
	      }
	      node = getLeafNode(node);
	    }
	  }
	  function containsNode(outerNode, innerNode) {
	    return outerNode && innerNode ? outerNode === innerNode ? true : outerNode && 3 === outerNode.nodeType ? false : innerNode && 3 === innerNode.nodeType ? containsNode(outerNode, innerNode.parentNode) : "contains" in outerNode ? outerNode.contains(innerNode) : outerNode.compareDocumentPosition ? !!(outerNode.compareDocumentPosition(innerNode) & 16) : false : false;
	  }
	  function getActiveElementDeep(containerInfo) {
	    containerInfo = null != containerInfo && null != containerInfo.ownerDocument && null != containerInfo.ownerDocument.defaultView ? containerInfo.ownerDocument.defaultView : window;
	    for (var element = getActiveElement(containerInfo.document); element instanceof containerInfo.HTMLIFrameElement; ) {
	      try {
	        var JSCompiler_inline_result = "string" === typeof element.contentWindow.location.href;
	      } catch (err) {
	        JSCompiler_inline_result = false;
	      }
	      if (JSCompiler_inline_result) containerInfo = element.contentWindow;
	      else break;
	      element = getActiveElement(containerInfo.document);
	    }
	    return element;
	  }
	  function hasSelectionCapabilities(elem) {
	    var nodeName = elem && elem.nodeName && elem.nodeName.toLowerCase();
	    return nodeName && ("input" === nodeName && ("text" === elem.type || "search" === elem.type || "tel" === elem.type || "url" === elem.type || "password" === elem.type) || "textarea" === nodeName || "true" === elem.contentEditable);
	  }
	  function constructSelectEvent(dispatchQueue, nativeEvent, nativeEventTarget) {
	    var doc = nativeEventTarget.window === nativeEventTarget ? nativeEventTarget.document : 9 === nativeEventTarget.nodeType ? nativeEventTarget : nativeEventTarget.ownerDocument;
	    mouseDown || null == activeElement || activeElement !== getActiveElement(doc) || (doc = activeElement, "selectionStart" in doc && hasSelectionCapabilities(doc) ? doc = { start: doc.selectionStart, end: doc.selectionEnd } : (doc = (doc.ownerDocument && doc.ownerDocument.defaultView || window).getSelection(), doc = {
	      anchorNode: doc.anchorNode,
	      anchorOffset: doc.anchorOffset,
	      focusNode: doc.focusNode,
	      focusOffset: doc.focusOffset
	    }), lastSelection && shallowEqual(lastSelection, doc) || (lastSelection = doc, doc = accumulateTwoPhaseListeners(activeElementInst, "onSelect"), 0 < doc.length && (nativeEvent = new SyntheticEvent(
	      "onSelect",
	      "select",
	      null,
	      nativeEvent,
	      nativeEventTarget
	    ), dispatchQueue.push({ event: nativeEvent, listeners: doc }), nativeEvent.target = activeElement)));
	  }
	  function makePrefixMap(styleProp, eventName) {
	    var prefixes = {};
	    prefixes[styleProp.toLowerCase()] = eventName.toLowerCase();
	    prefixes["Webkit" + styleProp] = "webkit" + eventName;
	    prefixes["Moz" + styleProp] = "moz" + eventName;
	    return prefixes;
	  }
	  function getVendorPrefixedEventName(eventName) {
	    if (prefixedEventNames[eventName]) return prefixedEventNames[eventName];
	    if (!vendorPrefixes[eventName]) return eventName;
	    var prefixMap = vendorPrefixes[eventName], styleProp;
	    for (styleProp in prefixMap)
	      if (prefixMap.hasOwnProperty(styleProp) && styleProp in style)
	        return prefixedEventNames[eventName] = prefixMap[styleProp];
	    return eventName;
	  }
	  function registerSimpleEvent(domEventName, reactName) {
	    topLevelEventsToReactNames.set(domEventName, reactName);
	    registerTwoPhaseEvent(reactName, [domEventName]);
	  }
	  function createCapturedValueAtFiber(value, source) {
	    if ("object" === typeof value && null !== value) {
	      var existing = CapturedStacks.get(value);
	      if (void 0 !== existing) return existing;
	      source = {
	        value,
	        source,
	        stack: getStackByFiberInDevAndProd(source)
	      };
	      CapturedStacks.set(value, source);
	      return source;
	    }
	    return {
	      value,
	      source,
	      stack: getStackByFiberInDevAndProd(source)
	    };
	  }
	  function finishQueueingConcurrentUpdates() {
	    for (var endIndex = concurrentQueuesIndex, i = concurrentlyUpdatedLanes = concurrentQueuesIndex = 0; i < endIndex; ) {
	      var fiber = concurrentQueues[i];
	      concurrentQueues[i++] = null;
	      var queue = concurrentQueues[i];
	      concurrentQueues[i++] = null;
	      var update = concurrentQueues[i];
	      concurrentQueues[i++] = null;
	      var lane = concurrentQueues[i];
	      concurrentQueues[i++] = null;
	      if (null !== queue && null !== update) {
	        var pending = queue.pending;
	        null === pending ? update.next = update : (update.next = pending.next, pending.next = update);
	        queue.pending = update;
	      }
	      0 !== lane && markUpdateLaneFromFiberToRoot(fiber, update, lane);
	    }
	  }
	  function enqueueUpdate$1(fiber, queue, update, lane) {
	    concurrentQueues[concurrentQueuesIndex++] = fiber;
	    concurrentQueues[concurrentQueuesIndex++] = queue;
	    concurrentQueues[concurrentQueuesIndex++] = update;
	    concurrentQueues[concurrentQueuesIndex++] = lane;
	    concurrentlyUpdatedLanes |= lane;
	    fiber.lanes |= lane;
	    fiber = fiber.alternate;
	    null !== fiber && (fiber.lanes |= lane);
	  }
	  function enqueueConcurrentHookUpdate(fiber, queue, update, lane) {
	    enqueueUpdate$1(fiber, queue, update, lane);
	    return getRootForUpdatedFiber(fiber);
	  }
	  function enqueueConcurrentRenderForLane(fiber, lane) {
	    enqueueUpdate$1(fiber, null, null, lane);
	    return getRootForUpdatedFiber(fiber);
	  }
	  function markUpdateLaneFromFiberToRoot(sourceFiber, update, lane) {
	    sourceFiber.lanes |= lane;
	    var alternate = sourceFiber.alternate;
	    null !== alternate && (alternate.lanes |= lane);
	    for (var isHidden = false, parent = sourceFiber.return; null !== parent; )
	      parent.childLanes |= lane, alternate = parent.alternate, null !== alternate && (alternate.childLanes |= lane), 22 === parent.tag && (sourceFiber = parent.stateNode, null === sourceFiber || sourceFiber._visibility & OffscreenVisible || (isHidden = true)), sourceFiber = parent, parent = parent.return;
	    return 3 === sourceFiber.tag ? (parent = sourceFiber.stateNode, isHidden && null !== update && (isHidden = 31 - clz32(lane), sourceFiber = parent.hiddenUpdates, alternate = sourceFiber[isHidden], null === alternate ? sourceFiber[isHidden] = [update] : alternate.push(update), update.lane = lane | 536870912), parent) : null;
	  }
	  function getRootForUpdatedFiber(sourceFiber) {
	    if (nestedUpdateCount > NESTED_UPDATE_LIMIT)
	      throw nestedPassiveUpdateCount = nestedUpdateCount = 0, rootWithPassiveNestedUpdates = rootWithNestedUpdates = null, Error(
	        "Maximum update depth exceeded. This can happen when a component repeatedly calls setState inside componentWillUpdate or componentDidUpdate. React limits the number of nested updates to prevent infinite loops."
	      );
	    nestedPassiveUpdateCount > NESTED_PASSIVE_UPDATE_LIMIT && (nestedPassiveUpdateCount = 0, rootWithPassiveNestedUpdates = null, console.error(
	      "Maximum update depth exceeded. This can happen when a component calls setState inside useEffect, but useEffect either doesn't have a dependency array, or one of the dependencies changes on every render."
	    ));
	    null === sourceFiber.alternate && 0 !== (sourceFiber.flags & 4098) && warnAboutUpdateOnNotYetMountedFiberInDEV(sourceFiber);
	    for (var node = sourceFiber, parent = node.return; null !== parent; )
	      null === node.alternate && 0 !== (node.flags & 4098) && warnAboutUpdateOnNotYetMountedFiberInDEV(sourceFiber), node = parent, parent = node.return;
	    return 3 === node.tag ? node.stateNode : null;
	  }
	  function resolveFunctionForHotReloading(type) {
	    if (null === resolveFamily) return type;
	    var family = resolveFamily(type);
	    return void 0 === family ? type : family.current;
	  }
	  function resolveForwardRefForHotReloading(type) {
	    if (null === resolveFamily) return type;
	    var family = resolveFamily(type);
	    return void 0 === family ? null !== type && void 0 !== type && "function" === typeof type.render && (family = resolveFunctionForHotReloading(type.render), type.render !== family) ? (family = { $$typeof: REACT_FORWARD_REF_TYPE, render: family }, void 0 !== type.displayName && (family.displayName = type.displayName), family) : type : family.current;
	  }
	  function isCompatibleFamilyForHotReloading(fiber, element) {
	    if (null === resolveFamily) return false;
	    var prevType = fiber.elementType;
	    element = element.type;
	    var needsCompareFamilies = false, $$typeofNextType = "object" === typeof element && null !== element ? element.$$typeof : null;
	    switch (fiber.tag) {
	      case 1:
	        "function" === typeof element && (needsCompareFamilies = true);
	        break;
	      case 0:
	        "function" === typeof element ? needsCompareFamilies = true : $$typeofNextType === REACT_LAZY_TYPE && (needsCompareFamilies = true);
	        break;
	      case 11:
	        $$typeofNextType === REACT_FORWARD_REF_TYPE ? needsCompareFamilies = true : $$typeofNextType === REACT_LAZY_TYPE && (needsCompareFamilies = true);
	        break;
	      case 14:
	      case 15:
	        $$typeofNextType === REACT_MEMO_TYPE ? needsCompareFamilies = true : $$typeofNextType === REACT_LAZY_TYPE && (needsCompareFamilies = true);
	        break;
	      default:
	        return false;
	    }
	    return needsCompareFamilies && (fiber = resolveFamily(prevType), void 0 !== fiber && fiber === resolveFamily(element)) ? true : false;
	  }
	  function markFailedErrorBoundaryForHotReloading(fiber) {
	    null !== resolveFamily && "function" === typeof WeakSet && (null === failedBoundaries && (failedBoundaries = /* @__PURE__ */ new WeakSet()), failedBoundaries.add(fiber));
	  }
	  function scheduleFibersWithFamiliesRecursively(fiber, updatedFamilies, staleFamilies) {
	    var alternate = fiber.alternate, child = fiber.child, sibling = fiber.sibling, tag = fiber.tag, type = fiber.type, candidateType = null;
	    switch (tag) {
	      case 0:
	      case 15:
	      case 1:
	        candidateType = type;
	        break;
	      case 11:
	        candidateType = type.render;
	    }
	    if (null === resolveFamily)
	      throw Error("Expected resolveFamily to be set during hot reload.");
	    var needsRender = false;
	    type = false;
	    null !== candidateType && (candidateType = resolveFamily(candidateType), void 0 !== candidateType && (staleFamilies.has(candidateType) ? type = true : updatedFamilies.has(candidateType) && (1 === tag ? type = true : needsRender = true)));
	    null !== failedBoundaries && (failedBoundaries.has(fiber) || null !== alternate && failedBoundaries.has(alternate)) && (type = true);
	    type && (fiber._debugNeedsRemount = true);
	    if (type || needsRender)
	      alternate = enqueueConcurrentRenderForLane(fiber, 2), null !== alternate && scheduleUpdateOnFiber(alternate, fiber, 2);
	    null === child || type || scheduleFibersWithFamiliesRecursively(
	      child,
	      updatedFamilies,
	      staleFamilies
	    );
	    null !== sibling && scheduleFibersWithFamiliesRecursively(
	      sibling,
	      updatedFamilies,
	      staleFamilies
	    );
	  }
	  function FiberNode(tag, pendingProps, key, mode) {
	    this.tag = tag;
	    this.key = key;
	    this.sibling = this.child = this.return = this.stateNode = this.type = this.elementType = null;
	    this.index = 0;
	    this.refCleanup = this.ref = null;
	    this.pendingProps = pendingProps;
	    this.dependencies = this.memoizedState = this.updateQueue = this.memoizedProps = null;
	    this.mode = mode;
	    this.subtreeFlags = this.flags = 0;
	    this.deletions = null;
	    this.childLanes = this.lanes = 0;
	    this.alternate = null;
	    this.actualDuration = -0;
	    this.actualStartTime = -1.1;
	    this.treeBaseDuration = this.selfBaseDuration = -0;
	    this._debugTask = this._debugStack = this._debugOwner = this._debugInfo = null;
	    this._debugNeedsRemount = false;
	    this._debugHookTypes = null;
	    hasBadMapPolyfill || "function" !== typeof Object.preventExtensions || Object.preventExtensions(this);
	  }
	  function shouldConstruct(Component) {
	    Component = Component.prototype;
	    return !(!Component || !Component.isReactComponent);
	  }
	  function createWorkInProgress(current2, pendingProps) {
	    var workInProgress2 = current2.alternate;
	    null === workInProgress2 ? (workInProgress2 = createFiber(
	      current2.tag,
	      pendingProps,
	      current2.key,
	      current2.mode
	    ), workInProgress2.elementType = current2.elementType, workInProgress2.type = current2.type, workInProgress2.stateNode = current2.stateNode, workInProgress2._debugOwner = current2._debugOwner, workInProgress2._debugStack = current2._debugStack, workInProgress2._debugTask = current2._debugTask, workInProgress2._debugHookTypes = current2._debugHookTypes, workInProgress2.alternate = current2, current2.alternate = workInProgress2) : (workInProgress2.pendingProps = pendingProps, workInProgress2.type = current2.type, workInProgress2.flags = 0, workInProgress2.subtreeFlags = 0, workInProgress2.deletions = null, workInProgress2.actualDuration = -0, workInProgress2.actualStartTime = -1.1);
	    workInProgress2.flags = current2.flags & 65011712;
	    workInProgress2.childLanes = current2.childLanes;
	    workInProgress2.lanes = current2.lanes;
	    workInProgress2.child = current2.child;
	    workInProgress2.memoizedProps = current2.memoizedProps;
	    workInProgress2.memoizedState = current2.memoizedState;
	    workInProgress2.updateQueue = current2.updateQueue;
	    pendingProps = current2.dependencies;
	    workInProgress2.dependencies = null === pendingProps ? null : {
	      lanes: pendingProps.lanes,
	      firstContext: pendingProps.firstContext,
	      _debugThenableState: pendingProps._debugThenableState
	    };
	    workInProgress2.sibling = current2.sibling;
	    workInProgress2.index = current2.index;
	    workInProgress2.ref = current2.ref;
	    workInProgress2.refCleanup = current2.refCleanup;
	    workInProgress2.selfBaseDuration = current2.selfBaseDuration;
	    workInProgress2.treeBaseDuration = current2.treeBaseDuration;
	    workInProgress2._debugInfo = current2._debugInfo;
	    workInProgress2._debugNeedsRemount = current2._debugNeedsRemount;
	    switch (workInProgress2.tag) {
	      case 0:
	      case 15:
	        workInProgress2.type = resolveFunctionForHotReloading(current2.type);
	        break;
	      case 1:
	        workInProgress2.type = resolveFunctionForHotReloading(current2.type);
	        break;
	      case 11:
	        workInProgress2.type = resolveForwardRefForHotReloading(current2.type);
	    }
	    return workInProgress2;
	  }
	  function resetWorkInProgress(workInProgress2, renderLanes2) {
	    workInProgress2.flags &= 65011714;
	    var current2 = workInProgress2.alternate;
	    null === current2 ? (workInProgress2.childLanes = 0, workInProgress2.lanes = renderLanes2, workInProgress2.child = null, workInProgress2.subtreeFlags = 0, workInProgress2.memoizedProps = null, workInProgress2.memoizedState = null, workInProgress2.updateQueue = null, workInProgress2.dependencies = null, workInProgress2.stateNode = null, workInProgress2.selfBaseDuration = 0, workInProgress2.treeBaseDuration = 0) : (workInProgress2.childLanes = current2.childLanes, workInProgress2.lanes = current2.lanes, workInProgress2.child = current2.child, workInProgress2.subtreeFlags = 0, workInProgress2.deletions = null, workInProgress2.memoizedProps = current2.memoizedProps, workInProgress2.memoizedState = current2.memoizedState, workInProgress2.updateQueue = current2.updateQueue, workInProgress2.type = current2.type, renderLanes2 = current2.dependencies, workInProgress2.dependencies = null === renderLanes2 ? null : {
	      lanes: renderLanes2.lanes,
	      firstContext: renderLanes2.firstContext,
	      _debugThenableState: renderLanes2._debugThenableState
	    }, workInProgress2.selfBaseDuration = current2.selfBaseDuration, workInProgress2.treeBaseDuration = current2.treeBaseDuration);
	    return workInProgress2;
	  }
	  function createFiberFromTypeAndProps(type, key, pendingProps, owner, mode, lanes) {
	    var fiberTag = 0, resolvedType = type;
	    if ("function" === typeof type)
	      shouldConstruct(type) && (fiberTag = 1), resolvedType = resolveFunctionForHotReloading(resolvedType);
	    else if ("string" === typeof type)
	      fiberTag = getHostContext(), fiberTag = isHostHoistableType(type, pendingProps, fiberTag) ? 26 : "html" === type || "head" === type || "body" === type ? 27 : 5;
	    else
	      a: switch (type) {
	        case REACT_ACTIVITY_TYPE:
	          return key = createFiber(31, pendingProps, key, mode), key.elementType = REACT_ACTIVITY_TYPE, key.lanes = lanes, key;
	        case REACT_FRAGMENT_TYPE:
	          return createFiberFromFragment(
	            pendingProps.children,
	            mode,
	            lanes,
	            key
	          );
	        case REACT_STRICT_MODE_TYPE:
	          fiberTag = 8;
	          mode |= StrictLegacyMode;
	          mode |= StrictEffectsMode;
	          break;
	        case REACT_PROFILER_TYPE:
	          return type = pendingProps, owner = mode, "string" !== typeof type.id && console.error(
	            'Profiler must specify an "id" of type `string` as a prop. Received the type `%s` instead.',
	            typeof type.id
	          ), key = createFiber(12, type, key, owner | ProfileMode), key.elementType = REACT_PROFILER_TYPE, key.lanes = lanes, key.stateNode = { effectDuration: 0, passiveEffectDuration: 0 }, key;
	        case REACT_SUSPENSE_TYPE:
	          return key = createFiber(13, pendingProps, key, mode), key.elementType = REACT_SUSPENSE_TYPE, key.lanes = lanes, key;
	        case REACT_SUSPENSE_LIST_TYPE:
	          return key = createFiber(19, pendingProps, key, mode), key.elementType = REACT_SUSPENSE_LIST_TYPE, key.lanes = lanes, key;
	        default:
	          if ("object" === typeof type && null !== type)
	            switch (type.$$typeof) {
	              case REACT_PROVIDER_TYPE:
	              case REACT_CONTEXT_TYPE:
	                fiberTag = 10;
	                break a;
	              case REACT_CONSUMER_TYPE:
	                fiberTag = 9;
	                break a;
	              case REACT_FORWARD_REF_TYPE:
	                fiberTag = 11;
	                resolvedType = resolveForwardRefForHotReloading(resolvedType);
	                break a;
	              case REACT_MEMO_TYPE:
	                fiberTag = 14;
	                break a;
	              case REACT_LAZY_TYPE:
	                fiberTag = 16;
	                resolvedType = null;
	                break a;
	            }
	          resolvedType = "";
	          if (void 0 === type || "object" === typeof type && null !== type && 0 === Object.keys(type).length)
	            resolvedType += " You likely forgot to export your component from the file it's defined in, or you might have mixed up default and named imports.";
	          null === type ? pendingProps = "null" : isArrayImpl(type) ? pendingProps = "array" : void 0 !== type && type.$$typeof === REACT_ELEMENT_TYPE ? (pendingProps = "<" + (getComponentNameFromType(type.type) || "Unknown") + " />", resolvedType = " Did you accidentally export a JSX literal instead of a component?") : pendingProps = typeof type;
	          (fiberTag = owner ? getComponentNameFromOwner(owner) : null) && (resolvedType += "\n\nCheck the render method of `" + fiberTag + "`.");
	          fiberTag = 29;
	          pendingProps = Error(
	            "Element type is invalid: expected a string (for built-in components) or a class/function (for composite components) but got: " + (pendingProps + "." + resolvedType)
	          );
	          resolvedType = null;
	      }
	    key = createFiber(fiberTag, pendingProps, key, mode);
	    key.elementType = type;
	    key.type = resolvedType;
	    key.lanes = lanes;
	    key._debugOwner = owner;
	    return key;
	  }
	  function createFiberFromElement(element, mode, lanes) {
	    mode = createFiberFromTypeAndProps(
	      element.type,
	      element.key,
	      element.props,
	      element._owner,
	      mode,
	      lanes
	    );
	    mode._debugOwner = element._owner;
	    mode._debugStack = element._debugStack;
	    mode._debugTask = element._debugTask;
	    return mode;
	  }
	  function createFiberFromFragment(elements, mode, lanes, key) {
	    elements = createFiber(7, elements, key, mode);
	    elements.lanes = lanes;
	    return elements;
	  }
	  function createFiberFromText(content, mode, lanes) {
	    content = createFiber(6, content, null, mode);
	    content.lanes = lanes;
	    return content;
	  }
	  function createFiberFromPortal(portal, mode, lanes) {
	    mode = createFiber(
	      4,
	      null !== portal.children ? portal.children : [],
	      portal.key,
	      mode
	    );
	    mode.lanes = lanes;
	    mode.stateNode = {
	      containerInfo: portal.containerInfo,
	      pendingChildren: null,
	      implementation: portal.implementation
	    };
	    return mode;
	  }
	  function pushTreeFork(workInProgress2, totalChildren) {
	    warnIfNotHydrating();
	    forkStack[forkStackIndex++] = treeForkCount;
	    forkStack[forkStackIndex++] = treeForkProvider;
	    treeForkProvider = workInProgress2;
	    treeForkCount = totalChildren;
	  }
	  function pushTreeId(workInProgress2, totalChildren, index) {
	    warnIfNotHydrating();
	    idStack[idStackIndex++] = treeContextId;
	    idStack[idStackIndex++] = treeContextOverflow;
	    idStack[idStackIndex++] = treeContextProvider;
	    treeContextProvider = workInProgress2;
	    var baseIdWithLeadingBit = treeContextId;
	    workInProgress2 = treeContextOverflow;
	    var baseLength = 32 - clz32(baseIdWithLeadingBit) - 1;
	    baseIdWithLeadingBit &= ~(1 << baseLength);
	    index += 1;
	    var length = 32 - clz32(totalChildren) + baseLength;
	    if (30 < length) {
	      var numberOfOverflowBits = baseLength - baseLength % 5;
	      length = (baseIdWithLeadingBit & (1 << numberOfOverflowBits) - 1).toString(32);
	      baseIdWithLeadingBit >>= numberOfOverflowBits;
	      baseLength -= numberOfOverflowBits;
	      treeContextId = 1 << 32 - clz32(totalChildren) + baseLength | index << baseLength | baseIdWithLeadingBit;
	      treeContextOverflow = length + workInProgress2;
	    } else
	      treeContextId = 1 << length | index << baseLength | baseIdWithLeadingBit, treeContextOverflow = workInProgress2;
	  }
	  function pushMaterializedTreeId(workInProgress2) {
	    warnIfNotHydrating();
	    null !== workInProgress2.return && (pushTreeFork(workInProgress2, 1), pushTreeId(workInProgress2, 1, 0));
	  }
	  function popTreeContext(workInProgress2) {
	    for (; workInProgress2 === treeForkProvider; )
	      treeForkProvider = forkStack[--forkStackIndex], forkStack[forkStackIndex] = null, treeForkCount = forkStack[--forkStackIndex], forkStack[forkStackIndex] = null;
	    for (; workInProgress2 === treeContextProvider; )
	      treeContextProvider = idStack[--idStackIndex], idStack[idStackIndex] = null, treeContextOverflow = idStack[--idStackIndex], idStack[idStackIndex] = null, treeContextId = idStack[--idStackIndex], idStack[idStackIndex] = null;
	  }
	  function warnIfNotHydrating() {
	    isHydrating || console.error(
	      "Expected to be hydrating. This is a bug in React. Please file an issue."
	    );
	  }
	  function buildHydrationDiffNode(fiber, distanceFromLeaf) {
	    if (null === fiber.return) {
	      if (null === hydrationDiffRootDEV)
	        hydrationDiffRootDEV = {
	          fiber,
	          children: [],
	          serverProps: void 0,
	          serverTail: [],
	          distanceFromLeaf
	        };
	      else {
	        if (hydrationDiffRootDEV.fiber !== fiber)
	          throw Error(
	            "Saw multiple hydration diff roots in a pass. This is a bug in React."
	          );
	        hydrationDiffRootDEV.distanceFromLeaf > distanceFromLeaf && (hydrationDiffRootDEV.distanceFromLeaf = distanceFromLeaf);
	      }
	      return hydrationDiffRootDEV;
	    }
	    var siblings = buildHydrationDiffNode(
	      fiber.return,
	      distanceFromLeaf + 1
	    ).children;
	    if (0 < siblings.length && siblings[siblings.length - 1].fiber === fiber)
	      return siblings = siblings[siblings.length - 1], siblings.distanceFromLeaf > distanceFromLeaf && (siblings.distanceFromLeaf = distanceFromLeaf), siblings;
	    distanceFromLeaf = {
	      fiber,
	      children: [],
	      serverProps: void 0,
	      serverTail: [],
	      distanceFromLeaf
	    };
	    siblings.push(distanceFromLeaf);
	    return distanceFromLeaf;
	  }
	  function warnNonHydratedInstance(fiber, rejectedCandidate) {
	    didSuspendOrErrorDEV || (fiber = buildHydrationDiffNode(fiber, 0), fiber.serverProps = null, null !== rejectedCandidate && (rejectedCandidate = describeHydratableInstanceForDevWarnings(rejectedCandidate), fiber.serverTail.push(rejectedCandidate)));
	  }
	  function throwOnHydrationMismatch(fiber) {
	    var diff = "", diffRoot = hydrationDiffRootDEV;
	    null !== diffRoot && (hydrationDiffRootDEV = null, diff = describeDiff(diffRoot));
	    queueHydrationError(
	      createCapturedValueAtFiber(
	        Error(
	          "Hydration failed because the server rendered HTML didn't match the client. As a result this tree will be regenerated on the client. This can happen if a SSR-ed Client Component used:\n\n- A server/client branch `if (typeof window !== 'undefined')`.\n- Variable input such as `Date.now()` or `Math.random()` which changes each time it's called.\n- Date formatting in a user's locale which doesn't match the server.\n- External changing data without sending a snapshot of it along with the HTML.\n- Invalid HTML tag nesting.\n\nIt can also happen if the client has a browser extension installed which messes with the HTML before React loaded.\n\nhttps://react.dev/link/hydration-mismatch" + diff
	        ),
	        fiber
	      )
	    );
	    throw HydrationMismatchException;
	  }
	  function prepareToHydrateHostInstance(fiber) {
	    var didHydrate = fiber.stateNode;
	    var type = fiber.type, props = fiber.memoizedProps;
	    didHydrate[internalInstanceKey] = fiber;
	    didHydrate[internalPropsKey] = props;
	    validatePropertiesInDevelopment(type, props);
	    switch (type) {
	      case "dialog":
	        listenToNonDelegatedEvent("cancel", didHydrate);
	        listenToNonDelegatedEvent("close", didHydrate);
	        break;
	      case "iframe":
	      case "object":
	      case "embed":
	        listenToNonDelegatedEvent("load", didHydrate);
	        break;
	      case "video":
	      case "audio":
	        for (type = 0; type < mediaEventTypes.length; type++)
	          listenToNonDelegatedEvent(mediaEventTypes[type], didHydrate);
	        break;
	      case "source":
	        listenToNonDelegatedEvent("error", didHydrate);
	        break;
	      case "img":
	      case "image":
	      case "link":
	        listenToNonDelegatedEvent("error", didHydrate);
	        listenToNonDelegatedEvent("load", didHydrate);
	        break;
	      case "details":
	        listenToNonDelegatedEvent("toggle", didHydrate);
	        break;
	      case "input":
	        checkControlledValueProps("input", props);
	        listenToNonDelegatedEvent("invalid", didHydrate);
	        validateInputProps(didHydrate, props);
	        initInput(
	          didHydrate,
	          props.value,
	          props.defaultValue,
	          props.checked,
	          props.defaultChecked,
	          props.type,
	          props.name,
	          true
	        );
	        track(didHydrate);
	        break;
	      case "option":
	        validateOptionProps(didHydrate, props);
	        break;
	      case "select":
	        checkControlledValueProps("select", props);
	        listenToNonDelegatedEvent("invalid", didHydrate);
	        validateSelectProps(didHydrate, props);
	        break;
	      case "textarea":
	        checkControlledValueProps("textarea", props), listenToNonDelegatedEvent("invalid", didHydrate), validateTextareaProps(didHydrate, props), initTextarea(
	          didHydrate,
	          props.value,
	          props.defaultValue,
	          props.children
	        ), track(didHydrate);
	    }
	    type = props.children;
	    "string" !== typeof type && "number" !== typeof type && "bigint" !== typeof type || didHydrate.textContent === "" + type || true === props.suppressHydrationWarning || checkForUnmatchedText(didHydrate.textContent, type) ? (null != props.popover && (listenToNonDelegatedEvent("beforetoggle", didHydrate), listenToNonDelegatedEvent("toggle", didHydrate)), null != props.onScroll && listenToNonDelegatedEvent("scroll", didHydrate), null != props.onScrollEnd && listenToNonDelegatedEvent("scrollend", didHydrate), null != props.onClick && (didHydrate.onclick = noop$1), didHydrate = true) : didHydrate = false;
	    didHydrate || throwOnHydrationMismatch(fiber);
	  }
	  function popToNextHostParent(fiber) {
	    for (hydrationParentFiber = fiber.return; hydrationParentFiber; )
	      switch (hydrationParentFiber.tag) {
	        case 5:
	        case 13:
	          rootOrSingletonContext = false;
	          return;
	        case 27:
	        case 3:
	          rootOrSingletonContext = true;
	          return;
	        default:
	          hydrationParentFiber = hydrationParentFiber.return;
	      }
	  }
	  function popHydrationState(fiber) {
	    if (fiber !== hydrationParentFiber) return false;
	    if (!isHydrating)
	      return popToNextHostParent(fiber), isHydrating = true, false;
	    var tag = fiber.tag, JSCompiler_temp;
	    if (JSCompiler_temp = 3 !== tag && 27 !== tag) {
	      if (JSCompiler_temp = 5 === tag)
	        JSCompiler_temp = fiber.type, JSCompiler_temp = !("form" !== JSCompiler_temp && "button" !== JSCompiler_temp) || shouldSetTextContent(fiber.type, fiber.memoizedProps);
	      JSCompiler_temp = !JSCompiler_temp;
	    }
	    if (JSCompiler_temp && nextHydratableInstance) {
	      for (JSCompiler_temp = nextHydratableInstance; JSCompiler_temp; ) {
	        var diffNode = buildHydrationDiffNode(fiber, 0), description = describeHydratableInstanceForDevWarnings(JSCompiler_temp);
	        diffNode.serverTail.push(description);
	        JSCompiler_temp = "Suspense" === description.type ? getNextHydratableInstanceAfterSuspenseInstance(JSCompiler_temp) : getNextHydratable(JSCompiler_temp.nextSibling);
	      }
	      throwOnHydrationMismatch(fiber);
	    }
	    popToNextHostParent(fiber);
	    if (13 === tag) {
	      fiber = fiber.memoizedState;
	      fiber = null !== fiber ? fiber.dehydrated : null;
	      if (!fiber)
	        throw Error(
	          "Expected to have a hydrated suspense instance. This error is likely caused by a bug in React. Please file an issue."
	        );
	      nextHydratableInstance = getNextHydratableInstanceAfterSuspenseInstance(fiber);
	    } else
	      27 === tag ? (tag = nextHydratableInstance, isSingletonScope(fiber.type) ? (fiber = previousHydratableOnEnteringScopedSingleton, previousHydratableOnEnteringScopedSingleton = null, nextHydratableInstance = fiber) : nextHydratableInstance = tag) : nextHydratableInstance = hydrationParentFiber ? getNextHydratable(fiber.stateNode.nextSibling) : null;
	    return true;
	  }
	  function resetHydrationState() {
	    nextHydratableInstance = hydrationParentFiber = null;
	    didSuspendOrErrorDEV = isHydrating = false;
	  }
	  function upgradeHydrationErrorsToRecoverable() {
	    var queuedErrors = hydrationErrors;
	    null !== queuedErrors && (null === workInProgressRootRecoverableErrors ? workInProgressRootRecoverableErrors = queuedErrors : workInProgressRootRecoverableErrors.push.apply(
	      workInProgressRootRecoverableErrors,
	      queuedErrors
	    ), hydrationErrors = null);
	    return queuedErrors;
	  }
	  function queueHydrationError(error) {
	    null === hydrationErrors ? hydrationErrors = [error] : hydrationErrors.push(error);
	  }
	  function emitPendingHydrationWarnings() {
	    var diffRoot = hydrationDiffRootDEV;
	    if (null !== diffRoot) {
	      hydrationDiffRootDEV = null;
	      for (var diff = describeDiff(diffRoot); 0 < diffRoot.children.length; )
	        diffRoot = diffRoot.children[0];
	      runWithFiberInDEV(diffRoot.fiber, function() {
	        console.error(
	          "A tree hydrated but some attributes of the server rendered HTML didn't match the client properties. This won't be patched up. This can happen if a SSR-ed Client Component used:\n\n- A server/client branch `if (typeof window !== 'undefined')`.\n- Variable input such as `Date.now()` or `Math.random()` which changes each time it's called.\n- Date formatting in a user's locale which doesn't match the server.\n- External changing data without sending a snapshot of it along with the HTML.\n- Invalid HTML tag nesting.\n\nIt can also happen if the client has a browser extension installed which messes with the HTML before React loaded.\n\n%s%s",
	          "https://react.dev/link/hydration-mismatch",
	          diff
	        );
	      });
	    }
	  }
	  function resetContextDependencies() {
	    lastContextDependency = currentlyRenderingFiber$1 = null;
	    isDisallowedContextReadInDEV = false;
	  }
	  function pushProvider(providerFiber, context, nextValue) {
	    push(valueCursor, context._currentValue, providerFiber);
	    context._currentValue = nextValue;
	    push(rendererCursorDEV, context._currentRenderer, providerFiber);
	    void 0 !== context._currentRenderer && null !== context._currentRenderer && context._currentRenderer !== rendererSigil && console.error(
	      "Detected multiple renderers concurrently rendering the same context provider. This is currently unsupported."
	    );
	    context._currentRenderer = rendererSigil;
	  }
	  function popProvider(context, providerFiber) {
	    context._currentValue = valueCursor.current;
	    var currentRenderer = rendererCursorDEV.current;
	    pop(rendererCursorDEV, providerFiber);
	    context._currentRenderer = currentRenderer;
	    pop(valueCursor, providerFiber);
	  }
	  function scheduleContextWorkOnParentPath(parent, renderLanes2, propagationRoot) {
	    for (; null !== parent; ) {
	      var alternate = parent.alternate;
	      (parent.childLanes & renderLanes2) !== renderLanes2 ? (parent.childLanes |= renderLanes2, null !== alternate && (alternate.childLanes |= renderLanes2)) : null !== alternate && (alternate.childLanes & renderLanes2) !== renderLanes2 && (alternate.childLanes |= renderLanes2);
	      if (parent === propagationRoot) break;
	      parent = parent.return;
	    }
	    parent !== propagationRoot && console.error(
	      "Expected to find the propagation root when scheduling context work. This error is likely caused by a bug in React. Please file an issue."
	    );
	  }
	  function propagateContextChanges(workInProgress2, contexts, renderLanes2, forcePropagateEntireTree) {
	    var fiber = workInProgress2.child;
	    null !== fiber && (fiber.return = workInProgress2);
	    for (; null !== fiber; ) {
	      var list = fiber.dependencies;
	      if (null !== list) {
	        var nextFiber = fiber.child;
	        list = list.firstContext;
	        a: for (; null !== list; ) {
	          var dependency = list;
	          list = fiber;
	          for (var i = 0; i < contexts.length; i++)
	            if (dependency.context === contexts[i]) {
	              list.lanes |= renderLanes2;
	              dependency = list.alternate;
	              null !== dependency && (dependency.lanes |= renderLanes2);
	              scheduleContextWorkOnParentPath(
	                list.return,
	                renderLanes2,
	                workInProgress2
	              );
	              forcePropagateEntireTree || (nextFiber = null);
	              break a;
	            }
	          list = dependency.next;
	        }
	      } else if (18 === fiber.tag) {
	        nextFiber = fiber.return;
	        if (null === nextFiber)
	          throw Error(
	            "We just came from a parent so we must have had a parent. This is a bug in React."
	          );
	        nextFiber.lanes |= renderLanes2;
	        list = nextFiber.alternate;
	        null !== list && (list.lanes |= renderLanes2);
	        scheduleContextWorkOnParentPath(
	          nextFiber,
	          renderLanes2,
	          workInProgress2
	        );
	        nextFiber = null;
	      } else nextFiber = fiber.child;
	      if (null !== nextFiber) nextFiber.return = fiber;
	      else
	        for (nextFiber = fiber; null !== nextFiber; ) {
	          if (nextFiber === workInProgress2) {
	            nextFiber = null;
	            break;
	          }
	          fiber = nextFiber.sibling;
	          if (null !== fiber) {
	            fiber.return = nextFiber.return;
	            nextFiber = fiber;
	            break;
	          }
	          nextFiber = nextFiber.return;
	        }
	      fiber = nextFiber;
	    }
	  }
	  function propagateParentContextChanges(current2, workInProgress2, renderLanes2, forcePropagateEntireTree) {
	    current2 = null;
	    for (var parent = workInProgress2, isInsidePropagationBailout = false; null !== parent; ) {
	      if (!isInsidePropagationBailout) {
	        if (0 !== (parent.flags & 524288)) isInsidePropagationBailout = true;
	        else if (0 !== (parent.flags & 262144)) break;
	      }
	      if (10 === parent.tag) {
	        var currentParent = parent.alternate;
	        if (null === currentParent)
	          throw Error("Should have a current fiber. This is a bug in React.");
	        currentParent = currentParent.memoizedProps;
	        if (null !== currentParent) {
	          var context = parent.type;
	          objectIs(parent.pendingProps.value, currentParent.value) || (null !== current2 ? current2.push(context) : current2 = [context]);
	        }
	      } else if (parent === hostTransitionProviderCursor.current) {
	        currentParent = parent.alternate;
	        if (null === currentParent)
	          throw Error("Should have a current fiber. This is a bug in React.");
	        currentParent.memoizedState.memoizedState !== parent.memoizedState.memoizedState && (null !== current2 ? current2.push(HostTransitionContext) : current2 = [HostTransitionContext]);
	      }
	      parent = parent.return;
	    }
	    null !== current2 && propagateContextChanges(
	      workInProgress2,
	      current2,
	      renderLanes2,
	      forcePropagateEntireTree
	    );
	    workInProgress2.flags |= 262144;
	  }
	  function checkIfContextChanged(currentDependencies) {
	    for (currentDependencies = currentDependencies.firstContext; null !== currentDependencies; ) {
	      if (!objectIs(
	        currentDependencies.context._currentValue,
	        currentDependencies.memoizedValue
	      ))
	        return true;
	      currentDependencies = currentDependencies.next;
	    }
	    return false;
	  }
	  function prepareToReadContext(workInProgress2) {
	    currentlyRenderingFiber$1 = workInProgress2;
	    lastContextDependency = null;
	    workInProgress2 = workInProgress2.dependencies;
	    null !== workInProgress2 && (workInProgress2.firstContext = null);
	  }
	  function readContext(context) {
	    isDisallowedContextReadInDEV && console.error(
	      "Context can only be read while React is rendering. In classes, you can read it in the render method or getDerivedStateFromProps. In function components, you can read it directly in the function body, but not inside Hooks like useReducer() or useMemo()."
	    );
	    return readContextForConsumer(currentlyRenderingFiber$1, context);
	  }
	  function readContextDuringReconciliation(consumer, context) {
	    null === currentlyRenderingFiber$1 && prepareToReadContext(consumer);
	    return readContextForConsumer(consumer, context);
	  }
	  function readContextForConsumer(consumer, context) {
	    var value = context._currentValue;
	    context = { context, memoizedValue: value, next: null };
	    if (null === lastContextDependency) {
	      if (null === consumer)
	        throw Error(
	          "Context can only be read while React is rendering. In classes, you can read it in the render method or getDerivedStateFromProps. In function components, you can read it directly in the function body, but not inside Hooks like useReducer() or useMemo()."
	        );
	      lastContextDependency = context;
	      consumer.dependencies = {
	        lanes: 0,
	        firstContext: context,
	        _debugThenableState: null
	      };
	      consumer.flags |= 524288;
	    } else lastContextDependency = lastContextDependency.next = context;
	    return value;
	  }
	  function createCache() {
	    return {
	      controller: new AbortControllerLocal(),
	      data: /* @__PURE__ */ new Map(),
	      refCount: 0
	    };
	  }
	  function retainCache(cache) {
	    cache.controller.signal.aborted && console.warn(
	      "A cache instance was retained after it was already freed. This likely indicates a bug in React."
	    );
	    cache.refCount++;
	  }
	  function releaseCache(cache) {
	    cache.refCount--;
	    0 > cache.refCount && console.warn(
	      "A cache instance was released after it was already freed. This likely indicates a bug in React."
	    );
	    0 === cache.refCount && scheduleCallback$2(NormalPriority, function() {
	      cache.controller.abort();
	    });
	  }
	  function pushNestedEffectDurations() {
	    var prevEffectDuration = profilerEffectDuration;
	    profilerEffectDuration = 0;
	    return prevEffectDuration;
	  }
	  function popNestedEffectDurations(prevEffectDuration) {
	    var elapsedTime = profilerEffectDuration;
	    profilerEffectDuration = prevEffectDuration;
	    return elapsedTime;
	  }
	  function bubbleNestedEffectDurations(prevEffectDuration) {
	    var elapsedTime = profilerEffectDuration;
	    profilerEffectDuration += prevEffectDuration;
	    return elapsedTime;
	  }
	  function startProfilerTimer(fiber) {
	    profilerStartTime = now();
	    0 > fiber.actualStartTime && (fiber.actualStartTime = profilerStartTime);
	  }
	  function stopProfilerTimerIfRunningAndRecordDuration(fiber) {
	    if (0 <= profilerStartTime) {
	      var elapsedTime = now() - profilerStartTime;
	      fiber.actualDuration += elapsedTime;
	      fiber.selfBaseDuration = elapsedTime;
	      profilerStartTime = -1;
	    }
	  }
	  function stopProfilerTimerIfRunningAndRecordIncompleteDuration(fiber) {
	    if (0 <= profilerStartTime) {
	      var elapsedTime = now() - profilerStartTime;
	      fiber.actualDuration += elapsedTime;
	      profilerStartTime = -1;
	    }
	  }
	  function recordEffectDuration() {
	    if (0 <= profilerStartTime) {
	      var elapsedTime = now() - profilerStartTime;
	      profilerStartTime = -1;
	      profilerEffectDuration += elapsedTime;
	    }
	  }
	  function startEffectTimer() {
	    profilerStartTime = now();
	  }
	  function transferActualDuration(fiber) {
	    for (var child = fiber.child; child; )
	      fiber.actualDuration += child.actualDuration, child = child.sibling;
	  }
	  function entangleAsyncAction(transition, thenable) {
	    if (null === currentEntangledListeners) {
	      var entangledListeners = currentEntangledListeners = [];
	      currentEntangledPendingCount = 0;
	      currentEntangledLane = requestTransitionLane();
	      currentEntangledActionThenable = {
	        status: "pending",
	        value: void 0,
	        then: function(resolve) {
	          entangledListeners.push(resolve);
	        }
	      };
	    }
	    currentEntangledPendingCount++;
	    thenable.then(pingEngtangledActionScope, pingEngtangledActionScope);
	    return thenable;
	  }
	  function pingEngtangledActionScope() {
	    if (0 === --currentEntangledPendingCount && null !== currentEntangledListeners) {
	      null !== currentEntangledActionThenable && (currentEntangledActionThenable.status = "fulfilled");
	      var listeners = currentEntangledListeners;
	      currentEntangledListeners = null;
	      currentEntangledLane = 0;
	      currentEntangledActionThenable = null;
	      for (var i = 0; i < listeners.length; i++) (0, listeners[i])();
	    }
	  }
	  function chainThenableValue(thenable, result) {
	    var listeners = [], thenableWithOverride = {
	      status: "pending",
	      value: null,
	      reason: null,
	      then: function(resolve) {
	        listeners.push(resolve);
	      }
	    };
	    thenable.then(
	      function() {
	        thenableWithOverride.status = "fulfilled";
	        thenableWithOverride.value = result;
	        for (var i = 0; i < listeners.length; i++) (0, listeners[i])(result);
	      },
	      function(error) {
	        thenableWithOverride.status = "rejected";
	        thenableWithOverride.reason = error;
	        for (error = 0; error < listeners.length; error++)
	          (0, listeners[error])(void 0);
	      }
	    );
	    return thenableWithOverride;
	  }
	  function peekCacheFromPool() {
	    var cacheResumedFromPreviousRender = resumedCache.current;
	    return null !== cacheResumedFromPreviousRender ? cacheResumedFromPreviousRender : workInProgressRoot.pooledCache;
	  }
	  function pushTransition(offscreenWorkInProgress, prevCachePool) {
	    null === prevCachePool ? push(resumedCache, resumedCache.current, offscreenWorkInProgress) : push(resumedCache, prevCachePool.pool, offscreenWorkInProgress);
	  }
	  function getSuspendedCache() {
	    var cacheFromPool = peekCacheFromPool();
	    return null === cacheFromPool ? null : { parent: CacheContext._currentValue, pool: cacheFromPool };
	  }
	  function createThenableState() {
	    return { didWarnAboutUncachedPromise: false, thenables: [] };
	  }
	  function isThenableResolved(thenable) {
	    thenable = thenable.status;
	    return "fulfilled" === thenable || "rejected" === thenable;
	  }
	  function noop$3() {
	  }
	  function trackUsedThenable(thenableState2, thenable, index) {
	    null !== ReactSharedInternals.actQueue && (ReactSharedInternals.didUsePromise = true);
	    var trackedThenables = thenableState2.thenables;
	    index = trackedThenables[index];
	    void 0 === index ? trackedThenables.push(thenable) : index !== thenable && (thenableState2.didWarnAboutUncachedPromise || (thenableState2.didWarnAboutUncachedPromise = true, console.error(
	      "A component was suspended by an uncached promise. Creating promises inside a Client Component or hook is not yet supported, except via a Suspense-compatible library or framework."
	    )), thenable.then(noop$3, noop$3), thenable = index);
	    switch (thenable.status) {
	      case "fulfilled":
	        return thenable.value;
	      case "rejected":
	        throw thenableState2 = thenable.reason, checkIfUseWrappedInAsyncCatch(thenableState2), thenableState2;
	      default:
	        if ("string" === typeof thenable.status)
	          thenable.then(noop$3, noop$3);
	        else {
	          thenableState2 = workInProgressRoot;
	          if (null !== thenableState2 && 100 < thenableState2.shellSuspendCounter)
	            throw Error(
	              "An unknown Component is an async Client Component. Only Server Components can be async at the moment. This error is often caused by accidentally adding `'use client'` to a module that was originally written for the server."
	            );
	          thenableState2 = thenable;
	          thenableState2.status = "pending";
	          thenableState2.then(
	            function(fulfilledValue) {
	              if ("pending" === thenable.status) {
	                var fulfilledThenable = thenable;
	                fulfilledThenable.status = "fulfilled";
	                fulfilledThenable.value = fulfilledValue;
	              }
	            },
	            function(error) {
	              if ("pending" === thenable.status) {
	                var rejectedThenable = thenable;
	                rejectedThenable.status = "rejected";
	                rejectedThenable.reason = error;
	              }
	            }
	          );
	        }
	        switch (thenable.status) {
	          case "fulfilled":
	            return thenable.value;
	          case "rejected":
	            throw thenableState2 = thenable.reason, checkIfUseWrappedInAsyncCatch(thenableState2), thenableState2;
	        }
	        suspendedThenable = thenable;
	        needsToResetSuspendedThenableDEV = true;
	        throw SuspenseException;
	    }
	  }
	  function getSuspendedThenable() {
	    if (null === suspendedThenable)
	      throw Error(
	        "Expected a suspended thenable. This is a bug in React. Please file an issue."
	      );
	    var thenable = suspendedThenable;
	    suspendedThenable = null;
	    needsToResetSuspendedThenableDEV = false;
	    return thenable;
	  }
	  function checkIfUseWrappedInAsyncCatch(rejectedReason) {
	    if (rejectedReason === SuspenseException || rejectedReason === SuspenseActionException)
	      throw Error(
	        "Hooks are not supported inside an async component. This error is often caused by accidentally adding `'use client'` to a module that was originally written for the server."
	      );
	  }
	  function initializeUpdateQueue(fiber) {
	    fiber.updateQueue = {
	      baseState: fiber.memoizedState,
	      firstBaseUpdate: null,
	      lastBaseUpdate: null,
	      shared: { pending: null, lanes: 0, hiddenCallbacks: null },
	      callbacks: null
	    };
	  }
	  function cloneUpdateQueue(current2, workInProgress2) {
	    current2 = current2.updateQueue;
	    workInProgress2.updateQueue === current2 && (workInProgress2.updateQueue = {
	      baseState: current2.baseState,
	      firstBaseUpdate: current2.firstBaseUpdate,
	      lastBaseUpdate: current2.lastBaseUpdate,
	      shared: current2.shared,
	      callbacks: null
	    });
	  }
	  function createUpdate(lane) {
	    return {
	      lane,
	      tag: UpdateState,
	      payload: null,
	      callback: null,
	      next: null
	    };
	  }
	  function enqueueUpdate(fiber, update, lane) {
	    var updateQueue = fiber.updateQueue;
	    if (null === updateQueue) return null;
	    updateQueue = updateQueue.shared;
	    if (currentlyProcessingQueue === updateQueue && !didWarnUpdateInsideUpdate) {
	      var componentName2 = getComponentNameFromFiber(fiber);
	      console.error(
	        "An update (setState, replaceState, or forceUpdate) was scheduled from inside an update function. Update functions should be pure, with zero side-effects. Consider using componentDidUpdate or a callback.\n\nPlease update the following component: %s",
	        componentName2
	      );
	      didWarnUpdateInsideUpdate = true;
	    }
	    if ((executionContext & RenderContext) !== NoContext)
	      return componentName2 = updateQueue.pending, null === componentName2 ? update.next = update : (update.next = componentName2.next, componentName2.next = update), updateQueue.pending = update, update = getRootForUpdatedFiber(fiber), markUpdateLaneFromFiberToRoot(fiber, null, lane), update;
	    enqueueUpdate$1(fiber, updateQueue, update, lane);
	    return getRootForUpdatedFiber(fiber);
	  }
	  function entangleTransitions(root2, fiber, lane) {
	    fiber = fiber.updateQueue;
	    if (null !== fiber && (fiber = fiber.shared, 0 !== (lane & 4194048))) {
	      var queueLanes = fiber.lanes;
	      queueLanes &= root2.pendingLanes;
	      lane |= queueLanes;
	      fiber.lanes = lane;
	      markRootEntangled(root2, lane);
	    }
	  }
	  function enqueueCapturedUpdate(workInProgress2, capturedUpdate) {
	    var queue = workInProgress2.updateQueue, current2 = workInProgress2.alternate;
	    if (null !== current2 && (current2 = current2.updateQueue, queue === current2)) {
	      var newFirst = null, newLast = null;
	      queue = queue.firstBaseUpdate;
	      if (null !== queue) {
	        do {
	          var clone = {
	            lane: queue.lane,
	            tag: queue.tag,
	            payload: queue.payload,
	            callback: null,
	            next: null
	          };
	          null === newLast ? newFirst = newLast = clone : newLast = newLast.next = clone;
	          queue = queue.next;
	        } while (null !== queue);
	        null === newLast ? newFirst = newLast = capturedUpdate : newLast = newLast.next = capturedUpdate;
	      } else newFirst = newLast = capturedUpdate;
	      queue = {
	        baseState: current2.baseState,
	        firstBaseUpdate: newFirst,
	        lastBaseUpdate: newLast,
	        shared: current2.shared,
	        callbacks: current2.callbacks
	      };
	      workInProgress2.updateQueue = queue;
	      return;
	    }
	    workInProgress2 = queue.lastBaseUpdate;
	    null === workInProgress2 ? queue.firstBaseUpdate = capturedUpdate : workInProgress2.next = capturedUpdate;
	    queue.lastBaseUpdate = capturedUpdate;
	  }
	  function suspendIfUpdateReadFromEntangledAsyncAction() {
	    if (didReadFromEntangledAsyncAction) {
	      var entangledActionThenable = currentEntangledActionThenable;
	      if (null !== entangledActionThenable) throw entangledActionThenable;
	    }
	  }
	  function processUpdateQueue(workInProgress2, props, instance$jscomp$0, renderLanes2) {
	    didReadFromEntangledAsyncAction = false;
	    var queue = workInProgress2.updateQueue;
	    hasForceUpdate = false;
	    currentlyProcessingQueue = queue.shared;
	    var firstBaseUpdate = queue.firstBaseUpdate, lastBaseUpdate = queue.lastBaseUpdate, pendingQueue = queue.shared.pending;
	    if (null !== pendingQueue) {
	      queue.shared.pending = null;
	      var lastPendingUpdate = pendingQueue, firstPendingUpdate = lastPendingUpdate.next;
	      lastPendingUpdate.next = null;
	      null === lastBaseUpdate ? firstBaseUpdate = firstPendingUpdate : lastBaseUpdate.next = firstPendingUpdate;
	      lastBaseUpdate = lastPendingUpdate;
	      var current2 = workInProgress2.alternate;
	      null !== current2 && (current2 = current2.updateQueue, pendingQueue = current2.lastBaseUpdate, pendingQueue !== lastBaseUpdate && (null === pendingQueue ? current2.firstBaseUpdate = firstPendingUpdate : pendingQueue.next = firstPendingUpdate, current2.lastBaseUpdate = lastPendingUpdate));
	    }
	    if (null !== firstBaseUpdate) {
	      var newState = queue.baseState;
	      lastBaseUpdate = 0;
	      current2 = firstPendingUpdate = lastPendingUpdate = null;
	      pendingQueue = firstBaseUpdate;
	      do {
	        var updateLane = pendingQueue.lane & -536870913, isHiddenUpdate = updateLane !== pendingQueue.lane;
	        if (isHiddenUpdate ? (workInProgressRootRenderLanes & updateLane) === updateLane : (renderLanes2 & updateLane) === updateLane) {
	          0 !== updateLane && updateLane === currentEntangledLane && (didReadFromEntangledAsyncAction = true);
	          null !== current2 && (current2 = current2.next = {
	            lane: 0,
	            tag: pendingQueue.tag,
	            payload: pendingQueue.payload,
	            callback: null,
	            next: null
	          });
	          a: {
	            updateLane = workInProgress2;
	            var partialState = pendingQueue;
	            var nextProps = props, instance = instance$jscomp$0;
	            switch (partialState.tag) {
	              case ReplaceState:
	                partialState = partialState.payload;
	                if ("function" === typeof partialState) {
	                  isDisallowedContextReadInDEV = true;
	                  var nextState = partialState.call(
	                    instance,
	                    newState,
	                    nextProps
	                  );
	                  if (updateLane.mode & StrictLegacyMode) {
	                    setIsStrictModeForDevtools(true);
	                    try {
	                      partialState.call(instance, newState, nextProps);
	                    } finally {
	                      setIsStrictModeForDevtools(false);
	                    }
	                  }
	                  isDisallowedContextReadInDEV = false;
	                  newState = nextState;
	                  break a;
	                }
	                newState = partialState;
	                break a;
	              case CaptureUpdate:
	                updateLane.flags = updateLane.flags & -65537 | 128;
	              case UpdateState:
	                nextState = partialState.payload;
	                if ("function" === typeof nextState) {
	                  isDisallowedContextReadInDEV = true;
	                  partialState = nextState.call(
	                    instance,
	                    newState,
	                    nextProps
	                  );
	                  if (updateLane.mode & StrictLegacyMode) {
	                    setIsStrictModeForDevtools(true);
	                    try {
	                      nextState.call(instance, newState, nextProps);
	                    } finally {
	                      setIsStrictModeForDevtools(false);
	                    }
	                  }
	                  isDisallowedContextReadInDEV = false;
	                } else partialState = nextState;
	                if (null === partialState || void 0 === partialState) break a;
	                newState = assign({}, newState, partialState);
	                break a;
	              case ForceUpdate:
	                hasForceUpdate = true;
	            }
	          }
	          updateLane = pendingQueue.callback;
	          null !== updateLane && (workInProgress2.flags |= 64, isHiddenUpdate && (workInProgress2.flags |= 8192), isHiddenUpdate = queue.callbacks, null === isHiddenUpdate ? queue.callbacks = [updateLane] : isHiddenUpdate.push(updateLane));
	        } else
	          isHiddenUpdate = {
	            lane: updateLane,
	            tag: pendingQueue.tag,
	            payload: pendingQueue.payload,
	            callback: pendingQueue.callback,
	            next: null
	          }, null === current2 ? (firstPendingUpdate = current2 = isHiddenUpdate, lastPendingUpdate = newState) : current2 = current2.next = isHiddenUpdate, lastBaseUpdate |= updateLane;
	        pendingQueue = pendingQueue.next;
	        if (null === pendingQueue)
	          if (pendingQueue = queue.shared.pending, null === pendingQueue)
	            break;
	          else
	            isHiddenUpdate = pendingQueue, pendingQueue = isHiddenUpdate.next, isHiddenUpdate.next = null, queue.lastBaseUpdate = isHiddenUpdate, queue.shared.pending = null;
	      } while (1);
	      null === current2 && (lastPendingUpdate = newState);
	      queue.baseState = lastPendingUpdate;
	      queue.firstBaseUpdate = firstPendingUpdate;
	      queue.lastBaseUpdate = current2;
	      null === firstBaseUpdate && (queue.shared.lanes = 0);
	      workInProgressRootSkippedLanes |= lastBaseUpdate;
	      workInProgress2.lanes = lastBaseUpdate;
	      workInProgress2.memoizedState = newState;
	    }
	    currentlyProcessingQueue = null;
	  }
	  function callCallback(callback, context) {
	    if ("function" !== typeof callback)
	      throw Error(
	        "Invalid argument passed as callback. Expected a function. Instead received: " + callback
	      );
	    callback.call(context);
	  }
	  function commitHiddenCallbacks(updateQueue, context) {
	    var hiddenCallbacks = updateQueue.shared.hiddenCallbacks;
	    if (null !== hiddenCallbacks)
	      for (updateQueue.shared.hiddenCallbacks = null, updateQueue = 0; updateQueue < hiddenCallbacks.length; updateQueue++)
	        callCallback(hiddenCallbacks[updateQueue], context);
	  }
	  function commitCallbacks(updateQueue, context) {
	    var callbacks = updateQueue.callbacks;
	    if (null !== callbacks)
	      for (updateQueue.callbacks = null, updateQueue = 0; updateQueue < callbacks.length; updateQueue++)
	        callCallback(callbacks[updateQueue], context);
	  }
	  function pushHiddenContext(fiber, context) {
	    var prevEntangledRenderLanes = entangledRenderLanes;
	    push(prevEntangledRenderLanesCursor, prevEntangledRenderLanes, fiber);
	    push(currentTreeHiddenStackCursor, context, fiber);
	    entangledRenderLanes = prevEntangledRenderLanes | context.baseLanes;
	  }
	  function reuseHiddenContextOnStack(fiber) {
	    push(prevEntangledRenderLanesCursor, entangledRenderLanes, fiber);
	    push(
	      currentTreeHiddenStackCursor,
	      currentTreeHiddenStackCursor.current,
	      fiber
	    );
	  }
	  function popHiddenContext(fiber) {
	    entangledRenderLanes = prevEntangledRenderLanesCursor.current;
	    pop(currentTreeHiddenStackCursor, fiber);
	    pop(prevEntangledRenderLanesCursor, fiber);
	  }
	  function mountHookTypesDev() {
	    var hookName = currentHookNameInDev;
	    null === hookTypesDev ? hookTypesDev = [hookName] : hookTypesDev.push(hookName);
	  }
	  function updateHookTypesDev() {
	    var hookName = currentHookNameInDev;
	    if (null !== hookTypesDev && (hookTypesUpdateIndexDev++, hookTypesDev[hookTypesUpdateIndexDev] !== hookName)) {
	      var componentName2 = getComponentNameFromFiber(currentlyRenderingFiber);
	      if (!didWarnAboutMismatchedHooksForComponent.has(componentName2) && (didWarnAboutMismatchedHooksForComponent.add(componentName2), null !== hookTypesDev)) {
	        for (var table = "", i = 0; i <= hookTypesUpdateIndexDev; i++) {
	          var oldHookName = hookTypesDev[i], newHookName = i === hookTypesUpdateIndexDev ? hookName : oldHookName;
	          for (oldHookName = i + 1 + ". " + oldHookName; 30 > oldHookName.length; )
	            oldHookName += " ";
	          oldHookName += newHookName + "\n";
	          table += oldHookName;
	        }
	        console.error(
	          "React has detected a change in the order of Hooks called by %s. This will lead to bugs and errors if not fixed. For more information, read the Rules of Hooks: https://react.dev/link/rules-of-hooks\n\n   Previous render            Next render\n   ------------------------------------------------------\n%s   ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\n",
	          componentName2,
	          table
	        );
	      }
	    }
	  }
	  function checkDepsAreArrayDev(deps) {
	    void 0 === deps || null === deps || isArrayImpl(deps) || console.error(
	      "%s received a final argument that is not an array (instead, received `%s`). When specified, the final argument must be an array.",
	      currentHookNameInDev,
	      typeof deps
	    );
	  }
	  function warnOnUseFormStateInDev() {
	    var componentName2 = getComponentNameFromFiber(currentlyRenderingFiber);
	    didWarnAboutUseFormState.has(componentName2) || (didWarnAboutUseFormState.add(componentName2), console.error(
	      "ReactDOM.useFormState has been renamed to React.useActionState. Please update %s to use React.useActionState.",
	      componentName2
	    ));
	  }
	  function throwInvalidHookError() {
	    throw Error(
	      "Invalid hook call. Hooks can only be called inside of the body of a function component. This could happen for one of the following reasons:\n1. You might have mismatching versions of React and the renderer (such as React DOM)\n2. You might be breaking the Rules of Hooks\n3. You might have more than one copy of React in the same app\nSee https://react.dev/link/invalid-hook-call for tips about how to debug and fix this problem."
	    );
	  }
	  function areHookInputsEqual(nextDeps, prevDeps) {
	    if (ignorePreviousDependencies) return false;
	    if (null === prevDeps)
	      return console.error(
	        "%s received a final argument during this render, but not during the previous render. Even though the final argument is optional, its type cannot change between renders.",
	        currentHookNameInDev
	      ), false;
	    nextDeps.length !== prevDeps.length && console.error(
	      "The final argument passed to %s changed size between renders. The order and size of this array must remain constant.\n\nPrevious: %s\nIncoming: %s",
	      currentHookNameInDev,
	      "[" + prevDeps.join(", ") + "]",
	      "[" + nextDeps.join(", ") + "]"
	    );
	    for (var i = 0; i < prevDeps.length && i < nextDeps.length; i++)
	      if (!objectIs(nextDeps[i], prevDeps[i])) return false;
	    return true;
	  }
	  function renderWithHooks(current2, workInProgress2, Component, props, secondArg, nextRenderLanes) {
	    renderLanes = nextRenderLanes;
	    currentlyRenderingFiber = workInProgress2;
	    hookTypesDev = null !== current2 ? current2._debugHookTypes : null;
	    hookTypesUpdateIndexDev = -1;
	    ignorePreviousDependencies = null !== current2 && current2.type !== workInProgress2.type;
	    if ("[object AsyncFunction]" === Object.prototype.toString.call(Component) || "[object AsyncGeneratorFunction]" === Object.prototype.toString.call(Component))
	      nextRenderLanes = getComponentNameFromFiber(currentlyRenderingFiber), didWarnAboutAsyncClientComponent.has(nextRenderLanes) || (didWarnAboutAsyncClientComponent.add(nextRenderLanes), console.error(
	        "%s is an async Client Component. Only Server Components can be async at the moment. This error is often caused by accidentally adding `'use client'` to a module that was originally written for the server.",
	        null === nextRenderLanes ? "An unknown Component" : "<" + nextRenderLanes + ">"
	      ));
	    workInProgress2.memoizedState = null;
	    workInProgress2.updateQueue = null;
	    workInProgress2.lanes = 0;
	    ReactSharedInternals.H = null !== current2 && null !== current2.memoizedState ? HooksDispatcherOnUpdateInDEV : null !== hookTypesDev ? HooksDispatcherOnMountWithHookTypesInDEV : HooksDispatcherOnMountInDEV;
	    shouldDoubleInvokeUserFnsInHooksDEV = nextRenderLanes = (workInProgress2.mode & StrictLegacyMode) !== NoMode;
	    var children = callComponentInDEV(Component, props, secondArg);
	    shouldDoubleInvokeUserFnsInHooksDEV = false;
	    didScheduleRenderPhaseUpdateDuringThisPass && (children = renderWithHooksAgain(
	      workInProgress2,
	      Component,
	      props,
	      secondArg
	    ));
	    if (nextRenderLanes) {
	      setIsStrictModeForDevtools(true);
	      try {
	        children = renderWithHooksAgain(
	          workInProgress2,
	          Component,
	          props,
	          secondArg
	        );
	      } finally {
	        setIsStrictModeForDevtools(false);
	      }
	    }
	    finishRenderingHooks(current2, workInProgress2);
	    return children;
	  }
	  function finishRenderingHooks(current2, workInProgress2) {
	    workInProgress2._debugHookTypes = hookTypesDev;
	    null === workInProgress2.dependencies ? null !== thenableState$1 && (workInProgress2.dependencies = {
	      lanes: 0,
	      firstContext: null,
	      _debugThenableState: thenableState$1
	    }) : workInProgress2.dependencies._debugThenableState = thenableState$1;
	    ReactSharedInternals.H = ContextOnlyDispatcher;
	    var didRenderTooFewHooks = null !== currentHook && null !== currentHook.next;
	    renderLanes = 0;
	    hookTypesDev = currentHookNameInDev = workInProgressHook = currentHook = currentlyRenderingFiber = null;
	    hookTypesUpdateIndexDev = -1;
	    null !== current2 && (current2.flags & 65011712) !== (workInProgress2.flags & 65011712) && console.error(
	      "Internal React error: Expected static flag was missing. Please notify the React team."
	    );
	    didScheduleRenderPhaseUpdate = false;
	    thenableIndexCounter$1 = 0;
	    thenableState$1 = null;
	    if (didRenderTooFewHooks)
	      throw Error(
	        "Rendered fewer hooks than expected. This may be caused by an accidental early return statement."
	      );
	    null === current2 || didReceiveUpdate || (current2 = current2.dependencies, null !== current2 && checkIfContextChanged(current2) && (didReceiveUpdate = true));
	    needsToResetSuspendedThenableDEV ? (needsToResetSuspendedThenableDEV = false, current2 = true) : current2 = false;
	    current2 && (workInProgress2 = getComponentNameFromFiber(workInProgress2) || "Unknown", didWarnAboutUseWrappedInTryCatch.has(workInProgress2) || didWarnAboutAsyncClientComponent.has(workInProgress2) || (didWarnAboutUseWrappedInTryCatch.add(workInProgress2), console.error(
	      "`use` was called from inside a try/catch block. This is not allowed and can lead to unexpected behavior. To handle errors triggered by `use`, wrap your component in a error boundary."
	    )));
	  }
	  function renderWithHooksAgain(workInProgress2, Component, props, secondArg) {
	    currentlyRenderingFiber = workInProgress2;
	    var numberOfReRenders = 0;
	    do {
	      didScheduleRenderPhaseUpdateDuringThisPass && (thenableState$1 = null);
	      thenableIndexCounter$1 = 0;
	      didScheduleRenderPhaseUpdateDuringThisPass = false;
	      if (numberOfReRenders >= RE_RENDER_LIMIT)
	        throw Error(
	          "Too many re-renders. React limits the number of renders to prevent an infinite loop."
	        );
	      numberOfReRenders += 1;
	      ignorePreviousDependencies = false;
	      workInProgressHook = currentHook = null;
	      if (null != workInProgress2.updateQueue) {
	        var children = workInProgress2.updateQueue;
	        children.lastEffect = null;
	        children.events = null;
	        children.stores = null;
	        null != children.memoCache && (children.memoCache.index = 0);
	      }
	      hookTypesUpdateIndexDev = -1;
	      ReactSharedInternals.H = HooksDispatcherOnRerenderInDEV;
	      children = callComponentInDEV(Component, props, secondArg);
	    } while (didScheduleRenderPhaseUpdateDuringThisPass);
	    return children;
	  }
	  function TransitionAwareHostComponent() {
	    var dispatcher = ReactSharedInternals.H, maybeThenable = dispatcher.useState()[0];
	    maybeThenable = "function" === typeof maybeThenable.then ? useThenable(maybeThenable) : maybeThenable;
	    dispatcher = dispatcher.useState()[0];
	    (null !== currentHook ? currentHook.memoizedState : null) !== dispatcher && (currentlyRenderingFiber.flags |= 1024);
	    return maybeThenable;
	  }
	  function checkDidRenderIdHook() {
	    var didRenderIdHook = 0 !== localIdCounter;
	    localIdCounter = 0;
	    return didRenderIdHook;
	  }
	  function bailoutHooks(current2, workInProgress2, lanes) {
	    workInProgress2.updateQueue = current2.updateQueue;
	    workInProgress2.flags = (workInProgress2.mode & StrictEffectsMode) !== NoMode ? workInProgress2.flags & -402655237 : workInProgress2.flags & -2053;
	    current2.lanes &= ~lanes;
	  }
	  function resetHooksOnUnwind(workInProgress2) {
	    if (didScheduleRenderPhaseUpdate) {
	      for (workInProgress2 = workInProgress2.memoizedState; null !== workInProgress2; ) {
	        var queue = workInProgress2.queue;
	        null !== queue && (queue.pending = null);
	        workInProgress2 = workInProgress2.next;
	      }
	      didScheduleRenderPhaseUpdate = false;
	    }
	    renderLanes = 0;
	    hookTypesDev = workInProgressHook = currentHook = currentlyRenderingFiber = null;
	    hookTypesUpdateIndexDev = -1;
	    currentHookNameInDev = null;
	    didScheduleRenderPhaseUpdateDuringThisPass = false;
	    thenableIndexCounter$1 = localIdCounter = 0;
	    thenableState$1 = null;
	  }
	  function mountWorkInProgressHook() {
	    var hook = {
	      memoizedState: null,
	      baseState: null,
	      baseQueue: null,
	      queue: null,
	      next: null
	    };
	    null === workInProgressHook ? currentlyRenderingFiber.memoizedState = workInProgressHook = hook : workInProgressHook = workInProgressHook.next = hook;
	    return workInProgressHook;
	  }
	  function updateWorkInProgressHook() {
	    if (null === currentHook) {
	      var nextCurrentHook = currentlyRenderingFiber.alternate;
	      nextCurrentHook = null !== nextCurrentHook ? nextCurrentHook.memoizedState : null;
	    } else nextCurrentHook = currentHook.next;
	    var nextWorkInProgressHook = null === workInProgressHook ? currentlyRenderingFiber.memoizedState : workInProgressHook.next;
	    if (null !== nextWorkInProgressHook)
	      workInProgressHook = nextWorkInProgressHook, currentHook = nextCurrentHook;
	    else {
	      if (null === nextCurrentHook) {
	        if (null === currentlyRenderingFiber.alternate)
	          throw Error(
	            "Update hook called on initial render. This is likely a bug in React. Please file an issue."
	          );
	        throw Error("Rendered more hooks than during the previous render.");
	      }
	      currentHook = nextCurrentHook;
	      nextCurrentHook = {
	        memoizedState: currentHook.memoizedState,
	        baseState: currentHook.baseState,
	        baseQueue: currentHook.baseQueue,
	        queue: currentHook.queue,
	        next: null
	      };
	      null === workInProgressHook ? currentlyRenderingFiber.memoizedState = workInProgressHook = nextCurrentHook : workInProgressHook = workInProgressHook.next = nextCurrentHook;
	    }
	    return workInProgressHook;
	  }
	  function createFunctionComponentUpdateQueue() {
	    return { lastEffect: null, events: null, stores: null, memoCache: null };
	  }
	  function useThenable(thenable) {
	    var index = thenableIndexCounter$1;
	    thenableIndexCounter$1 += 1;
	    null === thenableState$1 && (thenableState$1 = createThenableState());
	    thenable = trackUsedThenable(thenableState$1, thenable, index);
	    index = currentlyRenderingFiber;
	    null === (null === workInProgressHook ? index.memoizedState : workInProgressHook.next) && (index = index.alternate, ReactSharedInternals.H = null !== index && null !== index.memoizedState ? HooksDispatcherOnUpdateInDEV : HooksDispatcherOnMountInDEV);
	    return thenable;
	  }
	  function use(usable) {
	    if (null !== usable && "object" === typeof usable) {
	      if ("function" === typeof usable.then) return useThenable(usable);
	      if (usable.$$typeof === REACT_CONTEXT_TYPE) return readContext(usable);
	    }
	    throw Error("An unsupported type was passed to use(): " + String(usable));
	  }
	  function useMemoCache(size) {
	    var memoCache = null, updateQueue = currentlyRenderingFiber.updateQueue;
	    null !== updateQueue && (memoCache = updateQueue.memoCache);
	    if (null == memoCache) {
	      var current2 = currentlyRenderingFiber.alternate;
	      null !== current2 && (current2 = current2.updateQueue, null !== current2 && (current2 = current2.memoCache, null != current2 && (memoCache = {
	        data: current2.data.map(function(array) {
	          return array.slice();
	        }),
	        index: 0
	      })));
	    }
	    null == memoCache && (memoCache = { data: [], index: 0 });
	    null === updateQueue && (updateQueue = createFunctionComponentUpdateQueue(), currentlyRenderingFiber.updateQueue = updateQueue);
	    updateQueue.memoCache = memoCache;
	    updateQueue = memoCache.data[memoCache.index];
	    if (void 0 === updateQueue || ignorePreviousDependencies)
	      for (updateQueue = memoCache.data[memoCache.index] = Array(size), current2 = 0; current2 < size; current2++)
	        updateQueue[current2] = REACT_MEMO_CACHE_SENTINEL;
	    else
	      updateQueue.length !== size && console.error(
	        "Expected a constant size argument for each invocation of useMemoCache. The previous cache was allocated with size %s but size %s was requested.",
	        updateQueue.length,
	        size
	      );
	    memoCache.index++;
	    return updateQueue;
	  }
	  function basicStateReducer(state, action) {
	    return "function" === typeof action ? action(state) : action;
	  }
	  function mountReducer(reducer, initialArg, init) {
	    var hook = mountWorkInProgressHook();
	    if (void 0 !== init) {
	      var initialState = init(initialArg);
	      if (shouldDoubleInvokeUserFnsInHooksDEV) {
	        setIsStrictModeForDevtools(true);
	        try {
	          init(initialArg);
	        } finally {
	          setIsStrictModeForDevtools(false);
	        }
	      }
	    } else initialState = initialArg;
	    hook.memoizedState = hook.baseState = initialState;
	    reducer = {
	      pending: null,
	      lanes: 0,
	      dispatch: null,
	      lastRenderedReducer: reducer,
	      lastRenderedState: initialState
	    };
	    hook.queue = reducer;
	    reducer = reducer.dispatch = dispatchReducerAction.bind(
	      null,
	      currentlyRenderingFiber,
	      reducer
	    );
	    return [hook.memoizedState, reducer];
	  }
	  function updateReducer(reducer) {
	    var hook = updateWorkInProgressHook();
	    return updateReducerImpl(hook, currentHook, reducer);
	  }
	  function updateReducerImpl(hook, current2, reducer) {
	    var queue = hook.queue;
	    if (null === queue)
	      throw Error(
	        "Should have a queue. You are likely calling Hooks conditionally, which is not allowed. (https://react.dev/link/invalid-hook-call)"
	      );
	    queue.lastRenderedReducer = reducer;
	    var baseQueue = hook.baseQueue, pendingQueue = queue.pending;
	    if (null !== pendingQueue) {
	      if (null !== baseQueue) {
	        var baseFirst = baseQueue.next;
	        baseQueue.next = pendingQueue.next;
	        pendingQueue.next = baseFirst;
	      }
	      current2.baseQueue !== baseQueue && console.error(
	        "Internal error: Expected work-in-progress queue to be a clone. This is a bug in React."
	      );
	      current2.baseQueue = baseQueue = pendingQueue;
	      queue.pending = null;
	    }
	    pendingQueue = hook.baseState;
	    if (null === baseQueue) hook.memoizedState = pendingQueue;
	    else {
	      current2 = baseQueue.next;
	      var newBaseQueueFirst = baseFirst = null, newBaseQueueLast = null, update = current2, didReadFromEntangledAsyncAction2 = false;
	      do {
	        var updateLane = update.lane & -536870913;
	        if (updateLane !== update.lane ? (workInProgressRootRenderLanes & updateLane) === updateLane : (renderLanes & updateLane) === updateLane) {
	          var revertLane = update.revertLane;
	          if (0 === revertLane)
	            null !== newBaseQueueLast && (newBaseQueueLast = newBaseQueueLast.next = {
	              lane: 0,
	              revertLane: 0,
	              action: update.action,
	              hasEagerState: update.hasEagerState,
	              eagerState: update.eagerState,
	              next: null
	            }), updateLane === currentEntangledLane && (didReadFromEntangledAsyncAction2 = true);
	          else if ((renderLanes & revertLane) === revertLane) {
	            update = update.next;
	            revertLane === currentEntangledLane && (didReadFromEntangledAsyncAction2 = true);
	            continue;
	          } else
	            updateLane = {
	              lane: 0,
	              revertLane: update.revertLane,
	              action: update.action,
	              hasEagerState: update.hasEagerState,
	              eagerState: update.eagerState,
	              next: null
	            }, null === newBaseQueueLast ? (newBaseQueueFirst = newBaseQueueLast = updateLane, baseFirst = pendingQueue) : newBaseQueueLast = newBaseQueueLast.next = updateLane, currentlyRenderingFiber.lanes |= revertLane, workInProgressRootSkippedLanes |= revertLane;
	          updateLane = update.action;
	          shouldDoubleInvokeUserFnsInHooksDEV && reducer(pendingQueue, updateLane);
	          pendingQueue = update.hasEagerState ? update.eagerState : reducer(pendingQueue, updateLane);
	        } else
	          revertLane = {
	            lane: updateLane,
	            revertLane: update.revertLane,
	            action: update.action,
	            hasEagerState: update.hasEagerState,
	            eagerState: update.eagerState,
	            next: null
	          }, null === newBaseQueueLast ? (newBaseQueueFirst = newBaseQueueLast = revertLane, baseFirst = pendingQueue) : newBaseQueueLast = newBaseQueueLast.next = revertLane, currentlyRenderingFiber.lanes |= updateLane, workInProgressRootSkippedLanes |= updateLane;
	        update = update.next;
	      } while (null !== update && update !== current2);
	      null === newBaseQueueLast ? baseFirst = pendingQueue : newBaseQueueLast.next = newBaseQueueFirst;
	      if (!objectIs(pendingQueue, hook.memoizedState) && (didReceiveUpdate = true, didReadFromEntangledAsyncAction2 && (reducer = currentEntangledActionThenable, null !== reducer)))
	        throw reducer;
	      hook.memoizedState = pendingQueue;
	      hook.baseState = baseFirst;
	      hook.baseQueue = newBaseQueueLast;
	      queue.lastRenderedState = pendingQueue;
	    }
	    null === baseQueue && (queue.lanes = 0);
	    return [hook.memoizedState, queue.dispatch];
	  }
	  function rerenderReducer(reducer) {
	    var hook = updateWorkInProgressHook(), queue = hook.queue;
	    if (null === queue)
	      throw Error(
	        "Should have a queue. You are likely calling Hooks conditionally, which is not allowed. (https://react.dev/link/invalid-hook-call)"
	      );
	    queue.lastRenderedReducer = reducer;
	    var dispatch = queue.dispatch, lastRenderPhaseUpdate = queue.pending, newState = hook.memoizedState;
	    if (null !== lastRenderPhaseUpdate) {
	      queue.pending = null;
	      var update = lastRenderPhaseUpdate = lastRenderPhaseUpdate.next;
	      do
	        newState = reducer(newState, update.action), update = update.next;
	      while (update !== lastRenderPhaseUpdate);
	      objectIs(newState, hook.memoizedState) || (didReceiveUpdate = true);
	      hook.memoizedState = newState;
	      null === hook.baseQueue && (hook.baseState = newState);
	      queue.lastRenderedState = newState;
	    }
	    return [newState, dispatch];
	  }
	  function mountSyncExternalStore(subscribe, getSnapshot, getServerSnapshot) {
	    var fiber = currentlyRenderingFiber, hook = mountWorkInProgressHook();
	    if (isHydrating) {
	      if (void 0 === getServerSnapshot)
	        throw Error(
	          "Missing getServerSnapshot, which is required for server-rendered content. Will revert to client rendering."
	        );
	      var nextSnapshot = getServerSnapshot();
	      didWarnUncachedGetSnapshot || nextSnapshot === getServerSnapshot() || (console.error(
	        "The result of getServerSnapshot should be cached to avoid an infinite loop"
	      ), didWarnUncachedGetSnapshot = true);
	    } else {
	      nextSnapshot = getSnapshot();
	      didWarnUncachedGetSnapshot || (getServerSnapshot = getSnapshot(), objectIs(nextSnapshot, getServerSnapshot) || (console.error(
	        "The result of getSnapshot should be cached to avoid an infinite loop"
	      ), didWarnUncachedGetSnapshot = true));
	      if (null === workInProgressRoot)
	        throw Error(
	          "Expected a work-in-progress root. This is a bug in React. Please file an issue."
	        );
	      0 !== (workInProgressRootRenderLanes & 124) || pushStoreConsistencyCheck(fiber, getSnapshot, nextSnapshot);
	    }
	    hook.memoizedState = nextSnapshot;
	    getServerSnapshot = { value: nextSnapshot, getSnapshot };
	    hook.queue = getServerSnapshot;
	    mountEffect(
	      subscribeToStore.bind(null, fiber, getServerSnapshot, subscribe),
	      [subscribe]
	    );
	    fiber.flags |= 2048;
	    pushSimpleEffect(
	      HasEffect | Passive,
	      createEffectInstance(),
	      updateStoreInstance.bind(
	        null,
	        fiber,
	        getServerSnapshot,
	        nextSnapshot,
	        getSnapshot
	      ),
	      null
	    );
	    return nextSnapshot;
	  }
	  function updateSyncExternalStore(subscribe, getSnapshot, getServerSnapshot) {
	    var fiber = currentlyRenderingFiber, hook = updateWorkInProgressHook(), isHydrating$jscomp$0 = isHydrating;
	    if (isHydrating$jscomp$0) {
	      if (void 0 === getServerSnapshot)
	        throw Error(
	          "Missing getServerSnapshot, which is required for server-rendered content. Will revert to client rendering."
	        );
	      getServerSnapshot = getServerSnapshot();
	    } else if (getServerSnapshot = getSnapshot(), !didWarnUncachedGetSnapshot) {
	      var cachedSnapshot = getSnapshot();
	      objectIs(getServerSnapshot, cachedSnapshot) || (console.error(
	        "The result of getSnapshot should be cached to avoid an infinite loop"
	      ), didWarnUncachedGetSnapshot = true);
	    }
	    if (cachedSnapshot = !objectIs(
	      (currentHook || hook).memoizedState,
	      getServerSnapshot
	    ))
	      hook.memoizedState = getServerSnapshot, didReceiveUpdate = true;
	    hook = hook.queue;
	    var create = subscribeToStore.bind(null, fiber, hook, subscribe);
	    updateEffectImpl(2048, Passive, create, [subscribe]);
	    if (hook.getSnapshot !== getSnapshot || cachedSnapshot || null !== workInProgressHook && workInProgressHook.memoizedState.tag & HasEffect) {
	      fiber.flags |= 2048;
	      pushSimpleEffect(
	        HasEffect | Passive,
	        createEffectInstance(),
	        updateStoreInstance.bind(
	          null,
	          fiber,
	          hook,
	          getServerSnapshot,
	          getSnapshot
	        ),
	        null
	      );
	      if (null === workInProgressRoot)
	        throw Error(
	          "Expected a work-in-progress root. This is a bug in React. Please file an issue."
	        );
	      isHydrating$jscomp$0 || 0 !== (renderLanes & 124) || pushStoreConsistencyCheck(fiber, getSnapshot, getServerSnapshot);
	    }
	    return getServerSnapshot;
	  }
	  function pushStoreConsistencyCheck(fiber, getSnapshot, renderedSnapshot) {
	    fiber.flags |= 16384;
	    fiber = { getSnapshot, value: renderedSnapshot };
	    getSnapshot = currentlyRenderingFiber.updateQueue;
	    null === getSnapshot ? (getSnapshot = createFunctionComponentUpdateQueue(), currentlyRenderingFiber.updateQueue = getSnapshot, getSnapshot.stores = [fiber]) : (renderedSnapshot = getSnapshot.stores, null === renderedSnapshot ? getSnapshot.stores = [fiber] : renderedSnapshot.push(fiber));
	  }
	  function updateStoreInstance(fiber, inst, nextSnapshot, getSnapshot) {
	    inst.value = nextSnapshot;
	    inst.getSnapshot = getSnapshot;
	    checkIfSnapshotChanged(inst) && forceStoreRerender(fiber);
	  }
	  function subscribeToStore(fiber, inst, subscribe) {
	    return subscribe(function() {
	      checkIfSnapshotChanged(inst) && forceStoreRerender(fiber);
	    });
	  }
	  function checkIfSnapshotChanged(inst) {
	    var latestGetSnapshot = inst.getSnapshot;
	    inst = inst.value;
	    try {
	      var nextValue = latestGetSnapshot();
	      return !objectIs(inst, nextValue);
	    } catch (error) {
	      return true;
	    }
	  }
	  function forceStoreRerender(fiber) {
	    var root2 = enqueueConcurrentRenderForLane(fiber, 2);
	    null !== root2 && scheduleUpdateOnFiber(root2, fiber, 2);
	  }
	  function mountStateImpl(initialState) {
	    var hook = mountWorkInProgressHook();
	    if ("function" === typeof initialState) {
	      var initialStateInitializer = initialState;
	      initialState = initialStateInitializer();
	      if (shouldDoubleInvokeUserFnsInHooksDEV) {
	        setIsStrictModeForDevtools(true);
	        try {
	          initialStateInitializer();
	        } finally {
	          setIsStrictModeForDevtools(false);
	        }
	      }
	    }
	    hook.memoizedState = hook.baseState = initialState;
	    hook.queue = {
	      pending: null,
	      lanes: 0,
	      dispatch: null,
	      lastRenderedReducer: basicStateReducer,
	      lastRenderedState: initialState
	    };
	    return hook;
	  }
	  function mountState(initialState) {
	    initialState = mountStateImpl(initialState);
	    var queue = initialState.queue, dispatch = dispatchSetState.bind(null, currentlyRenderingFiber, queue);
	    queue.dispatch = dispatch;
	    return [initialState.memoizedState, dispatch];
	  }
	  function mountOptimistic(passthrough) {
	    var hook = mountWorkInProgressHook();
	    hook.memoizedState = hook.baseState = passthrough;
	    var queue = {
	      pending: null,
	      lanes: 0,
	      dispatch: null,
	      lastRenderedReducer: null,
	      lastRenderedState: null
	    };
	    hook.queue = queue;
	    hook = dispatchOptimisticSetState.bind(
	      null,
	      currentlyRenderingFiber,
	      true,
	      queue
	    );
	    queue.dispatch = hook;
	    return [passthrough, hook];
	  }
	  function updateOptimistic(passthrough, reducer) {
	    var hook = updateWorkInProgressHook();
	    return updateOptimisticImpl(hook, currentHook, passthrough, reducer);
	  }
	  function updateOptimisticImpl(hook, current2, passthrough, reducer) {
	    hook.baseState = passthrough;
	    return updateReducerImpl(
	      hook,
	      currentHook,
	      "function" === typeof reducer ? reducer : basicStateReducer
	    );
	  }
	  function rerenderOptimistic(passthrough, reducer) {
	    var hook = updateWorkInProgressHook();
	    if (null !== currentHook)
	      return updateOptimisticImpl(hook, currentHook, passthrough, reducer);
	    hook.baseState = passthrough;
	    return [passthrough, hook.queue.dispatch];
	  }
	  function dispatchActionState(fiber, actionQueue, setPendingState, setState, payload) {
	    if (isRenderPhaseUpdate(fiber))
	      throw Error("Cannot update form state while rendering.");
	    fiber = actionQueue.action;
	    if (null !== fiber) {
	      var actionNode = {
	        payload,
	        action: fiber,
	        next: null,
	        isTransition: true,
	        status: "pending",
	        value: null,
	        reason: null,
	        listeners: [],
	        then: function(listener) {
	          actionNode.listeners.push(listener);
	        }
	      };
	      null !== ReactSharedInternals.T ? setPendingState(true) : actionNode.isTransition = false;
	      setState(actionNode);
	      setPendingState = actionQueue.pending;
	      null === setPendingState ? (actionNode.next = actionQueue.pending = actionNode, runActionStateAction(actionQueue, actionNode)) : (actionNode.next = setPendingState.next, actionQueue.pending = setPendingState.next = actionNode);
	    }
	  }
	  function runActionStateAction(actionQueue, node) {
	    var action = node.action, payload = node.payload, prevState = actionQueue.state;
	    if (node.isTransition) {
	      var prevTransition = ReactSharedInternals.T, currentTransition = {};
	      ReactSharedInternals.T = currentTransition;
	      ReactSharedInternals.T._updatedFibers = /* @__PURE__ */ new Set();
	      try {
	        var returnValue = action(prevState, payload), onStartTransitionFinish = ReactSharedInternals.S;
	        null !== onStartTransitionFinish && onStartTransitionFinish(currentTransition, returnValue);
	        handleActionReturnValue(actionQueue, node, returnValue);
	      } catch (error) {
	        onActionError(actionQueue, node, error);
	      } finally {
	        ReactSharedInternals.T = prevTransition, null === prevTransition && currentTransition._updatedFibers && (actionQueue = currentTransition._updatedFibers.size, currentTransition._updatedFibers.clear(), 10 < actionQueue && console.warn(
	          "Detected a large number of updates inside startTransition. If this is due to a subscription please re-write it to use React provided hooks. Otherwise concurrent mode guarantees are off the table."
	        ));
	      }
	    } else
	      try {
	        currentTransition = action(prevState, payload), handleActionReturnValue(actionQueue, node, currentTransition);
	      } catch (error$4) {
	        onActionError(actionQueue, node, error$4);
	      }
	  }
	  function handleActionReturnValue(actionQueue, node, returnValue) {
	    null !== returnValue && "object" === typeof returnValue && "function" === typeof returnValue.then ? (returnValue.then(
	      function(nextState) {
	        onActionSuccess(actionQueue, node, nextState);
	      },
	      function(error) {
	        return onActionError(actionQueue, node, error);
	      }
	    ), node.isTransition || console.error(
	      "An async function with useActionState was called outside of a transition. This is likely not what you intended (for example, isPending will not update correctly). Either call the returned function inside startTransition, or pass it to an `action` or `formAction` prop."
	    )) : onActionSuccess(actionQueue, node, returnValue);
	  }
	  function onActionSuccess(actionQueue, actionNode, nextState) {
	    actionNode.status = "fulfilled";
	    actionNode.value = nextState;
	    notifyActionListeners(actionNode);
	    actionQueue.state = nextState;
	    actionNode = actionQueue.pending;
	    null !== actionNode && (nextState = actionNode.next, nextState === actionNode ? actionQueue.pending = null : (nextState = nextState.next, actionNode.next = nextState, runActionStateAction(actionQueue, nextState)));
	  }
	  function onActionError(actionQueue, actionNode, error) {
	    var last = actionQueue.pending;
	    actionQueue.pending = null;
	    if (null !== last) {
	      last = last.next;
	      do
	        actionNode.status = "rejected", actionNode.reason = error, notifyActionListeners(actionNode), actionNode = actionNode.next;
	      while (actionNode !== last);
	    }
	    actionQueue.action = null;
	  }
	  function notifyActionListeners(actionNode) {
	    actionNode = actionNode.listeners;
	    for (var i = 0; i < actionNode.length; i++) (0, actionNode[i])();
	  }
	  function actionStateReducer(oldState, newState) {
	    return newState;
	  }
	  function mountActionState(action, initialStateProp) {
	    if (isHydrating) {
	      var ssrFormState = workInProgressRoot.formState;
	      if (null !== ssrFormState) {
	        a: {
	          var isMatching = currentlyRenderingFiber;
	          if (isHydrating) {
	            if (nextHydratableInstance) {
	              b: {
	                var markerInstance = nextHydratableInstance;
	                for (var inRootOrSingleton = rootOrSingletonContext; 8 !== markerInstance.nodeType; ) {
	                  if (!inRootOrSingleton) {
	                    markerInstance = null;
	                    break b;
	                  }
	                  markerInstance = getNextHydratable(
	                    markerInstance.nextSibling
	                  );
	                  if (null === markerInstance) {
	                    markerInstance = null;
	                    break b;
	                  }
	                }
	                inRootOrSingleton = markerInstance.data;
	                markerInstance = inRootOrSingleton === FORM_STATE_IS_MATCHING || inRootOrSingleton === FORM_STATE_IS_NOT_MATCHING ? markerInstance : null;
	              }
	              if (markerInstance) {
	                nextHydratableInstance = getNextHydratable(
	                  markerInstance.nextSibling
	                );
	                isMatching = markerInstance.data === FORM_STATE_IS_MATCHING;
	                break a;
	              }
	            }
	            throwOnHydrationMismatch(isMatching);
	          }
	          isMatching = false;
	        }
	        isMatching && (initialStateProp = ssrFormState[0]);
	      }
	    }
	    ssrFormState = mountWorkInProgressHook();
	    ssrFormState.memoizedState = ssrFormState.baseState = initialStateProp;
	    isMatching = {
	      pending: null,
	      lanes: 0,
	      dispatch: null,
	      lastRenderedReducer: actionStateReducer,
	      lastRenderedState: initialStateProp
	    };
	    ssrFormState.queue = isMatching;
	    ssrFormState = dispatchSetState.bind(
	      null,
	      currentlyRenderingFiber,
	      isMatching
	    );
	    isMatching.dispatch = ssrFormState;
	    isMatching = mountStateImpl(false);
	    inRootOrSingleton = dispatchOptimisticSetState.bind(
	      null,
	      currentlyRenderingFiber,
	      false,
	      isMatching.queue
	    );
	    isMatching = mountWorkInProgressHook();
	    markerInstance = {
	      state: initialStateProp,
	      dispatch: null,
	      action,
	      pending: null
	    };
	    isMatching.queue = markerInstance;
	    ssrFormState = dispatchActionState.bind(
	      null,
	      currentlyRenderingFiber,
	      markerInstance,
	      inRootOrSingleton,
	      ssrFormState
	    );
	    markerInstance.dispatch = ssrFormState;
	    isMatching.memoizedState = action;
	    return [initialStateProp, ssrFormState, false];
	  }
	  function updateActionState(action) {
	    var stateHook = updateWorkInProgressHook();
	    return updateActionStateImpl(stateHook, currentHook, action);
	  }
	  function updateActionStateImpl(stateHook, currentStateHook, action) {
	    currentStateHook = updateReducerImpl(
	      stateHook,
	      currentStateHook,
	      actionStateReducer
	    )[0];
	    stateHook = updateReducer(basicStateReducer)[0];
	    if ("object" === typeof currentStateHook && null !== currentStateHook && "function" === typeof currentStateHook.then)
	      try {
	        var state = useThenable(currentStateHook);
	      } catch (x) {
	        if (x === SuspenseException) throw SuspenseActionException;
	        throw x;
	      }
	    else state = currentStateHook;
	    currentStateHook = updateWorkInProgressHook();
	    var actionQueue = currentStateHook.queue, dispatch = actionQueue.dispatch;
	    action !== currentStateHook.memoizedState && (currentlyRenderingFiber.flags |= 2048, pushSimpleEffect(
	      HasEffect | Passive,
	      createEffectInstance(),
	      actionStateActionEffect.bind(null, actionQueue, action),
	      null
	    ));
	    return [state, dispatch, stateHook];
	  }
	  function actionStateActionEffect(actionQueue, action) {
	    actionQueue.action = action;
	  }
	  function rerenderActionState(action) {
	    var stateHook = updateWorkInProgressHook(), currentStateHook = currentHook;
	    if (null !== currentStateHook)
	      return updateActionStateImpl(stateHook, currentStateHook, action);
	    updateWorkInProgressHook();
	    stateHook = stateHook.memoizedState;
	    currentStateHook = updateWorkInProgressHook();
	    var dispatch = currentStateHook.queue.dispatch;
	    currentStateHook.memoizedState = action;
	    return [stateHook, dispatch, false];
	  }
	  function pushSimpleEffect(tag, inst, create, createDeps) {
	    tag = {
	      tag,
	      create,
	      deps: createDeps,
	      inst,
	      next: null
	    };
	    inst = currentlyRenderingFiber.updateQueue;
	    null === inst && (inst = createFunctionComponentUpdateQueue(), currentlyRenderingFiber.updateQueue = inst);
	    create = inst.lastEffect;
	    null === create ? inst.lastEffect = tag.next = tag : (createDeps = create.next, create.next = tag, tag.next = createDeps, inst.lastEffect = tag);
	    return tag;
	  }
	  function createEffectInstance() {
	    return { destroy: void 0, resource: void 0 };
	  }
	  function mountRef(initialValue) {
	    var hook = mountWorkInProgressHook();
	    initialValue = { current: initialValue };
	    return hook.memoizedState = initialValue;
	  }
	  function mountEffectImpl(fiberFlags, hookFlags, create, createDeps) {
	    var hook = mountWorkInProgressHook();
	    createDeps = void 0 === createDeps ? null : createDeps;
	    currentlyRenderingFiber.flags |= fiberFlags;
	    hook.memoizedState = pushSimpleEffect(
	      HasEffect | hookFlags,
	      createEffectInstance(),
	      create,
	      createDeps
	    );
	  }
	  function updateEffectImpl(fiberFlags, hookFlags, create, deps) {
	    var hook = updateWorkInProgressHook();
	    deps = void 0 === deps ? null : deps;
	    var inst = hook.memoizedState.inst;
	    null !== currentHook && null !== deps && areHookInputsEqual(deps, currentHook.memoizedState.deps) ? hook.memoizedState = pushSimpleEffect(hookFlags, inst, create, deps) : (currentlyRenderingFiber.flags |= fiberFlags, hook.memoizedState = pushSimpleEffect(
	      HasEffect | hookFlags,
	      inst,
	      create,
	      deps
	    ));
	  }
	  function mountEffect(create, createDeps) {
	    (currentlyRenderingFiber.mode & StrictEffectsMode) !== NoMode && (currentlyRenderingFiber.mode & NoStrictPassiveEffectsMode) === NoMode ? mountEffectImpl(276826112, Passive, create, createDeps) : mountEffectImpl(8390656, Passive, create, createDeps);
	  }
	  function mountLayoutEffect(create, deps) {
	    var fiberFlags = 4194308;
	    (currentlyRenderingFiber.mode & StrictEffectsMode) !== NoMode && (fiberFlags |= 134217728);
	    return mountEffectImpl(fiberFlags, Layout, create, deps);
	  }
	  function imperativeHandleEffect(create, ref) {
	    if ("function" === typeof ref) {
	      create = create();
	      var refCleanup = ref(create);
	      return function() {
	        "function" === typeof refCleanup ? refCleanup() : ref(null);
	      };
	    }
	    if (null !== ref && void 0 !== ref)
	      return ref.hasOwnProperty("current") || console.error(
	        "Expected useImperativeHandle() first argument to either be a ref callback or React.createRef() object. Instead received: %s.",
	        "an object with keys {" + Object.keys(ref).join(", ") + "}"
	      ), create = create(), ref.current = create, function() {
	        ref.current = null;
	      };
	  }
	  function mountImperativeHandle(ref, create, deps) {
	    "function" !== typeof create && console.error(
	      "Expected useImperativeHandle() second argument to be a function that creates a handle. Instead received: %s.",
	      null !== create ? typeof create : "null"
	    );
	    deps = null !== deps && void 0 !== deps ? deps.concat([ref]) : null;
	    var fiberFlags = 4194308;
	    (currentlyRenderingFiber.mode & StrictEffectsMode) !== NoMode && (fiberFlags |= 134217728);
	    mountEffectImpl(
	      fiberFlags,
	      Layout,
	      imperativeHandleEffect.bind(null, create, ref),
	      deps
	    );
	  }
	  function updateImperativeHandle(ref, create, deps) {
	    "function" !== typeof create && console.error(
	      "Expected useImperativeHandle() second argument to be a function that creates a handle. Instead received: %s.",
	      null !== create ? typeof create : "null"
	    );
	    deps = null !== deps && void 0 !== deps ? deps.concat([ref]) : null;
	    updateEffectImpl(
	      4,
	      Layout,
	      imperativeHandleEffect.bind(null, create, ref),
	      deps
	    );
	  }
	  function mountCallback(callback, deps) {
	    mountWorkInProgressHook().memoizedState = [
	      callback,
	      void 0 === deps ? null : deps
	    ];
	    return callback;
	  }
	  function updateCallback(callback, deps) {
	    var hook = updateWorkInProgressHook();
	    deps = void 0 === deps ? null : deps;
	    var prevState = hook.memoizedState;
	    if (null !== deps && areHookInputsEqual(deps, prevState[1]))
	      return prevState[0];
	    hook.memoizedState = [callback, deps];
	    return callback;
	  }
	  function mountMemo(nextCreate, deps) {
	    var hook = mountWorkInProgressHook();
	    deps = void 0 === deps ? null : deps;
	    var nextValue = nextCreate();
	    if (shouldDoubleInvokeUserFnsInHooksDEV) {
	      setIsStrictModeForDevtools(true);
	      try {
	        nextCreate();
	      } finally {
	        setIsStrictModeForDevtools(false);
	      }
	    }
	    hook.memoizedState = [nextValue, deps];
	    return nextValue;
	  }
	  function updateMemo(nextCreate, deps) {
	    var hook = updateWorkInProgressHook();
	    deps = void 0 === deps ? null : deps;
	    var prevState = hook.memoizedState;
	    if (null !== deps && areHookInputsEqual(deps, prevState[1]))
	      return prevState[0];
	    prevState = nextCreate();
	    if (shouldDoubleInvokeUserFnsInHooksDEV) {
	      setIsStrictModeForDevtools(true);
	      try {
	        nextCreate();
	      } finally {
	        setIsStrictModeForDevtools(false);
	      }
	    }
	    hook.memoizedState = [prevState, deps];
	    return prevState;
	  }
	  function mountDeferredValue(value, initialValue) {
	    var hook = mountWorkInProgressHook();
	    return mountDeferredValueImpl(hook, value, initialValue);
	  }
	  function updateDeferredValue(value, initialValue) {
	    var hook = updateWorkInProgressHook();
	    return updateDeferredValueImpl(
	      hook,
	      currentHook.memoizedState,
	      value,
	      initialValue
	    );
	  }
	  function rerenderDeferredValue(value, initialValue) {
	    var hook = updateWorkInProgressHook();
	    return null === currentHook ? mountDeferredValueImpl(hook, value, initialValue) : updateDeferredValueImpl(
	      hook,
	      currentHook.memoizedState,
	      value,
	      initialValue
	    );
	  }
	  function mountDeferredValueImpl(hook, value, initialValue) {
	    if (void 0 === initialValue || 0 !== (renderLanes & 1073741824))
	      return hook.memoizedState = value;
	    hook.memoizedState = initialValue;
	    hook = requestDeferredLane();
	    currentlyRenderingFiber.lanes |= hook;
	    workInProgressRootSkippedLanes |= hook;
	    return initialValue;
	  }
	  function updateDeferredValueImpl(hook, prevValue, value, initialValue) {
	    if (objectIs(value, prevValue)) return value;
	    if (null !== currentTreeHiddenStackCursor.current)
	      return hook = mountDeferredValueImpl(hook, value, initialValue), objectIs(hook, prevValue) || (didReceiveUpdate = true), hook;
	    if (0 === (renderLanes & 42))
	      return didReceiveUpdate = true, hook.memoizedState = value;
	    hook = requestDeferredLane();
	    currentlyRenderingFiber.lanes |= hook;
	    workInProgressRootSkippedLanes |= hook;
	    return prevValue;
	  }
	  function startTransition(fiber, queue, pendingState, finishedState, callback) {
	    var previousPriority = ReactDOMSharedInternals.p;
	    ReactDOMSharedInternals.p = 0 !== previousPriority && previousPriority < ContinuousEventPriority ? previousPriority : ContinuousEventPriority;
	    var prevTransition = ReactSharedInternals.T, currentTransition = {};
	    ReactSharedInternals.T = currentTransition;
	    dispatchOptimisticSetState(fiber, false, queue, pendingState);
	    currentTransition._updatedFibers = /* @__PURE__ */ new Set();
	    try {
	      var returnValue = callback(), onStartTransitionFinish = ReactSharedInternals.S;
	      null !== onStartTransitionFinish && onStartTransitionFinish(currentTransition, returnValue);
	      if (null !== returnValue && "object" === typeof returnValue && "function" === typeof returnValue.then) {
	        var thenableForFinishedState = chainThenableValue(
	          returnValue,
	          finishedState
	        );
	        dispatchSetStateInternal(
	          fiber,
	          queue,
	          thenableForFinishedState,
	          requestUpdateLane(fiber)
	        );
	      } else
	        dispatchSetStateInternal(
	          fiber,
	          queue,
	          finishedState,
	          requestUpdateLane(fiber)
	        );
	    } catch (error) {
	      dispatchSetStateInternal(
	        fiber,
	        queue,
	        { then: function() {
	        }, status: "rejected", reason: error },
	        requestUpdateLane(fiber)
	      );
	    } finally {
	      ReactDOMSharedInternals.p = previousPriority, ReactSharedInternals.T = prevTransition, null === prevTransition && currentTransition._updatedFibers && (fiber = currentTransition._updatedFibers.size, currentTransition._updatedFibers.clear(), 10 < fiber && console.warn(
	        "Detected a large number of updates inside startTransition. If this is due to a subscription please re-write it to use React provided hooks. Otherwise concurrent mode guarantees are off the table."
	      ));
	    }
	  }
	  function startHostTransition(formFiber, pendingState, action, formData) {
	    if (5 !== formFiber.tag)
	      throw Error(
	        "Expected the form instance to be a HostComponent. This is a bug in React."
	      );
	    var queue = ensureFormComponentIsStateful(formFiber).queue;
	    startTransition(
	      formFiber,
	      queue,
	      pendingState,
	      NotPendingTransition,
	      null === action ? noop$2 : function() {
	        requestFormReset$1(formFiber);
	        return action(formData);
	      }
	    );
	  }
	  function ensureFormComponentIsStateful(formFiber) {
	    var existingStateHook = formFiber.memoizedState;
	    if (null !== existingStateHook) return existingStateHook;
	    existingStateHook = {
	      memoizedState: NotPendingTransition,
	      baseState: NotPendingTransition,
	      baseQueue: null,
	      queue: {
	        pending: null,
	        lanes: 0,
	        dispatch: null,
	        lastRenderedReducer: basicStateReducer,
	        lastRenderedState: NotPendingTransition
	      },
	      next: null
	    };
	    var initialResetState = {};
	    existingStateHook.next = {
	      memoizedState: initialResetState,
	      baseState: initialResetState,
	      baseQueue: null,
	      queue: {
	        pending: null,
	        lanes: 0,
	        dispatch: null,
	        lastRenderedReducer: basicStateReducer,
	        lastRenderedState: initialResetState
	      },
	      next: null
	    };
	    formFiber.memoizedState = existingStateHook;
	    formFiber = formFiber.alternate;
	    null !== formFiber && (formFiber.memoizedState = existingStateHook);
	    return existingStateHook;
	  }
	  function requestFormReset$1(formFiber) {
	    null === ReactSharedInternals.T && console.error(
	      "requestFormReset was called outside a transition or action. To fix, move to an action, or wrap with startTransition."
	    );
	    var resetStateQueue = ensureFormComponentIsStateful(formFiber).next.queue;
	    dispatchSetStateInternal(
	      formFiber,
	      resetStateQueue,
	      {},
	      requestUpdateLane(formFiber)
	    );
	  }
	  function mountTransition() {
	    var stateHook = mountStateImpl(false);
	    stateHook = startTransition.bind(
	      null,
	      currentlyRenderingFiber,
	      stateHook.queue,
	      true,
	      false
	    );
	    mountWorkInProgressHook().memoizedState = stateHook;
	    return [false, stateHook];
	  }
	  function updateTransition() {
	    var booleanOrThenable = updateReducer(basicStateReducer)[0], start = updateWorkInProgressHook().memoizedState;
	    return [
	      "boolean" === typeof booleanOrThenable ? booleanOrThenable : useThenable(booleanOrThenable),
	      start
	    ];
	  }
	  function rerenderTransition() {
	    var booleanOrThenable = rerenderReducer(basicStateReducer)[0], start = updateWorkInProgressHook().memoizedState;
	    return [
	      "boolean" === typeof booleanOrThenable ? booleanOrThenable : useThenable(booleanOrThenable),
	      start
	    ];
	  }
	  function useHostTransitionStatus() {
	    return readContext(HostTransitionContext);
	  }
	  function mountId() {
	    var hook = mountWorkInProgressHook(), identifierPrefix = workInProgressRoot.identifierPrefix;
	    if (isHydrating) {
	      var treeId = treeContextOverflow;
	      var idWithLeadingBit = treeContextId;
	      treeId = (idWithLeadingBit & ~(1 << 32 - clz32(idWithLeadingBit) - 1)).toString(32) + treeId;
	      identifierPrefix = "«" + identifierPrefix + "R" + treeId;
	      treeId = localIdCounter++;
	      0 < treeId && (identifierPrefix += "H" + treeId.toString(32));
	      identifierPrefix += "»";
	    } else
	      treeId = globalClientIdCounter++, identifierPrefix = "«" + identifierPrefix + "r" + treeId.toString(32) + "»";
	    return hook.memoizedState = identifierPrefix;
	  }
	  function mountRefresh() {
	    return mountWorkInProgressHook().memoizedState = refreshCache.bind(
	      null,
	      currentlyRenderingFiber
	    );
	  }
	  function refreshCache(fiber, seedKey) {
	    for (var provider = fiber.return; null !== provider; ) {
	      switch (provider.tag) {
	        case 24:
	        case 3:
	          var lane = requestUpdateLane(provider);
	          fiber = createUpdate(lane);
	          var root2 = enqueueUpdate(provider, fiber, lane);
	          null !== root2 && (scheduleUpdateOnFiber(root2, provider, lane), entangleTransitions(root2, provider, lane));
	          provider = createCache();
	          null !== seedKey && void 0 !== seedKey && null !== root2 && console.error(
	            "The seed argument is not enabled outside experimental channels."
	          );
	          fiber.payload = { cache: provider };
	          return;
	      }
	      provider = provider.return;
	    }
	  }
	  function dispatchReducerAction(fiber, queue, action) {
	    var args = arguments;
	    "function" === typeof args[3] && console.error(
	      "State updates from the useState() and useReducer() Hooks don't support the second callback argument. To execute a side effect after rendering, declare it in the component body with useEffect()."
	    );
	    args = requestUpdateLane(fiber);
	    var update = {
	      lane: args,
	      revertLane: 0,
	      action,
	      hasEagerState: false,
	      eagerState: null,
	      next: null
	    };
	    isRenderPhaseUpdate(fiber) ? enqueueRenderPhaseUpdate(queue, update) : (update = enqueueConcurrentHookUpdate(fiber, queue, update, args), null !== update && (scheduleUpdateOnFiber(update, fiber, args), entangleTransitionUpdate(update, queue, args)));
	    markStateUpdateScheduled(fiber, args);
	  }
	  function dispatchSetState(fiber, queue, action) {
	    var args = arguments;
	    "function" === typeof args[3] && console.error(
	      "State updates from the useState() and useReducer() Hooks don't support the second callback argument. To execute a side effect after rendering, declare it in the component body with useEffect()."
	    );
	    args = requestUpdateLane(fiber);
	    dispatchSetStateInternal(fiber, queue, action, args);
	    markStateUpdateScheduled(fiber, args);
	  }
	  function dispatchSetStateInternal(fiber, queue, action, lane) {
	    var update = {
	      lane,
	      revertLane: 0,
	      action,
	      hasEagerState: false,
	      eagerState: null,
	      next: null
	    };
	    if (isRenderPhaseUpdate(fiber)) enqueueRenderPhaseUpdate(queue, update);
	    else {
	      var alternate = fiber.alternate;
	      if (0 === fiber.lanes && (null === alternate || 0 === alternate.lanes) && (alternate = queue.lastRenderedReducer, null !== alternate)) {
	        var prevDispatcher = ReactSharedInternals.H;
	        ReactSharedInternals.H = InvalidNestedHooksDispatcherOnUpdateInDEV;
	        try {
	          var currentState = queue.lastRenderedState, eagerState = alternate(currentState, action);
	          update.hasEagerState = true;
	          update.eagerState = eagerState;
	          if (objectIs(eagerState, currentState))
	            return enqueueUpdate$1(fiber, queue, update, 0), null === workInProgressRoot && finishQueueingConcurrentUpdates(), false;
	        } catch (error) {
	        } finally {
	          ReactSharedInternals.H = prevDispatcher;
	        }
	      }
	      action = enqueueConcurrentHookUpdate(fiber, queue, update, lane);
	      if (null !== action)
	        return scheduleUpdateOnFiber(action, fiber, lane), entangleTransitionUpdate(action, queue, lane), true;
	    }
	    return false;
	  }
	  function dispatchOptimisticSetState(fiber, throwIfDuringRender, queue, action) {
	    null === ReactSharedInternals.T && 0 === currentEntangledLane && console.error(
	      "An optimistic state update occurred outside a transition or action. To fix, move the update to an action, or wrap with startTransition."
	    );
	    action = {
	      lane: 2,
	      revertLane: requestTransitionLane(),
	      action,
	      hasEagerState: false,
	      eagerState: null,
	      next: null
	    };
	    if (isRenderPhaseUpdate(fiber)) {
	      if (throwIfDuringRender)
	        throw Error("Cannot update optimistic state while rendering.");
	      console.error("Cannot call startTransition while rendering.");
	    } else
	      throwIfDuringRender = enqueueConcurrentHookUpdate(
	        fiber,
	        queue,
	        action,
	        2
	      ), null !== throwIfDuringRender && scheduleUpdateOnFiber(throwIfDuringRender, fiber, 2);
	    markStateUpdateScheduled(fiber, 2);
	  }
	  function isRenderPhaseUpdate(fiber) {
	    var alternate = fiber.alternate;
	    return fiber === currentlyRenderingFiber || null !== alternate && alternate === currentlyRenderingFiber;
	  }
	  function enqueueRenderPhaseUpdate(queue, update) {
	    didScheduleRenderPhaseUpdateDuringThisPass = didScheduleRenderPhaseUpdate = true;
	    var pending = queue.pending;
	    null === pending ? update.next = update : (update.next = pending.next, pending.next = update);
	    queue.pending = update;
	  }
	  function entangleTransitionUpdate(root2, queue, lane) {
	    if (0 !== (lane & 4194048)) {
	      var queueLanes = queue.lanes;
	      queueLanes &= root2.pendingLanes;
	      lane |= queueLanes;
	      queue.lanes = lane;
	      markRootEntangled(root2, lane);
	    }
	  }
	  function pushDebugInfo(debugInfo) {
	    var previousDebugInfo = currentDebugInfo;
	    null != debugInfo && (currentDebugInfo = null === previousDebugInfo ? debugInfo : previousDebugInfo.concat(debugInfo));
	    return previousDebugInfo;
	  }
	  function validateFragmentProps(element, fiber, returnFiber) {
	    for (var keys = Object.keys(element.props), i = 0; i < keys.length; i++) {
	      var key = keys[i];
	      if ("children" !== key && "key" !== key) {
	        null === fiber && (fiber = createFiberFromElement(element, returnFiber.mode, 0), fiber._debugInfo = currentDebugInfo, fiber.return = returnFiber);
	        runWithFiberInDEV(
	          fiber,
	          function(erroredKey) {
	            console.error(
	              "Invalid prop `%s` supplied to `React.Fragment`. React.Fragment can only have `key` and `children` props.",
	              erroredKey
	            );
	          },
	          key
	        );
	        break;
	      }
	    }
	  }
	  function unwrapThenable(thenable) {
	    var index = thenableIndexCounter;
	    thenableIndexCounter += 1;
	    null === thenableState && (thenableState = createThenableState());
	    return trackUsedThenable(thenableState, thenable, index);
	  }
	  function coerceRef(workInProgress2, element) {
	    element = element.props.ref;
	    workInProgress2.ref = void 0 !== element ? element : null;
	  }
	  function throwOnInvalidObjectType(returnFiber, newChild) {
	    if (newChild.$$typeof === REACT_LEGACY_ELEMENT_TYPE)
	      throw Error(
	        'A React Element from an older version of React was rendered. This is not supported. It can happen if:\n- Multiple copies of the "react" package is used.\n- A library pre-bundled an old copy of "react" or "react/jsx-runtime".\n- A compiler tries to "inline" JSX instead of using the runtime.'
	      );
	    returnFiber = Object.prototype.toString.call(newChild);
	    throw Error(
	      "Objects are not valid as a React child (found: " + ("[object Object]" === returnFiber ? "object with keys {" + Object.keys(newChild).join(", ") + "}" : returnFiber) + "). If you meant to render a collection of children, use an array instead."
	    );
	  }
	  function warnOnFunctionType(returnFiber, invalidChild) {
	    var parentName = getComponentNameFromFiber(returnFiber) || "Component";
	    ownerHasFunctionTypeWarning[parentName] || (ownerHasFunctionTypeWarning[parentName] = true, invalidChild = invalidChild.displayName || invalidChild.name || "Component", 3 === returnFiber.tag ? console.error(
	      "Functions are not valid as a React child. This may happen if you return %s instead of <%s /> from render. Or maybe you meant to call this function rather than return it.\n  root.render(%s)",
	      invalidChild,
	      invalidChild,
	      invalidChild
	    ) : console.error(
	      "Functions are not valid as a React child. This may happen if you return %s instead of <%s /> from render. Or maybe you meant to call this function rather than return it.\n  <%s>{%s}</%s>",
	      invalidChild,
	      invalidChild,
	      parentName,
	      invalidChild,
	      parentName
	    ));
	  }
	  function warnOnSymbolType(returnFiber, invalidChild) {
	    var parentName = getComponentNameFromFiber(returnFiber) || "Component";
	    ownerHasSymbolTypeWarning[parentName] || (ownerHasSymbolTypeWarning[parentName] = true, invalidChild = String(invalidChild), 3 === returnFiber.tag ? console.error(
	      "Symbols are not valid as a React child.\n  root.render(%s)",
	      invalidChild
	    ) : console.error(
	      "Symbols are not valid as a React child.\n  <%s>%s</%s>",
	      parentName,
	      invalidChild,
	      parentName
	    ));
	  }
	  function createChildReconciler(shouldTrackSideEffects) {
	    function deleteChild(returnFiber, childToDelete) {
	      if (shouldTrackSideEffects) {
	        var deletions = returnFiber.deletions;
	        null === deletions ? (returnFiber.deletions = [childToDelete], returnFiber.flags |= 16) : deletions.push(childToDelete);
	      }
	    }
	    function deleteRemainingChildren(returnFiber, currentFirstChild) {
	      if (!shouldTrackSideEffects) return null;
	      for (; null !== currentFirstChild; )
	        deleteChild(returnFiber, currentFirstChild), currentFirstChild = currentFirstChild.sibling;
	      return null;
	    }
	    function mapRemainingChildren(currentFirstChild) {
	      for (var existingChildren = /* @__PURE__ */ new Map(); null !== currentFirstChild; )
	        null !== currentFirstChild.key ? existingChildren.set(currentFirstChild.key, currentFirstChild) : existingChildren.set(currentFirstChild.index, currentFirstChild), currentFirstChild = currentFirstChild.sibling;
	      return existingChildren;
	    }
	    function useFiber(fiber, pendingProps) {
	      fiber = createWorkInProgress(fiber, pendingProps);
	      fiber.index = 0;
	      fiber.sibling = null;
	      return fiber;
	    }
	    function placeChild(newFiber, lastPlacedIndex, newIndex) {
	      newFiber.index = newIndex;
	      if (!shouldTrackSideEffects)
	        return newFiber.flags |= 1048576, lastPlacedIndex;
	      newIndex = newFiber.alternate;
	      if (null !== newIndex)
	        return newIndex = newIndex.index, newIndex < lastPlacedIndex ? (newFiber.flags |= 67108866, lastPlacedIndex) : newIndex;
	      newFiber.flags |= 67108866;
	      return lastPlacedIndex;
	    }
	    function placeSingleChild(newFiber) {
	      shouldTrackSideEffects && null === newFiber.alternate && (newFiber.flags |= 67108866);
	      return newFiber;
	    }
	    function updateTextNode(returnFiber, current2, textContent, lanes) {
	      if (null === current2 || 6 !== current2.tag)
	        return current2 = createFiberFromText(
	          textContent,
	          returnFiber.mode,
	          lanes
	        ), current2.return = returnFiber, current2._debugOwner = returnFiber, current2._debugTask = returnFiber._debugTask, current2._debugInfo = currentDebugInfo, current2;
	      current2 = useFiber(current2, textContent);
	      current2.return = returnFiber;
	      current2._debugInfo = currentDebugInfo;
	      return current2;
	    }
	    function updateElement(returnFiber, current2, element, lanes) {
	      var elementType = element.type;
	      if (elementType === REACT_FRAGMENT_TYPE)
	        return current2 = updateFragment(
	          returnFiber,
	          current2,
	          element.props.children,
	          lanes,
	          element.key
	        ), validateFragmentProps(element, current2, returnFiber), current2;
	      if (null !== current2 && (current2.elementType === elementType || isCompatibleFamilyForHotReloading(current2, element) || "object" === typeof elementType && null !== elementType && elementType.$$typeof === REACT_LAZY_TYPE && callLazyInitInDEV(elementType) === current2.type))
	        return current2 = useFiber(current2, element.props), coerceRef(current2, element), current2.return = returnFiber, current2._debugOwner = element._owner, current2._debugInfo = currentDebugInfo, current2;
	      current2 = createFiberFromElement(element, returnFiber.mode, lanes);
	      coerceRef(current2, element);
	      current2.return = returnFiber;
	      current2._debugInfo = currentDebugInfo;
	      return current2;
	    }
	    function updatePortal(returnFiber, current2, portal, lanes) {
	      if (null === current2 || 4 !== current2.tag || current2.stateNode.containerInfo !== portal.containerInfo || current2.stateNode.implementation !== portal.implementation)
	        return current2 = createFiberFromPortal(portal, returnFiber.mode, lanes), current2.return = returnFiber, current2._debugInfo = currentDebugInfo, current2;
	      current2 = useFiber(current2, portal.children || []);
	      current2.return = returnFiber;
	      current2._debugInfo = currentDebugInfo;
	      return current2;
	    }
	    function updateFragment(returnFiber, current2, fragment, lanes, key) {
	      if (null === current2 || 7 !== current2.tag)
	        return current2 = createFiberFromFragment(
	          fragment,
	          returnFiber.mode,
	          lanes,
	          key
	        ), current2.return = returnFiber, current2._debugOwner = returnFiber, current2._debugTask = returnFiber._debugTask, current2._debugInfo = currentDebugInfo, current2;
	      current2 = useFiber(current2, fragment);
	      current2.return = returnFiber;
	      current2._debugInfo = currentDebugInfo;
	      return current2;
	    }
	    function createChild(returnFiber, newChild, lanes) {
	      if ("string" === typeof newChild && "" !== newChild || "number" === typeof newChild || "bigint" === typeof newChild)
	        return newChild = createFiberFromText(
	          "" + newChild,
	          returnFiber.mode,
	          lanes
	        ), newChild.return = returnFiber, newChild._debugOwner = returnFiber, newChild._debugTask = returnFiber._debugTask, newChild._debugInfo = currentDebugInfo, newChild;
	      if ("object" === typeof newChild && null !== newChild) {
	        switch (newChild.$$typeof) {
	          case REACT_ELEMENT_TYPE:
	            return lanes = createFiberFromElement(
	              newChild,
	              returnFiber.mode,
	              lanes
	            ), coerceRef(lanes, newChild), lanes.return = returnFiber, returnFiber = pushDebugInfo(newChild._debugInfo), lanes._debugInfo = currentDebugInfo, currentDebugInfo = returnFiber, lanes;
	          case REACT_PORTAL_TYPE:
	            return newChild = createFiberFromPortal(
	              newChild,
	              returnFiber.mode,
	              lanes
	            ), newChild.return = returnFiber, newChild._debugInfo = currentDebugInfo, newChild;
	          case REACT_LAZY_TYPE:
	            var _prevDebugInfo = pushDebugInfo(newChild._debugInfo);
	            newChild = callLazyInitInDEV(newChild);
	            returnFiber = createChild(returnFiber, newChild, lanes);
	            currentDebugInfo = _prevDebugInfo;
	            return returnFiber;
	        }
	        if (isArrayImpl(newChild) || getIteratorFn(newChild))
	          return lanes = createFiberFromFragment(
	            newChild,
	            returnFiber.mode,
	            lanes,
	            null
	          ), lanes.return = returnFiber, lanes._debugOwner = returnFiber, lanes._debugTask = returnFiber._debugTask, returnFiber = pushDebugInfo(newChild._debugInfo), lanes._debugInfo = currentDebugInfo, currentDebugInfo = returnFiber, lanes;
	        if ("function" === typeof newChild.then)
	          return _prevDebugInfo = pushDebugInfo(newChild._debugInfo), returnFiber = createChild(
	            returnFiber,
	            unwrapThenable(newChild),
	            lanes
	          ), currentDebugInfo = _prevDebugInfo, returnFiber;
	        if (newChild.$$typeof === REACT_CONTEXT_TYPE)
	          return createChild(
	            returnFiber,
	            readContextDuringReconciliation(returnFiber, newChild),
	            lanes
	          );
	        throwOnInvalidObjectType(returnFiber, newChild);
	      }
	      "function" === typeof newChild && warnOnFunctionType(returnFiber, newChild);
	      "symbol" === typeof newChild && warnOnSymbolType(returnFiber, newChild);
	      return null;
	    }
	    function updateSlot(returnFiber, oldFiber, newChild, lanes) {
	      var key = null !== oldFiber ? oldFiber.key : null;
	      if ("string" === typeof newChild && "" !== newChild || "number" === typeof newChild || "bigint" === typeof newChild)
	        return null !== key ? null : updateTextNode(returnFiber, oldFiber, "" + newChild, lanes);
	      if ("object" === typeof newChild && null !== newChild) {
	        switch (newChild.$$typeof) {
	          case REACT_ELEMENT_TYPE:
	            return newChild.key === key ? (key = pushDebugInfo(newChild._debugInfo), returnFiber = updateElement(
	              returnFiber,
	              oldFiber,
	              newChild,
	              lanes
	            ), currentDebugInfo = key, returnFiber) : null;
	          case REACT_PORTAL_TYPE:
	            return newChild.key === key ? updatePortal(returnFiber, oldFiber, newChild, lanes) : null;
	          case REACT_LAZY_TYPE:
	            return key = pushDebugInfo(newChild._debugInfo), newChild = callLazyInitInDEV(newChild), returnFiber = updateSlot(
	              returnFiber,
	              oldFiber,
	              newChild,
	              lanes
	            ), currentDebugInfo = key, returnFiber;
	        }
	        if (isArrayImpl(newChild) || getIteratorFn(newChild)) {
	          if (null !== key) return null;
	          key = pushDebugInfo(newChild._debugInfo);
	          returnFiber = updateFragment(
	            returnFiber,
	            oldFiber,
	            newChild,
	            lanes,
	            null
	          );
	          currentDebugInfo = key;
	          return returnFiber;
	        }
	        if ("function" === typeof newChild.then)
	          return key = pushDebugInfo(newChild._debugInfo), returnFiber = updateSlot(
	            returnFiber,
	            oldFiber,
	            unwrapThenable(newChild),
	            lanes
	          ), currentDebugInfo = key, returnFiber;
	        if (newChild.$$typeof === REACT_CONTEXT_TYPE)
	          return updateSlot(
	            returnFiber,
	            oldFiber,
	            readContextDuringReconciliation(returnFiber, newChild),
	            lanes
	          );
	        throwOnInvalidObjectType(returnFiber, newChild);
	      }
	      "function" === typeof newChild && warnOnFunctionType(returnFiber, newChild);
	      "symbol" === typeof newChild && warnOnSymbolType(returnFiber, newChild);
	      return null;
	    }
	    function updateFromMap(existingChildren, returnFiber, newIdx, newChild, lanes) {
	      if ("string" === typeof newChild && "" !== newChild || "number" === typeof newChild || "bigint" === typeof newChild)
	        return existingChildren = existingChildren.get(newIdx) || null, updateTextNode(returnFiber, existingChildren, "" + newChild, lanes);
	      if ("object" === typeof newChild && null !== newChild) {
	        switch (newChild.$$typeof) {
	          case REACT_ELEMENT_TYPE:
	            return newIdx = existingChildren.get(
	              null === newChild.key ? newIdx : newChild.key
	            ) || null, existingChildren = pushDebugInfo(newChild._debugInfo), returnFiber = updateElement(
	              returnFiber,
	              newIdx,
	              newChild,
	              lanes
	            ), currentDebugInfo = existingChildren, returnFiber;
	          case REACT_PORTAL_TYPE:
	            return existingChildren = existingChildren.get(
	              null === newChild.key ? newIdx : newChild.key
	            ) || null, updatePortal(returnFiber, existingChildren, newChild, lanes);
	          case REACT_LAZY_TYPE:
	            var _prevDebugInfo7 = pushDebugInfo(newChild._debugInfo);
	            newChild = callLazyInitInDEV(newChild);
	            returnFiber = updateFromMap(
	              existingChildren,
	              returnFiber,
	              newIdx,
	              newChild,
	              lanes
	            );
	            currentDebugInfo = _prevDebugInfo7;
	            return returnFiber;
	        }
	        if (isArrayImpl(newChild) || getIteratorFn(newChild))
	          return newIdx = existingChildren.get(newIdx) || null, existingChildren = pushDebugInfo(newChild._debugInfo), returnFiber = updateFragment(
	            returnFiber,
	            newIdx,
	            newChild,
	            lanes,
	            null
	          ), currentDebugInfo = existingChildren, returnFiber;
	        if ("function" === typeof newChild.then)
	          return _prevDebugInfo7 = pushDebugInfo(newChild._debugInfo), returnFiber = updateFromMap(
	            existingChildren,
	            returnFiber,
	            newIdx,
	            unwrapThenable(newChild),
	            lanes
	          ), currentDebugInfo = _prevDebugInfo7, returnFiber;
	        if (newChild.$$typeof === REACT_CONTEXT_TYPE)
	          return updateFromMap(
	            existingChildren,
	            returnFiber,
	            newIdx,
	            readContextDuringReconciliation(returnFiber, newChild),
	            lanes
	          );
	        throwOnInvalidObjectType(returnFiber, newChild);
	      }
	      "function" === typeof newChild && warnOnFunctionType(returnFiber, newChild);
	      "symbol" === typeof newChild && warnOnSymbolType(returnFiber, newChild);
	      return null;
	    }
	    function warnOnInvalidKey(returnFiber, workInProgress2, child, knownKeys) {
	      if ("object" !== typeof child || null === child) return knownKeys;
	      switch (child.$$typeof) {
	        case REACT_ELEMENT_TYPE:
	        case REACT_PORTAL_TYPE:
	          warnForMissingKey(returnFiber, workInProgress2, child);
	          var key = child.key;
	          if ("string" !== typeof key) break;
	          if (null === knownKeys) {
	            knownKeys = /* @__PURE__ */ new Set();
	            knownKeys.add(key);
	            break;
	          }
	          if (!knownKeys.has(key)) {
	            knownKeys.add(key);
	            break;
	          }
	          runWithFiberInDEV(workInProgress2, function() {
	            console.error(
	              "Encountered two children with the same key, `%s`. Keys should be unique so that components maintain their identity across updates. Non-unique keys may cause children to be duplicated and/or omitted — the behavior is unsupported and could change in a future version.",
	              key
	            );
	          });
	          break;
	        case REACT_LAZY_TYPE:
	          child = callLazyInitInDEV(child), warnOnInvalidKey(returnFiber, workInProgress2, child, knownKeys);
	      }
	      return knownKeys;
	    }
	    function reconcileChildrenArray(returnFiber, currentFirstChild, newChildren, lanes) {
	      for (var knownKeys = null, resultingFirstChild = null, previousNewFiber = null, oldFiber = currentFirstChild, newIdx = currentFirstChild = 0, nextOldFiber = null; null !== oldFiber && newIdx < newChildren.length; newIdx++) {
	        oldFiber.index > newIdx ? (nextOldFiber = oldFiber, oldFiber = null) : nextOldFiber = oldFiber.sibling;
	        var newFiber = updateSlot(
	          returnFiber,
	          oldFiber,
	          newChildren[newIdx],
	          lanes
	        );
	        if (null === newFiber) {
	          null === oldFiber && (oldFiber = nextOldFiber);
	          break;
	        }
	        knownKeys = warnOnInvalidKey(
	          returnFiber,
	          newFiber,
	          newChildren[newIdx],
	          knownKeys
	        );
	        shouldTrackSideEffects && oldFiber && null === newFiber.alternate && deleteChild(returnFiber, oldFiber);
	        currentFirstChild = placeChild(newFiber, currentFirstChild, newIdx);
	        null === previousNewFiber ? resultingFirstChild = newFiber : previousNewFiber.sibling = newFiber;
	        previousNewFiber = newFiber;
	        oldFiber = nextOldFiber;
	      }
	      if (newIdx === newChildren.length)
	        return deleteRemainingChildren(returnFiber, oldFiber), isHydrating && pushTreeFork(returnFiber, newIdx), resultingFirstChild;
	      if (null === oldFiber) {
	        for (; newIdx < newChildren.length; newIdx++)
	          oldFiber = createChild(returnFiber, newChildren[newIdx], lanes), null !== oldFiber && (knownKeys = warnOnInvalidKey(
	            returnFiber,
	            oldFiber,
	            newChildren[newIdx],
	            knownKeys
	          ), currentFirstChild = placeChild(
	            oldFiber,
	            currentFirstChild,
	            newIdx
	          ), null === previousNewFiber ? resultingFirstChild = oldFiber : previousNewFiber.sibling = oldFiber, previousNewFiber = oldFiber);
	        isHydrating && pushTreeFork(returnFiber, newIdx);
	        return resultingFirstChild;
	      }
	      for (oldFiber = mapRemainingChildren(oldFiber); newIdx < newChildren.length; newIdx++)
	        nextOldFiber = updateFromMap(
	          oldFiber,
	          returnFiber,
	          newIdx,
	          newChildren[newIdx],
	          lanes
	        ), null !== nextOldFiber && (knownKeys = warnOnInvalidKey(
	          returnFiber,
	          nextOldFiber,
	          newChildren[newIdx],
	          knownKeys
	        ), shouldTrackSideEffects && null !== nextOldFiber.alternate && oldFiber.delete(
	          null === nextOldFiber.key ? newIdx : nextOldFiber.key
	        ), currentFirstChild = placeChild(
	          nextOldFiber,
	          currentFirstChild,
	          newIdx
	        ), null === previousNewFiber ? resultingFirstChild = nextOldFiber : previousNewFiber.sibling = nextOldFiber, previousNewFiber = nextOldFiber);
	      shouldTrackSideEffects && oldFiber.forEach(function(child) {
	        return deleteChild(returnFiber, child);
	      });
	      isHydrating && pushTreeFork(returnFiber, newIdx);
	      return resultingFirstChild;
	    }
	    function reconcileChildrenIterator(returnFiber, currentFirstChild, newChildren, lanes) {
	      if (null == newChildren)
	        throw Error("An iterable object provided no iterator.");
	      for (var resultingFirstChild = null, previousNewFiber = null, oldFiber = currentFirstChild, newIdx = currentFirstChild = 0, nextOldFiber = null, knownKeys = null, step = newChildren.next(); null !== oldFiber && !step.done; newIdx++, step = newChildren.next()) {
	        oldFiber.index > newIdx ? (nextOldFiber = oldFiber, oldFiber = null) : nextOldFiber = oldFiber.sibling;
	        var newFiber = updateSlot(returnFiber, oldFiber, step.value, lanes);
	        if (null === newFiber) {
	          null === oldFiber && (oldFiber = nextOldFiber);
	          break;
	        }
	        knownKeys = warnOnInvalidKey(
	          returnFiber,
	          newFiber,
	          step.value,
	          knownKeys
	        );
	        shouldTrackSideEffects && oldFiber && null === newFiber.alternate && deleteChild(returnFiber, oldFiber);
	        currentFirstChild = placeChild(newFiber, currentFirstChild, newIdx);
	        null === previousNewFiber ? resultingFirstChild = newFiber : previousNewFiber.sibling = newFiber;
	        previousNewFiber = newFiber;
	        oldFiber = nextOldFiber;
	      }
	      if (step.done)
	        return deleteRemainingChildren(returnFiber, oldFiber), isHydrating && pushTreeFork(returnFiber, newIdx), resultingFirstChild;
	      if (null === oldFiber) {
	        for (; !step.done; newIdx++, step = newChildren.next())
	          oldFiber = createChild(returnFiber, step.value, lanes), null !== oldFiber && (knownKeys = warnOnInvalidKey(
	            returnFiber,
	            oldFiber,
	            step.value,
	            knownKeys
	          ), currentFirstChild = placeChild(
	            oldFiber,
	            currentFirstChild,
	            newIdx
	          ), null === previousNewFiber ? resultingFirstChild = oldFiber : previousNewFiber.sibling = oldFiber, previousNewFiber = oldFiber);
	        isHydrating && pushTreeFork(returnFiber, newIdx);
	        return resultingFirstChild;
	      }
	      for (oldFiber = mapRemainingChildren(oldFiber); !step.done; newIdx++, step = newChildren.next())
	        nextOldFiber = updateFromMap(
	          oldFiber,
	          returnFiber,
	          newIdx,
	          step.value,
	          lanes
	        ), null !== nextOldFiber && (knownKeys = warnOnInvalidKey(
	          returnFiber,
	          nextOldFiber,
	          step.value,
	          knownKeys
	        ), shouldTrackSideEffects && null !== nextOldFiber.alternate && oldFiber.delete(
	          null === nextOldFiber.key ? newIdx : nextOldFiber.key
	        ), currentFirstChild = placeChild(
	          nextOldFiber,
	          currentFirstChild,
	          newIdx
	        ), null === previousNewFiber ? resultingFirstChild = nextOldFiber : previousNewFiber.sibling = nextOldFiber, previousNewFiber = nextOldFiber);
	      shouldTrackSideEffects && oldFiber.forEach(function(child) {
	        return deleteChild(returnFiber, child);
	      });
	      isHydrating && pushTreeFork(returnFiber, newIdx);
	      return resultingFirstChild;
	    }
	    function reconcileChildFibersImpl(returnFiber, currentFirstChild, newChild, lanes) {
	      "object" === typeof newChild && null !== newChild && newChild.type === REACT_FRAGMENT_TYPE && null === newChild.key && (validateFragmentProps(newChild, null, returnFiber), newChild = newChild.props.children);
	      if ("object" === typeof newChild && null !== newChild) {
	        switch (newChild.$$typeof) {
	          case REACT_ELEMENT_TYPE:
	            var prevDebugInfo = pushDebugInfo(newChild._debugInfo);
	            a: {
	              for (var key = newChild.key; null !== currentFirstChild; ) {
	                if (currentFirstChild.key === key) {
	                  key = newChild.type;
	                  if (key === REACT_FRAGMENT_TYPE) {
	                    if (7 === currentFirstChild.tag) {
	                      deleteRemainingChildren(
	                        returnFiber,
	                        currentFirstChild.sibling
	                      );
	                      lanes = useFiber(
	                        currentFirstChild,
	                        newChild.props.children
	                      );
	                      lanes.return = returnFiber;
	                      lanes._debugOwner = newChild._owner;
	                      lanes._debugInfo = currentDebugInfo;
	                      validateFragmentProps(newChild, lanes, returnFiber);
	                      returnFiber = lanes;
	                      break a;
	                    }
	                  } else if (currentFirstChild.elementType === key || isCompatibleFamilyForHotReloading(
	                    currentFirstChild,
	                    newChild
	                  ) || "object" === typeof key && null !== key && key.$$typeof === REACT_LAZY_TYPE && callLazyInitInDEV(key) === currentFirstChild.type) {
	                    deleteRemainingChildren(
	                      returnFiber,
	                      currentFirstChild.sibling
	                    );
	                    lanes = useFiber(currentFirstChild, newChild.props);
	                    coerceRef(lanes, newChild);
	                    lanes.return = returnFiber;
	                    lanes._debugOwner = newChild._owner;
	                    lanes._debugInfo = currentDebugInfo;
	                    returnFiber = lanes;
	                    break a;
	                  }
	                  deleteRemainingChildren(returnFiber, currentFirstChild);
	                  break;
	                } else deleteChild(returnFiber, currentFirstChild);
	                currentFirstChild = currentFirstChild.sibling;
	              }
	              newChild.type === REACT_FRAGMENT_TYPE ? (lanes = createFiberFromFragment(
	                newChild.props.children,
	                returnFiber.mode,
	                lanes,
	                newChild.key
	              ), lanes.return = returnFiber, lanes._debugOwner = returnFiber, lanes._debugTask = returnFiber._debugTask, lanes._debugInfo = currentDebugInfo, validateFragmentProps(newChild, lanes, returnFiber), returnFiber = lanes) : (lanes = createFiberFromElement(
	                newChild,
	                returnFiber.mode,
	                lanes
	              ), coerceRef(lanes, newChild), lanes.return = returnFiber, lanes._debugInfo = currentDebugInfo, returnFiber = lanes);
	            }
	            returnFiber = placeSingleChild(returnFiber);
	            currentDebugInfo = prevDebugInfo;
	            return returnFiber;
	          case REACT_PORTAL_TYPE:
	            a: {
	              prevDebugInfo = newChild;
	              for (newChild = prevDebugInfo.key; null !== currentFirstChild; ) {
	                if (currentFirstChild.key === newChild)
	                  if (4 === currentFirstChild.tag && currentFirstChild.stateNode.containerInfo === prevDebugInfo.containerInfo && currentFirstChild.stateNode.implementation === prevDebugInfo.implementation) {
	                    deleteRemainingChildren(
	                      returnFiber,
	                      currentFirstChild.sibling
	                    );
	                    lanes = useFiber(
	                      currentFirstChild,
	                      prevDebugInfo.children || []
	                    );
	                    lanes.return = returnFiber;
	                    returnFiber = lanes;
	                    break a;
	                  } else {
	                    deleteRemainingChildren(returnFiber, currentFirstChild);
	                    break;
	                  }
	                else deleteChild(returnFiber, currentFirstChild);
	                currentFirstChild = currentFirstChild.sibling;
	              }
	              lanes = createFiberFromPortal(
	                prevDebugInfo,
	                returnFiber.mode,
	                lanes
	              );
	              lanes.return = returnFiber;
	              returnFiber = lanes;
	            }
	            return placeSingleChild(returnFiber);
	          case REACT_LAZY_TYPE:
	            return prevDebugInfo = pushDebugInfo(newChild._debugInfo), newChild = callLazyInitInDEV(newChild), returnFiber = reconcileChildFibersImpl(
	              returnFiber,
	              currentFirstChild,
	              newChild,
	              lanes
	            ), currentDebugInfo = prevDebugInfo, returnFiber;
	        }
	        if (isArrayImpl(newChild))
	          return prevDebugInfo = pushDebugInfo(newChild._debugInfo), returnFiber = reconcileChildrenArray(
	            returnFiber,
	            currentFirstChild,
	            newChild,
	            lanes
	          ), currentDebugInfo = prevDebugInfo, returnFiber;
	        if (getIteratorFn(newChild)) {
	          prevDebugInfo = pushDebugInfo(newChild._debugInfo);
	          key = getIteratorFn(newChild);
	          if ("function" !== typeof key)
	            throw Error(
	              "An object is not an iterable. This error is likely caused by a bug in React. Please file an issue."
	            );
	          var newChildren = key.call(newChild);
	          if (newChildren === newChild) {
	            if (0 !== returnFiber.tag || "[object GeneratorFunction]" !== Object.prototype.toString.call(returnFiber.type) || "[object Generator]" !== Object.prototype.toString.call(newChildren))
	              didWarnAboutGenerators || console.error(
	                "Using Iterators as children is unsupported and will likely yield unexpected results because enumerating a generator mutates it. You may convert it to an array with `Array.from()` or the `[...spread]` operator before rendering. You can also use an Iterable that can iterate multiple times over the same items."
	              ), didWarnAboutGenerators = true;
	          } else
	            newChild.entries !== key || didWarnAboutMaps || (console.error(
	              "Using Maps as children is not supported. Use an array of keyed ReactElements instead."
	            ), didWarnAboutMaps = true);
	          returnFiber = reconcileChildrenIterator(
	            returnFiber,
	            currentFirstChild,
	            newChildren,
	            lanes
	          );
	          currentDebugInfo = prevDebugInfo;
	          return returnFiber;
	        }
	        if ("function" === typeof newChild.then)
	          return prevDebugInfo = pushDebugInfo(newChild._debugInfo), returnFiber = reconcileChildFibersImpl(
	            returnFiber,
	            currentFirstChild,
	            unwrapThenable(newChild),
	            lanes
	          ), currentDebugInfo = prevDebugInfo, returnFiber;
	        if (newChild.$$typeof === REACT_CONTEXT_TYPE)
	          return reconcileChildFibersImpl(
	            returnFiber,
	            currentFirstChild,
	            readContextDuringReconciliation(returnFiber, newChild),
	            lanes
	          );
	        throwOnInvalidObjectType(returnFiber, newChild);
	      }
	      if ("string" === typeof newChild && "" !== newChild || "number" === typeof newChild || "bigint" === typeof newChild)
	        return prevDebugInfo = "" + newChild, null !== currentFirstChild && 6 === currentFirstChild.tag ? (deleteRemainingChildren(
	          returnFiber,
	          currentFirstChild.sibling
	        ), lanes = useFiber(currentFirstChild, prevDebugInfo), lanes.return = returnFiber, returnFiber = lanes) : (deleteRemainingChildren(returnFiber, currentFirstChild), lanes = createFiberFromText(
	          prevDebugInfo,
	          returnFiber.mode,
	          lanes
	        ), lanes.return = returnFiber, lanes._debugOwner = returnFiber, lanes._debugTask = returnFiber._debugTask, lanes._debugInfo = currentDebugInfo, returnFiber = lanes), placeSingleChild(returnFiber);
	      "function" === typeof newChild && warnOnFunctionType(returnFiber, newChild);
	      "symbol" === typeof newChild && warnOnSymbolType(returnFiber, newChild);
	      return deleteRemainingChildren(returnFiber, currentFirstChild);
	    }
	    return function(returnFiber, currentFirstChild, newChild, lanes) {
	      var prevDebugInfo = currentDebugInfo;
	      currentDebugInfo = null;
	      try {
	        thenableIndexCounter = 0;
	        var firstChildFiber = reconcileChildFibersImpl(
	          returnFiber,
	          currentFirstChild,
	          newChild,
	          lanes
	        );
	        thenableState = null;
	        return firstChildFiber;
	      } catch (x) {
	        if (x === SuspenseException || x === SuspenseActionException) throw x;
	        var fiber = createFiber(29, x, null, returnFiber.mode);
	        fiber.lanes = lanes;
	        fiber.return = returnFiber;
	        var debugInfo = fiber._debugInfo = currentDebugInfo;
	        fiber._debugOwner = returnFiber._debugOwner;
	        fiber._debugTask = returnFiber._debugTask;
	        if (null != debugInfo) {
	          for (var i = debugInfo.length - 1; 0 <= i; i--)
	            if ("string" === typeof debugInfo[i].stack) {
	              fiber._debugOwner = debugInfo[i];
	              fiber._debugTask = debugInfo[i].debugTask;
	              break;
	            }
	        }
	        return fiber;
	      } finally {
	        currentDebugInfo = prevDebugInfo;
	      }
	    };
	  }
	  function pushPrimaryTreeSuspenseHandler(handler) {
	    var current2 = handler.alternate;
	    push(
	      suspenseStackCursor,
	      suspenseStackCursor.current & SubtreeSuspenseContextMask,
	      handler
	    );
	    push(suspenseHandlerStackCursor, handler, handler);
	    null === shellBoundary && (null === current2 || null !== currentTreeHiddenStackCursor.current ? shellBoundary = handler : null !== current2.memoizedState && (shellBoundary = handler));
	  }
	  function pushOffscreenSuspenseHandler(fiber) {
	    if (22 === fiber.tag) {
	      if (push(suspenseStackCursor, suspenseStackCursor.current, fiber), push(suspenseHandlerStackCursor, fiber, fiber), null === shellBoundary) {
	        var current2 = fiber.alternate;
	        null !== current2 && null !== current2.memoizedState && (shellBoundary = fiber);
	      }
	    } else reuseSuspenseHandlerOnStack(fiber);
	  }
	  function reuseSuspenseHandlerOnStack(fiber) {
	    push(suspenseStackCursor, suspenseStackCursor.current, fiber);
	    push(
	      suspenseHandlerStackCursor,
	      suspenseHandlerStackCursor.current,
	      fiber
	    );
	  }
	  function popSuspenseHandler(fiber) {
	    pop(suspenseHandlerStackCursor, fiber);
	    shellBoundary === fiber && (shellBoundary = null);
	    pop(suspenseStackCursor, fiber);
	  }
	  function findFirstSuspended(row) {
	    for (var node = row; null !== node; ) {
	      if (13 === node.tag) {
	        var state = node.memoizedState;
	        if (null !== state && (state = state.dehydrated, null === state || state.data === SUSPENSE_PENDING_START_DATA || isSuspenseInstanceFallback(state)))
	          return node;
	      } else if (19 === node.tag && void 0 !== node.memoizedProps.revealOrder) {
	        if (0 !== (node.flags & 128)) return node;
	      } else if (null !== node.child) {
	        node.child.return = node;
	        node = node.child;
	        continue;
	      }
	      if (node === row) break;
	      for (; null === node.sibling; ) {
	        if (null === node.return || node.return === row) return null;
	        node = node.return;
	      }
	      node.sibling.return = node.return;
	      node = node.sibling;
	    }
	    return null;
	  }
	  function warnOnInvalidCallback(callback) {
	    if (null !== callback && "function" !== typeof callback) {
	      var key = String(callback);
	      didWarnOnInvalidCallback.has(key) || (didWarnOnInvalidCallback.add(key), console.error(
	        "Expected the last optional `callback` argument to be a function. Instead received: %s.",
	        callback
	      ));
	    }
	  }
	  function applyDerivedStateFromProps(workInProgress2, ctor, getDerivedStateFromProps, nextProps) {
	    var prevState = workInProgress2.memoizedState, partialState = getDerivedStateFromProps(nextProps, prevState);
	    if (workInProgress2.mode & StrictLegacyMode) {
	      setIsStrictModeForDevtools(true);
	      try {
	        partialState = getDerivedStateFromProps(nextProps, prevState);
	      } finally {
	        setIsStrictModeForDevtools(false);
	      }
	    }
	    void 0 === partialState && (ctor = getComponentNameFromType(ctor) || "Component", didWarnAboutUndefinedDerivedState.has(ctor) || (didWarnAboutUndefinedDerivedState.add(ctor), console.error(
	      "%s.getDerivedStateFromProps(): A valid state object (or null) must be returned. You have returned undefined.",
	      ctor
	    )));
	    prevState = null === partialState || void 0 === partialState ? prevState : assign({}, prevState, partialState);
	    workInProgress2.memoizedState = prevState;
	    0 === workInProgress2.lanes && (workInProgress2.updateQueue.baseState = prevState);
	  }
	  function checkShouldComponentUpdate(workInProgress2, ctor, oldProps, newProps, oldState, newState, nextContext) {
	    var instance = workInProgress2.stateNode;
	    if ("function" === typeof instance.shouldComponentUpdate) {
	      oldProps = instance.shouldComponentUpdate(
	        newProps,
	        newState,
	        nextContext
	      );
	      if (workInProgress2.mode & StrictLegacyMode) {
	        setIsStrictModeForDevtools(true);
	        try {
	          oldProps = instance.shouldComponentUpdate(
	            newProps,
	            newState,
	            nextContext
	          );
	        } finally {
	          setIsStrictModeForDevtools(false);
	        }
	      }
	      void 0 === oldProps && console.error(
	        "%s.shouldComponentUpdate(): Returned undefined instead of a boolean value. Make sure to return true or false.",
	        getComponentNameFromType(ctor) || "Component"
	      );
	      return oldProps;
	    }
	    return ctor.prototype && ctor.prototype.isPureReactComponent ? !shallowEqual(oldProps, newProps) || !shallowEqual(oldState, newState) : true;
	  }
	  function callComponentWillReceiveProps(workInProgress2, instance, newProps, nextContext) {
	    var oldState = instance.state;
	    "function" === typeof instance.componentWillReceiveProps && instance.componentWillReceiveProps(newProps, nextContext);
	    "function" === typeof instance.UNSAFE_componentWillReceiveProps && instance.UNSAFE_componentWillReceiveProps(newProps, nextContext);
	    instance.state !== oldState && (workInProgress2 = getComponentNameFromFiber(workInProgress2) || "Component", didWarnAboutStateAssignmentForComponent.has(workInProgress2) || (didWarnAboutStateAssignmentForComponent.add(workInProgress2), console.error(
	      "%s.componentWillReceiveProps(): Assigning directly to this.state is deprecated (except inside a component's constructor). Use setState instead.",
	      workInProgress2
	    )), classComponentUpdater.enqueueReplaceState(
	      instance,
	      instance.state,
	      null
	    ));
	  }
	  function resolveClassComponentProps(Component, baseProps) {
	    var newProps = baseProps;
	    if ("ref" in baseProps) {
	      newProps = {};
	      for (var propName in baseProps)
	        "ref" !== propName && (newProps[propName] = baseProps[propName]);
	    }
	    if (Component = Component.defaultProps) {
	      newProps === baseProps && (newProps = assign({}, newProps));
	      for (var _propName in Component)
	        void 0 === newProps[_propName] && (newProps[_propName] = Component[_propName]);
	    }
	    return newProps;
	  }
	  function defaultOnUncaughtError(error) {
	    reportGlobalError(error);
	    console.warn(
	      "%s\n\n%s\n",
	      componentName ? "An error occurred in the <" + componentName + "> component." : "An error occurred in one of your React components.",
	      "Consider adding an error boundary to your tree to customize error handling behavior.\nVisit https://react.dev/link/error-boundaries to learn more about error boundaries."
	    );
	  }
	  function defaultOnCaughtError(error) {
	    var componentNameMessage = componentName ? "The above error occurred in the <" + componentName + "> component." : "The above error occurred in one of your React components.", recreateMessage = "React will try to recreate this component tree from scratch using the error boundary you provided, " + ((errorBoundaryName || "Anonymous") + ".");
	    if ("object" === typeof error && null !== error && "string" === typeof error.environmentName) {
	      var JSCompiler_inline_result = error.environmentName;
	      error = [
	        "%o\n\n%s\n\n%s\n",
	        error,
	        componentNameMessage,
	        recreateMessage
	      ].slice(0);
	      "string" === typeof error[0] ? error.splice(
	        0,
	        1,
	        badgeFormat + error[0],
	        badgeStyle,
	        pad + JSCompiler_inline_result + pad,
	        resetStyle
	      ) : error.splice(
	        0,
	        0,
	        badgeFormat,
	        badgeStyle,
	        pad + JSCompiler_inline_result + pad,
	        resetStyle
	      );
	      error.unshift(console);
	      JSCompiler_inline_result = bind.apply(console.error, error);
	      JSCompiler_inline_result();
	    } else
	      console.error(
	        "%o\n\n%s\n\n%s\n",
	        error,
	        componentNameMessage,
	        recreateMessage
	      );
	  }
	  function defaultOnRecoverableError(error) {
	    reportGlobalError(error);
	  }
	  function logUncaughtError(root2, errorInfo) {
	    try {
	      componentName = errorInfo.source ? getComponentNameFromFiber(errorInfo.source) : null;
	      errorBoundaryName = null;
	      var error = errorInfo.value;
	      if (null !== ReactSharedInternals.actQueue)
	        ReactSharedInternals.thrownErrors.push(error);
	      else {
	        var onUncaughtError = root2.onUncaughtError;
	        onUncaughtError(error, { componentStack: errorInfo.stack });
	      }
	    } catch (e$5) {
	      setTimeout(function() {
	        throw e$5;
	      });
	    }
	  }
	  function logCaughtError(root2, boundary, errorInfo) {
	    try {
	      componentName = errorInfo.source ? getComponentNameFromFiber(errorInfo.source) : null;
	      errorBoundaryName = getComponentNameFromFiber(boundary);
	      var onCaughtError = root2.onCaughtError;
	      onCaughtError(errorInfo.value, {
	        componentStack: errorInfo.stack,
	        errorBoundary: 1 === boundary.tag ? boundary.stateNode : null
	      });
	    } catch (e$6) {
	      setTimeout(function() {
	        throw e$6;
	      });
	    }
	  }
	  function createRootErrorUpdate(root2, errorInfo, lane) {
	    lane = createUpdate(lane);
	    lane.tag = CaptureUpdate;
	    lane.payload = { element: null };
	    lane.callback = function() {
	      runWithFiberInDEV(errorInfo.source, logUncaughtError, root2, errorInfo);
	    };
	    return lane;
	  }
	  function createClassErrorUpdate(lane) {
	    lane = createUpdate(lane);
	    lane.tag = CaptureUpdate;
	    return lane;
	  }
	  function initializeClassErrorUpdate(update, root2, fiber, errorInfo) {
	    var getDerivedStateFromError = fiber.type.getDerivedStateFromError;
	    if ("function" === typeof getDerivedStateFromError) {
	      var error = errorInfo.value;
	      update.payload = function() {
	        return getDerivedStateFromError(error);
	      };
	      update.callback = function() {
	        markFailedErrorBoundaryForHotReloading(fiber);
	        runWithFiberInDEV(
	          errorInfo.source,
	          logCaughtError,
	          root2,
	          fiber,
	          errorInfo
	        );
	      };
	    }
	    var inst = fiber.stateNode;
	    null !== inst && "function" === typeof inst.componentDidCatch && (update.callback = function() {
	      markFailedErrorBoundaryForHotReloading(fiber);
	      runWithFiberInDEV(
	        errorInfo.source,
	        logCaughtError,
	        root2,
	        fiber,
	        errorInfo
	      );
	      "function" !== typeof getDerivedStateFromError && (null === legacyErrorBoundariesThatAlreadyFailed ? legacyErrorBoundariesThatAlreadyFailed = /* @__PURE__ */ new Set([this]) : legacyErrorBoundariesThatAlreadyFailed.add(this));
	      callComponentDidCatchInDEV(this, errorInfo);
	      "function" === typeof getDerivedStateFromError || 0 === (fiber.lanes & 2) && console.error(
	        "%s: Error boundaries should implement getDerivedStateFromError(). In that method, return a state update to display an error message or fallback UI.",
	        getComponentNameFromFiber(fiber) || "Unknown"
	      );
	    });
	  }
	  function throwException(root2, returnFiber, sourceFiber, value, rootRenderLanes) {
	    sourceFiber.flags |= 32768;
	    isDevToolsPresent && restorePendingUpdaters(root2, rootRenderLanes);
	    if (null !== value && "object" === typeof value && "function" === typeof value.then) {
	      returnFiber = sourceFiber.alternate;
	      null !== returnFiber && propagateParentContextChanges(
	        returnFiber,
	        sourceFiber,
	        rootRenderLanes,
	        true
	      );
	      isHydrating && (didSuspendOrErrorDEV = true);
	      sourceFiber = suspenseHandlerStackCursor.current;
	      if (null !== sourceFiber) {
	        switch (sourceFiber.tag) {
	          case 13:
	            return null === shellBoundary ? renderDidSuspendDelayIfPossible() : null === sourceFiber.alternate && workInProgressRootExitStatus === RootInProgress && (workInProgressRootExitStatus = RootSuspended), sourceFiber.flags &= -257, sourceFiber.flags |= 65536, sourceFiber.lanes = rootRenderLanes, value === noopSuspenseyCommitThenable ? sourceFiber.flags |= 16384 : (returnFiber = sourceFiber.updateQueue, null === returnFiber ? sourceFiber.updateQueue = /* @__PURE__ */ new Set([value]) : returnFiber.add(value), attachPingListener(root2, value, rootRenderLanes)), false;
	          case 22:
	            return sourceFiber.flags |= 65536, value === noopSuspenseyCommitThenable ? sourceFiber.flags |= 16384 : (returnFiber = sourceFiber.updateQueue, null === returnFiber ? (returnFiber = {
	              transitions: null,
	              markerInstances: null,
	              retryQueue: /* @__PURE__ */ new Set([value])
	            }, sourceFiber.updateQueue = returnFiber) : (sourceFiber = returnFiber.retryQueue, null === sourceFiber ? returnFiber.retryQueue = /* @__PURE__ */ new Set([value]) : sourceFiber.add(value)), attachPingListener(root2, value, rootRenderLanes)), false;
	        }
	        throw Error(
	          "Unexpected Suspense handler tag (" + sourceFiber.tag + "). This is a bug in React."
	        );
	      }
	      attachPingListener(root2, value, rootRenderLanes);
	      renderDidSuspendDelayIfPossible();
	      return false;
	    }
	    if (isHydrating)
	      return didSuspendOrErrorDEV = true, returnFiber = suspenseHandlerStackCursor.current, null !== returnFiber ? (0 === (returnFiber.flags & 65536) && (returnFiber.flags |= 256), returnFiber.flags |= 65536, returnFiber.lanes = rootRenderLanes, value !== HydrationMismatchException && queueHydrationError(
	        createCapturedValueAtFiber(
	          Error(
	            "There was an error while hydrating but React was able to recover by instead client rendering from the nearest Suspense boundary.",
	            { cause: value }
	          ),
	          sourceFiber
	        )
	      )) : (value !== HydrationMismatchException && queueHydrationError(
	        createCapturedValueAtFiber(
	          Error(
	            "There was an error while hydrating but React was able to recover by instead client rendering the entire root.",
	            { cause: value }
	          ),
	          sourceFiber
	        )
	      ), root2 = root2.current.alternate, root2.flags |= 65536, rootRenderLanes &= -rootRenderLanes, root2.lanes |= rootRenderLanes, value = createCapturedValueAtFiber(value, sourceFiber), rootRenderLanes = createRootErrorUpdate(
	        root2.stateNode,
	        value,
	        rootRenderLanes
	      ), enqueueCapturedUpdate(root2, rootRenderLanes), workInProgressRootExitStatus !== RootSuspendedWithDelay && (workInProgressRootExitStatus = RootErrored)), false;
	    var error = createCapturedValueAtFiber(
	      Error(
	        "There was an error during concurrent rendering but React was able to recover by instead synchronously rendering the entire root.",
	        { cause: value }
	      ),
	      sourceFiber
	    );
	    null === workInProgressRootConcurrentErrors ? workInProgressRootConcurrentErrors = [error] : workInProgressRootConcurrentErrors.push(error);
	    workInProgressRootExitStatus !== RootSuspendedWithDelay && (workInProgressRootExitStatus = RootErrored);
	    if (null === returnFiber) return true;
	    value = createCapturedValueAtFiber(value, sourceFiber);
	    sourceFiber = returnFiber;
	    do {
	      switch (sourceFiber.tag) {
	        case 3:
	          return sourceFiber.flags |= 65536, root2 = rootRenderLanes & -rootRenderLanes, sourceFiber.lanes |= root2, root2 = createRootErrorUpdate(
	            sourceFiber.stateNode,
	            value,
	            root2
	          ), enqueueCapturedUpdate(sourceFiber, root2), false;
	        case 1:
	          if (returnFiber = sourceFiber.type, error = sourceFiber.stateNode, 0 === (sourceFiber.flags & 128) && ("function" === typeof returnFiber.getDerivedStateFromError || null !== error && "function" === typeof error.componentDidCatch && (null === legacyErrorBoundariesThatAlreadyFailed || !legacyErrorBoundariesThatAlreadyFailed.has(error))))
	            return sourceFiber.flags |= 65536, rootRenderLanes &= -rootRenderLanes, sourceFiber.lanes |= rootRenderLanes, rootRenderLanes = createClassErrorUpdate(rootRenderLanes), initializeClassErrorUpdate(
	              rootRenderLanes,
	              root2,
	              sourceFiber,
	              value
	            ), enqueueCapturedUpdate(sourceFiber, rootRenderLanes), false;
	      }
	      sourceFiber = sourceFiber.return;
	    } while (null !== sourceFiber);
	    return false;
	  }
	  function reconcileChildren(current2, workInProgress2, nextChildren, renderLanes2) {
	    workInProgress2.child = null === current2 ? mountChildFibers(workInProgress2, null, nextChildren, renderLanes2) : reconcileChildFibers(
	      workInProgress2,
	      current2.child,
	      nextChildren,
	      renderLanes2
	    );
	  }
	  function updateForwardRef(current2, workInProgress2, Component, nextProps, renderLanes2) {
	    Component = Component.render;
	    var ref = workInProgress2.ref;
	    if ("ref" in nextProps) {
	      var propsWithoutRef = {};
	      for (var key in nextProps)
	        "ref" !== key && (propsWithoutRef[key] = nextProps[key]);
	    } else propsWithoutRef = nextProps;
	    prepareToReadContext(workInProgress2);
	    markComponentRenderStarted(workInProgress2);
	    nextProps = renderWithHooks(
	      current2,
	      workInProgress2,
	      Component,
	      propsWithoutRef,
	      ref,
	      renderLanes2
	    );
	    key = checkDidRenderIdHook();
	    markComponentRenderStopped();
	    if (null !== current2 && !didReceiveUpdate)
	      return bailoutHooks(current2, workInProgress2, renderLanes2), bailoutOnAlreadyFinishedWork(current2, workInProgress2, renderLanes2);
	    isHydrating && key && pushMaterializedTreeId(workInProgress2);
	    workInProgress2.flags |= 1;
	    reconcileChildren(current2, workInProgress2, nextProps, renderLanes2);
	    return workInProgress2.child;
	  }
	  function updateMemoComponent(current2, workInProgress2, Component, nextProps, renderLanes2) {
	    if (null === current2) {
	      var type = Component.type;
	      if ("function" === typeof type && !shouldConstruct(type) && void 0 === type.defaultProps && null === Component.compare)
	        return Component = resolveFunctionForHotReloading(type), workInProgress2.tag = 15, workInProgress2.type = Component, validateFunctionComponentInDev(workInProgress2, type), updateSimpleMemoComponent(
	          current2,
	          workInProgress2,
	          Component,
	          nextProps,
	          renderLanes2
	        );
	      current2 = createFiberFromTypeAndProps(
	        Component.type,
	        null,
	        nextProps,
	        workInProgress2,
	        workInProgress2.mode,
	        renderLanes2
	      );
	      current2.ref = workInProgress2.ref;
	      current2.return = workInProgress2;
	      return workInProgress2.child = current2;
	    }
	    type = current2.child;
	    if (!checkScheduledUpdateOrContext(current2, renderLanes2)) {
	      var prevProps = type.memoizedProps;
	      Component = Component.compare;
	      Component = null !== Component ? Component : shallowEqual;
	      if (Component(prevProps, nextProps) && current2.ref === workInProgress2.ref)
	        return bailoutOnAlreadyFinishedWork(
	          current2,
	          workInProgress2,
	          renderLanes2
	        );
	    }
	    workInProgress2.flags |= 1;
	    current2 = createWorkInProgress(type, nextProps);
	    current2.ref = workInProgress2.ref;
	    current2.return = workInProgress2;
	    return workInProgress2.child = current2;
	  }
	  function updateSimpleMemoComponent(current2, workInProgress2, Component, nextProps, renderLanes2) {
	    if (null !== current2) {
	      var prevProps = current2.memoizedProps;
	      if (shallowEqual(prevProps, nextProps) && current2.ref === workInProgress2.ref && workInProgress2.type === current2.type)
	        if (didReceiveUpdate = false, workInProgress2.pendingProps = nextProps = prevProps, checkScheduledUpdateOrContext(current2, renderLanes2))
	          0 !== (current2.flags & 131072) && (didReceiveUpdate = true);
	        else
	          return workInProgress2.lanes = current2.lanes, bailoutOnAlreadyFinishedWork(current2, workInProgress2, renderLanes2);
	    }
	    return updateFunctionComponent(
	      current2,
	      workInProgress2,
	      Component,
	      nextProps,
	      renderLanes2
	    );
	  }
	  function updateOffscreenComponent(current2, workInProgress2, renderLanes2) {
	    var nextProps = workInProgress2.pendingProps, nextChildren = nextProps.children, prevState = null !== current2 ? current2.memoizedState : null;
	    if ("hidden" === nextProps.mode) {
	      if (0 !== (workInProgress2.flags & 128)) {
	        nextProps = null !== prevState ? prevState.baseLanes | renderLanes2 : renderLanes2;
	        if (null !== current2) {
	          nextChildren = workInProgress2.child = current2.child;
	          for (prevState = 0; null !== nextChildren; )
	            prevState = prevState | nextChildren.lanes | nextChildren.childLanes, nextChildren = nextChildren.sibling;
	          workInProgress2.childLanes = prevState & ~nextProps;
	        } else workInProgress2.childLanes = 0, workInProgress2.child = null;
	        return deferHiddenOffscreenComponent(
	          current2,
	          workInProgress2,
	          nextProps,
	          renderLanes2
	        );
	      }
	      if (0 !== (renderLanes2 & 536870912))
	        workInProgress2.memoizedState = { baseLanes: 0, cachePool: null }, null !== current2 && pushTransition(
	          workInProgress2,
	          null !== prevState ? prevState.cachePool : null
	        ), null !== prevState ? pushHiddenContext(workInProgress2, prevState) : reuseHiddenContextOnStack(workInProgress2), pushOffscreenSuspenseHandler(workInProgress2);
	      else
	        return workInProgress2.lanes = workInProgress2.childLanes = 536870912, deferHiddenOffscreenComponent(
	          current2,
	          workInProgress2,
	          null !== prevState ? prevState.baseLanes | renderLanes2 : renderLanes2,
	          renderLanes2
	        );
	    } else
	      null !== prevState ? (pushTransition(workInProgress2, prevState.cachePool), pushHiddenContext(workInProgress2, prevState), reuseSuspenseHandlerOnStack(workInProgress2), workInProgress2.memoizedState = null) : (null !== current2 && pushTransition(workInProgress2, null), reuseHiddenContextOnStack(workInProgress2), reuseSuspenseHandlerOnStack(workInProgress2));
	    reconcileChildren(current2, workInProgress2, nextChildren, renderLanes2);
	    return workInProgress2.child;
	  }
	  function deferHiddenOffscreenComponent(current2, workInProgress2, nextBaseLanes, renderLanes2) {
	    var JSCompiler_inline_result = peekCacheFromPool();
	    JSCompiler_inline_result = null === JSCompiler_inline_result ? null : {
	      parent: CacheContext._currentValue,
	      pool: JSCompiler_inline_result
	    };
	    workInProgress2.memoizedState = {
	      baseLanes: nextBaseLanes,
	      cachePool: JSCompiler_inline_result
	    };
	    null !== current2 && pushTransition(workInProgress2, null);
	    reuseHiddenContextOnStack(workInProgress2);
	    pushOffscreenSuspenseHandler(workInProgress2);
	    null !== current2 && propagateParentContextChanges(current2, workInProgress2, renderLanes2, true);
	    return null;
	  }
	  function markRef(current2, workInProgress2) {
	    var ref = workInProgress2.ref;
	    if (null === ref)
	      null !== current2 && null !== current2.ref && (workInProgress2.flags |= 4194816);
	    else {
	      if ("function" !== typeof ref && "object" !== typeof ref)
	        throw Error(
	          "Expected ref to be a function, an object returned by React.createRef(), or undefined/null."
	        );
	      if (null === current2 || current2.ref !== ref)
	        workInProgress2.flags |= 4194816;
	    }
	  }
	  function updateFunctionComponent(current2, workInProgress2, Component, nextProps, renderLanes2) {
	    if (Component.prototype && "function" === typeof Component.prototype.render) {
	      var componentName2 = getComponentNameFromType(Component) || "Unknown";
	      didWarnAboutBadClass[componentName2] || (console.error(
	        "The <%s /> component appears to have a render method, but doesn't extend React.Component. This is likely to cause errors. Change %s to extend React.Component instead.",
	        componentName2,
	        componentName2
	      ), didWarnAboutBadClass[componentName2] = true);
	    }
	    workInProgress2.mode & StrictLegacyMode && ReactStrictModeWarnings.recordLegacyContextWarning(
	      workInProgress2,
	      null
	    );
	    null === current2 && (validateFunctionComponentInDev(workInProgress2, workInProgress2.type), Component.contextTypes && (componentName2 = getComponentNameFromType(Component) || "Unknown", didWarnAboutContextTypes[componentName2] || (didWarnAboutContextTypes[componentName2] = true, console.error(
	      "%s uses the legacy contextTypes API which was removed in React 19. Use React.createContext() with React.useContext() instead. (https://react.dev/link/legacy-context)",
	      componentName2
	    ))));
	    prepareToReadContext(workInProgress2);
	    markComponentRenderStarted(workInProgress2);
	    Component = renderWithHooks(
	      current2,
	      workInProgress2,
	      Component,
	      nextProps,
	      void 0,
	      renderLanes2
	    );
	    nextProps = checkDidRenderIdHook();
	    markComponentRenderStopped();
	    if (null !== current2 && !didReceiveUpdate)
	      return bailoutHooks(current2, workInProgress2, renderLanes2), bailoutOnAlreadyFinishedWork(current2, workInProgress2, renderLanes2);
	    isHydrating && nextProps && pushMaterializedTreeId(workInProgress2);
	    workInProgress2.flags |= 1;
	    reconcileChildren(current2, workInProgress2, Component, renderLanes2);
	    return workInProgress2.child;
	  }
	  function replayFunctionComponent(current2, workInProgress2, nextProps, Component, secondArg, renderLanes2) {
	    prepareToReadContext(workInProgress2);
	    markComponentRenderStarted(workInProgress2);
	    hookTypesUpdateIndexDev = -1;
	    ignorePreviousDependencies = null !== current2 && current2.type !== workInProgress2.type;
	    workInProgress2.updateQueue = null;
	    nextProps = renderWithHooksAgain(
	      workInProgress2,
	      Component,
	      nextProps,
	      secondArg
	    );
	    finishRenderingHooks(current2, workInProgress2);
	    Component = checkDidRenderIdHook();
	    markComponentRenderStopped();
	    if (null !== current2 && !didReceiveUpdate)
	      return bailoutHooks(current2, workInProgress2, renderLanes2), bailoutOnAlreadyFinishedWork(current2, workInProgress2, renderLanes2);
	    isHydrating && Component && pushMaterializedTreeId(workInProgress2);
	    workInProgress2.flags |= 1;
	    reconcileChildren(current2, workInProgress2, nextProps, renderLanes2);
	    return workInProgress2.child;
	  }
	  function updateClassComponent(current2, workInProgress2, Component, nextProps, renderLanes2) {
	    switch (shouldErrorImpl(workInProgress2)) {
	      case false:
	        var _instance = workInProgress2.stateNode, state = new workInProgress2.type(
	          workInProgress2.memoizedProps,
	          _instance.context
	        ).state;
	        _instance.updater.enqueueSetState(_instance, state, null);
	        break;
	      case true:
	        workInProgress2.flags |= 128;
	        workInProgress2.flags |= 65536;
	        _instance = Error("Simulated error coming from DevTools");
	        var lane = renderLanes2 & -renderLanes2;
	        workInProgress2.lanes |= lane;
	        state = workInProgressRoot;
	        if (null === state)
	          throw Error(
	            "Expected a work-in-progress root. This is a bug in React. Please file an issue."
	          );
	        lane = createClassErrorUpdate(lane);
	        initializeClassErrorUpdate(
	          lane,
	          state,
	          workInProgress2,
	          createCapturedValueAtFiber(_instance, workInProgress2)
	        );
	        enqueueCapturedUpdate(workInProgress2, lane);
	    }
	    prepareToReadContext(workInProgress2);
	    if (null === workInProgress2.stateNode) {
	      state = emptyContextObject;
	      _instance = Component.contextType;
	      "contextType" in Component && null !== _instance && (void 0 === _instance || _instance.$$typeof !== REACT_CONTEXT_TYPE) && !didWarnAboutInvalidateContextType.has(Component) && (didWarnAboutInvalidateContextType.add(Component), lane = void 0 === _instance ? " However, it is set to undefined. This can be caused by a typo or by mixing up named and default imports. This can also happen due to a circular dependency, so try moving the createContext() call to a separate file." : "object" !== typeof _instance ? " However, it is set to a " + typeof _instance + "." : _instance.$$typeof === REACT_CONSUMER_TYPE ? " Did you accidentally pass the Context.Consumer instead?" : " However, it is set to an object with keys {" + Object.keys(_instance).join(", ") + "}.", console.error(
	        "%s defines an invalid contextType. contextType should point to the Context object returned by React.createContext().%s",
	        getComponentNameFromType(Component) || "Component",
	        lane
	      ));
	      "object" === typeof _instance && null !== _instance && (state = readContext(_instance));
	      _instance = new Component(nextProps, state);
	      if (workInProgress2.mode & StrictLegacyMode) {
	        setIsStrictModeForDevtools(true);
	        try {
	          _instance = new Component(nextProps, state);
	        } finally {
	          setIsStrictModeForDevtools(false);
	        }
	      }
	      state = workInProgress2.memoizedState = null !== _instance.state && void 0 !== _instance.state ? _instance.state : null;
	      _instance.updater = classComponentUpdater;
	      workInProgress2.stateNode = _instance;
	      _instance._reactInternals = workInProgress2;
	      _instance._reactInternalInstance = fakeInternalInstance;
	      "function" === typeof Component.getDerivedStateFromProps && null === state && (state = getComponentNameFromType(Component) || "Component", didWarnAboutUninitializedState.has(state) || (didWarnAboutUninitializedState.add(state), console.error(
	        "`%s` uses `getDerivedStateFromProps` but its initial state is %s. This is not recommended. Instead, define the initial state by assigning an object to `this.state` in the constructor of `%s`. This ensures that `getDerivedStateFromProps` arguments have a consistent shape.",
	        state,
	        null === _instance.state ? "null" : "undefined",
	        state
	      )));
	      if ("function" === typeof Component.getDerivedStateFromProps || "function" === typeof _instance.getSnapshotBeforeUpdate) {
	        var foundWillUpdateName = lane = state = null;
	        "function" === typeof _instance.componentWillMount && true !== _instance.componentWillMount.__suppressDeprecationWarning ? state = "componentWillMount" : "function" === typeof _instance.UNSAFE_componentWillMount && (state = "UNSAFE_componentWillMount");
	        "function" === typeof _instance.componentWillReceiveProps && true !== _instance.componentWillReceiveProps.__suppressDeprecationWarning ? lane = "componentWillReceiveProps" : "function" === typeof _instance.UNSAFE_componentWillReceiveProps && (lane = "UNSAFE_componentWillReceiveProps");
	        "function" === typeof _instance.componentWillUpdate && true !== _instance.componentWillUpdate.__suppressDeprecationWarning ? foundWillUpdateName = "componentWillUpdate" : "function" === typeof _instance.UNSAFE_componentWillUpdate && (foundWillUpdateName = "UNSAFE_componentWillUpdate");
	        if (null !== state || null !== lane || null !== foundWillUpdateName) {
	          _instance = getComponentNameFromType(Component) || "Component";
	          var newApiName = "function" === typeof Component.getDerivedStateFromProps ? "getDerivedStateFromProps()" : "getSnapshotBeforeUpdate()";
	          didWarnAboutLegacyLifecyclesAndDerivedState.has(_instance) || (didWarnAboutLegacyLifecyclesAndDerivedState.add(_instance), console.error(
	            "Unsafe legacy lifecycles will not be called for components using new component APIs.\n\n%s uses %s but also contains the following legacy lifecycles:%s%s%s\n\nThe above lifecycles should be removed. Learn more about this warning here:\nhttps://react.dev/link/unsafe-component-lifecycles",
	            _instance,
	            newApiName,
	            null !== state ? "\n  " + state : "",
	            null !== lane ? "\n  " + lane : "",
	            null !== foundWillUpdateName ? "\n  " + foundWillUpdateName : ""
	          ));
	        }
	      }
	      _instance = workInProgress2.stateNode;
	      state = getComponentNameFromType(Component) || "Component";
	      _instance.render || (Component.prototype && "function" === typeof Component.prototype.render ? console.error(
	        "No `render` method found on the %s instance: did you accidentally return an object from the constructor?",
	        state
	      ) : console.error(
	        "No `render` method found on the %s instance: you may have forgotten to define `render`.",
	        state
	      ));
	      !_instance.getInitialState || _instance.getInitialState.isReactClassApproved || _instance.state || console.error(
	        "getInitialState was defined on %s, a plain JavaScript class. This is only supported for classes created using React.createClass. Did you mean to define a state property instead?",
	        state
	      );
	      _instance.getDefaultProps && !_instance.getDefaultProps.isReactClassApproved && console.error(
	        "getDefaultProps was defined on %s, a plain JavaScript class. This is only supported for classes created using React.createClass. Use a static property to define defaultProps instead.",
	        state
	      );
	      _instance.contextType && console.error(
	        "contextType was defined as an instance property on %s. Use a static property to define contextType instead.",
	        state
	      );
	      Component.childContextTypes && !didWarnAboutChildContextTypes.has(Component) && (didWarnAboutChildContextTypes.add(Component), console.error(
	        "%s uses the legacy childContextTypes API which was removed in React 19. Use React.createContext() instead. (https://react.dev/link/legacy-context)",
	        state
	      ));
	      Component.contextTypes && !didWarnAboutContextTypes$1.has(Component) && (didWarnAboutContextTypes$1.add(Component), console.error(
	        "%s uses the legacy contextTypes API which was removed in React 19. Use React.createContext() with static contextType instead. (https://react.dev/link/legacy-context)",
	        state
	      ));
	      "function" === typeof _instance.componentShouldUpdate && console.error(
	        "%s has a method called componentShouldUpdate(). Did you mean shouldComponentUpdate()? The name is phrased as a question because the function is expected to return a value.",
	        state
	      );
	      Component.prototype && Component.prototype.isPureReactComponent && "undefined" !== typeof _instance.shouldComponentUpdate && console.error(
	        "%s has a method called shouldComponentUpdate(). shouldComponentUpdate should not be used when extending React.PureComponent. Please extend React.Component if shouldComponentUpdate is used.",
	        getComponentNameFromType(Component) || "A pure component"
	      );
	      "function" === typeof _instance.componentDidUnmount && console.error(
	        "%s has a method called componentDidUnmount(). But there is no such lifecycle method. Did you mean componentWillUnmount()?",
	        state
	      );
	      "function" === typeof _instance.componentDidReceiveProps && console.error(
	        "%s has a method called componentDidReceiveProps(). But there is no such lifecycle method. If you meant to update the state in response to changing props, use componentWillReceiveProps(). If you meant to fetch data or run side-effects or mutations after React has updated the UI, use componentDidUpdate().",
	        state
	      );
	      "function" === typeof _instance.componentWillRecieveProps && console.error(
	        "%s has a method called componentWillRecieveProps(). Did you mean componentWillReceiveProps()?",
	        state
	      );
	      "function" === typeof _instance.UNSAFE_componentWillRecieveProps && console.error(
	        "%s has a method called UNSAFE_componentWillRecieveProps(). Did you mean UNSAFE_componentWillReceiveProps()?",
	        state
	      );
	      lane = _instance.props !== nextProps;
	      void 0 !== _instance.props && lane && console.error(
	        "When calling super() in `%s`, make sure to pass up the same props that your component's constructor was passed.",
	        state
	      );
	      _instance.defaultProps && console.error(
	        "Setting defaultProps as an instance property on %s is not supported and will be ignored. Instead, define defaultProps as a static property on %s.",
	        state,
	        state
	      );
	      "function" !== typeof _instance.getSnapshotBeforeUpdate || "function" === typeof _instance.componentDidUpdate || didWarnAboutGetSnapshotBeforeUpdateWithoutDidUpdate.has(Component) || (didWarnAboutGetSnapshotBeforeUpdateWithoutDidUpdate.add(Component), console.error(
	        "%s: getSnapshotBeforeUpdate() should be used with componentDidUpdate(). This component defines getSnapshotBeforeUpdate() only.",
	        getComponentNameFromType(Component)
	      ));
	      "function" === typeof _instance.getDerivedStateFromProps && console.error(
	        "%s: getDerivedStateFromProps() is defined as an instance method and will be ignored. Instead, declare it as a static method.",
	        state
	      );
	      "function" === typeof _instance.getDerivedStateFromError && console.error(
	        "%s: getDerivedStateFromError() is defined as an instance method and will be ignored. Instead, declare it as a static method.",
	        state
	      );
	      "function" === typeof Component.getSnapshotBeforeUpdate && console.error(
	        "%s: getSnapshotBeforeUpdate() is defined as a static method and will be ignored. Instead, declare it as an instance method.",
	        state
	      );
	      (lane = _instance.state) && ("object" !== typeof lane || isArrayImpl(lane)) && console.error("%s.state: must be set to an object or null", state);
	      "function" === typeof _instance.getChildContext && "object" !== typeof Component.childContextTypes && console.error(
	        "%s.getChildContext(): childContextTypes must be defined in order to use getChildContext().",
	        state
	      );
	      _instance = workInProgress2.stateNode;
	      _instance.props = nextProps;
	      _instance.state = workInProgress2.memoizedState;
	      _instance.refs = {};
	      initializeUpdateQueue(workInProgress2);
	      state = Component.contextType;
	      _instance.context = "object" === typeof state && null !== state ? readContext(state) : emptyContextObject;
	      _instance.state === nextProps && (state = getComponentNameFromType(Component) || "Component", didWarnAboutDirectlyAssigningPropsToState.has(state) || (didWarnAboutDirectlyAssigningPropsToState.add(state), console.error(
	        "%s: It is not recommended to assign props directly to state because updates to props won't be reflected in state. In most cases, it is better to use props directly.",
	        state
	      )));
	      workInProgress2.mode & StrictLegacyMode && ReactStrictModeWarnings.recordLegacyContextWarning(
	        workInProgress2,
	        _instance
	      );
	      ReactStrictModeWarnings.recordUnsafeLifecycleWarnings(
	        workInProgress2,
	        _instance
	      );
	      _instance.state = workInProgress2.memoizedState;
	      state = Component.getDerivedStateFromProps;
	      "function" === typeof state && (applyDerivedStateFromProps(
	        workInProgress2,
	        Component,
	        state,
	        nextProps
	      ), _instance.state = workInProgress2.memoizedState);
	      "function" === typeof Component.getDerivedStateFromProps || "function" === typeof _instance.getSnapshotBeforeUpdate || "function" !== typeof _instance.UNSAFE_componentWillMount && "function" !== typeof _instance.componentWillMount || (state = _instance.state, "function" === typeof _instance.componentWillMount && _instance.componentWillMount(), "function" === typeof _instance.UNSAFE_componentWillMount && _instance.UNSAFE_componentWillMount(), state !== _instance.state && (console.error(
	        "%s.componentWillMount(): Assigning directly to this.state is deprecated (except inside a component's constructor). Use setState instead.",
	        getComponentNameFromFiber(workInProgress2) || "Component"
	      ), classComponentUpdater.enqueueReplaceState(
	        _instance,
	        _instance.state,
	        null
	      )), processUpdateQueue(workInProgress2, nextProps, _instance, renderLanes2), suspendIfUpdateReadFromEntangledAsyncAction(), _instance.state = workInProgress2.memoizedState);
	      "function" === typeof _instance.componentDidMount && (workInProgress2.flags |= 4194308);
	      (workInProgress2.mode & StrictEffectsMode) !== NoMode && (workInProgress2.flags |= 134217728);
	      _instance = true;
	    } else if (null === current2) {
	      _instance = workInProgress2.stateNode;
	      var unresolvedOldProps = workInProgress2.memoizedProps;
	      lane = resolveClassComponentProps(Component, unresolvedOldProps);
	      _instance.props = lane;
	      var oldContext = _instance.context;
	      foundWillUpdateName = Component.contextType;
	      state = emptyContextObject;
	      "object" === typeof foundWillUpdateName && null !== foundWillUpdateName && (state = readContext(foundWillUpdateName));
	      newApiName = Component.getDerivedStateFromProps;
	      foundWillUpdateName = "function" === typeof newApiName || "function" === typeof _instance.getSnapshotBeforeUpdate;
	      unresolvedOldProps = workInProgress2.pendingProps !== unresolvedOldProps;
	      foundWillUpdateName || "function" !== typeof _instance.UNSAFE_componentWillReceiveProps && "function" !== typeof _instance.componentWillReceiveProps || (unresolvedOldProps || oldContext !== state) && callComponentWillReceiveProps(
	        workInProgress2,
	        _instance,
	        nextProps,
	        state
	      );
	      hasForceUpdate = false;
	      var oldState = workInProgress2.memoizedState;
	      _instance.state = oldState;
	      processUpdateQueue(workInProgress2, nextProps, _instance, renderLanes2);
	      suspendIfUpdateReadFromEntangledAsyncAction();
	      oldContext = workInProgress2.memoizedState;
	      unresolvedOldProps || oldState !== oldContext || hasForceUpdate ? ("function" === typeof newApiName && (applyDerivedStateFromProps(
	        workInProgress2,
	        Component,
	        newApiName,
	        nextProps
	      ), oldContext = workInProgress2.memoizedState), (lane = hasForceUpdate || checkShouldComponentUpdate(
	        workInProgress2,
	        Component,
	        lane,
	        nextProps,
	        oldState,
	        oldContext,
	        state
	      )) ? (foundWillUpdateName || "function" !== typeof _instance.UNSAFE_componentWillMount && "function" !== typeof _instance.componentWillMount || ("function" === typeof _instance.componentWillMount && _instance.componentWillMount(), "function" === typeof _instance.UNSAFE_componentWillMount && _instance.UNSAFE_componentWillMount()), "function" === typeof _instance.componentDidMount && (workInProgress2.flags |= 4194308), (workInProgress2.mode & StrictEffectsMode) !== NoMode && (workInProgress2.flags |= 134217728)) : ("function" === typeof _instance.componentDidMount && (workInProgress2.flags |= 4194308), (workInProgress2.mode & StrictEffectsMode) !== NoMode && (workInProgress2.flags |= 134217728), workInProgress2.memoizedProps = nextProps, workInProgress2.memoizedState = oldContext), _instance.props = nextProps, _instance.state = oldContext, _instance.context = state, _instance = lane) : ("function" === typeof _instance.componentDidMount && (workInProgress2.flags |= 4194308), (workInProgress2.mode & StrictEffectsMode) !== NoMode && (workInProgress2.flags |= 134217728), _instance = false);
	    } else {
	      _instance = workInProgress2.stateNode;
	      cloneUpdateQueue(current2, workInProgress2);
	      state = workInProgress2.memoizedProps;
	      foundWillUpdateName = resolveClassComponentProps(Component, state);
	      _instance.props = foundWillUpdateName;
	      newApiName = workInProgress2.pendingProps;
	      oldState = _instance.context;
	      oldContext = Component.contextType;
	      lane = emptyContextObject;
	      "object" === typeof oldContext && null !== oldContext && (lane = readContext(oldContext));
	      unresolvedOldProps = Component.getDerivedStateFromProps;
	      (oldContext = "function" === typeof unresolvedOldProps || "function" === typeof _instance.getSnapshotBeforeUpdate) || "function" !== typeof _instance.UNSAFE_componentWillReceiveProps && "function" !== typeof _instance.componentWillReceiveProps || (state !== newApiName || oldState !== lane) && callComponentWillReceiveProps(
	        workInProgress2,
	        _instance,
	        nextProps,
	        lane
	      );
	      hasForceUpdate = false;
	      oldState = workInProgress2.memoizedState;
	      _instance.state = oldState;
	      processUpdateQueue(workInProgress2, nextProps, _instance, renderLanes2);
	      suspendIfUpdateReadFromEntangledAsyncAction();
	      var newState = workInProgress2.memoizedState;
	      state !== newApiName || oldState !== newState || hasForceUpdate || null !== current2 && null !== current2.dependencies && checkIfContextChanged(current2.dependencies) ? ("function" === typeof unresolvedOldProps && (applyDerivedStateFromProps(
	        workInProgress2,
	        Component,
	        unresolvedOldProps,
	        nextProps
	      ), newState = workInProgress2.memoizedState), (foundWillUpdateName = hasForceUpdate || checkShouldComponentUpdate(
	        workInProgress2,
	        Component,
	        foundWillUpdateName,
	        nextProps,
	        oldState,
	        newState,
	        lane
	      ) || null !== current2 && null !== current2.dependencies && checkIfContextChanged(current2.dependencies)) ? (oldContext || "function" !== typeof _instance.UNSAFE_componentWillUpdate && "function" !== typeof _instance.componentWillUpdate || ("function" === typeof _instance.componentWillUpdate && _instance.componentWillUpdate(nextProps, newState, lane), "function" === typeof _instance.UNSAFE_componentWillUpdate && _instance.UNSAFE_componentWillUpdate(
	        nextProps,
	        newState,
	        lane
	      )), "function" === typeof _instance.componentDidUpdate && (workInProgress2.flags |= 4), "function" === typeof _instance.getSnapshotBeforeUpdate && (workInProgress2.flags |= 1024)) : ("function" !== typeof _instance.componentDidUpdate || state === current2.memoizedProps && oldState === current2.memoizedState || (workInProgress2.flags |= 4), "function" !== typeof _instance.getSnapshotBeforeUpdate || state === current2.memoizedProps && oldState === current2.memoizedState || (workInProgress2.flags |= 1024), workInProgress2.memoizedProps = nextProps, workInProgress2.memoizedState = newState), _instance.props = nextProps, _instance.state = newState, _instance.context = lane, _instance = foundWillUpdateName) : ("function" !== typeof _instance.componentDidUpdate || state === current2.memoizedProps && oldState === current2.memoizedState || (workInProgress2.flags |= 4), "function" !== typeof _instance.getSnapshotBeforeUpdate || state === current2.memoizedProps && oldState === current2.memoizedState || (workInProgress2.flags |= 1024), _instance = false);
	    }
	    lane = _instance;
	    markRef(current2, workInProgress2);
	    state = 0 !== (workInProgress2.flags & 128);
	    if (lane || state) {
	      lane = workInProgress2.stateNode;
	      setCurrentFiber(workInProgress2);
	      if (state && "function" !== typeof Component.getDerivedStateFromError)
	        Component = null, profilerStartTime = -1;
	      else {
	        markComponentRenderStarted(workInProgress2);
	        Component = callRenderInDEV(lane);
	        if (workInProgress2.mode & StrictLegacyMode) {
	          setIsStrictModeForDevtools(true);
	          try {
	            callRenderInDEV(lane);
	          } finally {
	            setIsStrictModeForDevtools(false);
	          }
	        }
	        markComponentRenderStopped();
	      }
	      workInProgress2.flags |= 1;
	      null !== current2 && state ? (workInProgress2.child = reconcileChildFibers(
	        workInProgress2,
	        current2.child,
	        null,
	        renderLanes2
	      ), workInProgress2.child = reconcileChildFibers(
	        workInProgress2,
	        null,
	        Component,
	        renderLanes2
	      )) : reconcileChildren(current2, workInProgress2, Component, renderLanes2);
	      workInProgress2.memoizedState = lane.state;
	      current2 = workInProgress2.child;
	    } else
	      current2 = bailoutOnAlreadyFinishedWork(
	        current2,
	        workInProgress2,
	        renderLanes2
	      );
	    renderLanes2 = workInProgress2.stateNode;
	    _instance && renderLanes2.props !== nextProps && (didWarnAboutReassigningProps || console.error(
	      "It looks like %s is reassigning its own `this.props` while rendering. This is not supported and can lead to confusing bugs.",
	      getComponentNameFromFiber(workInProgress2) || "a component"
	    ), didWarnAboutReassigningProps = true);
	    return current2;
	  }
	  function mountHostRootWithoutHydrating(current2, workInProgress2, nextChildren, renderLanes2) {
	    resetHydrationState();
	    workInProgress2.flags |= 256;
	    reconcileChildren(current2, workInProgress2, nextChildren, renderLanes2);
	    return workInProgress2.child;
	  }
	  function validateFunctionComponentInDev(workInProgress2, Component) {
	    Component && Component.childContextTypes && console.error(
	      "childContextTypes cannot be defined on a function component.\n  %s.childContextTypes = ...",
	      Component.displayName || Component.name || "Component"
	    );
	    "function" === typeof Component.getDerivedStateFromProps && (workInProgress2 = getComponentNameFromType(Component) || "Unknown", didWarnAboutGetDerivedStateOnFunctionComponent[workInProgress2] || (console.error(
	      "%s: Function components do not support getDerivedStateFromProps.",
	      workInProgress2
	    ), didWarnAboutGetDerivedStateOnFunctionComponent[workInProgress2] = true));
	    "object" === typeof Component.contextType && null !== Component.contextType && (Component = getComponentNameFromType(Component) || "Unknown", didWarnAboutContextTypeOnFunctionComponent[Component] || (console.error(
	      "%s: Function components do not support contextType.",
	      Component
	    ), didWarnAboutContextTypeOnFunctionComponent[Component] = true));
	  }
	  function mountSuspenseOffscreenState(renderLanes2) {
	    return { baseLanes: renderLanes2, cachePool: getSuspendedCache() };
	  }
	  function getRemainingWorkInPrimaryTree(current2, primaryTreeDidDefer, renderLanes2) {
	    current2 = null !== current2 ? current2.childLanes & ~renderLanes2 : 0;
	    primaryTreeDidDefer && (current2 |= workInProgressDeferredLane);
	    return current2;
	  }
	  function updateSuspenseComponent(current2, workInProgress2, renderLanes2) {
	    var JSCompiler_object_inline_digest_2451;
	    var JSCompiler_object_inline_stack_2452 = workInProgress2.pendingProps;
	    shouldSuspendImpl(workInProgress2) && (workInProgress2.flags |= 128);
	    var JSCompiler_object_inline_componentStack_2453 = false;
	    var didSuspend = 0 !== (workInProgress2.flags & 128);
	    (JSCompiler_object_inline_digest_2451 = didSuspend) || (JSCompiler_object_inline_digest_2451 = null !== current2 && null === current2.memoizedState ? false : 0 !== (suspenseStackCursor.current & ForceSuspenseFallback));
	    JSCompiler_object_inline_digest_2451 && (JSCompiler_object_inline_componentStack_2453 = true, workInProgress2.flags &= -129);
	    JSCompiler_object_inline_digest_2451 = 0 !== (workInProgress2.flags & 32);
	    workInProgress2.flags &= -33;
	    if (null === current2) {
	      if (isHydrating) {
	        JSCompiler_object_inline_componentStack_2453 ? pushPrimaryTreeSuspenseHandler(workInProgress2) : reuseSuspenseHandlerOnStack(workInProgress2);
	        if (isHydrating) {
	          var JSCompiler_object_inline_message_2450 = nextHydratableInstance;
	          var JSCompiler_temp;
	          if (!(JSCompiler_temp = !JSCompiler_object_inline_message_2450)) {
	            c: {
	              var instance = JSCompiler_object_inline_message_2450;
	              for (JSCompiler_temp = rootOrSingletonContext; 8 !== instance.nodeType; ) {
	                if (!JSCompiler_temp) {
	                  JSCompiler_temp = null;
	                  break c;
	                }
	                instance = getNextHydratable(instance.nextSibling);
	                if (null === instance) {
	                  JSCompiler_temp = null;
	                  break c;
	                }
	              }
	              JSCompiler_temp = instance;
	            }
	            null !== JSCompiler_temp ? (warnIfNotHydrating(), workInProgress2.memoizedState = {
	              dehydrated: JSCompiler_temp,
	              treeContext: null !== treeContextProvider ? { id: treeContextId, overflow: treeContextOverflow } : null,
	              retryLane: 536870912,
	              hydrationErrors: null
	            }, instance = createFiber(18, null, null, NoMode), instance.stateNode = JSCompiler_temp, instance.return = workInProgress2, workInProgress2.child = instance, hydrationParentFiber = workInProgress2, nextHydratableInstance = null, JSCompiler_temp = true) : JSCompiler_temp = false;
	            JSCompiler_temp = !JSCompiler_temp;
	          }
	          JSCompiler_temp && (warnNonHydratedInstance(
	            workInProgress2,
	            JSCompiler_object_inline_message_2450
	          ), throwOnHydrationMismatch(workInProgress2));
	        }
	        JSCompiler_object_inline_message_2450 = workInProgress2.memoizedState;
	        if (null !== JSCompiler_object_inline_message_2450 && (JSCompiler_object_inline_message_2450 = JSCompiler_object_inline_message_2450.dehydrated, null !== JSCompiler_object_inline_message_2450))
	          return isSuspenseInstanceFallback(JSCompiler_object_inline_message_2450) ? workInProgress2.lanes = 32 : workInProgress2.lanes = 536870912, null;
	        popSuspenseHandler(workInProgress2);
	      }
	      JSCompiler_object_inline_message_2450 = JSCompiler_object_inline_stack_2452.children;
	      JSCompiler_object_inline_stack_2452 = JSCompiler_object_inline_stack_2452.fallback;
	      if (JSCompiler_object_inline_componentStack_2453)
	        return reuseSuspenseHandlerOnStack(workInProgress2), JSCompiler_object_inline_componentStack_2453 = workInProgress2.mode, JSCompiler_object_inline_message_2450 = mountWorkInProgressOffscreenFiber(
	          {
	            mode: "hidden",
	            children: JSCompiler_object_inline_message_2450
	          },
	          JSCompiler_object_inline_componentStack_2453
	        ), JSCompiler_object_inline_stack_2452 = createFiberFromFragment(
	          JSCompiler_object_inline_stack_2452,
	          JSCompiler_object_inline_componentStack_2453,
	          renderLanes2,
	          null
	        ), JSCompiler_object_inline_message_2450.return = workInProgress2, JSCompiler_object_inline_stack_2452.return = workInProgress2, JSCompiler_object_inline_message_2450.sibling = JSCompiler_object_inline_stack_2452, workInProgress2.child = JSCompiler_object_inline_message_2450, JSCompiler_object_inline_componentStack_2453 = workInProgress2.child, JSCompiler_object_inline_componentStack_2453.memoizedState = mountSuspenseOffscreenState(renderLanes2), JSCompiler_object_inline_componentStack_2453.childLanes = getRemainingWorkInPrimaryTree(
	          current2,
	          JSCompiler_object_inline_digest_2451,
	          renderLanes2
	        ), workInProgress2.memoizedState = SUSPENDED_MARKER, JSCompiler_object_inline_stack_2452;
	      pushPrimaryTreeSuspenseHandler(workInProgress2);
	      return mountSuspensePrimaryChildren(
	        workInProgress2,
	        JSCompiler_object_inline_message_2450
	      );
	    }
	    var prevState = current2.memoizedState;
	    if (null !== prevState && (JSCompiler_object_inline_message_2450 = prevState.dehydrated, null !== JSCompiler_object_inline_message_2450)) {
	      if (didSuspend)
	        workInProgress2.flags & 256 ? (pushPrimaryTreeSuspenseHandler(workInProgress2), workInProgress2.flags &= -257, workInProgress2 = retrySuspenseComponentWithoutHydrating(
	          current2,
	          workInProgress2,
	          renderLanes2
	        )) : null !== workInProgress2.memoizedState ? (reuseSuspenseHandlerOnStack(workInProgress2), workInProgress2.child = current2.child, workInProgress2.flags |= 128, workInProgress2 = null) : (reuseSuspenseHandlerOnStack(workInProgress2), JSCompiler_object_inline_componentStack_2453 = JSCompiler_object_inline_stack_2452.fallback, JSCompiler_object_inline_message_2450 = workInProgress2.mode, JSCompiler_object_inline_stack_2452 = mountWorkInProgressOffscreenFiber(
	          {
	            mode: "visible",
	            children: JSCompiler_object_inline_stack_2452.children
	          },
	          JSCompiler_object_inline_message_2450
	        ), JSCompiler_object_inline_componentStack_2453 = createFiberFromFragment(
	          JSCompiler_object_inline_componentStack_2453,
	          JSCompiler_object_inline_message_2450,
	          renderLanes2,
	          null
	        ), JSCompiler_object_inline_componentStack_2453.flags |= 2, JSCompiler_object_inline_stack_2452.return = workInProgress2, JSCompiler_object_inline_componentStack_2453.return = workInProgress2, JSCompiler_object_inline_stack_2452.sibling = JSCompiler_object_inline_componentStack_2453, workInProgress2.child = JSCompiler_object_inline_stack_2452, reconcileChildFibers(
	          workInProgress2,
	          current2.child,
	          null,
	          renderLanes2
	        ), JSCompiler_object_inline_stack_2452 = workInProgress2.child, JSCompiler_object_inline_stack_2452.memoizedState = mountSuspenseOffscreenState(renderLanes2), JSCompiler_object_inline_stack_2452.childLanes = getRemainingWorkInPrimaryTree(
	          current2,
	          JSCompiler_object_inline_digest_2451,
	          renderLanes2
	        ), workInProgress2.memoizedState = SUSPENDED_MARKER, workInProgress2 = JSCompiler_object_inline_componentStack_2453);
	      else if (pushPrimaryTreeSuspenseHandler(workInProgress2), isHydrating && console.error(
	        "We should not be hydrating here. This is a bug in React. Please file a bug."
	      ), isSuspenseInstanceFallback(JSCompiler_object_inline_message_2450)) {
	        JSCompiler_object_inline_digest_2451 = JSCompiler_object_inline_message_2450.nextSibling && JSCompiler_object_inline_message_2450.nextSibling.dataset;
	        if (JSCompiler_object_inline_digest_2451) {
	          JSCompiler_temp = JSCompiler_object_inline_digest_2451.dgst;
	          var message = JSCompiler_object_inline_digest_2451.msg;
	          instance = JSCompiler_object_inline_digest_2451.stck;
	          var componentStack = JSCompiler_object_inline_digest_2451.cstck;
	        }
	        JSCompiler_object_inline_message_2450 = message;
	        JSCompiler_object_inline_digest_2451 = JSCompiler_temp;
	        JSCompiler_object_inline_stack_2452 = instance;
	        JSCompiler_temp = JSCompiler_object_inline_componentStack_2453 = componentStack;
	        JSCompiler_object_inline_componentStack_2453 = JSCompiler_object_inline_message_2450 ? Error(JSCompiler_object_inline_message_2450) : Error(
	          "The server could not finish this Suspense boundary, likely due to an error during server rendering. Switched to client rendering."
	        );
	        JSCompiler_object_inline_componentStack_2453.stack = JSCompiler_object_inline_stack_2452 || "";
	        JSCompiler_object_inline_componentStack_2453.digest = JSCompiler_object_inline_digest_2451;
	        JSCompiler_object_inline_digest_2451 = void 0 === JSCompiler_temp ? null : JSCompiler_temp;
	        JSCompiler_object_inline_stack_2452 = {
	          value: JSCompiler_object_inline_componentStack_2453,
	          source: null,
	          stack: JSCompiler_object_inline_digest_2451
	        };
	        "string" === typeof JSCompiler_object_inline_digest_2451 && CapturedStacks.set(
	          JSCompiler_object_inline_componentStack_2453,
	          JSCompiler_object_inline_stack_2452
	        );
	        queueHydrationError(JSCompiler_object_inline_stack_2452);
	        workInProgress2 = retrySuspenseComponentWithoutHydrating(
	          current2,
	          workInProgress2,
	          renderLanes2
	        );
	      } else if (didReceiveUpdate || propagateParentContextChanges(
	        current2,
	        workInProgress2,
	        renderLanes2,
	        false
	      ), JSCompiler_object_inline_digest_2451 = 0 !== (renderLanes2 & current2.childLanes), didReceiveUpdate || JSCompiler_object_inline_digest_2451) {
	        JSCompiler_object_inline_digest_2451 = workInProgressRoot;
	        if (null !== JSCompiler_object_inline_digest_2451 && (JSCompiler_object_inline_stack_2452 = renderLanes2 & -renderLanes2, JSCompiler_object_inline_stack_2452 = 0 !== (JSCompiler_object_inline_stack_2452 & 42) ? 1 : getBumpedLaneForHydrationByLane(
	          JSCompiler_object_inline_stack_2452
	        ), JSCompiler_object_inline_stack_2452 = 0 !== (JSCompiler_object_inline_stack_2452 & (JSCompiler_object_inline_digest_2451.suspendedLanes | renderLanes2)) ? 0 : JSCompiler_object_inline_stack_2452, 0 !== JSCompiler_object_inline_stack_2452 && JSCompiler_object_inline_stack_2452 !== prevState.retryLane))
	          throw prevState.retryLane = JSCompiler_object_inline_stack_2452, enqueueConcurrentRenderForLane(
	            current2,
	            JSCompiler_object_inline_stack_2452
	          ), scheduleUpdateOnFiber(
	            JSCompiler_object_inline_digest_2451,
	            current2,
	            JSCompiler_object_inline_stack_2452
	          ), SelectiveHydrationException;
	        JSCompiler_object_inline_message_2450.data === SUSPENSE_PENDING_START_DATA || renderDidSuspendDelayIfPossible();
	        workInProgress2 = retrySuspenseComponentWithoutHydrating(
	          current2,
	          workInProgress2,
	          renderLanes2
	        );
	      } else
	        JSCompiler_object_inline_message_2450.data === SUSPENSE_PENDING_START_DATA ? (workInProgress2.flags |= 192, workInProgress2.child = current2.child, workInProgress2 = null) : (current2 = prevState.treeContext, nextHydratableInstance = getNextHydratable(
	          JSCompiler_object_inline_message_2450.nextSibling
	        ), hydrationParentFiber = workInProgress2, isHydrating = true, hydrationErrors = null, didSuspendOrErrorDEV = false, hydrationDiffRootDEV = null, rootOrSingletonContext = false, null !== current2 && (warnIfNotHydrating(), idStack[idStackIndex++] = treeContextId, idStack[idStackIndex++] = treeContextOverflow, idStack[idStackIndex++] = treeContextProvider, treeContextId = current2.id, treeContextOverflow = current2.overflow, treeContextProvider = workInProgress2), workInProgress2 = mountSuspensePrimaryChildren(
	          workInProgress2,
	          JSCompiler_object_inline_stack_2452.children
	        ), workInProgress2.flags |= 4096);
	      return workInProgress2;
	    }
	    if (JSCompiler_object_inline_componentStack_2453)
	      return reuseSuspenseHandlerOnStack(workInProgress2), JSCompiler_object_inline_componentStack_2453 = JSCompiler_object_inline_stack_2452.fallback, JSCompiler_object_inline_message_2450 = workInProgress2.mode, JSCompiler_temp = current2.child, instance = JSCompiler_temp.sibling, JSCompiler_object_inline_stack_2452 = createWorkInProgress(
	        JSCompiler_temp,
	        {
	          mode: "hidden",
	          children: JSCompiler_object_inline_stack_2452.children
	        }
	      ), JSCompiler_object_inline_stack_2452.subtreeFlags = JSCompiler_temp.subtreeFlags & 65011712, null !== instance ? JSCompiler_object_inline_componentStack_2453 = createWorkInProgress(
	        instance,
	        JSCompiler_object_inline_componentStack_2453
	      ) : (JSCompiler_object_inline_componentStack_2453 = createFiberFromFragment(
	        JSCompiler_object_inline_componentStack_2453,
	        JSCompiler_object_inline_message_2450,
	        renderLanes2,
	        null
	      ), JSCompiler_object_inline_componentStack_2453.flags |= 2), JSCompiler_object_inline_componentStack_2453.return = workInProgress2, JSCompiler_object_inline_stack_2452.return = workInProgress2, JSCompiler_object_inline_stack_2452.sibling = JSCompiler_object_inline_componentStack_2453, workInProgress2.child = JSCompiler_object_inline_stack_2452, JSCompiler_object_inline_stack_2452 = JSCompiler_object_inline_componentStack_2453, JSCompiler_object_inline_componentStack_2453 = workInProgress2.child, JSCompiler_object_inline_message_2450 = current2.child.memoizedState, null === JSCompiler_object_inline_message_2450 ? JSCompiler_object_inline_message_2450 = mountSuspenseOffscreenState(renderLanes2) : (JSCompiler_temp = JSCompiler_object_inline_message_2450.cachePool, null !== JSCompiler_temp ? (instance = CacheContext._currentValue, JSCompiler_temp = JSCompiler_temp.parent !== instance ? { parent: instance, pool: instance } : JSCompiler_temp) : JSCompiler_temp = getSuspendedCache(), JSCompiler_object_inline_message_2450 = {
	        baseLanes: JSCompiler_object_inline_message_2450.baseLanes | renderLanes2,
	        cachePool: JSCompiler_temp
	      }), JSCompiler_object_inline_componentStack_2453.memoizedState = JSCompiler_object_inline_message_2450, JSCompiler_object_inline_componentStack_2453.childLanes = getRemainingWorkInPrimaryTree(
	        current2,
	        JSCompiler_object_inline_digest_2451,
	        renderLanes2
	      ), workInProgress2.memoizedState = SUSPENDED_MARKER, JSCompiler_object_inline_stack_2452;
	    pushPrimaryTreeSuspenseHandler(workInProgress2);
	    renderLanes2 = current2.child;
	    current2 = renderLanes2.sibling;
	    renderLanes2 = createWorkInProgress(renderLanes2, {
	      mode: "visible",
	      children: JSCompiler_object_inline_stack_2452.children
	    });
	    renderLanes2.return = workInProgress2;
	    renderLanes2.sibling = null;
	    null !== current2 && (JSCompiler_object_inline_digest_2451 = workInProgress2.deletions, null === JSCompiler_object_inline_digest_2451 ? (workInProgress2.deletions = [current2], workInProgress2.flags |= 16) : JSCompiler_object_inline_digest_2451.push(current2));
	    workInProgress2.child = renderLanes2;
	    workInProgress2.memoizedState = null;
	    return renderLanes2;
	  }
	  function mountSuspensePrimaryChildren(workInProgress2, primaryChildren) {
	    primaryChildren = mountWorkInProgressOffscreenFiber(
	      { mode: "visible", children: primaryChildren },
	      workInProgress2.mode
	    );
	    primaryChildren.return = workInProgress2;
	    return workInProgress2.child = primaryChildren;
	  }
	  function mountWorkInProgressOffscreenFiber(offscreenProps, mode) {
	    offscreenProps = createFiber(22, offscreenProps, null, mode);
	    offscreenProps.lanes = 0;
	    offscreenProps.stateNode = {
	      _visibility: OffscreenVisible,
	      _pendingMarkers: null,
	      _retryCache: null,
	      _transitions: null
	    };
	    return offscreenProps;
	  }
	  function retrySuspenseComponentWithoutHydrating(current2, workInProgress2, renderLanes2) {
	    reconcileChildFibers(workInProgress2, current2.child, null, renderLanes2);
	    current2 = mountSuspensePrimaryChildren(
	      workInProgress2,
	      workInProgress2.pendingProps.children
	    );
	    current2.flags |= 2;
	    workInProgress2.memoizedState = null;
	    return current2;
	  }
	  function scheduleSuspenseWorkOnFiber(fiber, renderLanes2, propagationRoot) {
	    fiber.lanes |= renderLanes2;
	    var alternate = fiber.alternate;
	    null !== alternate && (alternate.lanes |= renderLanes2);
	    scheduleContextWorkOnParentPath(
	      fiber.return,
	      renderLanes2,
	      propagationRoot
	    );
	  }
	  function validateSuspenseListNestedChild(childSlot, index) {
	    var isAnArray = isArrayImpl(childSlot);
	    childSlot = !isAnArray && "function" === typeof getIteratorFn(childSlot);
	    return isAnArray || childSlot ? (isAnArray = isAnArray ? "array" : "iterable", console.error(
	      "A nested %s was passed to row #%s in <SuspenseList />. Wrap it in an additional SuspenseList to configure its revealOrder: <SuspenseList revealOrder=...> ... <SuspenseList revealOrder=...>{%s}</SuspenseList> ... </SuspenseList>",
	      isAnArray,
	      index,
	      isAnArray
	    ), false) : true;
	  }
	  function initSuspenseListRenderState(workInProgress2, isBackwards, tail, lastContentRow, tailMode) {
	    var renderState = workInProgress2.memoizedState;
	    null === renderState ? workInProgress2.memoizedState = {
	      isBackwards,
	      rendering: null,
	      renderingStartTime: 0,
	      last: lastContentRow,
	      tail,
	      tailMode
	    } : (renderState.isBackwards = isBackwards, renderState.rendering = null, renderState.renderingStartTime = 0, renderState.last = lastContentRow, renderState.tail = tail, renderState.tailMode = tailMode);
	  }
	  function updateSuspenseListComponent(current2, workInProgress2, renderLanes2) {
	    var nextProps = workInProgress2.pendingProps, revealOrder = nextProps.revealOrder, tailMode = nextProps.tail;
	    nextProps = nextProps.children;
	    if (void 0 !== revealOrder && "forwards" !== revealOrder && "backwards" !== revealOrder && "together" !== revealOrder && !didWarnAboutRevealOrder[revealOrder])
	      if (didWarnAboutRevealOrder[revealOrder] = true, "string" === typeof revealOrder)
	        switch (revealOrder.toLowerCase()) {
	          case "together":
	          case "forwards":
	          case "backwards":
	            console.error(
	              '"%s" is not a valid value for revealOrder on <SuspenseList />. Use lowercase "%s" instead.',
	              revealOrder,
	              revealOrder.toLowerCase()
	            );
	            break;
	          case "forward":
	          case "backward":
	            console.error(
	              '"%s" is not a valid value for revealOrder on <SuspenseList />. React uses the -s suffix in the spelling. Use "%ss" instead.',
	              revealOrder,
	              revealOrder.toLowerCase()
	            );
	            break;
	          default:
	            console.error(
	              '"%s" is not a supported revealOrder on <SuspenseList />. Did you mean "together", "forwards" or "backwards"?',
	              revealOrder
	            );
	        }
	      else
	        console.error(
	          '%s is not a supported value for revealOrder on <SuspenseList />. Did you mean "together", "forwards" or "backwards"?',
	          revealOrder
	        );
	    void 0 === tailMode || didWarnAboutTailOptions[tailMode] || ("collapsed" !== tailMode && "hidden" !== tailMode ? (didWarnAboutTailOptions[tailMode] = true, console.error(
	      '"%s" is not a supported value for tail on <SuspenseList />. Did you mean "collapsed" or "hidden"?',
	      tailMode
	    )) : "forwards" !== revealOrder && "backwards" !== revealOrder && (didWarnAboutTailOptions[tailMode] = true, console.error(
	      '<SuspenseList tail="%s" /> is only valid if revealOrder is "forwards" or "backwards". Did you mean to specify revealOrder="forwards"?',
	      tailMode
	    )));
	    a: if (("forwards" === revealOrder || "backwards" === revealOrder) && void 0 !== nextProps && null !== nextProps && false !== nextProps)
	      if (isArrayImpl(nextProps))
	        for (var i = 0; i < nextProps.length; i++) {
	          if (!validateSuspenseListNestedChild(nextProps[i], i)) break a;
	        }
	      else if (i = getIteratorFn(nextProps), "function" === typeof i) {
	        if (i = i.call(nextProps))
	          for (var step = i.next(), _i = 0; !step.done; step = i.next()) {
	            if (!validateSuspenseListNestedChild(step.value, _i)) break a;
	            _i++;
	          }
	      } else
	        console.error(
	          'A single row was passed to a <SuspenseList revealOrder="%s" />. This is not useful since it needs multiple rows. Did you mean to pass multiple children or an array?',
	          revealOrder
	        );
	    reconcileChildren(current2, workInProgress2, nextProps, renderLanes2);
	    nextProps = suspenseStackCursor.current;
	    if (0 !== (nextProps & ForceSuspenseFallback))
	      nextProps = nextProps & SubtreeSuspenseContextMask | ForceSuspenseFallback, workInProgress2.flags |= 128;
	    else {
	      if (null !== current2 && 0 !== (current2.flags & 128))
	        a: for (current2 = workInProgress2.child; null !== current2; ) {
	          if (13 === current2.tag)
	            null !== current2.memoizedState && scheduleSuspenseWorkOnFiber(
	              current2,
	              renderLanes2,
	              workInProgress2
	            );
	          else if (19 === current2.tag)
	            scheduleSuspenseWorkOnFiber(current2, renderLanes2, workInProgress2);
	          else if (null !== current2.child) {
	            current2.child.return = current2;
	            current2 = current2.child;
	            continue;
	          }
	          if (current2 === workInProgress2) break a;
	          for (; null === current2.sibling; ) {
	            if (null === current2.return || current2.return === workInProgress2)
	              break a;
	            current2 = current2.return;
	          }
	          current2.sibling.return = current2.return;
	          current2 = current2.sibling;
	        }
	      nextProps &= SubtreeSuspenseContextMask;
	    }
	    push(suspenseStackCursor, nextProps, workInProgress2);
	    switch (revealOrder) {
	      case "forwards":
	        renderLanes2 = workInProgress2.child;
	        for (revealOrder = null; null !== renderLanes2; )
	          current2 = renderLanes2.alternate, null !== current2 && null === findFirstSuspended(current2) && (revealOrder = renderLanes2), renderLanes2 = renderLanes2.sibling;
	        renderLanes2 = revealOrder;
	        null === renderLanes2 ? (revealOrder = workInProgress2.child, workInProgress2.child = null) : (revealOrder = renderLanes2.sibling, renderLanes2.sibling = null);
	        initSuspenseListRenderState(
	          workInProgress2,
	          false,
	          revealOrder,
	          renderLanes2,
	          tailMode
	        );
	        break;
	      case "backwards":
	        renderLanes2 = null;
	        revealOrder = workInProgress2.child;
	        for (workInProgress2.child = null; null !== revealOrder; ) {
	          current2 = revealOrder.alternate;
	          if (null !== current2 && null === findFirstSuspended(current2)) {
	            workInProgress2.child = revealOrder;
	            break;
	          }
	          current2 = revealOrder.sibling;
	          revealOrder.sibling = renderLanes2;
	          renderLanes2 = revealOrder;
	          revealOrder = current2;
	        }
	        initSuspenseListRenderState(
	          workInProgress2,
	          true,
	          renderLanes2,
	          null,
	          tailMode
	        );
	        break;
	      case "together":
	        initSuspenseListRenderState(workInProgress2, false, null, null, void 0);
	        break;
	      default:
	        workInProgress2.memoizedState = null;
	    }
	    return workInProgress2.child;
	  }
	  function bailoutOnAlreadyFinishedWork(current2, workInProgress2, renderLanes2) {
	    null !== current2 && (workInProgress2.dependencies = current2.dependencies);
	    profilerStartTime = -1;
	    workInProgressRootSkippedLanes |= workInProgress2.lanes;
	    if (0 === (renderLanes2 & workInProgress2.childLanes))
	      if (null !== current2) {
	        if (propagateParentContextChanges(
	          current2,
	          workInProgress2,
	          renderLanes2,
	          false
	        ), 0 === (renderLanes2 & workInProgress2.childLanes))
	          return null;
	      } else return null;
	    if (null !== current2 && workInProgress2.child !== current2.child)
	      throw Error("Resuming work not yet implemented.");
	    if (null !== workInProgress2.child) {
	      current2 = workInProgress2.child;
	      renderLanes2 = createWorkInProgress(current2, current2.pendingProps);
	      workInProgress2.child = renderLanes2;
	      for (renderLanes2.return = workInProgress2; null !== current2.sibling; )
	        current2 = current2.sibling, renderLanes2 = renderLanes2.sibling = createWorkInProgress(current2, current2.pendingProps), renderLanes2.return = workInProgress2;
	      renderLanes2.sibling = null;
	    }
	    return workInProgress2.child;
	  }
	  function checkScheduledUpdateOrContext(current2, renderLanes2) {
	    if (0 !== (current2.lanes & renderLanes2)) return true;
	    current2 = current2.dependencies;
	    return null !== current2 && checkIfContextChanged(current2) ? true : false;
	  }
	  function attemptEarlyBailoutIfNoScheduledUpdate(current2, workInProgress2, renderLanes2) {
	    switch (workInProgress2.tag) {
	      case 3:
	        pushHostContainer(
	          workInProgress2,
	          workInProgress2.stateNode.containerInfo
	        );
	        pushProvider(
	          workInProgress2,
	          CacheContext,
	          current2.memoizedState.cache
	        );
	        resetHydrationState();
	        break;
	      case 27:
	      case 5:
	        pushHostContext(workInProgress2);
	        break;
	      case 4:
	        pushHostContainer(
	          workInProgress2,
	          workInProgress2.stateNode.containerInfo
	        );
	        break;
	      case 10:
	        pushProvider(
	          workInProgress2,
	          workInProgress2.type,
	          workInProgress2.memoizedProps.value
	        );
	        break;
	      case 12:
	        0 !== (renderLanes2 & workInProgress2.childLanes) && (workInProgress2.flags |= 4);
	        workInProgress2.flags |= 2048;
	        var stateNode = workInProgress2.stateNode;
	        stateNode.effectDuration = -0;
	        stateNode.passiveEffectDuration = -0;
	        break;
	      case 13:
	        stateNode = workInProgress2.memoizedState;
	        if (null !== stateNode) {
	          if (null !== stateNode.dehydrated)
	            return pushPrimaryTreeSuspenseHandler(workInProgress2), workInProgress2.flags |= 128, null;
	          if (0 !== (renderLanes2 & workInProgress2.child.childLanes))
	            return updateSuspenseComponent(
	              current2,
	              workInProgress2,
	              renderLanes2
	            );
	          pushPrimaryTreeSuspenseHandler(workInProgress2);
	          current2 = bailoutOnAlreadyFinishedWork(
	            current2,
	            workInProgress2,
	            renderLanes2
	          );
	          return null !== current2 ? current2.sibling : null;
	        }
	        pushPrimaryTreeSuspenseHandler(workInProgress2);
	        break;
	      case 19:
	        var didSuspendBefore = 0 !== (current2.flags & 128);
	        stateNode = 0 !== (renderLanes2 & workInProgress2.childLanes);
	        stateNode || (propagateParentContextChanges(
	          current2,
	          workInProgress2,
	          renderLanes2,
	          false
	        ), stateNode = 0 !== (renderLanes2 & workInProgress2.childLanes));
	        if (didSuspendBefore) {
	          if (stateNode)
	            return updateSuspenseListComponent(
	              current2,
	              workInProgress2,
	              renderLanes2
	            );
	          workInProgress2.flags |= 128;
	        }
	        didSuspendBefore = workInProgress2.memoizedState;
	        null !== didSuspendBefore && (didSuspendBefore.rendering = null, didSuspendBefore.tail = null, didSuspendBefore.lastEffect = null);
	        push(
	          suspenseStackCursor,
	          suspenseStackCursor.current,
	          workInProgress2
	        );
	        if (stateNode) break;
	        else return null;
	      case 22:
	      case 23:
	        return workInProgress2.lanes = 0, updateOffscreenComponent(current2, workInProgress2, renderLanes2);
	      case 24:
	        pushProvider(
	          workInProgress2,
	          CacheContext,
	          current2.memoizedState.cache
	        );
	    }
	    return bailoutOnAlreadyFinishedWork(current2, workInProgress2, renderLanes2);
	  }
	  function beginWork(current2, workInProgress2, renderLanes2) {
	    if (workInProgress2._debugNeedsRemount && null !== current2) {
	      renderLanes2 = createFiberFromTypeAndProps(
	        workInProgress2.type,
	        workInProgress2.key,
	        workInProgress2.pendingProps,
	        workInProgress2._debugOwner || null,
	        workInProgress2.mode,
	        workInProgress2.lanes
	      );
	      renderLanes2._debugStack = workInProgress2._debugStack;
	      renderLanes2._debugTask = workInProgress2._debugTask;
	      var returnFiber = workInProgress2.return;
	      if (null === returnFiber) throw Error("Cannot swap the root fiber.");
	      current2.alternate = null;
	      workInProgress2.alternate = null;
	      renderLanes2.index = workInProgress2.index;
	      renderLanes2.sibling = workInProgress2.sibling;
	      renderLanes2.return = workInProgress2.return;
	      renderLanes2.ref = workInProgress2.ref;
	      renderLanes2._debugInfo = workInProgress2._debugInfo;
	      if (workInProgress2 === returnFiber.child)
	        returnFiber.child = renderLanes2;
	      else {
	        var prevSibling = returnFiber.child;
	        if (null === prevSibling)
	          throw Error("Expected parent to have a child.");
	        for (; prevSibling.sibling !== workInProgress2; )
	          if (prevSibling = prevSibling.sibling, null === prevSibling)
	            throw Error("Expected to find the previous sibling.");
	        prevSibling.sibling = renderLanes2;
	      }
	      workInProgress2 = returnFiber.deletions;
	      null === workInProgress2 ? (returnFiber.deletions = [current2], returnFiber.flags |= 16) : workInProgress2.push(current2);
	      renderLanes2.flags |= 2;
	      return renderLanes2;
	    }
	    if (null !== current2)
	      if (current2.memoizedProps !== workInProgress2.pendingProps || workInProgress2.type !== current2.type)
	        didReceiveUpdate = true;
	      else {
	        if (!checkScheduledUpdateOrContext(current2, renderLanes2) && 0 === (workInProgress2.flags & 128))
	          return didReceiveUpdate = false, attemptEarlyBailoutIfNoScheduledUpdate(
	            current2,
	            workInProgress2,
	            renderLanes2
	          );
	        didReceiveUpdate = 0 !== (current2.flags & 131072) ? true : false;
	      }
	    else {
	      didReceiveUpdate = false;
	      if (returnFiber = isHydrating)
	        warnIfNotHydrating(), returnFiber = 0 !== (workInProgress2.flags & 1048576);
	      returnFiber && (returnFiber = workInProgress2.index, warnIfNotHydrating(), pushTreeId(workInProgress2, treeForkCount, returnFiber));
	    }
	    workInProgress2.lanes = 0;
	    switch (workInProgress2.tag) {
	      case 16:
	        a: if (returnFiber = workInProgress2.pendingProps, current2 = callLazyInitInDEV(workInProgress2.elementType), workInProgress2.type = current2, "function" === typeof current2)
	          shouldConstruct(current2) ? (returnFiber = resolveClassComponentProps(
	            current2,
	            returnFiber
	          ), workInProgress2.tag = 1, workInProgress2.type = current2 = resolveFunctionForHotReloading(current2), workInProgress2 = updateClassComponent(
	            null,
	            workInProgress2,
	            current2,
	            returnFiber,
	            renderLanes2
	          )) : (workInProgress2.tag = 0, validateFunctionComponentInDev(workInProgress2, current2), workInProgress2.type = current2 = resolveFunctionForHotReloading(current2), workInProgress2 = updateFunctionComponent(
	            null,
	            workInProgress2,
	            current2,
	            returnFiber,
	            renderLanes2
	          ));
	        else {
	          if (void 0 !== current2 && null !== current2) {
	            if (prevSibling = current2.$$typeof, prevSibling === REACT_FORWARD_REF_TYPE) {
	              workInProgress2.tag = 11;
	              workInProgress2.type = current2 = resolveForwardRefForHotReloading(current2);
	              workInProgress2 = updateForwardRef(
	                null,
	                workInProgress2,
	                current2,
	                returnFiber,
	                renderLanes2
	              );
	              break a;
	            } else if (prevSibling === REACT_MEMO_TYPE) {
	              workInProgress2.tag = 14;
	              workInProgress2 = updateMemoComponent(
	                null,
	                workInProgress2,
	                current2,
	                returnFiber,
	                renderLanes2
	              );
	              break a;
	            }
	          }
	          workInProgress2 = "";
	          null !== current2 && "object" === typeof current2 && current2.$$typeof === REACT_LAZY_TYPE && (workInProgress2 = " Did you wrap a component in React.lazy() more than once?");
	          current2 = getComponentNameFromType(current2) || current2;
	          throw Error(
	            "Element type is invalid. Received a promise that resolves to: " + current2 + ". Lazy element type must resolve to a class or function." + workInProgress2
	          );
	        }
	        return workInProgress2;
	      case 0:
	        return updateFunctionComponent(
	          current2,
	          workInProgress2,
	          workInProgress2.type,
	          workInProgress2.pendingProps,
	          renderLanes2
	        );
	      case 1:
	        return returnFiber = workInProgress2.type, prevSibling = resolveClassComponentProps(
	          returnFiber,
	          workInProgress2.pendingProps
	        ), updateClassComponent(
	          current2,
	          workInProgress2,
	          returnFiber,
	          prevSibling,
	          renderLanes2
	        );
	      case 3:
	        a: {
	          pushHostContainer(
	            workInProgress2,
	            workInProgress2.stateNode.containerInfo
	          );
	          if (null === current2)
	            throw Error(
	              "Should have a current fiber. This is a bug in React."
	            );
	          returnFiber = workInProgress2.pendingProps;
	          var prevState = workInProgress2.memoizedState;
	          prevSibling = prevState.element;
	          cloneUpdateQueue(current2, workInProgress2);
	          processUpdateQueue(workInProgress2, returnFiber, null, renderLanes2);
	          var nextState = workInProgress2.memoizedState;
	          returnFiber = nextState.cache;
	          pushProvider(workInProgress2, CacheContext, returnFiber);
	          returnFiber !== prevState.cache && propagateContextChanges(
	            workInProgress2,
	            [CacheContext],
	            renderLanes2,
	            true
	          );
	          suspendIfUpdateReadFromEntangledAsyncAction();
	          returnFiber = nextState.element;
	          if (prevState.isDehydrated)
	            if (prevState = {
	              element: returnFiber,
	              isDehydrated: false,
	              cache: nextState.cache
	            }, workInProgress2.updateQueue.baseState = prevState, workInProgress2.memoizedState = prevState, workInProgress2.flags & 256) {
	              workInProgress2 = mountHostRootWithoutHydrating(
	                current2,
	                workInProgress2,
	                returnFiber,
	                renderLanes2
	              );
	              break a;
	            } else if (returnFiber !== prevSibling) {
	              prevSibling = createCapturedValueAtFiber(
	                Error(
	                  "This root received an early update, before anything was able hydrate. Switched the entire root to client rendering."
	                ),
	                workInProgress2
	              );
	              queueHydrationError(prevSibling);
	              workInProgress2 = mountHostRootWithoutHydrating(
	                current2,
	                workInProgress2,
	                returnFiber,
	                renderLanes2
	              );
	              break a;
	            } else {
	              current2 = workInProgress2.stateNode.containerInfo;
	              switch (current2.nodeType) {
	                case 9:
	                  current2 = current2.body;
	                  break;
	                default:
	                  current2 = "HTML" === current2.nodeName ? current2.ownerDocument.body : current2;
	              }
	              nextHydratableInstance = getNextHydratable(current2.firstChild);
	              hydrationParentFiber = workInProgress2;
	              isHydrating = true;
	              hydrationErrors = null;
	              didSuspendOrErrorDEV = false;
	              hydrationDiffRootDEV = null;
	              rootOrSingletonContext = true;
	              current2 = mountChildFibers(
	                workInProgress2,
	                null,
	                returnFiber,
	                renderLanes2
	              );
	              for (workInProgress2.child = current2; current2; )
	                current2.flags = current2.flags & -3 | 4096, current2 = current2.sibling;
	            }
	          else {
	            resetHydrationState();
	            if (returnFiber === prevSibling) {
	              workInProgress2 = bailoutOnAlreadyFinishedWork(
	                current2,
	                workInProgress2,
	                renderLanes2
	              );
	              break a;
	            }
	            reconcileChildren(
	              current2,
	              workInProgress2,
	              returnFiber,
	              renderLanes2
	            );
	          }
	          workInProgress2 = workInProgress2.child;
	        }
	        return workInProgress2;
	      case 26:
	        return markRef(current2, workInProgress2), null === current2 ? (current2 = getResource(
	          workInProgress2.type,
	          null,
	          workInProgress2.pendingProps,
	          null
	        )) ? workInProgress2.memoizedState = current2 : isHydrating || (current2 = workInProgress2.type, renderLanes2 = workInProgress2.pendingProps, returnFiber = requiredContext(
	          rootInstanceStackCursor.current
	        ), returnFiber = getOwnerDocumentFromRootContainer(
	          returnFiber
	        ).createElement(current2), returnFiber[internalInstanceKey] = workInProgress2, returnFiber[internalPropsKey] = renderLanes2, setInitialProperties(returnFiber, current2, renderLanes2), markNodeAsHoistable(returnFiber), workInProgress2.stateNode = returnFiber) : workInProgress2.memoizedState = getResource(
	          workInProgress2.type,
	          current2.memoizedProps,
	          workInProgress2.pendingProps,
	          current2.memoizedState
	        ), null;
	      case 27:
	        return pushHostContext(workInProgress2), null === current2 && isHydrating && (returnFiber = requiredContext(rootInstanceStackCursor.current), prevSibling = getHostContext(), returnFiber = workInProgress2.stateNode = resolveSingletonInstance(
	          workInProgress2.type,
	          workInProgress2.pendingProps,
	          returnFiber,
	          prevSibling,
	          false
	        ), didSuspendOrErrorDEV || (prevSibling = diffHydratedProperties(
	          returnFiber,
	          workInProgress2.type,
	          workInProgress2.pendingProps,
	          prevSibling
	        ), null !== prevSibling && (buildHydrationDiffNode(workInProgress2, 0).serverProps = prevSibling)), hydrationParentFiber = workInProgress2, rootOrSingletonContext = true, prevSibling = nextHydratableInstance, isSingletonScope(workInProgress2.type) ? (previousHydratableOnEnteringScopedSingleton = prevSibling, nextHydratableInstance = getNextHydratable(
	          returnFiber.firstChild
	        )) : nextHydratableInstance = prevSibling), reconcileChildren(
	          current2,
	          workInProgress2,
	          workInProgress2.pendingProps.children,
	          renderLanes2
	        ), markRef(current2, workInProgress2), null === current2 && (workInProgress2.flags |= 4194304), workInProgress2.child;
	      case 5:
	        return null === current2 && isHydrating && (prevState = getHostContext(), returnFiber = validateDOMNesting(
	          workInProgress2.type,
	          prevState.ancestorInfo
	        ), prevSibling = nextHydratableInstance, (nextState = !prevSibling) || (nextState = canHydrateInstance(
	          prevSibling,
	          workInProgress2.type,
	          workInProgress2.pendingProps,
	          rootOrSingletonContext
	        ), null !== nextState ? (workInProgress2.stateNode = nextState, didSuspendOrErrorDEV || (prevState = diffHydratedProperties(
	          nextState,
	          workInProgress2.type,
	          workInProgress2.pendingProps,
	          prevState
	        ), null !== prevState && (buildHydrationDiffNode(workInProgress2, 0).serverProps = prevState)), hydrationParentFiber = workInProgress2, nextHydratableInstance = getNextHydratable(
	          nextState.firstChild
	        ), rootOrSingletonContext = false, prevState = true) : prevState = false, nextState = !prevState), nextState && (returnFiber && warnNonHydratedInstance(workInProgress2, prevSibling), throwOnHydrationMismatch(workInProgress2))), pushHostContext(workInProgress2), prevSibling = workInProgress2.type, prevState = workInProgress2.pendingProps, nextState = null !== current2 ? current2.memoizedProps : null, returnFiber = prevState.children, shouldSetTextContent(prevSibling, prevState) ? returnFiber = null : null !== nextState && shouldSetTextContent(prevSibling, nextState) && (workInProgress2.flags |= 32), null !== workInProgress2.memoizedState && (prevSibling = renderWithHooks(
	          current2,
	          workInProgress2,
	          TransitionAwareHostComponent,
	          null,
	          null,
	          renderLanes2
	        ), HostTransitionContext._currentValue = prevSibling), markRef(current2, workInProgress2), reconcileChildren(
	          current2,
	          workInProgress2,
	          returnFiber,
	          renderLanes2
	        ), workInProgress2.child;
	      case 6:
	        return null === current2 && isHydrating && (current2 = workInProgress2.pendingProps, renderLanes2 = getHostContext(), returnFiber = renderLanes2.ancestorInfo.current, current2 = null != returnFiber ? validateTextNesting(
	          current2,
	          returnFiber.tag,
	          renderLanes2.ancestorInfo.implicitRootScope
	        ) : true, renderLanes2 = nextHydratableInstance, (returnFiber = !renderLanes2) || (returnFiber = canHydrateTextInstance(
	          renderLanes2,
	          workInProgress2.pendingProps,
	          rootOrSingletonContext
	        ), null !== returnFiber ? (workInProgress2.stateNode = returnFiber, hydrationParentFiber = workInProgress2, nextHydratableInstance = null, returnFiber = true) : returnFiber = false, returnFiber = !returnFiber), returnFiber && (current2 && warnNonHydratedInstance(workInProgress2, renderLanes2), throwOnHydrationMismatch(workInProgress2))), null;
	      case 13:
	        return updateSuspenseComponent(current2, workInProgress2, renderLanes2);
	      case 4:
	        return pushHostContainer(
	          workInProgress2,
	          workInProgress2.stateNode.containerInfo
	        ), returnFiber = workInProgress2.pendingProps, null === current2 ? workInProgress2.child = reconcileChildFibers(
	          workInProgress2,
	          null,
	          returnFiber,
	          renderLanes2
	        ) : reconcileChildren(
	          current2,
	          workInProgress2,
	          returnFiber,
	          renderLanes2
	        ), workInProgress2.child;
	      case 11:
	        return updateForwardRef(
	          current2,
	          workInProgress2,
	          workInProgress2.type,
	          workInProgress2.pendingProps,
	          renderLanes2
	        );
	      case 7:
	        return reconcileChildren(
	          current2,
	          workInProgress2,
	          workInProgress2.pendingProps,
	          renderLanes2
	        ), workInProgress2.child;
	      case 8:
	        return reconcileChildren(
	          current2,
	          workInProgress2,
	          workInProgress2.pendingProps.children,
	          renderLanes2
	        ), workInProgress2.child;
	      case 12:
	        return workInProgress2.flags |= 4, workInProgress2.flags |= 2048, returnFiber = workInProgress2.stateNode, returnFiber.effectDuration = -0, returnFiber.passiveEffectDuration = -0, reconcileChildren(
	          current2,
	          workInProgress2,
	          workInProgress2.pendingProps.children,
	          renderLanes2
	        ), workInProgress2.child;
	      case 10:
	        return returnFiber = workInProgress2.type, prevSibling = workInProgress2.pendingProps, prevState = prevSibling.value, "value" in prevSibling || hasWarnedAboutUsingNoValuePropOnContextProvider || (hasWarnedAboutUsingNoValuePropOnContextProvider = true, console.error(
	          "The `value` prop is required for the `<Context.Provider>`. Did you misspell it or forget to pass it?"
	        )), pushProvider(workInProgress2, returnFiber, prevState), reconcileChildren(
	          current2,
	          workInProgress2,
	          prevSibling.children,
	          renderLanes2
	        ), workInProgress2.child;
	      case 9:
	        return prevSibling = workInProgress2.type._context, returnFiber = workInProgress2.pendingProps.children, "function" !== typeof returnFiber && console.error(
	          "A context consumer was rendered with multiple children, or a child that isn't a function. A context consumer expects a single child that is a function. If you did pass a function, make sure there is no trailing or leading whitespace around it."
	        ), prepareToReadContext(workInProgress2), prevSibling = readContext(prevSibling), markComponentRenderStarted(workInProgress2), returnFiber = callComponentInDEV(
	          returnFiber,
	          prevSibling,
	          void 0
	        ), markComponentRenderStopped(), workInProgress2.flags |= 1, reconcileChildren(
	          current2,
	          workInProgress2,
	          returnFiber,
	          renderLanes2
	        ), workInProgress2.child;
	      case 14:
	        return updateMemoComponent(
	          current2,
	          workInProgress2,
	          workInProgress2.type,
	          workInProgress2.pendingProps,
	          renderLanes2
	        );
	      case 15:
	        return updateSimpleMemoComponent(
	          current2,
	          workInProgress2,
	          workInProgress2.type,
	          workInProgress2.pendingProps,
	          renderLanes2
	        );
	      case 19:
	        return updateSuspenseListComponent(
	          current2,
	          workInProgress2,
	          renderLanes2
	        );
	      case 31:
	        return returnFiber = workInProgress2.pendingProps, renderLanes2 = workInProgress2.mode, returnFiber = {
	          mode: returnFiber.mode,
	          children: returnFiber.children
	        }, null === current2 ? (current2 = mountWorkInProgressOffscreenFiber(
	          returnFiber,
	          renderLanes2
	        ), current2.ref = workInProgress2.ref, workInProgress2.child = current2, current2.return = workInProgress2, workInProgress2 = current2) : (current2 = createWorkInProgress(current2.child, returnFiber), current2.ref = workInProgress2.ref, workInProgress2.child = current2, current2.return = workInProgress2, workInProgress2 = current2), workInProgress2;
	      case 22:
	        return updateOffscreenComponent(current2, workInProgress2, renderLanes2);
	      case 24:
	        return prepareToReadContext(workInProgress2), returnFiber = readContext(CacheContext), null === current2 ? (prevSibling = peekCacheFromPool(), null === prevSibling && (prevSibling = workInProgressRoot, prevState = createCache(), prevSibling.pooledCache = prevState, retainCache(prevState), null !== prevState && (prevSibling.pooledCacheLanes |= renderLanes2), prevSibling = prevState), workInProgress2.memoizedState = {
	          parent: returnFiber,
	          cache: prevSibling
	        }, initializeUpdateQueue(workInProgress2), pushProvider(workInProgress2, CacheContext, prevSibling)) : (0 !== (current2.lanes & renderLanes2) && (cloneUpdateQueue(current2, workInProgress2), processUpdateQueue(workInProgress2, null, null, renderLanes2), suspendIfUpdateReadFromEntangledAsyncAction()), prevSibling = current2.memoizedState, prevState = workInProgress2.memoizedState, prevSibling.parent !== returnFiber ? (prevSibling = {
	          parent: returnFiber,
	          cache: returnFiber
	        }, workInProgress2.memoizedState = prevSibling, 0 === workInProgress2.lanes && (workInProgress2.memoizedState = workInProgress2.updateQueue.baseState = prevSibling), pushProvider(workInProgress2, CacheContext, returnFiber)) : (returnFiber = prevState.cache, pushProvider(workInProgress2, CacheContext, returnFiber), returnFiber !== prevSibling.cache && propagateContextChanges(
	          workInProgress2,
	          [CacheContext],
	          renderLanes2,
	          true
	        ))), reconcileChildren(
	          current2,
	          workInProgress2,
	          workInProgress2.pendingProps.children,
	          renderLanes2
	        ), workInProgress2.child;
	      case 29:
	        throw workInProgress2.pendingProps;
	    }
	    throw Error(
	      "Unknown unit of work tag (" + workInProgress2.tag + "). This error is likely caused by a bug in React. Please file an issue."
	    );
	  }
	  function markUpdate(workInProgress2) {
	    workInProgress2.flags |= 4;
	  }
	  function preloadResourceAndSuspendIfNeeded(workInProgress2, resource) {
	    if ("stylesheet" !== resource.type || (resource.state.loading & Inserted) !== NotLoaded)
	      workInProgress2.flags &= -16777217;
	    else if (workInProgress2.flags |= 16777216, !preloadResource(resource)) {
	      resource = suspenseHandlerStackCursor.current;
	      if (null !== resource && ((workInProgressRootRenderLanes & 4194048) === workInProgressRootRenderLanes ? null !== shellBoundary : (workInProgressRootRenderLanes & 62914560) !== workInProgressRootRenderLanes && 0 === (workInProgressRootRenderLanes & 536870912) || resource !== shellBoundary))
	        throw suspendedThenable = noopSuspenseyCommitThenable, SuspenseyCommitException;
	      workInProgress2.flags |= 8192;
	    }
	  }
	  function scheduleRetryEffect(workInProgress2, retryQueue) {
	    null !== retryQueue && (workInProgress2.flags |= 4);
	    workInProgress2.flags & 16384 && (retryQueue = 22 !== workInProgress2.tag ? claimNextRetryLane() : 536870912, workInProgress2.lanes |= retryQueue, workInProgressSuspendedRetryLanes |= retryQueue);
	  }
	  function cutOffTailIfNeeded(renderState, hasRenderedATailFallback) {
	    if (!isHydrating)
	      switch (renderState.tailMode) {
	        case "hidden":
	          hasRenderedATailFallback = renderState.tail;
	          for (var lastTailNode = null; null !== hasRenderedATailFallback; )
	            null !== hasRenderedATailFallback.alternate && (lastTailNode = hasRenderedATailFallback), hasRenderedATailFallback = hasRenderedATailFallback.sibling;
	          null === lastTailNode ? renderState.tail = null : lastTailNode.sibling = null;
	          break;
	        case "collapsed":
	          lastTailNode = renderState.tail;
	          for (var _lastTailNode = null; null !== lastTailNode; )
	            null !== lastTailNode.alternate && (_lastTailNode = lastTailNode), lastTailNode = lastTailNode.sibling;
	          null === _lastTailNode ? hasRenderedATailFallback || null === renderState.tail ? renderState.tail = null : renderState.tail.sibling = null : _lastTailNode.sibling = null;
	      }
	  }
	  function bubbleProperties(completedWork) {
	    var didBailout = null !== completedWork.alternate && completedWork.alternate.child === completedWork.child, newChildLanes = 0, subtreeFlags = 0;
	    if (didBailout)
	      if ((completedWork.mode & ProfileMode) !== NoMode) {
	        for (var _treeBaseDuration = completedWork.selfBaseDuration, _child2 = completedWork.child; null !== _child2; )
	          newChildLanes |= _child2.lanes | _child2.childLanes, subtreeFlags |= _child2.subtreeFlags & 65011712, subtreeFlags |= _child2.flags & 65011712, _treeBaseDuration += _child2.treeBaseDuration, _child2 = _child2.sibling;
	        completedWork.treeBaseDuration = _treeBaseDuration;
	      } else
	        for (_treeBaseDuration = completedWork.child; null !== _treeBaseDuration; )
	          newChildLanes |= _treeBaseDuration.lanes | _treeBaseDuration.childLanes, subtreeFlags |= _treeBaseDuration.subtreeFlags & 65011712, subtreeFlags |= _treeBaseDuration.flags & 65011712, _treeBaseDuration.return = completedWork, _treeBaseDuration = _treeBaseDuration.sibling;
	    else if ((completedWork.mode & ProfileMode) !== NoMode) {
	      _treeBaseDuration = completedWork.actualDuration;
	      _child2 = completedWork.selfBaseDuration;
	      for (var child = completedWork.child; null !== child; )
	        newChildLanes |= child.lanes | child.childLanes, subtreeFlags |= child.subtreeFlags, subtreeFlags |= child.flags, _treeBaseDuration += child.actualDuration, _child2 += child.treeBaseDuration, child = child.sibling;
	      completedWork.actualDuration = _treeBaseDuration;
	      completedWork.treeBaseDuration = _child2;
	    } else
	      for (_treeBaseDuration = completedWork.child; null !== _treeBaseDuration; )
	        newChildLanes |= _treeBaseDuration.lanes | _treeBaseDuration.childLanes, subtreeFlags |= _treeBaseDuration.subtreeFlags, subtreeFlags |= _treeBaseDuration.flags, _treeBaseDuration.return = completedWork, _treeBaseDuration = _treeBaseDuration.sibling;
	    completedWork.subtreeFlags |= subtreeFlags;
	    completedWork.childLanes = newChildLanes;
	    return didBailout;
	  }
	  function completeWork(current2, workInProgress2, renderLanes2) {
	    var newProps = workInProgress2.pendingProps;
	    popTreeContext(workInProgress2);
	    switch (workInProgress2.tag) {
	      case 31:
	      case 16:
	      case 15:
	      case 0:
	      case 11:
	      case 7:
	      case 8:
	      case 12:
	      case 9:
	      case 14:
	        return bubbleProperties(workInProgress2), null;
	      case 1:
	        return bubbleProperties(workInProgress2), null;
	      case 3:
	        renderLanes2 = workInProgress2.stateNode;
	        newProps = null;
	        null !== current2 && (newProps = current2.memoizedState.cache);
	        workInProgress2.memoizedState.cache !== newProps && (workInProgress2.flags |= 2048);
	        popProvider(CacheContext, workInProgress2);
	        popHostContainer(workInProgress2);
	        renderLanes2.pendingContext && (renderLanes2.context = renderLanes2.pendingContext, renderLanes2.pendingContext = null);
	        if (null === current2 || null === current2.child)
	          popHydrationState(workInProgress2) ? (emitPendingHydrationWarnings(), markUpdate(workInProgress2)) : null === current2 || current2.memoizedState.isDehydrated && 0 === (workInProgress2.flags & 256) || (workInProgress2.flags |= 1024, upgradeHydrationErrorsToRecoverable());
	        bubbleProperties(workInProgress2);
	        return null;
	      case 26:
	        return renderLanes2 = workInProgress2.memoizedState, null === current2 ? (markUpdate(workInProgress2), null !== renderLanes2 ? (bubbleProperties(workInProgress2), preloadResourceAndSuspendIfNeeded(
	          workInProgress2,
	          renderLanes2
	        )) : (bubbleProperties(workInProgress2), workInProgress2.flags &= -16777217)) : renderLanes2 ? renderLanes2 !== current2.memoizedState ? (markUpdate(workInProgress2), bubbleProperties(workInProgress2), preloadResourceAndSuspendIfNeeded(
	          workInProgress2,
	          renderLanes2
	        )) : (bubbleProperties(workInProgress2), workInProgress2.flags &= -16777217) : (current2.memoizedProps !== newProps && markUpdate(workInProgress2), bubbleProperties(workInProgress2), workInProgress2.flags &= -16777217), null;
	      case 27:
	        popHostContext(workInProgress2);
	        renderLanes2 = requiredContext(rootInstanceStackCursor.current);
	        var _type = workInProgress2.type;
	        if (null !== current2 && null != workInProgress2.stateNode)
	          current2.memoizedProps !== newProps && markUpdate(workInProgress2);
	        else {
	          if (!newProps) {
	            if (null === workInProgress2.stateNode)
	              throw Error(
	                "We must have new props for new mounts. This error is likely caused by a bug in React. Please file an issue."
	              );
	            bubbleProperties(workInProgress2);
	            return null;
	          }
	          current2 = getHostContext();
	          popHydrationState(workInProgress2) ? prepareToHydrateHostInstance(workInProgress2) : (current2 = resolveSingletonInstance(
	            _type,
	            newProps,
	            renderLanes2,
	            current2,
	            true
	          ), workInProgress2.stateNode = current2, markUpdate(workInProgress2));
	        }
	        bubbleProperties(workInProgress2);
	        return null;
	      case 5:
	        popHostContext(workInProgress2);
	        renderLanes2 = workInProgress2.type;
	        if (null !== current2 && null != workInProgress2.stateNode)
	          current2.memoizedProps !== newProps && markUpdate(workInProgress2);
	        else {
	          if (!newProps) {
	            if (null === workInProgress2.stateNode)
	              throw Error(
	                "We must have new props for new mounts. This error is likely caused by a bug in React. Please file an issue."
	              );
	            bubbleProperties(workInProgress2);
	            return null;
	          }
	          _type = getHostContext();
	          if (popHydrationState(workInProgress2))
	            prepareToHydrateHostInstance(workInProgress2);
	          else {
	            current2 = requiredContext(rootInstanceStackCursor.current);
	            validateDOMNesting(renderLanes2, _type.ancestorInfo);
	            _type = _type.context;
	            current2 = getOwnerDocumentFromRootContainer(current2);
	            switch (_type) {
	              case HostContextNamespaceSvg:
	                current2 = current2.createElementNS(SVG_NAMESPACE, renderLanes2);
	                break;
	              case HostContextNamespaceMath:
	                current2 = current2.createElementNS(
	                  MATH_NAMESPACE,
	                  renderLanes2
	                );
	                break;
	              default:
	                switch (renderLanes2) {
	                  case "svg":
	                    current2 = current2.createElementNS(
	                      SVG_NAMESPACE,
	                      renderLanes2
	                    );
	                    break;
	                  case "math":
	                    current2 = current2.createElementNS(
	                      MATH_NAMESPACE,
	                      renderLanes2
	                    );
	                    break;
	                  case "script":
	                    current2 = current2.createElement("div");
	                    current2.innerHTML = "<script></script>";
	                    current2 = current2.removeChild(current2.firstChild);
	                    break;
	                  case "select":
	                    current2 = "string" === typeof newProps.is ? current2.createElement("select", { is: newProps.is }) : current2.createElement("select");
	                    newProps.multiple ? current2.multiple = true : newProps.size && (current2.size = newProps.size);
	                    break;
	                  default:
	                    current2 = "string" === typeof newProps.is ? current2.createElement(renderLanes2, {
	                      is: newProps.is
	                    }) : current2.createElement(renderLanes2), -1 === renderLanes2.indexOf("-") && (renderLanes2 !== renderLanes2.toLowerCase() && console.error(
	                      "<%s /> is using incorrect casing. Use PascalCase for React components, or lowercase for HTML elements.",
	                      renderLanes2
	                    ), "[object HTMLUnknownElement]" !== Object.prototype.toString.call(current2) || hasOwnProperty.call(
	                      warnedUnknownTags,
	                      renderLanes2
	                    ) || (warnedUnknownTags[renderLanes2] = true, console.error(
	                      "The tag <%s> is unrecognized in this browser. If you meant to render a React component, start its name with an uppercase letter.",
	                      renderLanes2
	                    )));
	                }
	            }
	            current2[internalInstanceKey] = workInProgress2;
	            current2[internalPropsKey] = newProps;
	            a: for (_type = workInProgress2.child; null !== _type; ) {
	              if (5 === _type.tag || 6 === _type.tag)
	                current2.appendChild(_type.stateNode);
	              else if (4 !== _type.tag && 27 !== _type.tag && null !== _type.child) {
	                _type.child.return = _type;
	                _type = _type.child;
	                continue;
	              }
	              if (_type === workInProgress2) break a;
	              for (; null === _type.sibling; ) {
	                if (null === _type.return || _type.return === workInProgress2)
	                  break a;
	                _type = _type.return;
	              }
	              _type.sibling.return = _type.return;
	              _type = _type.sibling;
	            }
	            workInProgress2.stateNode = current2;
	            a: switch (setInitialProperties(current2, renderLanes2, newProps), renderLanes2) {
	              case "button":
	              case "input":
	              case "select":
	              case "textarea":
	                current2 = !!newProps.autoFocus;
	                break a;
	              case "img":
	                current2 = true;
	                break a;
	              default:
	                current2 = false;
	            }
	            current2 && markUpdate(workInProgress2);
	          }
	        }
	        bubbleProperties(workInProgress2);
	        workInProgress2.flags &= -16777217;
	        return null;
	      case 6:
	        if (current2 && null != workInProgress2.stateNode)
	          current2.memoizedProps !== newProps && markUpdate(workInProgress2);
	        else {
	          if ("string" !== typeof newProps && null === workInProgress2.stateNode)
	            throw Error(
	              "We must have new props for new mounts. This error is likely caused by a bug in React. Please file an issue."
	            );
	          current2 = requiredContext(rootInstanceStackCursor.current);
	          renderLanes2 = getHostContext();
	          if (popHydrationState(workInProgress2)) {
	            current2 = workInProgress2.stateNode;
	            renderLanes2 = workInProgress2.memoizedProps;
	            _type = !didSuspendOrErrorDEV;
	            newProps = null;
	            var returnFiber = hydrationParentFiber;
	            if (null !== returnFiber)
	              switch (returnFiber.tag) {
	                case 3:
	                  _type && (_type = diffHydratedTextForDevWarnings(
	                    current2,
	                    renderLanes2,
	                    newProps
	                  ), null !== _type && (buildHydrationDiffNode(workInProgress2, 0).serverProps = _type));
	                  break;
	                case 27:
	                case 5:
	                  newProps = returnFiber.memoizedProps, _type && (_type = diffHydratedTextForDevWarnings(
	                    current2,
	                    renderLanes2,
	                    newProps
	                  ), null !== _type && (buildHydrationDiffNode(
	                    workInProgress2,
	                    0
	                  ).serverProps = _type));
	              }
	            current2[internalInstanceKey] = workInProgress2;
	            current2 = current2.nodeValue === renderLanes2 || null !== newProps && true === newProps.suppressHydrationWarning || checkForUnmatchedText(current2.nodeValue, renderLanes2) ? true : false;
	            current2 || throwOnHydrationMismatch(workInProgress2);
	          } else
	            _type = renderLanes2.ancestorInfo.current, null != _type && validateTextNesting(
	              newProps,
	              _type.tag,
	              renderLanes2.ancestorInfo.implicitRootScope
	            ), current2 = getOwnerDocumentFromRootContainer(current2).createTextNode(
	              newProps
	            ), current2[internalInstanceKey] = workInProgress2, workInProgress2.stateNode = current2;
	        }
	        bubbleProperties(workInProgress2);
	        return null;
	      case 13:
	        newProps = workInProgress2.memoizedState;
	        if (null === current2 || null !== current2.memoizedState && null !== current2.memoizedState.dehydrated) {
	          _type = popHydrationState(workInProgress2);
	          if (null !== newProps && null !== newProps.dehydrated) {
	            if (null === current2) {
	              if (!_type)
	                throw Error(
	                  "A dehydrated suspense component was completed without a hydrated node. This is probably a bug in React."
	                );
	              _type = workInProgress2.memoizedState;
	              _type = null !== _type ? _type.dehydrated : null;
	              if (!_type)
	                throw Error(
	                  "Expected to have a hydrated suspense instance. This error is likely caused by a bug in React. Please file an issue."
	                );
	              _type[internalInstanceKey] = workInProgress2;
	              bubbleProperties(workInProgress2);
	              (workInProgress2.mode & ProfileMode) !== NoMode && null !== newProps && (_type = workInProgress2.child, null !== _type && (workInProgress2.treeBaseDuration -= _type.treeBaseDuration));
	            } else
	              emitPendingHydrationWarnings(), resetHydrationState(), 0 === (workInProgress2.flags & 128) && (workInProgress2.memoizedState = null), workInProgress2.flags |= 4, bubbleProperties(workInProgress2), (workInProgress2.mode & ProfileMode) !== NoMode && null !== newProps && (_type = workInProgress2.child, null !== _type && (workInProgress2.treeBaseDuration -= _type.treeBaseDuration));
	            _type = false;
	          } else
	            _type = upgradeHydrationErrorsToRecoverable(), null !== current2 && null !== current2.memoizedState && (current2.memoizedState.hydrationErrors = _type), _type = true;
	          if (!_type) {
	            if (workInProgress2.flags & 256)
	              return popSuspenseHandler(workInProgress2), workInProgress2;
	            popSuspenseHandler(workInProgress2);
	            return null;
	          }
	        }
	        popSuspenseHandler(workInProgress2);
	        if (0 !== (workInProgress2.flags & 128))
	          return workInProgress2.lanes = renderLanes2, (workInProgress2.mode & ProfileMode) !== NoMode && transferActualDuration(workInProgress2), workInProgress2;
	        renderLanes2 = null !== newProps;
	        current2 = null !== current2 && null !== current2.memoizedState;
	        renderLanes2 && (newProps = workInProgress2.child, _type = null, null !== newProps.alternate && null !== newProps.alternate.memoizedState && null !== newProps.alternate.memoizedState.cachePool && (_type = newProps.alternate.memoizedState.cachePool.pool), returnFiber = null, null !== newProps.memoizedState && null !== newProps.memoizedState.cachePool && (returnFiber = newProps.memoizedState.cachePool.pool), returnFiber !== _type && (newProps.flags |= 2048));
	        renderLanes2 !== current2 && renderLanes2 && (workInProgress2.child.flags |= 8192);
	        scheduleRetryEffect(workInProgress2, workInProgress2.updateQueue);
	        bubbleProperties(workInProgress2);
	        (workInProgress2.mode & ProfileMode) !== NoMode && renderLanes2 && (current2 = workInProgress2.child, null !== current2 && (workInProgress2.treeBaseDuration -= current2.treeBaseDuration));
	        return null;
	      case 4:
	        return popHostContainer(workInProgress2), null === current2 && listenToAllSupportedEvents(
	          workInProgress2.stateNode.containerInfo
	        ), bubbleProperties(workInProgress2), null;
	      case 10:
	        return popProvider(workInProgress2.type, workInProgress2), bubbleProperties(workInProgress2), null;
	      case 19:
	        pop(suspenseStackCursor, workInProgress2);
	        _type = workInProgress2.memoizedState;
	        if (null === _type) return bubbleProperties(workInProgress2), null;
	        newProps = 0 !== (workInProgress2.flags & 128);
	        returnFiber = _type.rendering;
	        if (null === returnFiber)
	          if (newProps) cutOffTailIfNeeded(_type, false);
	          else {
	            if (workInProgressRootExitStatus !== RootInProgress || null !== current2 && 0 !== (current2.flags & 128))
	              for (current2 = workInProgress2.child; null !== current2; ) {
	                returnFiber = findFirstSuspended(current2);
	                if (null !== returnFiber) {
	                  workInProgress2.flags |= 128;
	                  cutOffTailIfNeeded(_type, false);
	                  current2 = returnFiber.updateQueue;
	                  workInProgress2.updateQueue = current2;
	                  scheduleRetryEffect(workInProgress2, current2);
	                  workInProgress2.subtreeFlags = 0;
	                  current2 = renderLanes2;
	                  for (renderLanes2 = workInProgress2.child; null !== renderLanes2; )
	                    resetWorkInProgress(renderLanes2, current2), renderLanes2 = renderLanes2.sibling;
	                  push(
	                    suspenseStackCursor,
	                    suspenseStackCursor.current & SubtreeSuspenseContextMask | ForceSuspenseFallback,
	                    workInProgress2
	                  );
	                  return workInProgress2.child;
	                }
	                current2 = current2.sibling;
	              }
	            null !== _type.tail && now$1() > workInProgressRootRenderTargetTime && (workInProgress2.flags |= 128, newProps = true, cutOffTailIfNeeded(_type, false), workInProgress2.lanes = 4194304);
	          }
	        else {
	          if (!newProps)
	            if (current2 = findFirstSuspended(returnFiber), null !== current2) {
	              if (workInProgress2.flags |= 128, newProps = true, current2 = current2.updateQueue, workInProgress2.updateQueue = current2, scheduleRetryEffect(workInProgress2, current2), cutOffTailIfNeeded(_type, true), null === _type.tail && "hidden" === _type.tailMode && !returnFiber.alternate && !isHydrating)
	                return bubbleProperties(workInProgress2), null;
	            } else
	              2 * now$1() - _type.renderingStartTime > workInProgressRootRenderTargetTime && 536870912 !== renderLanes2 && (workInProgress2.flags |= 128, newProps = true, cutOffTailIfNeeded(_type, false), workInProgress2.lanes = 4194304);
	          _type.isBackwards ? (returnFiber.sibling = workInProgress2.child, workInProgress2.child = returnFiber) : (current2 = _type.last, null !== current2 ? current2.sibling = returnFiber : workInProgress2.child = returnFiber, _type.last = returnFiber);
	        }
	        if (null !== _type.tail)
	          return current2 = _type.tail, _type.rendering = current2, _type.tail = current2.sibling, _type.renderingStartTime = now$1(), current2.sibling = null, renderLanes2 = suspenseStackCursor.current, renderLanes2 = newProps ? renderLanes2 & SubtreeSuspenseContextMask | ForceSuspenseFallback : renderLanes2 & SubtreeSuspenseContextMask, push(suspenseStackCursor, renderLanes2, workInProgress2), current2;
	        bubbleProperties(workInProgress2);
	        return null;
	      case 22:
	      case 23:
	        return popSuspenseHandler(workInProgress2), popHiddenContext(workInProgress2), newProps = null !== workInProgress2.memoizedState, null !== current2 ? null !== current2.memoizedState !== newProps && (workInProgress2.flags |= 8192) : newProps && (workInProgress2.flags |= 8192), newProps ? 0 !== (renderLanes2 & 536870912) && 0 === (workInProgress2.flags & 128) && (bubbleProperties(workInProgress2), workInProgress2.subtreeFlags & 6 && (workInProgress2.flags |= 8192)) : bubbleProperties(workInProgress2), renderLanes2 = workInProgress2.updateQueue, null !== renderLanes2 && scheduleRetryEffect(workInProgress2, renderLanes2.retryQueue), renderLanes2 = null, null !== current2 && null !== current2.memoizedState && null !== current2.memoizedState.cachePool && (renderLanes2 = current2.memoizedState.cachePool.pool), newProps = null, null !== workInProgress2.memoizedState && null !== workInProgress2.memoizedState.cachePool && (newProps = workInProgress2.memoizedState.cachePool.pool), newProps !== renderLanes2 && (workInProgress2.flags |= 2048), null !== current2 && pop(resumedCache, workInProgress2), null;
	      case 24:
	        return renderLanes2 = null, null !== current2 && (renderLanes2 = current2.memoizedState.cache), workInProgress2.memoizedState.cache !== renderLanes2 && (workInProgress2.flags |= 2048), popProvider(CacheContext, workInProgress2), bubbleProperties(workInProgress2), null;
	      case 25:
	        return null;
	      case 30:
	        return null;
	    }
	    throw Error(
	      "Unknown unit of work tag (" + workInProgress2.tag + "). This error is likely caused by a bug in React. Please file an issue."
	    );
	  }
	  function unwindWork(current2, workInProgress2) {
	    popTreeContext(workInProgress2);
	    switch (workInProgress2.tag) {
	      case 1:
	        return current2 = workInProgress2.flags, current2 & 65536 ? (workInProgress2.flags = current2 & -65537 | 128, (workInProgress2.mode & ProfileMode) !== NoMode && transferActualDuration(workInProgress2), workInProgress2) : null;
	      case 3:
	        return popProvider(CacheContext, workInProgress2), popHostContainer(workInProgress2), current2 = workInProgress2.flags, 0 !== (current2 & 65536) && 0 === (current2 & 128) ? (workInProgress2.flags = current2 & -65537 | 128, workInProgress2) : null;
	      case 26:
	      case 27:
	      case 5:
	        return popHostContext(workInProgress2), null;
	      case 13:
	        popSuspenseHandler(workInProgress2);
	        current2 = workInProgress2.memoizedState;
	        if (null !== current2 && null !== current2.dehydrated) {
	          if (null === workInProgress2.alternate)
	            throw Error(
	              "Threw in newly mounted dehydrated component. This is likely a bug in React. Please file an issue."
	            );
	          resetHydrationState();
	        }
	        current2 = workInProgress2.flags;
	        return current2 & 65536 ? (workInProgress2.flags = current2 & -65537 | 128, (workInProgress2.mode & ProfileMode) !== NoMode && transferActualDuration(workInProgress2), workInProgress2) : null;
	      case 19:
	        return pop(suspenseStackCursor, workInProgress2), null;
	      case 4:
	        return popHostContainer(workInProgress2), null;
	      case 10:
	        return popProvider(workInProgress2.type, workInProgress2), null;
	      case 22:
	      case 23:
	        return popSuspenseHandler(workInProgress2), popHiddenContext(workInProgress2), null !== current2 && pop(resumedCache, workInProgress2), current2 = workInProgress2.flags, current2 & 65536 ? (workInProgress2.flags = current2 & -65537 | 128, (workInProgress2.mode & ProfileMode) !== NoMode && transferActualDuration(workInProgress2), workInProgress2) : null;
	      case 24:
	        return popProvider(CacheContext, workInProgress2), null;
	      case 25:
	        return null;
	      default:
	        return null;
	    }
	  }
	  function unwindInterruptedWork(current2, interruptedWork) {
	    popTreeContext(interruptedWork);
	    switch (interruptedWork.tag) {
	      case 3:
	        popProvider(CacheContext, interruptedWork);
	        popHostContainer(interruptedWork);
	        break;
	      case 26:
	      case 27:
	      case 5:
	        popHostContext(interruptedWork);
	        break;
	      case 4:
	        popHostContainer(interruptedWork);
	        break;
	      case 13:
	        popSuspenseHandler(interruptedWork);
	        break;
	      case 19:
	        pop(suspenseStackCursor, interruptedWork);
	        break;
	      case 10:
	        popProvider(interruptedWork.type, interruptedWork);
	        break;
	      case 22:
	      case 23:
	        popSuspenseHandler(interruptedWork);
	        popHiddenContext(interruptedWork);
	        null !== current2 && pop(resumedCache, interruptedWork);
	        break;
	      case 24:
	        popProvider(CacheContext, interruptedWork);
	    }
	  }
	  function shouldProfile(current2) {
	    return (current2.mode & ProfileMode) !== NoMode;
	  }
	  function commitHookLayoutEffects(finishedWork, hookFlags) {
	    shouldProfile(finishedWork) ? (startEffectTimer(), commitHookEffectListMount(hookFlags, finishedWork), recordEffectDuration()) : commitHookEffectListMount(hookFlags, finishedWork);
	  }
	  function commitHookLayoutUnmountEffects(finishedWork, nearestMountedAncestor, hookFlags) {
	    shouldProfile(finishedWork) ? (startEffectTimer(), commitHookEffectListUnmount(
	      hookFlags,
	      finishedWork,
	      nearestMountedAncestor
	    ), recordEffectDuration()) : commitHookEffectListUnmount(
	      hookFlags,
	      finishedWork,
	      nearestMountedAncestor
	    );
	  }
	  function commitHookEffectListMount(flags, finishedWork) {
	    try {
	      var updateQueue = finishedWork.updateQueue, lastEffect = null !== updateQueue ? updateQueue.lastEffect : null;
	      if (null !== lastEffect) {
	        var firstEffect = lastEffect.next;
	        updateQueue = firstEffect;
	        do {
	          if ((updateQueue.tag & flags) === flags && ((flags & Passive) !== NoFlags ? null !== injectedProfilingHooks && "function" === typeof injectedProfilingHooks.markComponentPassiveEffectMountStarted && injectedProfilingHooks.markComponentPassiveEffectMountStarted(
	            finishedWork
	          ) : (flags & Layout) !== NoFlags && null !== injectedProfilingHooks && "function" === typeof injectedProfilingHooks.markComponentLayoutEffectMountStarted && injectedProfilingHooks.markComponentLayoutEffectMountStarted(
	            finishedWork
	          ), lastEffect = void 0, (flags & Insertion) !== NoFlags && (isRunningInsertionEffect = true), lastEffect = runWithFiberInDEV(
	            finishedWork,
	            callCreateInDEV,
	            updateQueue
	          ), (flags & Insertion) !== NoFlags && (isRunningInsertionEffect = false), (flags & Passive) !== NoFlags ? null !== injectedProfilingHooks && "function" === typeof injectedProfilingHooks.markComponentPassiveEffectMountStopped && injectedProfilingHooks.markComponentPassiveEffectMountStopped() : (flags & Layout) !== NoFlags && null !== injectedProfilingHooks && "function" === typeof injectedProfilingHooks.markComponentLayoutEffectMountStopped && injectedProfilingHooks.markComponentLayoutEffectMountStopped(), void 0 !== lastEffect && "function" !== typeof lastEffect)) {
	            var hookName = void 0;
	            hookName = 0 !== (updateQueue.tag & Layout) ? "useLayoutEffect" : 0 !== (updateQueue.tag & Insertion) ? "useInsertionEffect" : "useEffect";
	            var addendum = void 0;
	            addendum = null === lastEffect ? " You returned null. If your effect does not require clean up, return undefined (or nothing)." : "function" === typeof lastEffect.then ? "\n\nIt looks like you wrote " + hookName + "(async () => ...) or returned a Promise. Instead, write the async function inside your effect and call it immediately:\n\n" + hookName + "(() => {\n  async function fetchData() {\n    // You can await here\n    const response = await MyAPI.getData(someId);\n    // ...\n  }\n  fetchData();\n}, [someId]); // Or [] if effect doesn't need props or state\n\nLearn more about data fetching with Hooks: https://react.dev/link/hooks-data-fetching" : " You returned: " + lastEffect;
	            runWithFiberInDEV(
	              finishedWork,
	              function(n, a) {
	                console.error(
	                  "%s must not return anything besides a function, which is used for clean-up.%s",
	                  n,
	                  a
	                );
	              },
	              hookName,
	              addendum
	            );
	          }
	          updateQueue = updateQueue.next;
	        } while (updateQueue !== firstEffect);
	      }
	    } catch (error) {
	      captureCommitPhaseError(finishedWork, finishedWork.return, error);
	    }
	  }
	  function commitHookEffectListUnmount(flags, finishedWork, nearestMountedAncestor) {
	    try {
	      var updateQueue = finishedWork.updateQueue, lastEffect = null !== updateQueue ? updateQueue.lastEffect : null;
	      if (null !== lastEffect) {
	        var firstEffect = lastEffect.next;
	        updateQueue = firstEffect;
	        do {
	          if ((updateQueue.tag & flags) === flags) {
	            var inst = updateQueue.inst, destroy = inst.destroy;
	            void 0 !== destroy && (inst.destroy = void 0, (flags & Passive) !== NoFlags ? null !== injectedProfilingHooks && "function" === typeof injectedProfilingHooks.markComponentPassiveEffectUnmountStarted && injectedProfilingHooks.markComponentPassiveEffectUnmountStarted(
	              finishedWork
	            ) : (flags & Layout) !== NoFlags && null !== injectedProfilingHooks && "function" === typeof injectedProfilingHooks.markComponentLayoutEffectUnmountStarted && injectedProfilingHooks.markComponentLayoutEffectUnmountStarted(
	              finishedWork
	            ), (flags & Insertion) !== NoFlags && (isRunningInsertionEffect = true), lastEffect = finishedWork, runWithFiberInDEV(
	              lastEffect,
	              callDestroyInDEV,
	              lastEffect,
	              nearestMountedAncestor,
	              destroy
	            ), (flags & Insertion) !== NoFlags && (isRunningInsertionEffect = false), (flags & Passive) !== NoFlags ? null !== injectedProfilingHooks && "function" === typeof injectedProfilingHooks.markComponentPassiveEffectUnmountStopped && injectedProfilingHooks.markComponentPassiveEffectUnmountStopped() : (flags & Layout) !== NoFlags && null !== injectedProfilingHooks && "function" === typeof injectedProfilingHooks.markComponentLayoutEffectUnmountStopped && injectedProfilingHooks.markComponentLayoutEffectUnmountStopped());
	          }
	          updateQueue = updateQueue.next;
	        } while (updateQueue !== firstEffect);
	      }
	    } catch (error) {
	      captureCommitPhaseError(finishedWork, finishedWork.return, error);
	    }
	  }
	  function commitHookPassiveMountEffects(finishedWork, hookFlags) {
	    shouldProfile(finishedWork) ? (startEffectTimer(), commitHookEffectListMount(hookFlags, finishedWork), recordEffectDuration()) : commitHookEffectListMount(hookFlags, finishedWork);
	  }
	  function commitHookPassiveUnmountEffects(finishedWork, nearestMountedAncestor, hookFlags) {
	    shouldProfile(finishedWork) ? (startEffectTimer(), commitHookEffectListUnmount(
	      hookFlags,
	      finishedWork,
	      nearestMountedAncestor
	    ), recordEffectDuration()) : commitHookEffectListUnmount(
	      hookFlags,
	      finishedWork,
	      nearestMountedAncestor
	    );
	  }
	  function commitClassCallbacks(finishedWork) {
	    var updateQueue = finishedWork.updateQueue;
	    if (null !== updateQueue) {
	      var instance = finishedWork.stateNode;
	      finishedWork.type.defaultProps || "ref" in finishedWork.memoizedProps || didWarnAboutReassigningProps || (instance.props !== finishedWork.memoizedProps && console.error(
	        "Expected %s props to match memoized props before processing the update queue. This might either be because of a bug in React, or because a component reassigns its own `this.props`. Please file an issue.",
	        getComponentNameFromFiber(finishedWork) || "instance"
	      ), instance.state !== finishedWork.memoizedState && console.error(
	        "Expected %s state to match memoized state before processing the update queue. This might either be because of a bug in React, or because a component reassigns its own `this.state`. Please file an issue.",
	        getComponentNameFromFiber(finishedWork) || "instance"
	      ));
	      try {
	        runWithFiberInDEV(
	          finishedWork,
	          commitCallbacks,
	          updateQueue,
	          instance
	        );
	      } catch (error) {
	        captureCommitPhaseError(finishedWork, finishedWork.return, error);
	      }
	    }
	  }
	  function callGetSnapshotBeforeUpdates(instance, prevProps, prevState) {
	    return instance.getSnapshotBeforeUpdate(prevProps, prevState);
	  }
	  function commitClassSnapshot(finishedWork, current2) {
	    var prevProps = current2.memoizedProps, prevState = current2.memoizedState;
	    current2 = finishedWork.stateNode;
	    finishedWork.type.defaultProps || "ref" in finishedWork.memoizedProps || didWarnAboutReassigningProps || (current2.props !== finishedWork.memoizedProps && console.error(
	      "Expected %s props to match memoized props before getSnapshotBeforeUpdate. This might either be because of a bug in React, or because a component reassigns its own `this.props`. Please file an issue.",
	      getComponentNameFromFiber(finishedWork) || "instance"
	    ), current2.state !== finishedWork.memoizedState && console.error(
	      "Expected %s state to match memoized state before getSnapshotBeforeUpdate. This might either be because of a bug in React, or because a component reassigns its own `this.state`. Please file an issue.",
	      getComponentNameFromFiber(finishedWork) || "instance"
	    ));
	    try {
	      var resolvedPrevProps = resolveClassComponentProps(
	        finishedWork.type,
	        prevProps,
	        finishedWork.elementType === finishedWork.type
	      );
	      var snapshot = runWithFiberInDEV(
	        finishedWork,
	        callGetSnapshotBeforeUpdates,
	        current2,
	        resolvedPrevProps,
	        prevState
	      );
	      prevProps = didWarnAboutUndefinedSnapshotBeforeUpdate;
	      void 0 !== snapshot || prevProps.has(finishedWork.type) || (prevProps.add(finishedWork.type), runWithFiberInDEV(finishedWork, function() {
	        console.error(
	          "%s.getSnapshotBeforeUpdate(): A snapshot value (or null) must be returned. You have returned undefined.",
	          getComponentNameFromFiber(finishedWork)
	        );
	      }));
	      current2.__reactInternalSnapshotBeforeUpdate = snapshot;
	    } catch (error) {
	      captureCommitPhaseError(finishedWork, finishedWork.return, error);
	    }
	  }
	  function safelyCallComponentWillUnmount(current2, nearestMountedAncestor, instance) {
	    instance.props = resolveClassComponentProps(
	      current2.type,
	      current2.memoizedProps
	    );
	    instance.state = current2.memoizedState;
	    shouldProfile(current2) ? (startEffectTimer(), runWithFiberInDEV(
	      current2,
	      callComponentWillUnmountInDEV,
	      current2,
	      nearestMountedAncestor,
	      instance
	    ), recordEffectDuration()) : runWithFiberInDEV(
	      current2,
	      callComponentWillUnmountInDEV,
	      current2,
	      nearestMountedAncestor,
	      instance
	    );
	  }
	  function commitAttachRef(finishedWork) {
	    var ref = finishedWork.ref;
	    if (null !== ref) {
	      switch (finishedWork.tag) {
	        case 26:
	        case 27:
	        case 5:
	          var instanceToUse = finishedWork.stateNode;
	          break;
	        case 30:
	          instanceToUse = finishedWork.stateNode;
	          break;
	        default:
	          instanceToUse = finishedWork.stateNode;
	      }
	      if ("function" === typeof ref)
	        if (shouldProfile(finishedWork))
	          try {
	            startEffectTimer(), finishedWork.refCleanup = ref(instanceToUse);
	          } finally {
	            recordEffectDuration();
	          }
	        else finishedWork.refCleanup = ref(instanceToUse);
	      else
	        "string" === typeof ref ? console.error("String refs are no longer supported.") : ref.hasOwnProperty("current") || console.error(
	          "Unexpected ref object provided for %s. Use either a ref-setter function or React.createRef().",
	          getComponentNameFromFiber(finishedWork)
	        ), ref.current = instanceToUse;
	    }
	  }
	  function safelyAttachRef(current2, nearestMountedAncestor) {
	    try {
	      runWithFiberInDEV(current2, commitAttachRef, current2);
	    } catch (error) {
	      captureCommitPhaseError(current2, nearestMountedAncestor, error);
	    }
	  }
	  function safelyDetachRef(current2, nearestMountedAncestor) {
	    var ref = current2.ref, refCleanup = current2.refCleanup;
	    if (null !== ref)
	      if ("function" === typeof refCleanup)
	        try {
	          if (shouldProfile(current2))
	            try {
	              startEffectTimer(), runWithFiberInDEV(current2, refCleanup);
	            } finally {
	              recordEffectDuration(current2);
	            }
	          else runWithFiberInDEV(current2, refCleanup);
	        } catch (error) {
	          captureCommitPhaseError(current2, nearestMountedAncestor, error);
	        } finally {
	          current2.refCleanup = null, current2 = current2.alternate, null != current2 && (current2.refCleanup = null);
	        }
	      else if ("function" === typeof ref)
	        try {
	          if (shouldProfile(current2))
	            try {
	              startEffectTimer(), runWithFiberInDEV(current2, ref, null);
	            } finally {
	              recordEffectDuration(current2);
	            }
	          else runWithFiberInDEV(current2, ref, null);
	        } catch (error$7) {
	          captureCommitPhaseError(current2, nearestMountedAncestor, error$7);
	        }
	      else ref.current = null;
	  }
	  function commitProfiler(finishedWork, current2, commitStartTime2, effectDuration) {
	    var _finishedWork$memoize = finishedWork.memoizedProps, id = _finishedWork$memoize.id, onCommit = _finishedWork$memoize.onCommit;
	    _finishedWork$memoize = _finishedWork$memoize.onRender;
	    current2 = null === current2 ? "mount" : "update";
	    currentUpdateIsNested && (current2 = "nested-update");
	    "function" === typeof _finishedWork$memoize && _finishedWork$memoize(
	      id,
	      current2,
	      finishedWork.actualDuration,
	      finishedWork.treeBaseDuration,
	      finishedWork.actualStartTime,
	      commitStartTime2
	    );
	    "function" === typeof onCommit && onCommit(
	      finishedWork.memoizedProps.id,
	      current2,
	      effectDuration,
	      commitStartTime2
	    );
	  }
	  function commitProfilerPostCommitImpl(finishedWork, current2, commitStartTime2, passiveEffectDuration) {
	    var _finishedWork$memoize2 = finishedWork.memoizedProps;
	    finishedWork = _finishedWork$memoize2.id;
	    _finishedWork$memoize2 = _finishedWork$memoize2.onPostCommit;
	    current2 = null === current2 ? "mount" : "update";
	    currentUpdateIsNested && (current2 = "nested-update");
	    "function" === typeof _finishedWork$memoize2 && _finishedWork$memoize2(
	      finishedWork,
	      current2,
	      passiveEffectDuration,
	      commitStartTime2
	    );
	  }
	  function commitHostMount(finishedWork) {
	    var type = finishedWork.type, props = finishedWork.memoizedProps, instance = finishedWork.stateNode;
	    try {
	      runWithFiberInDEV(
	        finishedWork,
	        commitMount,
	        instance,
	        type,
	        props,
	        finishedWork
	      );
	    } catch (error) {
	      captureCommitPhaseError(finishedWork, finishedWork.return, error);
	    }
	  }
	  function commitHostUpdate(finishedWork, newProps, oldProps) {
	    try {
	      runWithFiberInDEV(
	        finishedWork,
	        commitUpdate,
	        finishedWork.stateNode,
	        finishedWork.type,
	        oldProps,
	        newProps,
	        finishedWork
	      );
	    } catch (error) {
	      captureCommitPhaseError(finishedWork, finishedWork.return, error);
	    }
	  }
	  function isHostParent(fiber) {
	    return 5 === fiber.tag || 3 === fiber.tag || 26 === fiber.tag || 27 === fiber.tag && isSingletonScope(fiber.type) || 4 === fiber.tag;
	  }
	  function getHostSibling(fiber) {
	    a: for (; ; ) {
	      for (; null === fiber.sibling; ) {
	        if (null === fiber.return || isHostParent(fiber.return)) return null;
	        fiber = fiber.return;
	      }
	      fiber.sibling.return = fiber.return;
	      for (fiber = fiber.sibling; 5 !== fiber.tag && 6 !== fiber.tag && 18 !== fiber.tag; ) {
	        if (27 === fiber.tag && isSingletonScope(fiber.type)) continue a;
	        if (fiber.flags & 2) continue a;
	        if (null === fiber.child || 4 === fiber.tag) continue a;
	        else fiber.child.return = fiber, fiber = fiber.child;
	      }
	      if (!(fiber.flags & 2)) return fiber.stateNode;
	    }
	  }
	  function insertOrAppendPlacementNodeIntoContainer(node, before, parent) {
	    var tag = node.tag;
	    if (5 === tag || 6 === tag)
	      node = node.stateNode, before ? (9 === parent.nodeType ? parent.body : "HTML" === parent.nodeName ? parent.ownerDocument.body : parent).insertBefore(node, before) : (before = 9 === parent.nodeType ? parent.body : "HTML" === parent.nodeName ? parent.ownerDocument.body : parent, before.appendChild(node), parent = parent._reactRootContainer, null !== parent && void 0 !== parent || null !== before.onclick || (before.onclick = noop$1));
	    else if (4 !== tag && (27 === tag && isSingletonScope(node.type) && (parent = node.stateNode, before = null), node = node.child, null !== node))
	      for (insertOrAppendPlacementNodeIntoContainer(node, before, parent), node = node.sibling; null !== node; )
	        insertOrAppendPlacementNodeIntoContainer(node, before, parent), node = node.sibling;
	  }
	  function insertOrAppendPlacementNode(node, before, parent) {
	    var tag = node.tag;
	    if (5 === tag || 6 === tag)
	      node = node.stateNode, before ? parent.insertBefore(node, before) : parent.appendChild(node);
	    else if (4 !== tag && (27 === tag && isSingletonScope(node.type) && (parent = node.stateNode), node = node.child, null !== node))
	      for (insertOrAppendPlacementNode(node, before, parent), node = node.sibling; null !== node; )
	        insertOrAppendPlacementNode(node, before, parent), node = node.sibling;
	  }
	  function commitPlacement(finishedWork) {
	    for (var hostParentFiber, parentFiber = finishedWork.return; null !== parentFiber; ) {
	      if (isHostParent(parentFiber)) {
	        hostParentFiber = parentFiber;
	        break;
	      }
	      parentFiber = parentFiber.return;
	    }
	    if (null == hostParentFiber)
	      throw Error(
	        "Expected to find a host parent. This error is likely caused by a bug in React. Please file an issue."
	      );
	    switch (hostParentFiber.tag) {
	      case 27:
	        hostParentFiber = hostParentFiber.stateNode;
	        parentFiber = getHostSibling(finishedWork);
	        insertOrAppendPlacementNode(
	          finishedWork,
	          parentFiber,
	          hostParentFiber
	        );
	        break;
	      case 5:
	        parentFiber = hostParentFiber.stateNode;
	        hostParentFiber.flags & 32 && (resetTextContent(parentFiber), hostParentFiber.flags &= -33);
	        hostParentFiber = getHostSibling(finishedWork);
	        insertOrAppendPlacementNode(
	          finishedWork,
	          hostParentFiber,
	          parentFiber
	        );
	        break;
	      case 3:
	      case 4:
	        hostParentFiber = hostParentFiber.stateNode.containerInfo;
	        parentFiber = getHostSibling(finishedWork);
	        insertOrAppendPlacementNodeIntoContainer(
	          finishedWork,
	          parentFiber,
	          hostParentFiber
	        );
	        break;
	      default:
	        throw Error(
	          "Invalid host parent fiber. This error is likely caused by a bug in React. Please file an issue."
	        );
	    }
	  }
	  function commitHostSingletonAcquisition(finishedWork) {
	    var singleton = finishedWork.stateNode, props = finishedWork.memoizedProps;
	    try {
	      runWithFiberInDEV(
	        finishedWork,
	        acquireSingletonInstance,
	        finishedWork.type,
	        props,
	        singleton,
	        finishedWork
	      );
	    } catch (error) {
	      captureCommitPhaseError(finishedWork, finishedWork.return, error);
	    }
	  }
	  function commitBeforeMutationEffects(root2, firstChild) {
	    root2 = root2.containerInfo;
	    eventsEnabled = _enabled;
	    root2 = getActiveElementDeep(root2);
	    if (hasSelectionCapabilities(root2)) {
	      if ("selectionStart" in root2)
	        var JSCompiler_temp = {
	          start: root2.selectionStart,
	          end: root2.selectionEnd
	        };
	      else
	        a: {
	          JSCompiler_temp = (JSCompiler_temp = root2.ownerDocument) && JSCompiler_temp.defaultView || window;
	          var selection = JSCompiler_temp.getSelection && JSCompiler_temp.getSelection();
	          if (selection && 0 !== selection.rangeCount) {
	            JSCompiler_temp = selection.anchorNode;
	            var anchorOffset = selection.anchorOffset, focusNode = selection.focusNode;
	            selection = selection.focusOffset;
	            try {
	              JSCompiler_temp.nodeType, focusNode.nodeType;
	            } catch (e$2) {
	              JSCompiler_temp = null;
	              break a;
	            }
	            var length = 0, start = -1, end = -1, indexWithinAnchor = 0, indexWithinFocus = 0, node = root2, parentNode = null;
	            b: for (; ; ) {
	              for (var next; ; ) {
	                node !== JSCompiler_temp || 0 !== anchorOffset && 3 !== node.nodeType || (start = length + anchorOffset);
	                node !== focusNode || 0 !== selection && 3 !== node.nodeType || (end = length + selection);
	                3 === node.nodeType && (length += node.nodeValue.length);
	                if (null === (next = node.firstChild)) break;
	                parentNode = node;
	                node = next;
	              }
	              for (; ; ) {
	                if (node === root2) break b;
	                parentNode === JSCompiler_temp && ++indexWithinAnchor === anchorOffset && (start = length);
	                parentNode === focusNode && ++indexWithinFocus === selection && (end = length);
	                if (null !== (next = node.nextSibling)) break;
	                node = parentNode;
	                parentNode = node.parentNode;
	              }
	              node = next;
	            }
	            JSCompiler_temp = -1 === start || -1 === end ? null : { start, end };
	          } else JSCompiler_temp = null;
	        }
	      JSCompiler_temp = JSCompiler_temp || { start: 0, end: 0 };
	    } else JSCompiler_temp = null;
	    selectionInformation = {
	      focusedElem: root2,
	      selectionRange: JSCompiler_temp
	    };
	    _enabled = false;
	    for (nextEffect = firstChild; null !== nextEffect; )
	      if (firstChild = nextEffect, root2 = firstChild.child, 0 !== (firstChild.subtreeFlags & 1024) && null !== root2)
	        root2.return = firstChild, nextEffect = root2;
	      else
	        for (; null !== nextEffect; ) {
	          root2 = firstChild = nextEffect;
	          JSCompiler_temp = root2.alternate;
	          anchorOffset = root2.flags;
	          switch (root2.tag) {
	            case 0:
	              break;
	            case 11:
	            case 15:
	              break;
	            case 1:
	              0 !== (anchorOffset & 1024) && null !== JSCompiler_temp && commitClassSnapshot(root2, JSCompiler_temp);
	              break;
	            case 3:
	              if (0 !== (anchorOffset & 1024)) {
	                if (root2 = root2.stateNode.containerInfo, JSCompiler_temp = root2.nodeType, 9 === JSCompiler_temp)
	                  clearContainerSparingly(root2);
	                else if (1 === JSCompiler_temp)
	                  switch (root2.nodeName) {
	                    case "HEAD":
	                    case "HTML":
	                    case "BODY":
	                      clearContainerSparingly(root2);
	                      break;
	                    default:
	                      root2.textContent = "";
	                  }
	              }
	              break;
	            case 5:
	            case 26:
	            case 27:
	            case 6:
	            case 4:
	            case 17:
	              break;
	            default:
	              if (0 !== (anchorOffset & 1024))
	                throw Error(
	                  "This unit of work tag should not have side-effects. This error is likely caused by a bug in React. Please file an issue."
	                );
	          }
	          root2 = firstChild.sibling;
	          if (null !== root2) {
	            root2.return = firstChild.return;
	            nextEffect = root2;
	            break;
	          }
	          nextEffect = firstChild.return;
	        }
	  }
	  function commitLayoutEffectOnFiber(finishedRoot, current2, finishedWork) {
	    var flags = finishedWork.flags;
	    switch (finishedWork.tag) {
	      case 0:
	      case 11:
	      case 15:
	        recursivelyTraverseLayoutEffects(finishedRoot, finishedWork);
	        flags & 4 && commitHookLayoutEffects(finishedWork, Layout | HasEffect);
	        break;
	      case 1:
	        recursivelyTraverseLayoutEffects(finishedRoot, finishedWork);
	        if (flags & 4)
	          if (finishedRoot = finishedWork.stateNode, null === current2)
	            finishedWork.type.defaultProps || "ref" in finishedWork.memoizedProps || didWarnAboutReassigningProps || (finishedRoot.props !== finishedWork.memoizedProps && console.error(
	              "Expected %s props to match memoized props before componentDidMount. This might either be because of a bug in React, or because a component reassigns its own `this.props`. Please file an issue.",
	              getComponentNameFromFiber(finishedWork) || "instance"
	            ), finishedRoot.state !== finishedWork.memoizedState && console.error(
	              "Expected %s state to match memoized state before componentDidMount. This might either be because of a bug in React, or because a component reassigns its own `this.state`. Please file an issue.",
	              getComponentNameFromFiber(finishedWork) || "instance"
	            )), shouldProfile(finishedWork) ? (startEffectTimer(), runWithFiberInDEV(
	              finishedWork,
	              callComponentDidMountInDEV,
	              finishedWork,
	              finishedRoot
	            ), recordEffectDuration()) : runWithFiberInDEV(
	              finishedWork,
	              callComponentDidMountInDEV,
	              finishedWork,
	              finishedRoot
	            );
	          else {
	            var prevProps = resolveClassComponentProps(
	              finishedWork.type,
	              current2.memoizedProps
	            );
	            current2 = current2.memoizedState;
	            finishedWork.type.defaultProps || "ref" in finishedWork.memoizedProps || didWarnAboutReassigningProps || (finishedRoot.props !== finishedWork.memoizedProps && console.error(
	              "Expected %s props to match memoized props before componentDidUpdate. This might either be because of a bug in React, or because a component reassigns its own `this.props`. Please file an issue.",
	              getComponentNameFromFiber(finishedWork) || "instance"
	            ), finishedRoot.state !== finishedWork.memoizedState && console.error(
	              "Expected %s state to match memoized state before componentDidUpdate. This might either be because of a bug in React, or because a component reassigns its own `this.state`. Please file an issue.",
	              getComponentNameFromFiber(finishedWork) || "instance"
	            ));
	            shouldProfile(finishedWork) ? (startEffectTimer(), runWithFiberInDEV(
	              finishedWork,
	              callComponentDidUpdateInDEV,
	              finishedWork,
	              finishedRoot,
	              prevProps,
	              current2,
	              finishedRoot.__reactInternalSnapshotBeforeUpdate
	            ), recordEffectDuration()) : runWithFiberInDEV(
	              finishedWork,
	              callComponentDidUpdateInDEV,
	              finishedWork,
	              finishedRoot,
	              prevProps,
	              current2,
	              finishedRoot.__reactInternalSnapshotBeforeUpdate
	            );
	          }
	        flags & 64 && commitClassCallbacks(finishedWork);
	        flags & 512 && safelyAttachRef(finishedWork, finishedWork.return);
	        break;
	      case 3:
	        current2 = pushNestedEffectDurations();
	        recursivelyTraverseLayoutEffects(finishedRoot, finishedWork);
	        if (flags & 64 && (flags = finishedWork.updateQueue, null !== flags)) {
	          prevProps = null;
	          if (null !== finishedWork.child)
	            switch (finishedWork.child.tag) {
	              case 27:
	              case 5:
	                prevProps = finishedWork.child.stateNode;
	                break;
	              case 1:
	                prevProps = finishedWork.child.stateNode;
	            }
	          try {
	            runWithFiberInDEV(
	              finishedWork,
	              commitCallbacks,
	              flags,
	              prevProps
	            );
	          } catch (error) {
	            captureCommitPhaseError(finishedWork, finishedWork.return, error);
	          }
	        }
	        finishedRoot.effectDuration += popNestedEffectDurations(current2);
	        break;
	      case 27:
	        null === current2 && flags & 4 && commitHostSingletonAcquisition(finishedWork);
	      case 26:
	      case 5:
	        recursivelyTraverseLayoutEffects(finishedRoot, finishedWork);
	        null === current2 && flags & 4 && commitHostMount(finishedWork);
	        flags & 512 && safelyAttachRef(finishedWork, finishedWork.return);
	        break;
	      case 12:
	        if (flags & 4) {
	          flags = pushNestedEffectDurations();
	          recursivelyTraverseLayoutEffects(finishedRoot, finishedWork);
	          finishedRoot = finishedWork.stateNode;
	          finishedRoot.effectDuration += bubbleNestedEffectDurations(flags);
	          try {
	            runWithFiberInDEV(
	              finishedWork,
	              commitProfiler,
	              finishedWork,
	              current2,
	              commitStartTime,
	              finishedRoot.effectDuration
	            );
	          } catch (error) {
	            captureCommitPhaseError(finishedWork, finishedWork.return, error);
	          }
	        } else recursivelyTraverseLayoutEffects(finishedRoot, finishedWork);
	        break;
	      case 13:
	        recursivelyTraverseLayoutEffects(finishedRoot, finishedWork);
	        flags & 4 && commitSuspenseHydrationCallbacks(finishedRoot, finishedWork);
	        flags & 64 && (finishedRoot = finishedWork.memoizedState, null !== finishedRoot && (finishedRoot = finishedRoot.dehydrated, null !== finishedRoot && (finishedWork = retryDehydratedSuspenseBoundary.bind(
	          null,
	          finishedWork
	        ), registerSuspenseInstanceRetry(finishedRoot, finishedWork))));
	        break;
	      case 22:
	        flags = null !== finishedWork.memoizedState || offscreenSubtreeIsHidden;
	        if (!flags) {
	          current2 = null !== current2 && null !== current2.memoizedState || offscreenSubtreeWasHidden;
	          prevProps = offscreenSubtreeIsHidden;
	          var prevOffscreenSubtreeWasHidden = offscreenSubtreeWasHidden;
	          offscreenSubtreeIsHidden = flags;
	          (offscreenSubtreeWasHidden = current2) && !prevOffscreenSubtreeWasHidden ? recursivelyTraverseReappearLayoutEffects(
	            finishedRoot,
	            finishedWork,
	            0 !== (finishedWork.subtreeFlags & 8772)
	          ) : recursivelyTraverseLayoutEffects(finishedRoot, finishedWork);
	          offscreenSubtreeIsHidden = prevProps;
	          offscreenSubtreeWasHidden = prevOffscreenSubtreeWasHidden;
	        }
	        break;
	      case 30:
	        break;
	      default:
	        recursivelyTraverseLayoutEffects(finishedRoot, finishedWork);
	    }
	  }
	  function detachFiberAfterEffects(fiber) {
	    var alternate = fiber.alternate;
	    null !== alternate && (fiber.alternate = null, detachFiberAfterEffects(alternate));
	    fiber.child = null;
	    fiber.deletions = null;
	    fiber.sibling = null;
	    5 === fiber.tag && (alternate = fiber.stateNode, null !== alternate && detachDeletedInstance(alternate));
	    fiber.stateNode = null;
	    fiber._debugOwner = null;
	    fiber.return = null;
	    fiber.dependencies = null;
	    fiber.memoizedProps = null;
	    fiber.memoizedState = null;
	    fiber.pendingProps = null;
	    fiber.stateNode = null;
	    fiber.updateQueue = null;
	  }
	  function recursivelyTraverseDeletionEffects(finishedRoot, nearestMountedAncestor, parent) {
	    for (parent = parent.child; null !== parent; )
	      commitDeletionEffectsOnFiber(
	        finishedRoot,
	        nearestMountedAncestor,
	        parent
	      ), parent = parent.sibling;
	  }
	  function commitDeletionEffectsOnFiber(finishedRoot, nearestMountedAncestor, deletedFiber) {
	    if (injectedHook && "function" === typeof injectedHook.onCommitFiberUnmount)
	      try {
	        injectedHook.onCommitFiberUnmount(rendererID, deletedFiber);
	      } catch (err) {
	        hasLoggedError || (hasLoggedError = true, console.error(
	          "React instrumentation encountered an error: %s",
	          err
	        ));
	      }
	    switch (deletedFiber.tag) {
	      case 26:
	        offscreenSubtreeWasHidden || safelyDetachRef(deletedFiber, nearestMountedAncestor);
	        recursivelyTraverseDeletionEffects(
	          finishedRoot,
	          nearestMountedAncestor,
	          deletedFiber
	        );
	        deletedFiber.memoizedState ? deletedFiber.memoizedState.count-- : deletedFiber.stateNode && (deletedFiber = deletedFiber.stateNode, deletedFiber.parentNode.removeChild(deletedFiber));
	        break;
	      case 27:
	        offscreenSubtreeWasHidden || safelyDetachRef(deletedFiber, nearestMountedAncestor);
	        var prevHostParent = hostParent, prevHostParentIsContainer = hostParentIsContainer;
	        isSingletonScope(deletedFiber.type) && (hostParent = deletedFiber.stateNode, hostParentIsContainer = false);
	        recursivelyTraverseDeletionEffects(
	          finishedRoot,
	          nearestMountedAncestor,
	          deletedFiber
	        );
	        runWithFiberInDEV(
	          deletedFiber,
	          releaseSingletonInstance,
	          deletedFiber.stateNode
	        );
	        hostParent = prevHostParent;
	        hostParentIsContainer = prevHostParentIsContainer;
	        break;
	      case 5:
	        offscreenSubtreeWasHidden || safelyDetachRef(deletedFiber, nearestMountedAncestor);
	      case 6:
	        prevHostParent = hostParent;
	        prevHostParentIsContainer = hostParentIsContainer;
	        hostParent = null;
	        recursivelyTraverseDeletionEffects(
	          finishedRoot,
	          nearestMountedAncestor,
	          deletedFiber
	        );
	        hostParent = prevHostParent;
	        hostParentIsContainer = prevHostParentIsContainer;
	        if (null !== hostParent)
	          if (hostParentIsContainer)
	            try {
	              runWithFiberInDEV(
	                deletedFiber,
	                removeChildFromContainer,
	                hostParent,
	                deletedFiber.stateNode
	              );
	            } catch (error) {
	              captureCommitPhaseError(
	                deletedFiber,
	                nearestMountedAncestor,
	                error
	              );
	            }
	          else
	            try {
	              runWithFiberInDEV(
	                deletedFiber,
	                removeChild,
	                hostParent,
	                deletedFiber.stateNode
	              );
	            } catch (error) {
	              captureCommitPhaseError(
	                deletedFiber,
	                nearestMountedAncestor,
	                error
	              );
	            }
	        break;
	      case 18:
	        null !== hostParent && (hostParentIsContainer ? (finishedRoot = hostParent, clearSuspenseBoundary(
	          9 === finishedRoot.nodeType ? finishedRoot.body : "HTML" === finishedRoot.nodeName ? finishedRoot.ownerDocument.body : finishedRoot,
	          deletedFiber.stateNode
	        ), retryIfBlockedOn(finishedRoot)) : clearSuspenseBoundary(hostParent, deletedFiber.stateNode));
	        break;
	      case 4:
	        prevHostParent = hostParent;
	        prevHostParentIsContainer = hostParentIsContainer;
	        hostParent = deletedFiber.stateNode.containerInfo;
	        hostParentIsContainer = true;
	        recursivelyTraverseDeletionEffects(
	          finishedRoot,
	          nearestMountedAncestor,
	          deletedFiber
	        );
	        hostParent = prevHostParent;
	        hostParentIsContainer = prevHostParentIsContainer;
	        break;
	      case 0:
	      case 11:
	      case 14:
	      case 15:
	        offscreenSubtreeWasHidden || commitHookEffectListUnmount(
	          Insertion,
	          deletedFiber,
	          nearestMountedAncestor
	        );
	        offscreenSubtreeWasHidden || commitHookLayoutUnmountEffects(
	          deletedFiber,
	          nearestMountedAncestor,
	          Layout
	        );
	        recursivelyTraverseDeletionEffects(
	          finishedRoot,
	          nearestMountedAncestor,
	          deletedFiber
	        );
	        break;
	      case 1:
	        offscreenSubtreeWasHidden || (safelyDetachRef(deletedFiber, nearestMountedAncestor), prevHostParent = deletedFiber.stateNode, "function" === typeof prevHostParent.componentWillUnmount && safelyCallComponentWillUnmount(
	          deletedFiber,
	          nearestMountedAncestor,
	          prevHostParent
	        ));
	        recursivelyTraverseDeletionEffects(
	          finishedRoot,
	          nearestMountedAncestor,
	          deletedFiber
	        );
	        break;
	      case 21:
	        recursivelyTraverseDeletionEffects(
	          finishedRoot,
	          nearestMountedAncestor,
	          deletedFiber
	        );
	        break;
	      case 22:
	        offscreenSubtreeWasHidden = (prevHostParent = offscreenSubtreeWasHidden) || null !== deletedFiber.memoizedState;
	        recursivelyTraverseDeletionEffects(
	          finishedRoot,
	          nearestMountedAncestor,
	          deletedFiber
	        );
	        offscreenSubtreeWasHidden = prevHostParent;
	        break;
	      default:
	        recursivelyTraverseDeletionEffects(
	          finishedRoot,
	          nearestMountedAncestor,
	          deletedFiber
	        );
	    }
	  }
	  function commitSuspenseHydrationCallbacks(finishedRoot, finishedWork) {
	    if (null === finishedWork.memoizedState && (finishedRoot = finishedWork.alternate, null !== finishedRoot && (finishedRoot = finishedRoot.memoizedState, null !== finishedRoot && (finishedRoot = finishedRoot.dehydrated, null !== finishedRoot))))
	      try {
	        runWithFiberInDEV(
	          finishedWork,
	          commitHydratedSuspenseInstance,
	          finishedRoot
	        );
	      } catch (error) {
	        captureCommitPhaseError(finishedWork, finishedWork.return, error);
	      }
	  }
	  function getRetryCache(finishedWork) {
	    switch (finishedWork.tag) {
	      case 13:
	      case 19:
	        var retryCache = finishedWork.stateNode;
	        null === retryCache && (retryCache = finishedWork.stateNode = new PossiblyWeakSet());
	        return retryCache;
	      case 22:
	        return finishedWork = finishedWork.stateNode, retryCache = finishedWork._retryCache, null === retryCache && (retryCache = finishedWork._retryCache = new PossiblyWeakSet()), retryCache;
	      default:
	        throw Error(
	          "Unexpected Suspense handler tag (" + finishedWork.tag + "). This is a bug in React."
	        );
	    }
	  }
	  function attachSuspenseRetryListeners(finishedWork, wakeables) {
	    var retryCache = getRetryCache(finishedWork);
	    wakeables.forEach(function(wakeable) {
	      var retry = resolveRetryWakeable.bind(null, finishedWork, wakeable);
	      if (!retryCache.has(wakeable)) {
	        retryCache.add(wakeable);
	        if (isDevToolsPresent)
	          if (null !== inProgressLanes && null !== inProgressRoot)
	            restorePendingUpdaters(inProgressRoot, inProgressLanes);
	          else
	            throw Error(
	              "Expected finished root and lanes to be set. This is a bug in React."
	            );
	        wakeable.then(retry, retry);
	      }
	    });
	  }
	  function recursivelyTraverseMutationEffects(root$jscomp$0, parentFiber) {
	    var deletions = parentFiber.deletions;
	    if (null !== deletions)
	      for (var i = 0; i < deletions.length; i++) {
	        var root2 = root$jscomp$0, returnFiber = parentFiber, deletedFiber = deletions[i], parent = returnFiber;
	        a: for (; null !== parent; ) {
	          switch (parent.tag) {
	            case 27:
	              if (isSingletonScope(parent.type)) {
	                hostParent = parent.stateNode;
	                hostParentIsContainer = false;
	                break a;
	              }
	              break;
	            case 5:
	              hostParent = parent.stateNode;
	              hostParentIsContainer = false;
	              break a;
	            case 3:
	            case 4:
	              hostParent = parent.stateNode.containerInfo;
	              hostParentIsContainer = true;
	              break a;
	          }
	          parent = parent.return;
	        }
	        if (null === hostParent)
	          throw Error(
	            "Expected to find a host parent. This error is likely caused by a bug in React. Please file an issue."
	          );
	        commitDeletionEffectsOnFiber(root2, returnFiber, deletedFiber);
	        hostParent = null;
	        hostParentIsContainer = false;
	        root2 = deletedFiber;
	        returnFiber = root2.alternate;
	        null !== returnFiber && (returnFiber.return = null);
	        root2.return = null;
	      }
	    if (parentFiber.subtreeFlags & 13878)
	      for (parentFiber = parentFiber.child; null !== parentFiber; )
	        commitMutationEffectsOnFiber(parentFiber, root$jscomp$0), parentFiber = parentFiber.sibling;
	  }
	  function commitMutationEffectsOnFiber(finishedWork, root2) {
	    var current2 = finishedWork.alternate, flags = finishedWork.flags;
	    switch (finishedWork.tag) {
	      case 0:
	      case 11:
	      case 14:
	      case 15:
	        recursivelyTraverseMutationEffects(root2, finishedWork);
	        commitReconciliationEffects(finishedWork);
	        flags & 4 && (commitHookEffectListUnmount(
	          Insertion | HasEffect,
	          finishedWork,
	          finishedWork.return
	        ), commitHookEffectListMount(Insertion | HasEffect, finishedWork), commitHookLayoutUnmountEffects(
	          finishedWork,
	          finishedWork.return,
	          Layout | HasEffect
	        ));
	        break;
	      case 1:
	        recursivelyTraverseMutationEffects(root2, finishedWork);
	        commitReconciliationEffects(finishedWork);
	        flags & 512 && (offscreenSubtreeWasHidden || null === current2 || safelyDetachRef(current2, current2.return));
	        flags & 64 && offscreenSubtreeIsHidden && (finishedWork = finishedWork.updateQueue, null !== finishedWork && (flags = finishedWork.callbacks, null !== flags && (current2 = finishedWork.shared.hiddenCallbacks, finishedWork.shared.hiddenCallbacks = null === current2 ? flags : current2.concat(flags))));
	        break;
	      case 26:
	        var hoistableRoot = currentHoistableRoot;
	        recursivelyTraverseMutationEffects(root2, finishedWork);
	        commitReconciliationEffects(finishedWork);
	        flags & 512 && (offscreenSubtreeWasHidden || null === current2 || safelyDetachRef(current2, current2.return));
	        if (flags & 4)
	          if (root2 = null !== current2 ? current2.memoizedState : null, flags = finishedWork.memoizedState, null === current2)
	            if (null === flags)
	              if (null === finishedWork.stateNode) {
	                a: {
	                  flags = finishedWork.type;
	                  current2 = finishedWork.memoizedProps;
	                  root2 = hoistableRoot.ownerDocument || hoistableRoot;
	                  b: switch (flags) {
	                    case "title":
	                      hoistableRoot = root2.getElementsByTagName("title")[0];
	                      if (!hoistableRoot || hoistableRoot[internalHoistableMarker] || hoistableRoot[internalInstanceKey] || hoistableRoot.namespaceURI === SVG_NAMESPACE || hoistableRoot.hasAttribute("itemprop"))
	                        hoistableRoot = root2.createElement(flags), root2.head.insertBefore(
	                          hoistableRoot,
	                          root2.querySelector("head > title")
	                        );
	                      setInitialProperties(hoistableRoot, flags, current2);
	                      hoistableRoot[internalInstanceKey] = finishedWork;
	                      markNodeAsHoistable(hoistableRoot);
	                      flags = hoistableRoot;
	                      break a;
	                    case "link":
	                      var maybeNodes = getHydratableHoistableCache(
	                        "link",
	                        "href",
	                        root2
	                      ).get(flags + (current2.href || ""));
	                      if (maybeNodes) {
	                        for (var i = 0; i < maybeNodes.length; i++)
	                          if (hoistableRoot = maybeNodes[i], hoistableRoot.getAttribute("href") === (null == current2.href || "" === current2.href ? null : current2.href) && hoistableRoot.getAttribute("rel") === (null == current2.rel ? null : current2.rel) && hoistableRoot.getAttribute("title") === (null == current2.title ? null : current2.title) && hoistableRoot.getAttribute("crossorigin") === (null == current2.crossOrigin ? null : current2.crossOrigin)) {
	                            maybeNodes.splice(i, 1);
	                            break b;
	                          }
	                      }
	                      hoistableRoot = root2.createElement(flags);
	                      setInitialProperties(hoistableRoot, flags, current2);
	                      root2.head.appendChild(hoistableRoot);
	                      break;
	                    case "meta":
	                      if (maybeNodes = getHydratableHoistableCache(
	                        "meta",
	                        "content",
	                        root2
	                      ).get(flags + (current2.content || ""))) {
	                        for (i = 0; i < maybeNodes.length; i++)
	                          if (hoistableRoot = maybeNodes[i], checkAttributeStringCoercion(
	                            current2.content,
	                            "content"
	                          ), hoistableRoot.getAttribute("content") === (null == current2.content ? null : "" + current2.content) && hoistableRoot.getAttribute("name") === (null == current2.name ? null : current2.name) && hoistableRoot.getAttribute("property") === (null == current2.property ? null : current2.property) && hoistableRoot.getAttribute("http-equiv") === (null == current2.httpEquiv ? null : current2.httpEquiv) && hoistableRoot.getAttribute("charset") === (null == current2.charSet ? null : current2.charSet)) {
	                            maybeNodes.splice(i, 1);
	                            break b;
	                          }
	                      }
	                      hoistableRoot = root2.createElement(flags);
	                      setInitialProperties(hoistableRoot, flags, current2);
	                      root2.head.appendChild(hoistableRoot);
	                      break;
	                    default:
	                      throw Error(
	                        'getNodesForType encountered a type it did not expect: "' + flags + '". This is a bug in React.'
	                      );
	                  }
	                  hoistableRoot[internalInstanceKey] = finishedWork;
	                  markNodeAsHoistable(hoistableRoot);
	                  flags = hoistableRoot;
	                }
	                finishedWork.stateNode = flags;
	              } else
	                mountHoistable(
	                  hoistableRoot,
	                  finishedWork.type,
	                  finishedWork.stateNode
	                );
	            else
	              finishedWork.stateNode = acquireResource(
	                hoistableRoot,
	                flags,
	                finishedWork.memoizedProps
	              );
	          else
	            root2 !== flags ? (null === root2 ? null !== current2.stateNode && (current2 = current2.stateNode, current2.parentNode.removeChild(current2)) : root2.count--, null === flags ? mountHoistable(
	              hoistableRoot,
	              finishedWork.type,
	              finishedWork.stateNode
	            ) : acquireResource(
	              hoistableRoot,
	              flags,
	              finishedWork.memoizedProps
	            )) : null === flags && null !== finishedWork.stateNode && commitHostUpdate(
	              finishedWork,
	              finishedWork.memoizedProps,
	              current2.memoizedProps
	            );
	        break;
	      case 27:
	        recursivelyTraverseMutationEffects(root2, finishedWork);
	        commitReconciliationEffects(finishedWork);
	        flags & 512 && (offscreenSubtreeWasHidden || null === current2 || safelyDetachRef(current2, current2.return));
	        null !== current2 && flags & 4 && commitHostUpdate(
	          finishedWork,
	          finishedWork.memoizedProps,
	          current2.memoizedProps
	        );
	        break;
	      case 5:
	        recursivelyTraverseMutationEffects(root2, finishedWork);
	        commitReconciliationEffects(finishedWork);
	        flags & 512 && (offscreenSubtreeWasHidden || null === current2 || safelyDetachRef(current2, current2.return));
	        if (finishedWork.flags & 32) {
	          root2 = finishedWork.stateNode;
	          try {
	            runWithFiberInDEV(finishedWork, resetTextContent, root2);
	          } catch (error) {
	            captureCommitPhaseError(finishedWork, finishedWork.return, error);
	          }
	        }
	        flags & 4 && null != finishedWork.stateNode && (root2 = finishedWork.memoizedProps, commitHostUpdate(
	          finishedWork,
	          root2,
	          null !== current2 ? current2.memoizedProps : root2
	        ));
	        flags & 1024 && (needsFormReset = true, "form" !== finishedWork.type && console.error(
	          "Unexpected host component type. Expected a form. This is a bug in React."
	        ));
	        break;
	      case 6:
	        recursivelyTraverseMutationEffects(root2, finishedWork);
	        commitReconciliationEffects(finishedWork);
	        if (flags & 4) {
	          if (null === finishedWork.stateNode)
	            throw Error(
	              "This should have a text node initialized. This error is likely caused by a bug in React. Please file an issue."
	            );
	          flags = finishedWork.memoizedProps;
	          current2 = null !== current2 ? current2.memoizedProps : flags;
	          root2 = finishedWork.stateNode;
	          try {
	            runWithFiberInDEV(
	              finishedWork,
	              commitTextUpdate,
	              root2,
	              current2,
	              flags
	            );
	          } catch (error) {
	            captureCommitPhaseError(finishedWork, finishedWork.return, error);
	          }
	        }
	        break;
	      case 3:
	        hoistableRoot = pushNestedEffectDurations();
	        tagCaches = null;
	        maybeNodes = currentHoistableRoot;
	        currentHoistableRoot = getHoistableRoot(root2.containerInfo);
	        recursivelyTraverseMutationEffects(root2, finishedWork);
	        currentHoistableRoot = maybeNodes;
	        commitReconciliationEffects(finishedWork);
	        if (flags & 4 && null !== current2 && current2.memoizedState.isDehydrated)
	          try {
	            runWithFiberInDEV(
	              finishedWork,
	              commitHydratedContainer,
	              root2.containerInfo
	            );
	          } catch (error) {
	            captureCommitPhaseError(finishedWork, finishedWork.return, error);
	          }
	        needsFormReset && (needsFormReset = false, recursivelyResetForms(finishedWork));
	        root2.effectDuration += popNestedEffectDurations(hoistableRoot);
	        break;
	      case 4:
	        flags = currentHoistableRoot;
	        currentHoistableRoot = getHoistableRoot(
	          finishedWork.stateNode.containerInfo
	        );
	        recursivelyTraverseMutationEffects(root2, finishedWork);
	        commitReconciliationEffects(finishedWork);
	        currentHoistableRoot = flags;
	        break;
	      case 12:
	        flags = pushNestedEffectDurations();
	        recursivelyTraverseMutationEffects(root2, finishedWork);
	        commitReconciliationEffects(finishedWork);
	        finishedWork.stateNode.effectDuration += bubbleNestedEffectDurations(flags);
	        break;
	      case 13:
	        recursivelyTraverseMutationEffects(root2, finishedWork);
	        commitReconciliationEffects(finishedWork);
	        finishedWork.child.flags & 8192 && null !== finishedWork.memoizedState !== (null !== current2 && null !== current2.memoizedState) && (globalMostRecentFallbackTime = now$1());
	        flags & 4 && (flags = finishedWork.updateQueue, null !== flags && (finishedWork.updateQueue = null, attachSuspenseRetryListeners(finishedWork, flags)));
	        break;
	      case 22:
	        hoistableRoot = null !== finishedWork.memoizedState;
	        var wasHidden = null !== current2 && null !== current2.memoizedState, prevOffscreenSubtreeIsHidden = offscreenSubtreeIsHidden, prevOffscreenSubtreeWasHidden = offscreenSubtreeWasHidden;
	        offscreenSubtreeIsHidden = prevOffscreenSubtreeIsHidden || hoistableRoot;
	        offscreenSubtreeWasHidden = prevOffscreenSubtreeWasHidden || wasHidden;
	        recursivelyTraverseMutationEffects(root2, finishedWork);
	        offscreenSubtreeWasHidden = prevOffscreenSubtreeWasHidden;
	        offscreenSubtreeIsHidden = prevOffscreenSubtreeIsHidden;
	        commitReconciliationEffects(finishedWork);
	        if (flags & 8192)
	          a: for (root2 = finishedWork.stateNode, root2._visibility = hoistableRoot ? root2._visibility & ~OffscreenVisible : root2._visibility | OffscreenVisible, hoistableRoot && (null === current2 || wasHidden || offscreenSubtreeIsHidden || offscreenSubtreeWasHidden || recursivelyTraverseDisappearLayoutEffects(finishedWork)), current2 = null, root2 = finishedWork; ; ) {
	            if (5 === root2.tag || 26 === root2.tag) {
	              if (null === current2) {
	                wasHidden = current2 = root2;
	                try {
	                  maybeNodes = wasHidden.stateNode, hoistableRoot ? runWithFiberInDEV(wasHidden, hideInstance, maybeNodes) : runWithFiberInDEV(
	                    wasHidden,
	                    unhideInstance,
	                    wasHidden.stateNode,
	                    wasHidden.memoizedProps
	                  );
	                } catch (error) {
	                  captureCommitPhaseError(wasHidden, wasHidden.return, error);
	                }
	              }
	            } else if (6 === root2.tag) {
	              if (null === current2) {
	                wasHidden = root2;
	                try {
	                  i = wasHidden.stateNode, hoistableRoot ? runWithFiberInDEV(wasHidden, hideTextInstance, i) : runWithFiberInDEV(
	                    wasHidden,
	                    unhideTextInstance,
	                    i,
	                    wasHidden.memoizedProps
	                  );
	                } catch (error) {
	                  captureCommitPhaseError(wasHidden, wasHidden.return, error);
	                }
	              }
	            } else if ((22 !== root2.tag && 23 !== root2.tag || null === root2.memoizedState || root2 === finishedWork) && null !== root2.child) {
	              root2.child.return = root2;
	              root2 = root2.child;
	              continue;
	            }
	            if (root2 === finishedWork) break a;
	            for (; null === root2.sibling; ) {
	              if (null === root2.return || root2.return === finishedWork)
	                break a;
	              current2 === root2 && (current2 = null);
	              root2 = root2.return;
	            }
	            current2 === root2 && (current2 = null);
	            root2.sibling.return = root2.return;
	            root2 = root2.sibling;
	          }
	        flags & 4 && (flags = finishedWork.updateQueue, null !== flags && (current2 = flags.retryQueue, null !== current2 && (flags.retryQueue = null, attachSuspenseRetryListeners(finishedWork, current2))));
	        break;
	      case 19:
	        recursivelyTraverseMutationEffects(root2, finishedWork);
	        commitReconciliationEffects(finishedWork);
	        flags & 4 && (flags = finishedWork.updateQueue, null !== flags && (finishedWork.updateQueue = null, attachSuspenseRetryListeners(finishedWork, flags)));
	        break;
	      case 30:
	        break;
	      case 21:
	        break;
	      default:
	        recursivelyTraverseMutationEffects(root2, finishedWork), commitReconciliationEffects(finishedWork);
	    }
	  }
	  function commitReconciliationEffects(finishedWork) {
	    var flags = finishedWork.flags;
	    if (flags & 2) {
	      try {
	        runWithFiberInDEV(finishedWork, commitPlacement, finishedWork);
	      } catch (error) {
	        captureCommitPhaseError(finishedWork, finishedWork.return, error);
	      }
	      finishedWork.flags &= -3;
	    }
	    flags & 4096 && (finishedWork.flags &= -4097);
	  }
	  function recursivelyResetForms(parentFiber) {
	    if (parentFiber.subtreeFlags & 1024)
	      for (parentFiber = parentFiber.child; null !== parentFiber; ) {
	        var fiber = parentFiber;
	        recursivelyResetForms(fiber);
	        5 === fiber.tag && fiber.flags & 1024 && fiber.stateNode.reset();
	        parentFiber = parentFiber.sibling;
	      }
	  }
	  function recursivelyTraverseLayoutEffects(root2, parentFiber) {
	    if (parentFiber.subtreeFlags & 8772)
	      for (parentFiber = parentFiber.child; null !== parentFiber; )
	        commitLayoutEffectOnFiber(root2, parentFiber.alternate, parentFiber), parentFiber = parentFiber.sibling;
	  }
	  function disappearLayoutEffects(finishedWork) {
	    switch (finishedWork.tag) {
	      case 0:
	      case 11:
	      case 14:
	      case 15:
	        commitHookLayoutUnmountEffects(
	          finishedWork,
	          finishedWork.return,
	          Layout
	        );
	        recursivelyTraverseDisappearLayoutEffects(finishedWork);
	        break;
	      case 1:
	        safelyDetachRef(finishedWork, finishedWork.return);
	        var instance = finishedWork.stateNode;
	        "function" === typeof instance.componentWillUnmount && safelyCallComponentWillUnmount(
	          finishedWork,
	          finishedWork.return,
	          instance
	        );
	        recursivelyTraverseDisappearLayoutEffects(finishedWork);
	        break;
	      case 27:
	        runWithFiberInDEV(
	          finishedWork,
	          releaseSingletonInstance,
	          finishedWork.stateNode
	        );
	      case 26:
	      case 5:
	        safelyDetachRef(finishedWork, finishedWork.return);
	        recursivelyTraverseDisappearLayoutEffects(finishedWork);
	        break;
	      case 22:
	        null === finishedWork.memoizedState && recursivelyTraverseDisappearLayoutEffects(finishedWork);
	        break;
	      case 30:
	        recursivelyTraverseDisappearLayoutEffects(finishedWork);
	        break;
	      default:
	        recursivelyTraverseDisappearLayoutEffects(finishedWork);
	    }
	  }
	  function recursivelyTraverseDisappearLayoutEffects(parentFiber) {
	    for (parentFiber = parentFiber.child; null !== parentFiber; )
	      disappearLayoutEffects(parentFiber), parentFiber = parentFiber.sibling;
	  }
	  function reappearLayoutEffects(finishedRoot, current2, finishedWork, includeWorkInProgressEffects) {
	    var flags = finishedWork.flags;
	    switch (finishedWork.tag) {
	      case 0:
	      case 11:
	      case 15:
	        recursivelyTraverseReappearLayoutEffects(
	          finishedRoot,
	          finishedWork,
	          includeWorkInProgressEffects
	        );
	        commitHookLayoutEffects(finishedWork, Layout);
	        break;
	      case 1:
	        recursivelyTraverseReappearLayoutEffects(
	          finishedRoot,
	          finishedWork,
	          includeWorkInProgressEffects
	        );
	        current2 = finishedWork.stateNode;
	        "function" === typeof current2.componentDidMount && runWithFiberInDEV(
	          finishedWork,
	          callComponentDidMountInDEV,
	          finishedWork,
	          current2
	        );
	        current2 = finishedWork.updateQueue;
	        if (null !== current2) {
	          finishedRoot = finishedWork.stateNode;
	          try {
	            runWithFiberInDEV(
	              finishedWork,
	              commitHiddenCallbacks,
	              current2,
	              finishedRoot
	            );
	          } catch (error) {
	            captureCommitPhaseError(finishedWork, finishedWork.return, error);
	          }
	        }
	        includeWorkInProgressEffects && flags & 64 && commitClassCallbacks(finishedWork);
	        safelyAttachRef(finishedWork, finishedWork.return);
	        break;
	      case 27:
	        commitHostSingletonAcquisition(finishedWork);
	      case 26:
	      case 5:
	        recursivelyTraverseReappearLayoutEffects(
	          finishedRoot,
	          finishedWork,
	          includeWorkInProgressEffects
	        );
	        includeWorkInProgressEffects && null === current2 && flags & 4 && commitHostMount(finishedWork);
	        safelyAttachRef(finishedWork, finishedWork.return);
	        break;
	      case 12:
	        if (includeWorkInProgressEffects && flags & 4) {
	          flags = pushNestedEffectDurations();
	          recursivelyTraverseReappearLayoutEffects(
	            finishedRoot,
	            finishedWork,
	            includeWorkInProgressEffects
	          );
	          includeWorkInProgressEffects = finishedWork.stateNode;
	          includeWorkInProgressEffects.effectDuration += bubbleNestedEffectDurations(flags);
	          try {
	            runWithFiberInDEV(
	              finishedWork,
	              commitProfiler,
	              finishedWork,
	              current2,
	              commitStartTime,
	              includeWorkInProgressEffects.effectDuration
	            );
	          } catch (error) {
	            captureCommitPhaseError(finishedWork, finishedWork.return, error);
	          }
	        } else
	          recursivelyTraverseReappearLayoutEffects(
	            finishedRoot,
	            finishedWork,
	            includeWorkInProgressEffects
	          );
	        break;
	      case 13:
	        recursivelyTraverseReappearLayoutEffects(
	          finishedRoot,
	          finishedWork,
	          includeWorkInProgressEffects
	        );
	        includeWorkInProgressEffects && flags & 4 && commitSuspenseHydrationCallbacks(finishedRoot, finishedWork);
	        break;
	      case 22:
	        null === finishedWork.memoizedState && recursivelyTraverseReappearLayoutEffects(
	          finishedRoot,
	          finishedWork,
	          includeWorkInProgressEffects
	        );
	        safelyAttachRef(finishedWork, finishedWork.return);
	        break;
	      case 30:
	        break;
	      default:
	        recursivelyTraverseReappearLayoutEffects(
	          finishedRoot,
	          finishedWork,
	          includeWorkInProgressEffects
	        );
	    }
	  }
	  function recursivelyTraverseReappearLayoutEffects(finishedRoot, parentFiber, includeWorkInProgressEffects) {
	    includeWorkInProgressEffects = includeWorkInProgressEffects && 0 !== (parentFiber.subtreeFlags & 8772);
	    for (parentFiber = parentFiber.child; null !== parentFiber; )
	      reappearLayoutEffects(
	        finishedRoot,
	        parentFiber.alternate,
	        parentFiber,
	        includeWorkInProgressEffects
	      ), parentFiber = parentFiber.sibling;
	  }
	  function commitOffscreenPassiveMountEffects(current2, finishedWork) {
	    var previousCache = null;
	    null !== current2 && null !== current2.memoizedState && null !== current2.memoizedState.cachePool && (previousCache = current2.memoizedState.cachePool.pool);
	    current2 = null;
	    null !== finishedWork.memoizedState && null !== finishedWork.memoizedState.cachePool && (current2 = finishedWork.memoizedState.cachePool.pool);
	    current2 !== previousCache && (null != current2 && retainCache(current2), null != previousCache && releaseCache(previousCache));
	  }
	  function commitCachePassiveMountEffect(current2, finishedWork) {
	    current2 = null;
	    null !== finishedWork.alternate && (current2 = finishedWork.alternate.memoizedState.cache);
	    finishedWork = finishedWork.memoizedState.cache;
	    finishedWork !== current2 && (retainCache(finishedWork), null != current2 && releaseCache(current2));
	  }
	  function recursivelyTraversePassiveMountEffects(root2, parentFiber, committedLanes, committedTransitions) {
	    if (parentFiber.subtreeFlags & 10256)
	      for (parentFiber = parentFiber.child; null !== parentFiber; )
	        commitPassiveMountOnFiber(
	          root2,
	          parentFiber,
	          committedLanes,
	          committedTransitions
	        ), parentFiber = parentFiber.sibling;
	  }
	  function commitPassiveMountOnFiber(finishedRoot, finishedWork, committedLanes, committedTransitions) {
	    var flags = finishedWork.flags;
	    switch (finishedWork.tag) {
	      case 0:
	      case 11:
	      case 15:
	        recursivelyTraversePassiveMountEffects(
	          finishedRoot,
	          finishedWork,
	          committedLanes,
	          committedTransitions
	        );
	        flags & 2048 && commitHookPassiveMountEffects(finishedWork, Passive | HasEffect);
	        break;
	      case 1:
	        recursivelyTraversePassiveMountEffects(
	          finishedRoot,
	          finishedWork,
	          committedLanes,
	          committedTransitions
	        );
	        break;
	      case 3:
	        var prevEffectDuration = pushNestedEffectDurations();
	        recursivelyTraversePassiveMountEffects(
	          finishedRoot,
	          finishedWork,
	          committedLanes,
	          committedTransitions
	        );
	        flags & 2048 && (committedLanes = null, null !== finishedWork.alternate && (committedLanes = finishedWork.alternate.memoizedState.cache), finishedWork = finishedWork.memoizedState.cache, finishedWork !== committedLanes && (retainCache(finishedWork), null != committedLanes && releaseCache(committedLanes)));
	        finishedRoot.passiveEffectDuration += popNestedEffectDurations(prevEffectDuration);
	        break;
	      case 12:
	        if (flags & 2048) {
	          flags = pushNestedEffectDurations();
	          recursivelyTraversePassiveMountEffects(
	            finishedRoot,
	            finishedWork,
	            committedLanes,
	            committedTransitions
	          );
	          finishedRoot = finishedWork.stateNode;
	          finishedRoot.passiveEffectDuration += bubbleNestedEffectDurations(flags);
	          try {
	            runWithFiberInDEV(
	              finishedWork,
	              commitProfilerPostCommitImpl,
	              finishedWork,
	              finishedWork.alternate,
	              commitStartTime,
	              finishedRoot.passiveEffectDuration
	            );
	          } catch (error) {
	            captureCommitPhaseError(finishedWork, finishedWork.return, error);
	          }
	        } else
	          recursivelyTraversePassiveMountEffects(
	            finishedRoot,
	            finishedWork,
	            committedLanes,
	            committedTransitions
	          );
	        break;
	      case 13:
	        recursivelyTraversePassiveMountEffects(
	          finishedRoot,
	          finishedWork,
	          committedLanes,
	          committedTransitions
	        );
	        break;
	      case 23:
	        break;
	      case 22:
	        prevEffectDuration = finishedWork.stateNode;
	        var _current = finishedWork.alternate;
	        null !== finishedWork.memoizedState ? prevEffectDuration._visibility & OffscreenPassiveEffectsConnected ? recursivelyTraversePassiveMountEffects(
	          finishedRoot,
	          finishedWork,
	          committedLanes,
	          committedTransitions
	        ) : recursivelyTraverseAtomicPassiveEffects(
	          finishedRoot,
	          finishedWork
	        ) : prevEffectDuration._visibility & OffscreenPassiveEffectsConnected ? recursivelyTraversePassiveMountEffects(
	          finishedRoot,
	          finishedWork,
	          committedLanes,
	          committedTransitions
	        ) : (prevEffectDuration._visibility |= OffscreenPassiveEffectsConnected, recursivelyTraverseReconnectPassiveEffects(
	          finishedRoot,
	          finishedWork,
	          committedLanes,
	          committedTransitions,
	          0 !== (finishedWork.subtreeFlags & 10256)
	        ));
	        flags & 2048 && commitOffscreenPassiveMountEffects(_current, finishedWork);
	        break;
	      case 24:
	        recursivelyTraversePassiveMountEffects(
	          finishedRoot,
	          finishedWork,
	          committedLanes,
	          committedTransitions
	        );
	        flags & 2048 && commitCachePassiveMountEffect(finishedWork.alternate, finishedWork);
	        break;
	      default:
	        recursivelyTraversePassiveMountEffects(
	          finishedRoot,
	          finishedWork,
	          committedLanes,
	          committedTransitions
	        );
	    }
	  }
	  function recursivelyTraverseReconnectPassiveEffects(finishedRoot, parentFiber, committedLanes, committedTransitions, includeWorkInProgressEffects) {
	    includeWorkInProgressEffects = includeWorkInProgressEffects && 0 !== (parentFiber.subtreeFlags & 10256);
	    for (parentFiber = parentFiber.child; null !== parentFiber; )
	      reconnectPassiveEffects(
	        finishedRoot,
	        parentFiber,
	        committedLanes,
	        committedTransitions,
	        includeWorkInProgressEffects
	      ), parentFiber = parentFiber.sibling;
	  }
	  function reconnectPassiveEffects(finishedRoot, finishedWork, committedLanes, committedTransitions, includeWorkInProgressEffects) {
	    var flags = finishedWork.flags;
	    switch (finishedWork.tag) {
	      case 0:
	      case 11:
	      case 15:
	        recursivelyTraverseReconnectPassiveEffects(
	          finishedRoot,
	          finishedWork,
	          committedLanes,
	          committedTransitions,
	          includeWorkInProgressEffects
	        );
	        commitHookPassiveMountEffects(finishedWork, Passive);
	        break;
	      case 23:
	        break;
	      case 22:
	        var _instance2 = finishedWork.stateNode;
	        null !== finishedWork.memoizedState ? _instance2._visibility & OffscreenPassiveEffectsConnected ? recursivelyTraverseReconnectPassiveEffects(
	          finishedRoot,
	          finishedWork,
	          committedLanes,
	          committedTransitions,
	          includeWorkInProgressEffects
	        ) : recursivelyTraverseAtomicPassiveEffects(
	          finishedRoot,
	          finishedWork
	        ) : (_instance2._visibility |= OffscreenPassiveEffectsConnected, recursivelyTraverseReconnectPassiveEffects(
	          finishedRoot,
	          finishedWork,
	          committedLanes,
	          committedTransitions,
	          includeWorkInProgressEffects
	        ));
	        includeWorkInProgressEffects && flags & 2048 && commitOffscreenPassiveMountEffects(
	          finishedWork.alternate,
	          finishedWork
	        );
	        break;
	      case 24:
	        recursivelyTraverseReconnectPassiveEffects(
	          finishedRoot,
	          finishedWork,
	          committedLanes,
	          committedTransitions,
	          includeWorkInProgressEffects
	        );
	        includeWorkInProgressEffects && flags & 2048 && commitCachePassiveMountEffect(finishedWork.alternate, finishedWork);
	        break;
	      default:
	        recursivelyTraverseReconnectPassiveEffects(
	          finishedRoot,
	          finishedWork,
	          committedLanes,
	          committedTransitions,
	          includeWorkInProgressEffects
	        );
	    }
	  }
	  function recursivelyTraverseAtomicPassiveEffects(finishedRoot$jscomp$0, parentFiber) {
	    if (parentFiber.subtreeFlags & 10256)
	      for (parentFiber = parentFiber.child; null !== parentFiber; ) {
	        var finishedRoot = finishedRoot$jscomp$0, finishedWork = parentFiber, flags = finishedWork.flags;
	        switch (finishedWork.tag) {
	          case 22:
	            recursivelyTraverseAtomicPassiveEffects(
	              finishedRoot,
	              finishedWork
	            );
	            flags & 2048 && commitOffscreenPassiveMountEffects(
	              finishedWork.alternate,
	              finishedWork
	            );
	            break;
	          case 24:
	            recursivelyTraverseAtomicPassiveEffects(
	              finishedRoot,
	              finishedWork
	            );
	            flags & 2048 && commitCachePassiveMountEffect(
	              finishedWork.alternate,
	              finishedWork
	            );
	            break;
	          default:
	            recursivelyTraverseAtomicPassiveEffects(
	              finishedRoot,
	              finishedWork
	            );
	        }
	        parentFiber = parentFiber.sibling;
	      }
	  }
	  function recursivelyAccumulateSuspenseyCommit(parentFiber) {
	    if (parentFiber.subtreeFlags & suspenseyCommitFlag)
	      for (parentFiber = parentFiber.child; null !== parentFiber; )
	        accumulateSuspenseyCommitOnFiber(parentFiber), parentFiber = parentFiber.sibling;
	  }
	  function accumulateSuspenseyCommitOnFiber(fiber) {
	    switch (fiber.tag) {
	      case 26:
	        recursivelyAccumulateSuspenseyCommit(fiber);
	        fiber.flags & suspenseyCommitFlag && null !== fiber.memoizedState && suspendResource(
	          currentHoistableRoot,
	          fiber.memoizedState,
	          fiber.memoizedProps
	        );
	        break;
	      case 5:
	        recursivelyAccumulateSuspenseyCommit(fiber);
	        break;
	      case 3:
	      case 4:
	        var previousHoistableRoot = currentHoistableRoot;
	        currentHoistableRoot = getHoistableRoot(
	          fiber.stateNode.containerInfo
	        );
	        recursivelyAccumulateSuspenseyCommit(fiber);
	        currentHoistableRoot = previousHoistableRoot;
	        break;
	      case 22:
	        null === fiber.memoizedState && (previousHoistableRoot = fiber.alternate, null !== previousHoistableRoot && null !== previousHoistableRoot.memoizedState ? (previousHoistableRoot = suspenseyCommitFlag, suspenseyCommitFlag = 16777216, recursivelyAccumulateSuspenseyCommit(fiber), suspenseyCommitFlag = previousHoistableRoot) : recursivelyAccumulateSuspenseyCommit(fiber));
	        break;
	      default:
	        recursivelyAccumulateSuspenseyCommit(fiber);
	    }
	  }
	  function detachAlternateSiblings(parentFiber) {
	    var previousFiber = parentFiber.alternate;
	    if (null !== previousFiber && (parentFiber = previousFiber.child, null !== parentFiber)) {
	      previousFiber.child = null;
	      do
	        previousFiber = parentFiber.sibling, parentFiber.sibling = null, parentFiber = previousFiber;
	      while (null !== parentFiber);
	    }
	  }
	  function recursivelyTraversePassiveUnmountEffects(parentFiber) {
	    var deletions = parentFiber.deletions;
	    if (0 !== (parentFiber.flags & 16)) {
	      if (null !== deletions)
	        for (var i = 0; i < deletions.length; i++) {
	          var childToDelete = deletions[i];
	          nextEffect = childToDelete;
	          commitPassiveUnmountEffectsInsideOfDeletedTree_begin(
	            childToDelete,
	            parentFiber
	          );
	        }
	      detachAlternateSiblings(parentFiber);
	    }
	    if (parentFiber.subtreeFlags & 10256)
	      for (parentFiber = parentFiber.child; null !== parentFiber; )
	        commitPassiveUnmountOnFiber(parentFiber), parentFiber = parentFiber.sibling;
	  }
	  function commitPassiveUnmountOnFiber(finishedWork) {
	    switch (finishedWork.tag) {
	      case 0:
	      case 11:
	      case 15:
	        recursivelyTraversePassiveUnmountEffects(finishedWork);
	        finishedWork.flags & 2048 && commitHookPassiveUnmountEffects(
	          finishedWork,
	          finishedWork.return,
	          Passive | HasEffect
	        );
	        break;
	      case 3:
	        var prevEffectDuration = pushNestedEffectDurations();
	        recursivelyTraversePassiveUnmountEffects(finishedWork);
	        finishedWork.stateNode.passiveEffectDuration += popNestedEffectDurations(prevEffectDuration);
	        break;
	      case 12:
	        prevEffectDuration = pushNestedEffectDurations();
	        recursivelyTraversePassiveUnmountEffects(finishedWork);
	        finishedWork.stateNode.passiveEffectDuration += bubbleNestedEffectDurations(prevEffectDuration);
	        break;
	      case 22:
	        prevEffectDuration = finishedWork.stateNode;
	        null !== finishedWork.memoizedState && prevEffectDuration._visibility & OffscreenPassiveEffectsConnected && (null === finishedWork.return || 13 !== finishedWork.return.tag) ? (prevEffectDuration._visibility &= ~OffscreenPassiveEffectsConnected, recursivelyTraverseDisconnectPassiveEffects(finishedWork)) : recursivelyTraversePassiveUnmountEffects(finishedWork);
	        break;
	      default:
	        recursivelyTraversePassiveUnmountEffects(finishedWork);
	    }
	  }
	  function recursivelyTraverseDisconnectPassiveEffects(parentFiber) {
	    var deletions = parentFiber.deletions;
	    if (0 !== (parentFiber.flags & 16)) {
	      if (null !== deletions)
	        for (var i = 0; i < deletions.length; i++) {
	          var childToDelete = deletions[i];
	          nextEffect = childToDelete;
	          commitPassiveUnmountEffectsInsideOfDeletedTree_begin(
	            childToDelete,
	            parentFiber
	          );
	        }
	      detachAlternateSiblings(parentFiber);
	    }
	    for (parentFiber = parentFiber.child; null !== parentFiber; )
	      disconnectPassiveEffect(parentFiber), parentFiber = parentFiber.sibling;
	  }
	  function disconnectPassiveEffect(finishedWork) {
	    switch (finishedWork.tag) {
	      case 0:
	      case 11:
	      case 15:
	        commitHookPassiveUnmountEffects(
	          finishedWork,
	          finishedWork.return,
	          Passive
	        );
	        recursivelyTraverseDisconnectPassiveEffects(finishedWork);
	        break;
	      case 22:
	        var instance = finishedWork.stateNode;
	        instance._visibility & OffscreenPassiveEffectsConnected && (instance._visibility &= ~OffscreenPassiveEffectsConnected, recursivelyTraverseDisconnectPassiveEffects(finishedWork));
	        break;
	      default:
	        recursivelyTraverseDisconnectPassiveEffects(finishedWork);
	    }
	  }
	  function commitPassiveUnmountEffectsInsideOfDeletedTree_begin(deletedSubtreeRoot, nearestMountedAncestor) {
	    for (; null !== nextEffect; ) {
	      var fiber = nextEffect, current2 = fiber;
	      switch (current2.tag) {
	        case 0:
	        case 11:
	        case 15:
	          commitHookPassiveUnmountEffects(
	            current2,
	            nearestMountedAncestor,
	            Passive
	          );
	          break;
	        case 23:
	        case 22:
	          null !== current2.memoizedState && null !== current2.memoizedState.cachePool && (current2 = current2.memoizedState.cachePool.pool, null != current2 && retainCache(current2));
	          break;
	        case 24:
	          releaseCache(current2.memoizedState.cache);
	      }
	      current2 = fiber.child;
	      if (null !== current2) current2.return = fiber, nextEffect = current2;
	      else
	        a: for (fiber = deletedSubtreeRoot; null !== nextEffect; ) {
	          current2 = nextEffect;
	          var sibling = current2.sibling, returnFiber = current2.return;
	          detachFiberAfterEffects(current2);
	          if (current2 === fiber) {
	            nextEffect = null;
	            break a;
	          }
	          if (null !== sibling) {
	            sibling.return = returnFiber;
	            nextEffect = sibling;
	            break a;
	          }
	          nextEffect = returnFiber;
	        }
	    }
	  }
	  function onCommitRoot() {
	    commitHooks.forEach(function(commitHook) {
	      return commitHook();
	    });
	  }
	  function isConcurrentActEnvironment() {
	    var isReactActEnvironmentGlobal = "undefined" !== typeof IS_REACT_ACT_ENVIRONMENT ? IS_REACT_ACT_ENVIRONMENT : void 0;
	    isReactActEnvironmentGlobal || null === ReactSharedInternals.actQueue || console.error(
	      "The current testing environment is not configured to support act(...)"
	    );
	    return isReactActEnvironmentGlobal;
	  }
	  function requestUpdateLane(fiber) {
	    if ((executionContext & RenderContext) !== NoContext && 0 !== workInProgressRootRenderLanes)
	      return workInProgressRootRenderLanes & -workInProgressRootRenderLanes;
	    var transition = ReactSharedInternals.T;
	    return null !== transition ? (transition._updatedFibers || (transition._updatedFibers = /* @__PURE__ */ new Set()), transition._updatedFibers.add(fiber), fiber = currentEntangledLane, 0 !== fiber ? fiber : requestTransitionLane()) : resolveUpdatePriority();
	  }
	  function requestDeferredLane() {
	    0 === workInProgressDeferredLane && (workInProgressDeferredLane = 0 === (workInProgressRootRenderLanes & 536870912) || isHydrating ? claimNextTransitionLane() : 536870912);
	    var suspenseHandler = suspenseHandlerStackCursor.current;
	    null !== suspenseHandler && (suspenseHandler.flags |= 32);
	    return workInProgressDeferredLane;
	  }
	  function scheduleUpdateOnFiber(root2, fiber, lane) {
	    isRunningInsertionEffect && console.error("useInsertionEffect must not schedule updates.");
	    isFlushingPassiveEffects && (didScheduleUpdateDuringPassiveEffects = true);
	    if (root2 === workInProgressRoot && (workInProgressSuspendedReason === SuspendedOnData || workInProgressSuspendedReason === SuspendedOnAction) || null !== root2.cancelPendingCommit)
	      prepareFreshStack(root2, 0), markRootSuspended(
	        root2,
	        workInProgressRootRenderLanes,
	        workInProgressDeferredLane,
	        false
	      );
	    markRootUpdated$1(root2, lane);
	    if (0 !== (executionContext & RenderContext) && root2 === workInProgressRoot) {
	      if (isRendering)
	        switch (fiber.tag) {
	          case 0:
	          case 11:
	          case 15:
	            root2 = workInProgress && getComponentNameFromFiber(workInProgress) || "Unknown";
	            didWarnAboutUpdateInRenderForAnotherComponent.has(root2) || (didWarnAboutUpdateInRenderForAnotherComponent.add(root2), fiber = getComponentNameFromFiber(fiber) || "Unknown", console.error(
	              "Cannot update a component (`%s`) while rendering a different component (`%s`). To locate the bad setState() call inside `%s`, follow the stack trace as described in https://react.dev/link/setstate-in-render",
	              fiber,
	              root2,
	              root2
	            ));
	            break;
	          case 1:
	            didWarnAboutUpdateInRender || (console.error(
	              "Cannot update during an existing state transition (such as within `render`). Render methods should be a pure function of props and state."
	            ), didWarnAboutUpdateInRender = true);
	        }
	    } else
	      isDevToolsPresent && addFiberToLanesMap(root2, fiber, lane), warnIfUpdatesNotWrappedWithActDEV(fiber), root2 === workInProgressRoot && ((executionContext & RenderContext) === NoContext && (workInProgressRootInterleavedUpdatedLanes |= lane), workInProgressRootExitStatus === RootSuspendedWithDelay && markRootSuspended(
	        root2,
	        workInProgressRootRenderLanes,
	        workInProgressDeferredLane,
	        false
	      )), ensureRootIsScheduled(root2);
	  }
	  function performWorkOnRoot(root2, lanes, forceSync) {
	    if ((executionContext & (RenderContext | CommitContext)) !== NoContext)
	      throw Error("Should not already be working.");
	    var shouldTimeSlice = !forceSync && 0 === (lanes & 124) && 0 === (lanes & root2.expiredLanes) || checkIfRootIsPrerendering(root2, lanes), exitStatus = shouldTimeSlice ? renderRootConcurrent(root2, lanes) : renderRootSync(root2, lanes, true), renderWasConcurrent = shouldTimeSlice;
	    do {
	      if (exitStatus === RootInProgress) {
	        workInProgressRootIsPrerendering && !shouldTimeSlice && markRootSuspended(root2, lanes, 0, false);
	        break;
	      } else {
	        forceSync = root2.current.alternate;
	        if (renderWasConcurrent && !isRenderConsistentWithExternalStores(forceSync)) {
	          exitStatus = renderRootSync(root2, lanes, false);
	          renderWasConcurrent = false;
	          continue;
	        }
	        if (exitStatus === RootErrored) {
	          renderWasConcurrent = lanes;
	          if (root2.errorRecoveryDisabledLanes & renderWasConcurrent)
	            var errorRetryLanes = 0;
	          else
	            errorRetryLanes = root2.pendingLanes & -536870913, errorRetryLanes = 0 !== errorRetryLanes ? errorRetryLanes : errorRetryLanes & 536870912 ? 536870912 : 0;
	          if (0 !== errorRetryLanes) {
	            lanes = errorRetryLanes;
	            a: {
	              exitStatus = root2;
	              var errorRetryLanes$jscomp$0 = errorRetryLanes;
	              errorRetryLanes = workInProgressRootConcurrentErrors;
	              var wasRootDehydrated = exitStatus.current.memoizedState.isDehydrated;
	              wasRootDehydrated && (prepareFreshStack(
	                exitStatus,
	                errorRetryLanes$jscomp$0
	              ).flags |= 256);
	              errorRetryLanes$jscomp$0 = renderRootSync(
	                exitStatus,
	                errorRetryLanes$jscomp$0,
	                false
	              );
	              if (errorRetryLanes$jscomp$0 !== RootErrored) {
	                if (workInProgressRootDidAttachPingListener && !wasRootDehydrated) {
	                  exitStatus.errorRecoveryDisabledLanes |= renderWasConcurrent;
	                  workInProgressRootInterleavedUpdatedLanes |= renderWasConcurrent;
	                  exitStatus = RootSuspendedWithDelay;
	                  break a;
	                }
	                exitStatus = workInProgressRootRecoverableErrors;
	                workInProgressRootRecoverableErrors = errorRetryLanes;
	                null !== exitStatus && (null === workInProgressRootRecoverableErrors ? workInProgressRootRecoverableErrors = exitStatus : workInProgressRootRecoverableErrors.push.apply(
	                  workInProgressRootRecoverableErrors,
	                  exitStatus
	                ));
	              }
	              exitStatus = errorRetryLanes$jscomp$0;
	            }
	            renderWasConcurrent = false;
	            if (exitStatus !== RootErrored) continue;
	          }
	        }
	        if (exitStatus === RootFatalErrored) {
	          prepareFreshStack(root2, 0);
	          markRootSuspended(root2, lanes, 0, true);
	          break;
	        }
	        a: {
	          shouldTimeSlice = root2;
	          switch (exitStatus) {
	            case RootInProgress:
	            case RootFatalErrored:
	              throw Error("Root did not complete. This is a bug in React.");
	            case RootSuspendedWithDelay:
	              if ((lanes & 4194048) !== lanes) break;
	            case RootSuspendedAtTheShell:
	              markRootSuspended(
	                shouldTimeSlice,
	                lanes,
	                workInProgressDeferredLane,
	                !workInProgressRootDidSkipSuspendedSiblings
	              );
	              break a;
	            case RootErrored:
	              workInProgressRootRecoverableErrors = null;
	              break;
	            case RootSuspended:
	            case RootCompleted:
	              break;
	            default:
	              throw Error("Unknown root exit status.");
	          }
	          if (null !== ReactSharedInternals.actQueue)
	            commitRoot(
	              shouldTimeSlice,
	              forceSync,
	              lanes,
	              workInProgressRootRecoverableErrors,
	              workInProgressTransitions,
	              workInProgressRootDidIncludeRecursiveRenderUpdate,
	              workInProgressDeferredLane,
	              workInProgressRootInterleavedUpdatedLanes,
	              workInProgressSuspendedRetryLanes
	            );
	          else {
	            if ((lanes & 62914560) === lanes && (renderWasConcurrent = globalMostRecentFallbackTime + FALLBACK_THROTTLE_MS - now$1(), 10 < renderWasConcurrent)) {
	              markRootSuspended(
	                shouldTimeSlice,
	                lanes,
	                workInProgressDeferredLane,
	                !workInProgressRootDidSkipSuspendedSiblings
	              );
	              if (0 !== getNextLanes(shouldTimeSlice, 0, true)) break a;
	              shouldTimeSlice.timeoutHandle = scheduleTimeout(
	                commitRootWhenReady.bind(
	                  null,
	                  shouldTimeSlice,
	                  forceSync,
	                  workInProgressRootRecoverableErrors,
	                  workInProgressTransitions,
	                  workInProgressRootDidIncludeRecursiveRenderUpdate,
	                  lanes,
	                  workInProgressDeferredLane,
	                  workInProgressRootInterleavedUpdatedLanes,
	                  workInProgressSuspendedRetryLanes,
	                  workInProgressRootDidSkipSuspendedSiblings,
	                  exitStatus,
	                  THROTTLED_COMMIT,
	                  renderStartTime,
	                  0
	                ),
	                renderWasConcurrent
	              );
	              break a;
	            }
	            commitRootWhenReady(
	              shouldTimeSlice,
	              forceSync,
	              workInProgressRootRecoverableErrors,
	              workInProgressTransitions,
	              workInProgressRootDidIncludeRecursiveRenderUpdate,
	              lanes,
	              workInProgressDeferredLane,
	              workInProgressRootInterleavedUpdatedLanes,
	              workInProgressSuspendedRetryLanes,
	              workInProgressRootDidSkipSuspendedSiblings,
	              exitStatus,
	              IMMEDIATE_COMMIT,
	              renderStartTime,
	              0
	            );
	          }
	        }
	      }
	      break;
	    } while (1);
	    ensureRootIsScheduled(root2);
	  }
	  function commitRootWhenReady(root2, finishedWork, recoverableErrors, transitions, didIncludeRenderPhaseUpdate, lanes, spawnedLane, updatedLanes, suspendedRetryLanes, didSkipSuspendedSiblings, exitStatus, suspendedCommitReason, completedRenderStartTime, completedRenderEndTime) {
	    root2.timeoutHandle = noTimeout;
	    suspendedCommitReason = finishedWork.subtreeFlags;
	    if (suspendedCommitReason & 8192 || 16785408 === (suspendedCommitReason & 16785408)) {
	      if (suspendedState = { stylesheets: null, count: 0, unsuspend: noop }, accumulateSuspenseyCommitOnFiber(finishedWork), suspendedCommitReason = waitForCommitToBeReady(), null !== suspendedCommitReason) {
	        root2.cancelPendingCommit = suspendedCommitReason(
	          commitRoot.bind(
	            null,
	            root2,
	            finishedWork,
	            lanes,
	            recoverableErrors,
	            transitions,
	            didIncludeRenderPhaseUpdate,
	            spawnedLane,
	            updatedLanes,
	            suspendedRetryLanes,
	            exitStatus,
	            SUSPENDED_COMMIT,
	            completedRenderStartTime,
	            completedRenderEndTime
	          )
	        );
	        markRootSuspended(
	          root2,
	          lanes,
	          spawnedLane,
	          !didSkipSuspendedSiblings
	        );
	        return;
	      }
	    }
	    commitRoot(
	      root2,
	      finishedWork,
	      lanes,
	      recoverableErrors,
	      transitions,
	      didIncludeRenderPhaseUpdate,
	      spawnedLane,
	      updatedLanes,
	      suspendedRetryLanes
	    );
	  }
	  function isRenderConsistentWithExternalStores(finishedWork) {
	    for (var node = finishedWork; ; ) {
	      var tag = node.tag;
	      if ((0 === tag || 11 === tag || 15 === tag) && node.flags & 16384 && (tag = node.updateQueue, null !== tag && (tag = tag.stores, null !== tag)))
	        for (var i = 0; i < tag.length; i++) {
	          var check = tag[i], getSnapshot = check.getSnapshot;
	          check = check.value;
	          try {
	            if (!objectIs(getSnapshot(), check)) return false;
	          } catch (error) {
	            return false;
	          }
	        }
	      tag = node.child;
	      if (node.subtreeFlags & 16384 && null !== tag)
	        tag.return = node, node = tag;
	      else {
	        if (node === finishedWork) break;
	        for (; null === node.sibling; ) {
	          if (null === node.return || node.return === finishedWork) return true;
	          node = node.return;
	        }
	        node.sibling.return = node.return;
	        node = node.sibling;
	      }
	    }
	    return true;
	  }
	  function markRootSuspended(root2, suspendedLanes, spawnedLane, didAttemptEntireTree) {
	    suspendedLanes &= ~workInProgressRootPingedLanes;
	    suspendedLanes &= ~workInProgressRootInterleavedUpdatedLanes;
	    root2.suspendedLanes |= suspendedLanes;
	    root2.pingedLanes &= ~suspendedLanes;
	    didAttemptEntireTree && (root2.warmLanes |= suspendedLanes);
	    didAttemptEntireTree = root2.expirationTimes;
	    for (var lanes = suspendedLanes; 0 < lanes; ) {
	      var index = 31 - clz32(lanes), lane = 1 << index;
	      didAttemptEntireTree[index] = -1;
	      lanes &= ~lane;
	    }
	    0 !== spawnedLane && markSpawnedDeferredLane(root2, spawnedLane, suspendedLanes);
	  }
	  function flushSyncWork$1() {
	    return (executionContext & (RenderContext | CommitContext)) === NoContext ? (flushSyncWorkAcrossRoots_impl(0), false) : true;
	  }
	  function resetWorkInProgressStack() {
	    if (null !== workInProgress) {
	      if (workInProgressSuspendedReason === NotSuspended)
	        var interruptedWork = workInProgress.return;
	      else
	        interruptedWork = workInProgress, resetContextDependencies(), resetHooksOnUnwind(interruptedWork), thenableState = null, thenableIndexCounter = 0, interruptedWork = workInProgress;
	      for (; null !== interruptedWork; )
	        unwindInterruptedWork(interruptedWork.alternate, interruptedWork), interruptedWork = interruptedWork.return;
	      workInProgress = null;
	    }
	  }
	  function prepareFreshStack(root2, lanes) {
	    var timeoutHandle = root2.timeoutHandle;
	    timeoutHandle !== noTimeout && (root2.timeoutHandle = noTimeout, cancelTimeout(timeoutHandle));
	    timeoutHandle = root2.cancelPendingCommit;
	    null !== timeoutHandle && (root2.cancelPendingCommit = null, timeoutHandle());
	    resetWorkInProgressStack();
	    workInProgressRoot = root2;
	    workInProgress = timeoutHandle = createWorkInProgress(root2.current, null);
	    workInProgressRootRenderLanes = lanes;
	    workInProgressSuspendedReason = NotSuspended;
	    workInProgressThrownValue = null;
	    workInProgressRootDidSkipSuspendedSiblings = false;
	    workInProgressRootIsPrerendering = checkIfRootIsPrerendering(root2, lanes);
	    workInProgressRootDidAttachPingListener = false;
	    workInProgressRootExitStatus = RootInProgress;
	    workInProgressSuspendedRetryLanes = workInProgressDeferredLane = workInProgressRootPingedLanes = workInProgressRootInterleavedUpdatedLanes = workInProgressRootSkippedLanes = 0;
	    workInProgressRootRecoverableErrors = workInProgressRootConcurrentErrors = null;
	    workInProgressRootDidIncludeRecursiveRenderUpdate = false;
	    0 !== (lanes & 8) && (lanes |= lanes & 32);
	    var allEntangledLanes = root2.entangledLanes;
	    if (0 !== allEntangledLanes)
	      for (root2 = root2.entanglements, allEntangledLanes &= lanes; 0 < allEntangledLanes; ) {
	        var index = 31 - clz32(allEntangledLanes), lane = 1 << index;
	        lanes |= root2[index];
	        allEntangledLanes &= ~lane;
	      }
	    entangledRenderLanes = lanes;
	    finishQueueingConcurrentUpdates();
	    lanes = getCurrentTime();
	    1e3 < lanes - lastResetTime && (ReactSharedInternals.recentlyCreatedOwnerStacks = 0, lastResetTime = lanes);
	    ReactStrictModeWarnings.discardPendingWarnings();
	    return timeoutHandle;
	  }
	  function handleThrow(root2, thrownValue) {
	    currentlyRenderingFiber = null;
	    ReactSharedInternals.H = ContextOnlyDispatcher;
	    ReactSharedInternals.getCurrentStack = null;
	    isRendering = false;
	    current = null;
	    thrownValue === SuspenseException || thrownValue === SuspenseActionException ? (thrownValue = getSuspendedThenable(), workInProgressSuspendedReason = SuspendedOnImmediate) : thrownValue === SuspenseyCommitException ? (thrownValue = getSuspendedThenable(), workInProgressSuspendedReason = SuspendedOnInstance) : workInProgressSuspendedReason = thrownValue === SelectiveHydrationException ? SuspendedOnHydration : null !== thrownValue && "object" === typeof thrownValue && "function" === typeof thrownValue.then ? SuspendedOnDeprecatedThrowPromise : SuspendedOnError;
	    workInProgressThrownValue = thrownValue;
	    var erroredWork = workInProgress;
	    if (null === erroredWork)
	      workInProgressRootExitStatus = RootFatalErrored, logUncaughtError(
	        root2,
	        createCapturedValueAtFiber(thrownValue, root2.current)
	      );
	    else
	      switch (erroredWork.mode & ProfileMode && stopProfilerTimerIfRunningAndRecordDuration(erroredWork), markComponentRenderStopped(), workInProgressSuspendedReason) {
	        case SuspendedOnError:
	          null !== injectedProfilingHooks && "function" === typeof injectedProfilingHooks.markComponentErrored && injectedProfilingHooks.markComponentErrored(
	            erroredWork,
	            thrownValue,
	            workInProgressRootRenderLanes
	          );
	          break;
	        case SuspendedOnData:
	        case SuspendedOnAction:
	        case SuspendedOnImmediate:
	        case SuspendedOnDeprecatedThrowPromise:
	        case SuspendedAndReadyToContinue:
	          null !== injectedProfilingHooks && "function" === typeof injectedProfilingHooks.markComponentSuspended && injectedProfilingHooks.markComponentSuspended(
	            erroredWork,
	            thrownValue,
	            workInProgressRootRenderLanes
	          );
	      }
	  }
	  function pushDispatcher() {
	    var prevDispatcher = ReactSharedInternals.H;
	    ReactSharedInternals.H = ContextOnlyDispatcher;
	    return null === prevDispatcher ? ContextOnlyDispatcher : prevDispatcher;
	  }
	  function pushAsyncDispatcher() {
	    var prevAsyncDispatcher = ReactSharedInternals.A;
	    ReactSharedInternals.A = DefaultAsyncDispatcher;
	    return prevAsyncDispatcher;
	  }
	  function renderDidSuspendDelayIfPossible() {
	    workInProgressRootExitStatus = RootSuspendedWithDelay;
	    workInProgressRootDidSkipSuspendedSiblings || (workInProgressRootRenderLanes & 4194048) !== workInProgressRootRenderLanes && null !== suspenseHandlerStackCursor.current || (workInProgressRootIsPrerendering = true);
	    0 === (workInProgressRootSkippedLanes & 134217727) && 0 === (workInProgressRootInterleavedUpdatedLanes & 134217727) || null === workInProgressRoot || markRootSuspended(
	      workInProgressRoot,
	      workInProgressRootRenderLanes,
	      workInProgressDeferredLane,
	      false
	    );
	  }
	  function renderRootSync(root2, lanes, shouldYieldForPrerendering) {
	    var prevExecutionContext = executionContext;
	    executionContext |= RenderContext;
	    var prevDispatcher = pushDispatcher(), prevAsyncDispatcher = pushAsyncDispatcher();
	    if (workInProgressRoot !== root2 || workInProgressRootRenderLanes !== lanes) {
	      if (isDevToolsPresent) {
	        var memoizedUpdaters = root2.memoizedUpdaters;
	        0 < memoizedUpdaters.size && (restorePendingUpdaters(root2, workInProgressRootRenderLanes), memoizedUpdaters.clear());
	        movePendingFibersToMemoized(root2, lanes);
	      }
	      workInProgressTransitions = null;
	      prepareFreshStack(root2, lanes);
	    }
	    markRenderStarted(lanes);
	    lanes = false;
	    memoizedUpdaters = workInProgressRootExitStatus;
	    a: do
	      try {
	        if (workInProgressSuspendedReason !== NotSuspended && null !== workInProgress) {
	          var unitOfWork = workInProgress, thrownValue = workInProgressThrownValue;
	          switch (workInProgressSuspendedReason) {
	            case SuspendedOnHydration:
	              resetWorkInProgressStack();
	              memoizedUpdaters = RootSuspendedAtTheShell;
	              break a;
	            case SuspendedOnImmediate:
	            case SuspendedOnData:
	            case SuspendedOnAction:
	            case SuspendedOnDeprecatedThrowPromise:
	              null === suspenseHandlerStackCursor.current && (lanes = true);
	              var reason = workInProgressSuspendedReason;
	              workInProgressSuspendedReason = NotSuspended;
	              workInProgressThrownValue = null;
	              throwAndUnwindWorkLoop(root2, unitOfWork, thrownValue, reason);
	              if (shouldYieldForPrerendering && workInProgressRootIsPrerendering) {
	                memoizedUpdaters = RootInProgress;
	                break a;
	              }
	              break;
	            default:
	              reason = workInProgressSuspendedReason, workInProgressSuspendedReason = NotSuspended, workInProgressThrownValue = null, throwAndUnwindWorkLoop(root2, unitOfWork, thrownValue, reason);
	          }
	        }
	        workLoopSync();
	        memoizedUpdaters = workInProgressRootExitStatus;
	        break;
	      } catch (thrownValue$8) {
	        handleThrow(root2, thrownValue$8);
	      }
	    while (1);
	    lanes && root2.shellSuspendCounter++;
	    resetContextDependencies();
	    executionContext = prevExecutionContext;
	    ReactSharedInternals.H = prevDispatcher;
	    ReactSharedInternals.A = prevAsyncDispatcher;
	    markRenderStopped();
	    null === workInProgress && (workInProgressRoot = null, workInProgressRootRenderLanes = 0, finishQueueingConcurrentUpdates());
	    return memoizedUpdaters;
	  }
	  function workLoopSync() {
	    for (; null !== workInProgress; ) performUnitOfWork(workInProgress);
	  }
	  function renderRootConcurrent(root2, lanes) {
	    var prevExecutionContext = executionContext;
	    executionContext |= RenderContext;
	    var prevDispatcher = pushDispatcher(), prevAsyncDispatcher = pushAsyncDispatcher();
	    if (workInProgressRoot !== root2 || workInProgressRootRenderLanes !== lanes) {
	      if (isDevToolsPresent) {
	        var memoizedUpdaters = root2.memoizedUpdaters;
	        0 < memoizedUpdaters.size && (restorePendingUpdaters(root2, workInProgressRootRenderLanes), memoizedUpdaters.clear());
	        movePendingFibersToMemoized(root2, lanes);
	      }
	      workInProgressTransitions = null;
	      workInProgressRootRenderTargetTime = now$1() + RENDER_TIMEOUT_MS;
	      prepareFreshStack(root2, lanes);
	    } else
	      workInProgressRootIsPrerendering = checkIfRootIsPrerendering(
	        root2,
	        lanes
	      );
	    markRenderStarted(lanes);
	    a: do
	      try {
	        if (workInProgressSuspendedReason !== NotSuspended && null !== workInProgress)
	          b: switch (lanes = workInProgress, memoizedUpdaters = workInProgressThrownValue, workInProgressSuspendedReason) {
	            case SuspendedOnError:
	              workInProgressSuspendedReason = NotSuspended;
	              workInProgressThrownValue = null;
	              throwAndUnwindWorkLoop(
	                root2,
	                lanes,
	                memoizedUpdaters,
	                SuspendedOnError
	              );
	              break;
	            case SuspendedOnData:
	            case SuspendedOnAction:
	              if (isThenableResolved(memoizedUpdaters)) {
	                workInProgressSuspendedReason = NotSuspended;
	                workInProgressThrownValue = null;
	                replaySuspendedUnitOfWork(lanes);
	                break;
	              }
	              lanes = function() {
	                workInProgressSuspendedReason !== SuspendedOnData && workInProgressSuspendedReason !== SuspendedOnAction || workInProgressRoot !== root2 || (workInProgressSuspendedReason = SuspendedAndReadyToContinue);
	                ensureRootIsScheduled(root2);
	              };
	              memoizedUpdaters.then(lanes, lanes);
	              break a;
	            case SuspendedOnImmediate:
	              workInProgressSuspendedReason = SuspendedAndReadyToContinue;
	              break a;
	            case SuspendedOnInstance:
	              workInProgressSuspendedReason = SuspendedOnInstanceAndReadyToContinue;
	              break a;
	            case SuspendedAndReadyToContinue:
	              isThenableResolved(memoizedUpdaters) ? (workInProgressSuspendedReason = NotSuspended, workInProgressThrownValue = null, replaySuspendedUnitOfWork(lanes)) : (workInProgressSuspendedReason = NotSuspended, workInProgressThrownValue = null, throwAndUnwindWorkLoop(
	                root2,
	                lanes,
	                memoizedUpdaters,
	                SuspendedAndReadyToContinue
	              ));
	              break;
	            case SuspendedOnInstanceAndReadyToContinue:
	              var resource = null;
	              switch (workInProgress.tag) {
	                case 26:
	                  resource = workInProgress.memoizedState;
	                case 5:
	                case 27:
	                  var hostFiber = workInProgress;
	                  if (resource ? preloadResource(resource) : 1) {
	                    workInProgressSuspendedReason = NotSuspended;
	                    workInProgressThrownValue = null;
	                    var sibling = hostFiber.sibling;
	                    if (null !== sibling) workInProgress = sibling;
	                    else {
	                      var returnFiber = hostFiber.return;
	                      null !== returnFiber ? (workInProgress = returnFiber, completeUnitOfWork(returnFiber)) : workInProgress = null;
	                    }
	                    break b;
	                  }
	                  break;
	                default:
	                  console.error(
	                    "Unexpected type of fiber triggered a suspensey commit. This is a bug in React."
	                  );
	              }
	              workInProgressSuspendedReason = NotSuspended;
	              workInProgressThrownValue = null;
	              throwAndUnwindWorkLoop(
	                root2,
	                lanes,
	                memoizedUpdaters,
	                SuspendedOnInstanceAndReadyToContinue
	              );
	              break;
	            case SuspendedOnDeprecatedThrowPromise:
	              workInProgressSuspendedReason = NotSuspended;
	              workInProgressThrownValue = null;
	              throwAndUnwindWorkLoop(
	                root2,
	                lanes,
	                memoizedUpdaters,
	                SuspendedOnDeprecatedThrowPromise
	              );
	              break;
	            case SuspendedOnHydration:
	              resetWorkInProgressStack();
	              workInProgressRootExitStatus = RootSuspendedAtTheShell;
	              break a;
	            default:
	              throw Error(
	                "Unexpected SuspendedReason. This is a bug in React."
	              );
	          }
	        null !== ReactSharedInternals.actQueue ? workLoopSync() : workLoopConcurrentByScheduler();
	        break;
	      } catch (thrownValue$9) {
	        handleThrow(root2, thrownValue$9);
	      }
	    while (1);
	    resetContextDependencies();
	    ReactSharedInternals.H = prevDispatcher;
	    ReactSharedInternals.A = prevAsyncDispatcher;
	    executionContext = prevExecutionContext;
	    if (null !== workInProgress)
	      return null !== injectedProfilingHooks && "function" === typeof injectedProfilingHooks.markRenderYielded && injectedProfilingHooks.markRenderYielded(), RootInProgress;
	    markRenderStopped();
	    workInProgressRoot = null;
	    workInProgressRootRenderLanes = 0;
	    finishQueueingConcurrentUpdates();
	    return workInProgressRootExitStatus;
	  }
	  function workLoopConcurrentByScheduler() {
	    for (; null !== workInProgress && !shouldYield(); )
	      performUnitOfWork(workInProgress);
	  }
	  function performUnitOfWork(unitOfWork) {
	    var current2 = unitOfWork.alternate;
	    (unitOfWork.mode & ProfileMode) !== NoMode ? (startProfilerTimer(unitOfWork), current2 = runWithFiberInDEV(
	      unitOfWork,
	      beginWork,
	      current2,
	      unitOfWork,
	      entangledRenderLanes
	    ), stopProfilerTimerIfRunningAndRecordDuration(unitOfWork)) : current2 = runWithFiberInDEV(
	      unitOfWork,
	      beginWork,
	      current2,
	      unitOfWork,
	      entangledRenderLanes
	    );
	    unitOfWork.memoizedProps = unitOfWork.pendingProps;
	    null === current2 ? completeUnitOfWork(unitOfWork) : workInProgress = current2;
	  }
	  function replaySuspendedUnitOfWork(unitOfWork) {
	    var next = runWithFiberInDEV(unitOfWork, replayBeginWork, unitOfWork);
	    unitOfWork.memoizedProps = unitOfWork.pendingProps;
	    null === next ? completeUnitOfWork(unitOfWork) : workInProgress = next;
	  }
	  function replayBeginWork(unitOfWork) {
	    var current2 = unitOfWork.alternate, isProfilingMode = (unitOfWork.mode & ProfileMode) !== NoMode;
	    isProfilingMode && startProfilerTimer(unitOfWork);
	    switch (unitOfWork.tag) {
	      case 15:
	      case 0:
	        current2 = replayFunctionComponent(
	          current2,
	          unitOfWork,
	          unitOfWork.pendingProps,
	          unitOfWork.type,
	          void 0,
	          workInProgressRootRenderLanes
	        );
	        break;
	      case 11:
	        current2 = replayFunctionComponent(
	          current2,
	          unitOfWork,
	          unitOfWork.pendingProps,
	          unitOfWork.type.render,
	          unitOfWork.ref,
	          workInProgressRootRenderLanes
	        );
	        break;
	      case 5:
	        resetHooksOnUnwind(unitOfWork);
	      default:
	        unwindInterruptedWork(current2, unitOfWork), unitOfWork = workInProgress = resetWorkInProgress(unitOfWork, entangledRenderLanes), current2 = beginWork(current2, unitOfWork, entangledRenderLanes);
	    }
	    isProfilingMode && stopProfilerTimerIfRunningAndRecordDuration(unitOfWork);
	    return current2;
	  }
	  function throwAndUnwindWorkLoop(root2, unitOfWork, thrownValue, suspendedReason) {
	    resetContextDependencies();
	    resetHooksOnUnwind(unitOfWork);
	    thenableState = null;
	    thenableIndexCounter = 0;
	    var returnFiber = unitOfWork.return;
	    try {
	      if (throwException(
	        root2,
	        returnFiber,
	        unitOfWork,
	        thrownValue,
	        workInProgressRootRenderLanes
	      )) {
	        workInProgressRootExitStatus = RootFatalErrored;
	        logUncaughtError(
	          root2,
	          createCapturedValueAtFiber(thrownValue, root2.current)
	        );
	        workInProgress = null;
	        return;
	      }
	    } catch (error) {
	      if (null !== returnFiber) throw workInProgress = returnFiber, error;
	      workInProgressRootExitStatus = RootFatalErrored;
	      logUncaughtError(
	        root2,
	        createCapturedValueAtFiber(thrownValue, root2.current)
	      );
	      workInProgress = null;
	      return;
	    }
	    if (unitOfWork.flags & 32768) {
	      if (isHydrating || suspendedReason === SuspendedOnError) root2 = true;
	      else if (workInProgressRootIsPrerendering || 0 !== (workInProgressRootRenderLanes & 536870912))
	        root2 = false;
	      else if (workInProgressRootDidSkipSuspendedSiblings = root2 = true, suspendedReason === SuspendedOnData || suspendedReason === SuspendedOnAction || suspendedReason === SuspendedOnImmediate || suspendedReason === SuspendedOnDeprecatedThrowPromise)
	        suspendedReason = suspenseHandlerStackCursor.current, null !== suspendedReason && 13 === suspendedReason.tag && (suspendedReason.flags |= 16384);
	      unwindUnitOfWork(unitOfWork, root2);
	    } else completeUnitOfWork(unitOfWork);
	  }
	  function completeUnitOfWork(unitOfWork) {
	    var completedWork = unitOfWork;
	    do {
	      if (0 !== (completedWork.flags & 32768)) {
	        unwindUnitOfWork(
	          completedWork,
	          workInProgressRootDidSkipSuspendedSiblings
	        );
	        return;
	      }
	      var current2 = completedWork.alternate;
	      unitOfWork = completedWork.return;
	      startProfilerTimer(completedWork);
	      current2 = runWithFiberInDEV(
	        completedWork,
	        completeWork,
	        current2,
	        completedWork,
	        entangledRenderLanes
	      );
	      (completedWork.mode & ProfileMode) !== NoMode && stopProfilerTimerIfRunningAndRecordIncompleteDuration(completedWork);
	      if (null !== current2) {
	        workInProgress = current2;
	        return;
	      }
	      completedWork = completedWork.sibling;
	      if (null !== completedWork) {
	        workInProgress = completedWork;
	        return;
	      }
	      workInProgress = completedWork = unitOfWork;
	    } while (null !== completedWork);
	    workInProgressRootExitStatus === RootInProgress && (workInProgressRootExitStatus = RootCompleted);
	  }
	  function unwindUnitOfWork(unitOfWork, skipSiblings) {
	    do {
	      var next = unwindWork(unitOfWork.alternate, unitOfWork);
	      if (null !== next) {
	        next.flags &= 32767;
	        workInProgress = next;
	        return;
	      }
	      if ((unitOfWork.mode & ProfileMode) !== NoMode) {
	        stopProfilerTimerIfRunningAndRecordIncompleteDuration(unitOfWork);
	        next = unitOfWork.actualDuration;
	        for (var child = unitOfWork.child; null !== child; )
	          next += child.actualDuration, child = child.sibling;
	        unitOfWork.actualDuration = next;
	      }
	      next = unitOfWork.return;
	      null !== next && (next.flags |= 32768, next.subtreeFlags = 0, next.deletions = null);
	      if (!skipSiblings && (unitOfWork = unitOfWork.sibling, null !== unitOfWork)) {
	        workInProgress = unitOfWork;
	        return;
	      }
	      workInProgress = unitOfWork = next;
	    } while (null !== unitOfWork);
	    workInProgressRootExitStatus = RootSuspendedAtTheShell;
	    workInProgress = null;
	  }
	  function commitRoot(root2, finishedWork, lanes, recoverableErrors, transitions, didIncludeRenderPhaseUpdate, spawnedLane, updatedLanes, suspendedRetryLanes) {
	    root2.cancelPendingCommit = null;
	    do
	      flushPendingEffects();
	    while (pendingEffectsStatus !== NO_PENDING_EFFECTS);
	    ReactStrictModeWarnings.flushLegacyContextWarning();
	    ReactStrictModeWarnings.flushPendingUnsafeLifecycleWarnings();
	    if ((executionContext & (RenderContext | CommitContext)) !== NoContext)
	      throw Error("Should not already be working.");
	    null !== injectedProfilingHooks && "function" === typeof injectedProfilingHooks.markCommitStarted && injectedProfilingHooks.markCommitStarted(lanes);
	    if (null === finishedWork) markCommitStopped();
	    else {
	      0 === lanes && console.error(
	        "finishedLanes should not be empty during a commit. This is a bug in React."
	      );
	      if (finishedWork === root2.current)
	        throw Error(
	          "Cannot commit the same tree as before. This error is likely caused by a bug in React. Please file an issue."
	        );
	      didIncludeRenderPhaseUpdate = finishedWork.lanes | finishedWork.childLanes;
	      didIncludeRenderPhaseUpdate |= concurrentlyUpdatedLanes;
	      markRootFinished(
	        root2,
	        lanes,
	        didIncludeRenderPhaseUpdate,
	        spawnedLane,
	        updatedLanes,
	        suspendedRetryLanes
	      );
	      root2 === workInProgressRoot && (workInProgress = workInProgressRoot = null, workInProgressRootRenderLanes = 0);
	      pendingFinishedWork = finishedWork;
	      pendingEffectsRoot = root2;
	      pendingEffectsLanes = lanes;
	      pendingEffectsRemainingLanes = didIncludeRenderPhaseUpdate;
	      pendingPassiveTransitions = transitions;
	      pendingRecoverableErrors = recoverableErrors;
	      0 !== (finishedWork.subtreeFlags & 10256) || 0 !== (finishedWork.flags & 10256) ? (root2.callbackNode = null, root2.callbackPriority = 0, scheduleCallback$1(NormalPriority$1, function() {
	        flushPassiveEffects();
	        return null;
	      })) : (root2.callbackNode = null, root2.callbackPriority = 0);
	      commitStartTime = now();
	      recoverableErrors = 0 !== (finishedWork.flags & 13878);
	      if (0 !== (finishedWork.subtreeFlags & 13878) || recoverableErrors) {
	        recoverableErrors = ReactSharedInternals.T;
	        ReactSharedInternals.T = null;
	        transitions = ReactDOMSharedInternals.p;
	        ReactDOMSharedInternals.p = DiscreteEventPriority;
	        spawnedLane = executionContext;
	        executionContext |= CommitContext;
	        try {
	          commitBeforeMutationEffects(root2, finishedWork, lanes);
	        } finally {
	          executionContext = spawnedLane, ReactDOMSharedInternals.p = transitions, ReactSharedInternals.T = recoverableErrors;
	        }
	      }
	      pendingEffectsStatus = PENDING_MUTATION_PHASE;
	      flushMutationEffects();
	      flushLayoutEffects();
	      flushSpawnedWork();
	    }
	  }
	  function flushMutationEffects() {
	    if (pendingEffectsStatus === PENDING_MUTATION_PHASE) {
	      pendingEffectsStatus = NO_PENDING_EFFECTS;
	      var root2 = pendingEffectsRoot, finishedWork = pendingFinishedWork, lanes = pendingEffectsLanes, rootMutationHasEffect = 0 !== (finishedWork.flags & 13878);
	      if (0 !== (finishedWork.subtreeFlags & 13878) || rootMutationHasEffect) {
	        rootMutationHasEffect = ReactSharedInternals.T;
	        ReactSharedInternals.T = null;
	        var previousPriority = ReactDOMSharedInternals.p;
	        ReactDOMSharedInternals.p = DiscreteEventPriority;
	        var prevExecutionContext = executionContext;
	        executionContext |= CommitContext;
	        try {
	          inProgressLanes = lanes;
	          inProgressRoot = root2;
	          commitMutationEffectsOnFiber(finishedWork, root2);
	          inProgressRoot = inProgressLanes = null;
	          lanes = selectionInformation;
	          var curFocusedElem = getActiveElementDeep(root2.containerInfo), priorFocusedElem = lanes.focusedElem, priorSelectionRange = lanes.selectionRange;
	          if (curFocusedElem !== priorFocusedElem && priorFocusedElem && priorFocusedElem.ownerDocument && containsNode(
	            priorFocusedElem.ownerDocument.documentElement,
	            priorFocusedElem
	          )) {
	            if (null !== priorSelectionRange && hasSelectionCapabilities(priorFocusedElem)) {
	              var start = priorSelectionRange.start, end = priorSelectionRange.end;
	              void 0 === end && (end = start);
	              if ("selectionStart" in priorFocusedElem)
	                priorFocusedElem.selectionStart = start, priorFocusedElem.selectionEnd = Math.min(
	                  end,
	                  priorFocusedElem.value.length
	                );
	              else {
	                var doc = priorFocusedElem.ownerDocument || document, win = doc && doc.defaultView || window;
	                if (win.getSelection) {
	                  var selection = win.getSelection(), length = priorFocusedElem.textContent.length, start$jscomp$0 = Math.min(
	                    priorSelectionRange.start,
	                    length
	                  ), end$jscomp$0 = void 0 === priorSelectionRange.end ? start$jscomp$0 : Math.min(priorSelectionRange.end, length);
	                  !selection.extend && start$jscomp$0 > end$jscomp$0 && (curFocusedElem = end$jscomp$0, end$jscomp$0 = start$jscomp$0, start$jscomp$0 = curFocusedElem);
	                  var startMarker = getNodeForCharacterOffset(
	                    priorFocusedElem,
	                    start$jscomp$0
	                  ), endMarker = getNodeForCharacterOffset(
	                    priorFocusedElem,
	                    end$jscomp$0
	                  );
	                  if (startMarker && endMarker && (1 !== selection.rangeCount || selection.anchorNode !== startMarker.node || selection.anchorOffset !== startMarker.offset || selection.focusNode !== endMarker.node || selection.focusOffset !== endMarker.offset)) {
	                    var range = doc.createRange();
	                    range.setStart(startMarker.node, startMarker.offset);
	                    selection.removeAllRanges();
	                    start$jscomp$0 > end$jscomp$0 ? (selection.addRange(range), selection.extend(endMarker.node, endMarker.offset)) : (range.setEnd(endMarker.node, endMarker.offset), selection.addRange(range));
	                  }
	                }
	              }
	            }
	            doc = [];
	            for (selection = priorFocusedElem; selection = selection.parentNode; )
	              1 === selection.nodeType && doc.push({
	                element: selection,
	                left: selection.scrollLeft,
	                top: selection.scrollTop
	              });
	            "function" === typeof priorFocusedElem.focus && priorFocusedElem.focus();
	            for (priorFocusedElem = 0; priorFocusedElem < doc.length; priorFocusedElem++) {
	              var info = doc[priorFocusedElem];
	              info.element.scrollLeft = info.left;
	              info.element.scrollTop = info.top;
	            }
	          }
	          _enabled = !!eventsEnabled;
	          selectionInformation = eventsEnabled = null;
	        } finally {
	          executionContext = prevExecutionContext, ReactDOMSharedInternals.p = previousPriority, ReactSharedInternals.T = rootMutationHasEffect;
	        }
	      }
	      root2.current = finishedWork;
	      pendingEffectsStatus = PENDING_LAYOUT_PHASE;
	    }
	  }
	  function flushLayoutEffects() {
	    if (pendingEffectsStatus === PENDING_LAYOUT_PHASE) {
	      pendingEffectsStatus = NO_PENDING_EFFECTS;
	      var root2 = pendingEffectsRoot, finishedWork = pendingFinishedWork, lanes = pendingEffectsLanes, rootHasLayoutEffect = 0 !== (finishedWork.flags & 8772);
	      if (0 !== (finishedWork.subtreeFlags & 8772) || rootHasLayoutEffect) {
	        rootHasLayoutEffect = ReactSharedInternals.T;
	        ReactSharedInternals.T = null;
	        var previousPriority = ReactDOMSharedInternals.p;
	        ReactDOMSharedInternals.p = DiscreteEventPriority;
	        var prevExecutionContext = executionContext;
	        executionContext |= CommitContext;
	        try {
	          null !== injectedProfilingHooks && "function" === typeof injectedProfilingHooks.markLayoutEffectsStarted && injectedProfilingHooks.markLayoutEffectsStarted(lanes), inProgressLanes = lanes, inProgressRoot = root2, commitLayoutEffectOnFiber(
	            root2,
	            finishedWork.alternate,
	            finishedWork
	          ), inProgressRoot = inProgressLanes = null, null !== injectedProfilingHooks && "function" === typeof injectedProfilingHooks.markLayoutEffectsStopped && injectedProfilingHooks.markLayoutEffectsStopped();
	        } finally {
	          executionContext = prevExecutionContext, ReactDOMSharedInternals.p = previousPriority, ReactSharedInternals.T = rootHasLayoutEffect;
	        }
	      }
	      pendingEffectsStatus = PENDING_AFTER_MUTATION_PHASE;
	    }
	  }
	  function flushSpawnedWork() {
	    if (pendingEffectsStatus === PENDING_SPAWNED_WORK || pendingEffectsStatus === PENDING_AFTER_MUTATION_PHASE) {
	      pendingEffectsStatus = NO_PENDING_EFFECTS;
	      requestPaint();
	      var root2 = pendingEffectsRoot, finishedWork = pendingFinishedWork, lanes = pendingEffectsLanes, recoverableErrors = pendingRecoverableErrors, rootDidHavePassiveEffects = 0 !== (finishedWork.subtreeFlags & 10256) || 0 !== (finishedWork.flags & 10256);
	      rootDidHavePassiveEffects ? pendingEffectsStatus = PENDING_PASSIVE_PHASE : (pendingEffectsStatus = NO_PENDING_EFFECTS, pendingFinishedWork = pendingEffectsRoot = null, releaseRootPooledCache(root2, root2.pendingLanes), nestedPassiveUpdateCount = 0, rootWithPassiveNestedUpdates = null);
	      var remainingLanes = root2.pendingLanes;
	      0 === remainingLanes && (legacyErrorBoundariesThatAlreadyFailed = null);
	      rootDidHavePassiveEffects || commitDoubleInvokeEffectsInDEV(root2);
	      rootDidHavePassiveEffects = lanesToEventPriority(lanes);
	      finishedWork = finishedWork.stateNode;
	      if (injectedHook && "function" === typeof injectedHook.onCommitFiberRoot)
	        try {
	          var didError = 128 === (finishedWork.current.flags & 128);
	          switch (rootDidHavePassiveEffects) {
	            case DiscreteEventPriority:
	              var schedulerPriority = ImmediatePriority;
	              break;
	            case ContinuousEventPriority:
	              schedulerPriority = UserBlockingPriority;
	              break;
	            case DefaultEventPriority:
	              schedulerPriority = NormalPriority$1;
	              break;
	            case IdleEventPriority:
	              schedulerPriority = IdlePriority;
	              break;
	            default:
	              schedulerPriority = NormalPriority$1;
	          }
	          injectedHook.onCommitFiberRoot(
	            rendererID,
	            finishedWork,
	            schedulerPriority,
	            didError
	          );
	        } catch (err) {
	          hasLoggedError || (hasLoggedError = true, console.error(
	            "React instrumentation encountered an error: %s",
	            err
	          ));
	        }
	      isDevToolsPresent && root2.memoizedUpdaters.clear();
	      onCommitRoot();
	      if (null !== recoverableErrors) {
	        didError = ReactSharedInternals.T;
	        schedulerPriority = ReactDOMSharedInternals.p;
	        ReactDOMSharedInternals.p = DiscreteEventPriority;
	        ReactSharedInternals.T = null;
	        try {
	          var onRecoverableError = root2.onRecoverableError;
	          for (finishedWork = 0; finishedWork < recoverableErrors.length; finishedWork++) {
	            var recoverableError = recoverableErrors[finishedWork], errorInfo = makeErrorInfo(recoverableError.stack);
	            runWithFiberInDEV(
	              recoverableError.source,
	              onRecoverableError,
	              recoverableError.value,
	              errorInfo
	            );
	          }
	        } finally {
	          ReactSharedInternals.T = didError, ReactDOMSharedInternals.p = schedulerPriority;
	        }
	      }
	      0 !== (pendingEffectsLanes & 3) && flushPendingEffects();
	      ensureRootIsScheduled(root2);
	      remainingLanes = root2.pendingLanes;
	      0 !== (lanes & 4194090) && 0 !== (remainingLanes & 42) ? (nestedUpdateScheduled = true, root2 === rootWithNestedUpdates ? nestedUpdateCount++ : (nestedUpdateCount = 0, rootWithNestedUpdates = root2)) : nestedUpdateCount = 0;
	      flushSyncWorkAcrossRoots_impl(0);
	      markCommitStopped();
	    }
	  }
	  function makeErrorInfo(componentStack) {
	    componentStack = { componentStack };
	    Object.defineProperty(componentStack, "digest", {
	      get: function() {
	        console.error(
	          'You are accessing "digest" from the errorInfo object passed to onRecoverableError. This property is no longer provided as part of errorInfo but can be accessed as a property of the Error instance itself.'
	        );
	      }
	    });
	    return componentStack;
	  }
	  function releaseRootPooledCache(root2, remainingLanes) {
	    0 === (root2.pooledCacheLanes &= remainingLanes) && (remainingLanes = root2.pooledCache, null != remainingLanes && (root2.pooledCache = null, releaseCache(remainingLanes)));
	  }
	  function flushPendingEffects(wasDelayedCommit) {
	    flushMutationEffects();
	    flushLayoutEffects();
	    flushSpawnedWork();
	    return flushPassiveEffects();
	  }
	  function flushPassiveEffects() {
	    if (pendingEffectsStatus !== PENDING_PASSIVE_PHASE) return false;
	    var root2 = pendingEffectsRoot, remainingLanes = pendingEffectsRemainingLanes;
	    pendingEffectsRemainingLanes = 0;
	    var renderPriority = lanesToEventPriority(pendingEffectsLanes), priority = DefaultEventPriority > renderPriority ? DefaultEventPriority : renderPriority;
	    renderPriority = ReactSharedInternals.T;
	    var previousPriority = ReactDOMSharedInternals.p;
	    try {
	      ReactDOMSharedInternals.p = priority;
	      ReactSharedInternals.T = null;
	      priority = pendingPassiveTransitions;
	      pendingPassiveTransitions = null;
	      var root$jscomp$0 = pendingEffectsRoot, lanes = pendingEffectsLanes;
	      pendingEffectsStatus = NO_PENDING_EFFECTS;
	      pendingFinishedWork = pendingEffectsRoot = null;
	      pendingEffectsLanes = 0;
	      if ((executionContext & (RenderContext | CommitContext)) !== NoContext)
	        throw Error("Cannot flush passive effects while already rendering.");
	      isFlushingPassiveEffects = true;
	      didScheduleUpdateDuringPassiveEffects = false;
	      null !== injectedProfilingHooks && "function" === typeof injectedProfilingHooks.markPassiveEffectsStarted && injectedProfilingHooks.markPassiveEffectsStarted(lanes);
	      var prevExecutionContext = executionContext;
	      executionContext |= CommitContext;
	      commitPassiveUnmountOnFiber(root$jscomp$0.current);
	      commitPassiveMountOnFiber(
	        root$jscomp$0,
	        root$jscomp$0.current,
	        lanes,
	        priority
	      );
	      null !== injectedProfilingHooks && "function" === typeof injectedProfilingHooks.markPassiveEffectsStopped && injectedProfilingHooks.markPassiveEffectsStopped();
	      commitDoubleInvokeEffectsInDEV(root$jscomp$0);
	      executionContext = prevExecutionContext;
	      flushSyncWorkAcrossRoots_impl(0, false);
	      didScheduleUpdateDuringPassiveEffects ? root$jscomp$0 === rootWithPassiveNestedUpdates ? nestedPassiveUpdateCount++ : (nestedPassiveUpdateCount = 0, rootWithPassiveNestedUpdates = root$jscomp$0) : nestedPassiveUpdateCount = 0;
	      didScheduleUpdateDuringPassiveEffects = isFlushingPassiveEffects = false;
	      if (injectedHook && "function" === typeof injectedHook.onPostCommitFiberRoot)
	        try {
	          injectedHook.onPostCommitFiberRoot(rendererID, root$jscomp$0);
	        } catch (err) {
	          hasLoggedError || (hasLoggedError = true, console.error(
	            "React instrumentation encountered an error: %s",
	            err
	          ));
	        }
	      var stateNode = root$jscomp$0.current.stateNode;
	      stateNode.effectDuration = 0;
	      stateNode.passiveEffectDuration = 0;
	      return true;
	    } finally {
	      ReactDOMSharedInternals.p = previousPriority, ReactSharedInternals.T = renderPriority, releaseRootPooledCache(root2, remainingLanes);
	    }
	  }
	  function captureCommitPhaseErrorOnRoot(rootFiber, sourceFiber, error) {
	    sourceFiber = createCapturedValueAtFiber(error, sourceFiber);
	    sourceFiber = createRootErrorUpdate(rootFiber.stateNode, sourceFiber, 2);
	    rootFiber = enqueueUpdate(rootFiber, sourceFiber, 2);
	    null !== rootFiber && (markRootUpdated$1(rootFiber, 2), ensureRootIsScheduled(rootFiber));
	  }
	  function captureCommitPhaseError(sourceFiber, nearestMountedAncestor, error) {
	    isRunningInsertionEffect = false;
	    if (3 === sourceFiber.tag)
	      captureCommitPhaseErrorOnRoot(sourceFiber, sourceFiber, error);
	    else {
	      for (; null !== nearestMountedAncestor; ) {
	        if (3 === nearestMountedAncestor.tag) {
	          captureCommitPhaseErrorOnRoot(
	            nearestMountedAncestor,
	            sourceFiber,
	            error
	          );
	          return;
	        }
	        if (1 === nearestMountedAncestor.tag) {
	          var instance = nearestMountedAncestor.stateNode;
	          if ("function" === typeof nearestMountedAncestor.type.getDerivedStateFromError || "function" === typeof instance.componentDidCatch && (null === legacyErrorBoundariesThatAlreadyFailed || !legacyErrorBoundariesThatAlreadyFailed.has(instance))) {
	            sourceFiber = createCapturedValueAtFiber(error, sourceFiber);
	            error = createClassErrorUpdate(2);
	            instance = enqueueUpdate(nearestMountedAncestor, error, 2);
	            null !== instance && (initializeClassErrorUpdate(
	              error,
	              instance,
	              nearestMountedAncestor,
	              sourceFiber
	            ), markRootUpdated$1(instance, 2), ensureRootIsScheduled(instance));
	            return;
	          }
	        }
	        nearestMountedAncestor = nearestMountedAncestor.return;
	      }
	      console.error(
	        "Internal React error: Attempted to capture a commit phase error inside a detached tree. This indicates a bug in React. Potential causes include deleting the same fiber more than once, committing an already-finished tree, or an inconsistent return pointer.\n\nError message:\n\n%s",
	        error
	      );
	    }
	  }
	  function attachPingListener(root2, wakeable, lanes) {
	    var pingCache = root2.pingCache;
	    if (null === pingCache) {
	      pingCache = root2.pingCache = new PossiblyWeakMap();
	      var threadIDs = /* @__PURE__ */ new Set();
	      pingCache.set(wakeable, threadIDs);
	    } else
	      threadIDs = pingCache.get(wakeable), void 0 === threadIDs && (threadIDs = /* @__PURE__ */ new Set(), pingCache.set(wakeable, threadIDs));
	    threadIDs.has(lanes) || (workInProgressRootDidAttachPingListener = true, threadIDs.add(lanes), pingCache = pingSuspendedRoot.bind(null, root2, wakeable, lanes), isDevToolsPresent && restorePendingUpdaters(root2, lanes), wakeable.then(pingCache, pingCache));
	  }
	  function pingSuspendedRoot(root2, wakeable, pingedLanes) {
	    var pingCache = root2.pingCache;
	    null !== pingCache && pingCache.delete(wakeable);
	    root2.pingedLanes |= root2.suspendedLanes & pingedLanes;
	    root2.warmLanes &= ~pingedLanes;
	    isConcurrentActEnvironment() && null === ReactSharedInternals.actQueue && console.error(
	      "A suspended resource finished loading inside a test, but the event was not wrapped in act(...).\n\nWhen testing, code that resolves suspended data should be wrapped into act(...):\n\nact(() => {\n  /* finish loading suspended data */\n});\n/* assert on the output */\n\nThis ensures that you're testing the behavior the user would see in the browser. Learn more at https://react.dev/link/wrap-tests-with-act"
	    );
	    workInProgressRoot === root2 && (workInProgressRootRenderLanes & pingedLanes) === pingedLanes && (workInProgressRootExitStatus === RootSuspendedWithDelay || workInProgressRootExitStatus === RootSuspended && (workInProgressRootRenderLanes & 62914560) === workInProgressRootRenderLanes && now$1() - globalMostRecentFallbackTime < FALLBACK_THROTTLE_MS ? (executionContext & RenderContext) === NoContext && prepareFreshStack(root2, 0) : workInProgressRootPingedLanes |= pingedLanes, workInProgressSuspendedRetryLanes === workInProgressRootRenderLanes && (workInProgressSuspendedRetryLanes = 0));
	    ensureRootIsScheduled(root2);
	  }
	  function retryTimedOutBoundary(boundaryFiber, retryLane) {
	    0 === retryLane && (retryLane = claimNextRetryLane());
	    boundaryFiber = enqueueConcurrentRenderForLane(boundaryFiber, retryLane);
	    null !== boundaryFiber && (markRootUpdated$1(boundaryFiber, retryLane), ensureRootIsScheduled(boundaryFiber));
	  }
	  function retryDehydratedSuspenseBoundary(boundaryFiber) {
	    var suspenseState = boundaryFiber.memoizedState, retryLane = 0;
	    null !== suspenseState && (retryLane = suspenseState.retryLane);
	    retryTimedOutBoundary(boundaryFiber, retryLane);
	  }
	  function resolveRetryWakeable(boundaryFiber, wakeable) {
	    var retryLane = 0;
	    switch (boundaryFiber.tag) {
	      case 13:
	        var retryCache = boundaryFiber.stateNode;
	        var suspenseState = boundaryFiber.memoizedState;
	        null !== suspenseState && (retryLane = suspenseState.retryLane);
	        break;
	      case 19:
	        retryCache = boundaryFiber.stateNode;
	        break;
	      case 22:
	        retryCache = boundaryFiber.stateNode._retryCache;
	        break;
	      default:
	        throw Error(
	          "Pinged unknown suspense boundary type. This is probably a bug in React."
	        );
	    }
	    null !== retryCache && retryCache.delete(wakeable);
	    retryTimedOutBoundary(boundaryFiber, retryLane);
	  }
	  function recursivelyTraverseAndDoubleInvokeEffectsInDEV(root$jscomp$0, parentFiber, isInStrictMode) {
	    if (0 !== (parentFiber.subtreeFlags & 67117056))
	      for (parentFiber = parentFiber.child; null !== parentFiber; ) {
	        var root2 = root$jscomp$0, fiber = parentFiber, isStrictModeFiber = fiber.type === REACT_STRICT_MODE_TYPE;
	        isStrictModeFiber = isInStrictMode || isStrictModeFiber;
	        22 !== fiber.tag ? fiber.flags & 67108864 ? isStrictModeFiber && runWithFiberInDEV(
	          fiber,
	          doubleInvokeEffectsOnFiber,
	          root2,
	          fiber,
	          (fiber.mode & NoStrictPassiveEffectsMode) === NoMode
	        ) : recursivelyTraverseAndDoubleInvokeEffectsInDEV(
	          root2,
	          fiber,
	          isStrictModeFiber
	        ) : null === fiber.memoizedState && (isStrictModeFiber && fiber.flags & 8192 ? runWithFiberInDEV(
	          fiber,
	          doubleInvokeEffectsOnFiber,
	          root2,
	          fiber
	        ) : fiber.subtreeFlags & 67108864 && runWithFiberInDEV(
	          fiber,
	          recursivelyTraverseAndDoubleInvokeEffectsInDEV,
	          root2,
	          fiber,
	          isStrictModeFiber
	        ));
	        parentFiber = parentFiber.sibling;
	      }
	  }
	  function doubleInvokeEffectsOnFiber(root2, fiber) {
	    var shouldDoubleInvokePassiveEffects = 2 < arguments.length && void 0 !== arguments[2] ? arguments[2] : true;
	    setIsStrictModeForDevtools(true);
	    try {
	      disappearLayoutEffects(fiber), shouldDoubleInvokePassiveEffects && disconnectPassiveEffect(fiber), reappearLayoutEffects(root2, fiber.alternate, fiber, false), shouldDoubleInvokePassiveEffects && reconnectPassiveEffects(root2, fiber, 0, null, false, 0);
	    } finally {
	      setIsStrictModeForDevtools(false);
	    }
	  }
	  function commitDoubleInvokeEffectsInDEV(root2) {
	    var doubleInvokeEffects = true;
	    root2.current.mode & (StrictLegacyMode | StrictEffectsMode) || (doubleInvokeEffects = false);
	    recursivelyTraverseAndDoubleInvokeEffectsInDEV(
	      root2,
	      root2.current,
	      doubleInvokeEffects
	    );
	  }
	  function warnAboutUpdateOnNotYetMountedFiberInDEV(fiber) {
	    if ((executionContext & RenderContext) === NoContext) {
	      var tag = fiber.tag;
	      if (3 === tag || 1 === tag || 0 === tag || 11 === tag || 14 === tag || 15 === tag) {
	        tag = getComponentNameFromFiber(fiber) || "ReactComponent";
	        if (null !== didWarnStateUpdateForNotYetMountedComponent) {
	          if (didWarnStateUpdateForNotYetMountedComponent.has(tag)) return;
	          didWarnStateUpdateForNotYetMountedComponent.add(tag);
	        } else didWarnStateUpdateForNotYetMountedComponent = /* @__PURE__ */ new Set([tag]);
	        runWithFiberInDEV(fiber, function() {
	          console.error(
	            "Can't perform a React state update on a component that hasn't mounted yet. This indicates that you have a side-effect in your render function that asynchronously later calls tries to update the component. Move this work to useEffect instead."
	          );
	        });
	      }
	    }
	  }
	  function restorePendingUpdaters(root2, lanes) {
	    isDevToolsPresent && root2.memoizedUpdaters.forEach(function(schedulingFiber) {
	      addFiberToLanesMap(root2, schedulingFiber, lanes);
	    });
	  }
	  function scheduleCallback$1(priorityLevel, callback) {
	    var actQueue = ReactSharedInternals.actQueue;
	    return null !== actQueue ? (actQueue.push(callback), fakeActCallbackNode$1) : scheduleCallback$3(priorityLevel, callback);
	  }
	  function warnIfUpdatesNotWrappedWithActDEV(fiber) {
	    isConcurrentActEnvironment() && null === ReactSharedInternals.actQueue && runWithFiberInDEV(fiber, function() {
	      console.error(
	        "An update to %s inside a test was not wrapped in act(...).\n\nWhen testing, code that causes React state updates should be wrapped into act(...):\n\nact(() => {\n  /* fire events that update state */\n});\n/* assert on the output */\n\nThis ensures that you're testing the behavior the user would see in the browser. Learn more at https://react.dev/link/wrap-tests-with-act",
	        getComponentNameFromFiber(fiber)
	      );
	    });
	  }
	  function ensureRootIsScheduled(root2) {
	    root2 !== lastScheduledRoot && null === root2.next && (null === lastScheduledRoot ? firstScheduledRoot = lastScheduledRoot = root2 : lastScheduledRoot = lastScheduledRoot.next = root2);
	    mightHavePendingSyncWork = true;
	    null !== ReactSharedInternals.actQueue ? didScheduleMicrotask_act || (didScheduleMicrotask_act = true, scheduleImmediateRootScheduleTask()) : didScheduleMicrotask || (didScheduleMicrotask = true, scheduleImmediateRootScheduleTask());
	  }
	  function flushSyncWorkAcrossRoots_impl(syncTransitionLanes, onlyLegacy) {
	    if (!isFlushingWork && mightHavePendingSyncWork) {
	      isFlushingWork = true;
	      do {
	        var didPerformSomeWork = false;
	        for (var root2 = firstScheduledRoot; null !== root2; ) {
	          if (0 !== syncTransitionLanes) {
	              var pendingLanes = root2.pendingLanes;
	              if (0 === pendingLanes) var nextLanes = 0;
	              else {
	                var suspendedLanes = root2.suspendedLanes, pingedLanes = root2.pingedLanes;
	                nextLanes = (1 << 31 - clz32(42 | syncTransitionLanes) + 1) - 1;
	                nextLanes &= pendingLanes & ~(suspendedLanes & ~pingedLanes);
	                nextLanes = nextLanes & 201326741 ? nextLanes & 201326741 | 1 : nextLanes ? nextLanes | 2 : 0;
	              }
	              0 !== nextLanes && (didPerformSomeWork = true, performSyncWorkOnRoot(root2, nextLanes));
	            } else
	              nextLanes = workInProgressRootRenderLanes, nextLanes = getNextLanes(
	                root2,
	                root2 === workInProgressRoot ? nextLanes : 0,
	                null !== root2.cancelPendingCommit || root2.timeoutHandle !== noTimeout
	              ), 0 === (nextLanes & 3) || checkIfRootIsPrerendering(root2, nextLanes) || (didPerformSomeWork = true, performSyncWorkOnRoot(root2, nextLanes));
	          root2 = root2.next;
	        }
	      } while (didPerformSomeWork);
	      isFlushingWork = false;
	    }
	  }
	  function processRootScheduleInImmediateTask() {
	    processRootScheduleInMicrotask();
	  }
	  function processRootScheduleInMicrotask() {
	    mightHavePendingSyncWork = didScheduleMicrotask_act = didScheduleMicrotask = false;
	    var syncTransitionLanes = 0;
	    0 !== currentEventTransitionLane && (shouldAttemptEagerTransition() && (syncTransitionLanes = currentEventTransitionLane), currentEventTransitionLane = 0);
	    for (var currentTime = now$1(), prev = null, root2 = firstScheduledRoot; null !== root2; ) {
	      var next = root2.next, nextLanes = scheduleTaskForRootDuringMicrotask(root2, currentTime);
	      if (0 === nextLanes)
	        root2.next = null, null === prev ? firstScheduledRoot = next : prev.next = next, null === next && (lastScheduledRoot = prev);
	      else if (prev = root2, 0 !== syncTransitionLanes || 0 !== (nextLanes & 3))
	        mightHavePendingSyncWork = true;
	      root2 = next;
	    }
	    flushSyncWorkAcrossRoots_impl(syncTransitionLanes);
	  }
	  function scheduleTaskForRootDuringMicrotask(root2, currentTime) {
	    for (var suspendedLanes = root2.suspendedLanes, pingedLanes = root2.pingedLanes, expirationTimes = root2.expirationTimes, lanes = root2.pendingLanes & -62914561; 0 < lanes; ) {
	      var index = 31 - clz32(lanes), lane = 1 << index, expirationTime = expirationTimes[index];
	      if (-1 === expirationTime) {
	        if (0 === (lane & suspendedLanes) || 0 !== (lane & pingedLanes))
	          expirationTimes[index] = computeExpirationTime(lane, currentTime);
	      } else expirationTime <= currentTime && (root2.expiredLanes |= lane);
	      lanes &= ~lane;
	    }
	    currentTime = workInProgressRoot;
	    suspendedLanes = workInProgressRootRenderLanes;
	    suspendedLanes = getNextLanes(
	      root2,
	      root2 === currentTime ? suspendedLanes : 0,
	      null !== root2.cancelPendingCommit || root2.timeoutHandle !== noTimeout
	    );
	    pingedLanes = root2.callbackNode;
	    if (0 === suspendedLanes || root2 === currentTime && (workInProgressSuspendedReason === SuspendedOnData || workInProgressSuspendedReason === SuspendedOnAction) || null !== root2.cancelPendingCommit)
	      return null !== pingedLanes && cancelCallback(pingedLanes), root2.callbackNode = null, root2.callbackPriority = 0;
	    if (0 === (suspendedLanes & 3) || checkIfRootIsPrerendering(root2, suspendedLanes)) {
	      currentTime = suspendedLanes & -suspendedLanes;
	      if (currentTime !== root2.callbackPriority || null !== ReactSharedInternals.actQueue && pingedLanes !== fakeActCallbackNode)
	        cancelCallback(pingedLanes);
	      else return currentTime;
	      switch (lanesToEventPriority(suspendedLanes)) {
	        case DiscreteEventPriority:
	        case ContinuousEventPriority:
	          suspendedLanes = UserBlockingPriority;
	          break;
	        case DefaultEventPriority:
	          suspendedLanes = NormalPriority$1;
	          break;
	        case IdleEventPriority:
	          suspendedLanes = IdlePriority;
	          break;
	        default:
	          suspendedLanes = NormalPriority$1;
	      }
	      pingedLanes = performWorkOnRootViaSchedulerTask.bind(null, root2);
	      null !== ReactSharedInternals.actQueue ? (ReactSharedInternals.actQueue.push(pingedLanes), suspendedLanes = fakeActCallbackNode) : suspendedLanes = scheduleCallback$3(suspendedLanes, pingedLanes);
	      root2.callbackPriority = currentTime;
	      root2.callbackNode = suspendedLanes;
	      return currentTime;
	    }
	    null !== pingedLanes && cancelCallback(pingedLanes);
	    root2.callbackPriority = 2;
	    root2.callbackNode = null;
	    return 2;
	  }
	  function performWorkOnRootViaSchedulerTask(root2, didTimeout) {
	    nestedUpdateScheduled = currentUpdateIsNested = false;
	    if (pendingEffectsStatus !== NO_PENDING_EFFECTS && pendingEffectsStatus !== PENDING_PASSIVE_PHASE)
	      return root2.callbackNode = null, root2.callbackPriority = 0, null;
	    var originalCallbackNode = root2.callbackNode;
	    if (flushPendingEffects() && root2.callbackNode !== originalCallbackNode)
	      return null;
	    var workInProgressRootRenderLanes$jscomp$0 = workInProgressRootRenderLanes;
	    workInProgressRootRenderLanes$jscomp$0 = getNextLanes(
	      root2,
	      root2 === workInProgressRoot ? workInProgressRootRenderLanes$jscomp$0 : 0,
	      null !== root2.cancelPendingCommit || root2.timeoutHandle !== noTimeout
	    );
	    if (0 === workInProgressRootRenderLanes$jscomp$0) return null;
	    performWorkOnRoot(
	      root2,
	      workInProgressRootRenderLanes$jscomp$0,
	      didTimeout
	    );
	    scheduleTaskForRootDuringMicrotask(root2, now$1());
	    return null != root2.callbackNode && root2.callbackNode === originalCallbackNode ? performWorkOnRootViaSchedulerTask.bind(null, root2) : null;
	  }
	  function performSyncWorkOnRoot(root2, lanes) {
	    if (flushPendingEffects()) return null;
	    currentUpdateIsNested = nestedUpdateScheduled;
	    nestedUpdateScheduled = false;
	    performWorkOnRoot(root2, lanes, true);
	  }
	  function cancelCallback(callbackNode) {
	    callbackNode !== fakeActCallbackNode && null !== callbackNode && cancelCallback$1(callbackNode);
	  }
	  function scheduleImmediateRootScheduleTask() {
	    null !== ReactSharedInternals.actQueue && ReactSharedInternals.actQueue.push(function() {
	      processRootScheduleInMicrotask();
	      return null;
	    });
	    scheduleMicrotask(function() {
	      (executionContext & (RenderContext | CommitContext)) !== NoContext ? scheduleCallback$3(
	        ImmediatePriority,
	        processRootScheduleInImmediateTask
	      ) : processRootScheduleInMicrotask();
	    });
	  }
	  function requestTransitionLane() {
	    0 === currentEventTransitionLane && (currentEventTransitionLane = claimNextTransitionLane());
	    return currentEventTransitionLane;
	  }
	  function coerceFormActionProp(actionProp) {
	    if (null == actionProp || "symbol" === typeof actionProp || "boolean" === typeof actionProp)
	      return null;
	    if ("function" === typeof actionProp) return actionProp;
	    checkAttributeStringCoercion(actionProp, "action");
	    return sanitizeURL("" + actionProp);
	  }
	  function createFormDataWithSubmitter(form, submitter) {
	    var temp = submitter.ownerDocument.createElement("input");
	    temp.name = submitter.name;
	    temp.value = submitter.value;
	    form.id && temp.setAttribute("form", form.id);
	    submitter.parentNode.insertBefore(temp, submitter);
	    form = new FormData(form);
	    temp.parentNode.removeChild(temp);
	    return form;
	  }
	  function extractEvents$1(dispatchQueue, domEventName, maybeTargetInst, nativeEvent, nativeEventTarget) {
	    if ("submit" === domEventName && maybeTargetInst && maybeTargetInst.stateNode === nativeEventTarget) {
	      var action = coerceFormActionProp(
	        (nativeEventTarget[internalPropsKey] || null).action
	      ), submitter = nativeEvent.submitter;
	      submitter && (domEventName = (domEventName = submitter[internalPropsKey] || null) ? coerceFormActionProp(domEventName.formAction) : submitter.getAttribute("formAction"), null !== domEventName && (action = domEventName, submitter = null));
	      var event = new SyntheticEvent(
	        "action",
	        "action",
	        null,
	        nativeEvent,
	        nativeEventTarget
	      );
	      dispatchQueue.push({
	        event,
	        listeners: [
	          {
	            instance: null,
	            listener: function() {
	              if (nativeEvent.defaultPrevented) {
	                if (0 !== currentEventTransitionLane) {
	                  var formData = submitter ? createFormDataWithSubmitter(
	                    nativeEventTarget,
	                    submitter
	                  ) : new FormData(nativeEventTarget), pendingState = {
	                    pending: true,
	                    data: formData,
	                    method: nativeEventTarget.method,
	                    action
	                  };
	                  Object.freeze(pendingState);
	                  startHostTransition(
	                    maybeTargetInst,
	                    pendingState,
	                    null,
	                    formData
	                  );
	                }
	              } else
	                "function" === typeof action && (event.preventDefault(), formData = submitter ? createFormDataWithSubmitter(
	                  nativeEventTarget,
	                  submitter
	                ) : new FormData(nativeEventTarget), pendingState = {
	                  pending: true,
	                  data: formData,
	                  method: nativeEventTarget.method,
	                  action
	                }, Object.freeze(pendingState), startHostTransition(
	                  maybeTargetInst,
	                  pendingState,
	                  action,
	                  formData
	                ));
	            },
	            currentTarget: nativeEventTarget
	          }
	        ]
	      });
	    }
	  }
	  function executeDispatch(event, listener, currentTarget) {
	    event.currentTarget = currentTarget;
	    try {
	      listener(event);
	    } catch (error) {
	      reportGlobalError(error);
	    }
	    event.currentTarget = null;
	  }
	  function processDispatchQueue(dispatchQueue, eventSystemFlags) {
	    eventSystemFlags = 0 !== (eventSystemFlags & 4);
	    for (var i = 0; i < dispatchQueue.length; i++) {
	      var _dispatchQueue$i = dispatchQueue[i];
	      a: {
	        var previousInstance = void 0, event = _dispatchQueue$i.event;
	        _dispatchQueue$i = _dispatchQueue$i.listeners;
	        if (eventSystemFlags)
	          for (var i$jscomp$0 = _dispatchQueue$i.length - 1; 0 <= i$jscomp$0; i$jscomp$0--) {
	            var _dispatchListeners$i = _dispatchQueue$i[i$jscomp$0], instance = _dispatchListeners$i.instance, currentTarget = _dispatchListeners$i.currentTarget;
	            _dispatchListeners$i = _dispatchListeners$i.listener;
	            if (instance !== previousInstance && event.isPropagationStopped())
	              break a;
	            null !== instance ? runWithFiberInDEV(
	              instance,
	              executeDispatch,
	              event,
	              _dispatchListeners$i,
	              currentTarget
	            ) : executeDispatch(event, _dispatchListeners$i, currentTarget);
	            previousInstance = instance;
	          }
	        else
	          for (i$jscomp$0 = 0; i$jscomp$0 < _dispatchQueue$i.length; i$jscomp$0++) {
	            _dispatchListeners$i = _dispatchQueue$i[i$jscomp$0];
	            instance = _dispatchListeners$i.instance;
	            currentTarget = _dispatchListeners$i.currentTarget;
	            _dispatchListeners$i = _dispatchListeners$i.listener;
	            if (instance !== previousInstance && event.isPropagationStopped())
	              break a;
	            null !== instance ? runWithFiberInDEV(
	              instance,
	              executeDispatch,
	              event,
	              _dispatchListeners$i,
	              currentTarget
	            ) : executeDispatch(event, _dispatchListeners$i, currentTarget);
	            previousInstance = instance;
	          }
	      }
	    }
	  }
	  function listenToNonDelegatedEvent(domEventName, targetElement) {
	    nonDelegatedEvents.has(domEventName) || console.error(
	      'Did not expect a listenToNonDelegatedEvent() call for "%s". This is a bug in React. Please file an issue.',
	      domEventName
	    );
	    var listenerSet = targetElement[internalEventHandlersKey];
	    void 0 === listenerSet && (listenerSet = targetElement[internalEventHandlersKey] = /* @__PURE__ */ new Set());
	    var listenerSetKey = domEventName + "__bubble";
	    listenerSet.has(listenerSetKey) || (addTrappedEventListener(targetElement, domEventName, 2, false), listenerSet.add(listenerSetKey));
	  }
	  function listenToNativeEvent(domEventName, isCapturePhaseListener, target) {
	    nonDelegatedEvents.has(domEventName) && !isCapturePhaseListener && console.error(
	      'Did not expect a listenToNativeEvent() call for "%s" in the bubble phase. This is a bug in React. Please file an issue.',
	      domEventName
	    );
	    var eventSystemFlags = 0;
	    isCapturePhaseListener && (eventSystemFlags |= 4);
	    addTrappedEventListener(
	      target,
	      domEventName,
	      eventSystemFlags,
	      isCapturePhaseListener
	    );
	  }
	  function listenToAllSupportedEvents(rootContainerElement) {
	    if (!rootContainerElement[listeningMarker]) {
	      rootContainerElement[listeningMarker] = true;
	      allNativeEvents.forEach(function(domEventName) {
	        "selectionchange" !== domEventName && (nonDelegatedEvents.has(domEventName) || listenToNativeEvent(domEventName, false, rootContainerElement), listenToNativeEvent(domEventName, true, rootContainerElement));
	      });
	      var ownerDocument = 9 === rootContainerElement.nodeType ? rootContainerElement : rootContainerElement.ownerDocument;
	      null === ownerDocument || ownerDocument[listeningMarker] || (ownerDocument[listeningMarker] = true, listenToNativeEvent("selectionchange", false, ownerDocument));
	    }
	  }
	  function addTrappedEventListener(targetContainer, domEventName, eventSystemFlags, isCapturePhaseListener) {
	    switch (getEventPriority(domEventName)) {
	      case DiscreteEventPriority:
	        var listenerWrapper = dispatchDiscreteEvent;
	        break;
	      case ContinuousEventPriority:
	        listenerWrapper = dispatchContinuousEvent;
	        break;
	      default:
	        listenerWrapper = dispatchEvent;
	    }
	    eventSystemFlags = listenerWrapper.bind(
	      null,
	      domEventName,
	      eventSystemFlags,
	      targetContainer
	    );
	    listenerWrapper = void 0;
	    !passiveBrowserEventsSupported || "touchstart" !== domEventName && "touchmove" !== domEventName && "wheel" !== domEventName || (listenerWrapper = true);
	    isCapturePhaseListener ? void 0 !== listenerWrapper ? targetContainer.addEventListener(domEventName, eventSystemFlags, {
	      capture: true,
	      passive: listenerWrapper
	    }) : targetContainer.addEventListener(domEventName, eventSystemFlags, true) : void 0 !== listenerWrapper ? targetContainer.addEventListener(domEventName, eventSystemFlags, {
	      passive: listenerWrapper
	    }) : targetContainer.addEventListener(
	      domEventName,
	      eventSystemFlags,
	      false
	    );
	  }
	  function dispatchEventForPluginEventSystem(domEventName, eventSystemFlags, nativeEvent, targetInst$jscomp$0, targetContainer) {
	    var ancestorInst = targetInst$jscomp$0;
	    if (0 === (eventSystemFlags & 1) && 0 === (eventSystemFlags & 2) && null !== targetInst$jscomp$0)
	      a: for (; ; ) {
	        if (null === targetInst$jscomp$0) return;
	        var nodeTag = targetInst$jscomp$0.tag;
	        if (3 === nodeTag || 4 === nodeTag) {
	          var container = targetInst$jscomp$0.stateNode.containerInfo;
	          if (container === targetContainer) break;
	          if (4 === nodeTag)
	            for (nodeTag = targetInst$jscomp$0.return; null !== nodeTag; ) {
	              var grandTag = nodeTag.tag;
	              if ((3 === grandTag || 4 === grandTag) && nodeTag.stateNode.containerInfo === targetContainer)
	                return;
	              nodeTag = nodeTag.return;
	            }
	          for (; null !== container; ) {
	            nodeTag = getClosestInstanceFromNode(container);
	            if (null === nodeTag) return;
	            grandTag = nodeTag.tag;
	            if (5 === grandTag || 6 === grandTag || 26 === grandTag || 27 === grandTag) {
	              targetInst$jscomp$0 = ancestorInst = nodeTag;
	              continue a;
	            }
	            container = container.parentNode;
	          }
	        }
	        targetInst$jscomp$0 = targetInst$jscomp$0.return;
	      }
	    batchedUpdates$1(function() {
	      var targetInst = ancestorInst, nativeEventTarget = getEventTarget(nativeEvent), dispatchQueue = [];
	      a: {
	        var reactName = topLevelEventsToReactNames.get(domEventName);
	        if (void 0 !== reactName) {
	          var SyntheticEventCtor = SyntheticEvent, reactEventType = domEventName;
	          switch (domEventName) {
	            case "keypress":
	              if (0 === getEventCharCode(nativeEvent)) break a;
	            case "keydown":
	            case "keyup":
	              SyntheticEventCtor = SyntheticKeyboardEvent;
	              break;
	            case "focusin":
	              reactEventType = "focus";
	              SyntheticEventCtor = SyntheticFocusEvent;
	              break;
	            case "focusout":
	              reactEventType = "blur";
	              SyntheticEventCtor = SyntheticFocusEvent;
	              break;
	            case "beforeblur":
	            case "afterblur":
	              SyntheticEventCtor = SyntheticFocusEvent;
	              break;
	            case "click":
	              if (2 === nativeEvent.button) break a;
	            case "auxclick":
	            case "dblclick":
	            case "mousedown":
	            case "mousemove":
	            case "mouseup":
	            case "mouseout":
	            case "mouseover":
	            case "contextmenu":
	              SyntheticEventCtor = SyntheticMouseEvent;
	              break;
	            case "drag":
	            case "dragend":
	            case "dragenter":
	            case "dragexit":
	            case "dragleave":
	            case "dragover":
	            case "dragstart":
	            case "drop":
	              SyntheticEventCtor = SyntheticDragEvent;
	              break;
	            case "touchcancel":
	            case "touchend":
	            case "touchmove":
	            case "touchstart":
	              SyntheticEventCtor = SyntheticTouchEvent;
	              break;
	            case ANIMATION_END:
	            case ANIMATION_ITERATION:
	            case ANIMATION_START:
	              SyntheticEventCtor = SyntheticAnimationEvent;
	              break;
	            case TRANSITION_END:
	              SyntheticEventCtor = SyntheticTransitionEvent;
	              break;
	            case "scroll":
	            case "scrollend":
	              SyntheticEventCtor = SyntheticUIEvent;
	              break;
	            case "wheel":
	              SyntheticEventCtor = SyntheticWheelEvent;
	              break;
	            case "copy":
	            case "cut":
	            case "paste":
	              SyntheticEventCtor = SyntheticClipboardEvent;
	              break;
	            case "gotpointercapture":
	            case "lostpointercapture":
	            case "pointercancel":
	            case "pointerdown":
	            case "pointermove":
	            case "pointerout":
	            case "pointerover":
	            case "pointerup":
	              SyntheticEventCtor = SyntheticPointerEvent;
	              break;
	            case "toggle":
	            case "beforetoggle":
	              SyntheticEventCtor = SyntheticToggleEvent;
	          }
	          var inCapturePhase = 0 !== (eventSystemFlags & 4), accumulateTargetOnly = !inCapturePhase && ("scroll" === domEventName || "scrollend" === domEventName), reactEventName = inCapturePhase ? null !== reactName ? reactName + "Capture" : null : reactName;
	          inCapturePhase = [];
	          for (var instance = targetInst, lastHostComponent; null !== instance; ) {
	            var _instance2 = instance;
	            lastHostComponent = _instance2.stateNode;
	            _instance2 = _instance2.tag;
	            5 !== _instance2 && 26 !== _instance2 && 27 !== _instance2 || null === lastHostComponent || null === reactEventName || (_instance2 = getListener(instance, reactEventName), null != _instance2 && inCapturePhase.push(
	              createDispatchListener(
	                instance,
	                _instance2,
	                lastHostComponent
	              )
	            ));
	            if (accumulateTargetOnly) break;
	            instance = instance.return;
	          }
	          0 < inCapturePhase.length && (reactName = new SyntheticEventCtor(
	            reactName,
	            reactEventType,
	            null,
	            nativeEvent,
	            nativeEventTarget
	          ), dispatchQueue.push({
	            event: reactName,
	            listeners: inCapturePhase
	          }));
	        }
	      }
	      if (0 === (eventSystemFlags & 7)) {
	        a: {
	          reactName = "mouseover" === domEventName || "pointerover" === domEventName;
	          SyntheticEventCtor = "mouseout" === domEventName || "pointerout" === domEventName;
	          if (reactName && nativeEvent !== currentReplayingEvent && (reactEventType = nativeEvent.relatedTarget || nativeEvent.fromElement) && (getClosestInstanceFromNode(reactEventType) || reactEventType[internalContainerInstanceKey]))
	            break a;
	          if (SyntheticEventCtor || reactName) {
	            reactName = nativeEventTarget.window === nativeEventTarget ? nativeEventTarget : (reactName = nativeEventTarget.ownerDocument) ? reactName.defaultView || reactName.parentWindow : window;
	            if (SyntheticEventCtor) {
	              if (reactEventType = nativeEvent.relatedTarget || nativeEvent.toElement, SyntheticEventCtor = targetInst, reactEventType = reactEventType ? getClosestInstanceFromNode(reactEventType) : null, null !== reactEventType && (accumulateTargetOnly = getNearestMountedFiber(reactEventType), inCapturePhase = reactEventType.tag, reactEventType !== accumulateTargetOnly || 5 !== inCapturePhase && 27 !== inCapturePhase && 6 !== inCapturePhase))
	                reactEventType = null;
	            } else SyntheticEventCtor = null, reactEventType = targetInst;
	            if (SyntheticEventCtor !== reactEventType) {
	              inCapturePhase = SyntheticMouseEvent;
	              _instance2 = "onMouseLeave";
	              reactEventName = "onMouseEnter";
	              instance = "mouse";
	              if ("pointerout" === domEventName || "pointerover" === domEventName)
	                inCapturePhase = SyntheticPointerEvent, _instance2 = "onPointerLeave", reactEventName = "onPointerEnter", instance = "pointer";
	              accumulateTargetOnly = null == SyntheticEventCtor ? reactName : getNodeFromInstance(SyntheticEventCtor);
	              lastHostComponent = null == reactEventType ? reactName : getNodeFromInstance(reactEventType);
	              reactName = new inCapturePhase(
	                _instance2,
	                instance + "leave",
	                SyntheticEventCtor,
	                nativeEvent,
	                nativeEventTarget
	              );
	              reactName.target = accumulateTargetOnly;
	              reactName.relatedTarget = lastHostComponent;
	              _instance2 = null;
	              getClosestInstanceFromNode(nativeEventTarget) === targetInst && (inCapturePhase = new inCapturePhase(
	                reactEventName,
	                instance + "enter",
	                reactEventType,
	                nativeEvent,
	                nativeEventTarget
	              ), inCapturePhase.target = lastHostComponent, inCapturePhase.relatedTarget = accumulateTargetOnly, _instance2 = inCapturePhase);
	              accumulateTargetOnly = _instance2;
	              if (SyntheticEventCtor && reactEventType)
	                b: {
	                  inCapturePhase = SyntheticEventCtor;
	                  reactEventName = reactEventType;
	                  instance = 0;
	                  for (lastHostComponent = inCapturePhase; lastHostComponent; lastHostComponent = getParent(lastHostComponent))
	                    instance++;
	                  lastHostComponent = 0;
	                  for (_instance2 = reactEventName; _instance2; _instance2 = getParent(_instance2))
	                    lastHostComponent++;
	                  for (; 0 < instance - lastHostComponent; )
	                    inCapturePhase = getParent(inCapturePhase), instance--;
	                  for (; 0 < lastHostComponent - instance; )
	                    reactEventName = getParent(reactEventName), lastHostComponent--;
	                  for (; instance--; ) {
	                    if (inCapturePhase === reactEventName || null !== reactEventName && inCapturePhase === reactEventName.alternate)
	                      break b;
	                    inCapturePhase = getParent(inCapturePhase);
	                    reactEventName = getParent(reactEventName);
	                  }
	                  inCapturePhase = null;
	                }
	              else inCapturePhase = null;
	              null !== SyntheticEventCtor && accumulateEnterLeaveListenersForEvent(
	                dispatchQueue,
	                reactName,
	                SyntheticEventCtor,
	                inCapturePhase,
	                false
	              );
	              null !== reactEventType && null !== accumulateTargetOnly && accumulateEnterLeaveListenersForEvent(
	                dispatchQueue,
	                accumulateTargetOnly,
	                reactEventType,
	                inCapturePhase,
	                true
	              );
	            }
	          }
	        }
	        a: {
	          reactName = targetInst ? getNodeFromInstance(targetInst) : window;
	          SyntheticEventCtor = reactName.nodeName && reactName.nodeName.toLowerCase();
	          if ("select" === SyntheticEventCtor || "input" === SyntheticEventCtor && "file" === reactName.type)
	            var getTargetInstFunc = getTargetInstForChangeEvent;
	          else if (isTextInputElement(reactName))
	            if (isInputEventSupported)
	              getTargetInstFunc = getTargetInstForInputOrChangeEvent;
	            else {
	              getTargetInstFunc = getTargetInstForInputEventPolyfill;
	              var handleEventFunc = handleEventsForInputEventPolyfill;
	            }
	          else
	            SyntheticEventCtor = reactName.nodeName, !SyntheticEventCtor || "input" !== SyntheticEventCtor.toLowerCase() || "checkbox" !== reactName.type && "radio" !== reactName.type ? targetInst && isCustomElement(targetInst.elementType) && (getTargetInstFunc = getTargetInstForChangeEvent) : getTargetInstFunc = getTargetInstForClickEvent;
	          if (getTargetInstFunc && (getTargetInstFunc = getTargetInstFunc(domEventName, targetInst))) {
	            createAndAccumulateChangeEvent(
	              dispatchQueue,
	              getTargetInstFunc,
	              nativeEvent,
	              nativeEventTarget
	            );
	            break a;
	          }
	          handleEventFunc && handleEventFunc(domEventName, reactName, targetInst);
	          "focusout" === domEventName && targetInst && "number" === reactName.type && null != targetInst.memoizedProps.value && setDefaultValue(reactName, "number", reactName.value);
	        }
	        handleEventFunc = targetInst ? getNodeFromInstance(targetInst) : window;
	        switch (domEventName) {
	          case "focusin":
	            if (isTextInputElement(handleEventFunc) || "true" === handleEventFunc.contentEditable)
	              activeElement = handleEventFunc, activeElementInst = targetInst, lastSelection = null;
	            break;
	          case "focusout":
	            lastSelection = activeElementInst = activeElement = null;
	            break;
	          case "mousedown":
	            mouseDown = true;
	            break;
	          case "contextmenu":
	          case "mouseup":
	          case "dragend":
	            mouseDown = false;
	            constructSelectEvent(
	              dispatchQueue,
	              nativeEvent,
	              nativeEventTarget
	            );
	            break;
	          case "selectionchange":
	            if (skipSelectionChangeEvent) break;
	          case "keydown":
	          case "keyup":
	            constructSelectEvent(
	              dispatchQueue,
	              nativeEvent,
	              nativeEventTarget
	            );
	        }
	        var fallbackData;
	        if (canUseCompositionEvent)
	          b: {
	            switch (domEventName) {
	              case "compositionstart":
	                var eventType = "onCompositionStart";
	                break b;
	              case "compositionend":
	                eventType = "onCompositionEnd";
	                break b;
	              case "compositionupdate":
	                eventType = "onCompositionUpdate";
	                break b;
	            }
	            eventType = void 0;
	          }
	        else
	          isComposing ? isFallbackCompositionEnd(domEventName, nativeEvent) && (eventType = "onCompositionEnd") : "keydown" === domEventName && nativeEvent.keyCode === START_KEYCODE && (eventType = "onCompositionStart");
	        eventType && (useFallbackCompositionData && "ko" !== nativeEvent.locale && (isComposing || "onCompositionStart" !== eventType ? "onCompositionEnd" === eventType && isComposing && (fallbackData = getData()) : (root = nativeEventTarget, startText = "value" in root ? root.value : root.textContent, isComposing = true)), handleEventFunc = accumulateTwoPhaseListeners(
	          targetInst,
	          eventType
	        ), 0 < handleEventFunc.length && (eventType = new SyntheticCompositionEvent(
	          eventType,
	          domEventName,
	          null,
	          nativeEvent,
	          nativeEventTarget
	        ), dispatchQueue.push({
	          event: eventType,
	          listeners: handleEventFunc
	        }), fallbackData ? eventType.data = fallbackData : (fallbackData = getDataFromCustomEvent(nativeEvent), null !== fallbackData && (eventType.data = fallbackData))));
	        if (fallbackData = canUseTextInputEvent ? getNativeBeforeInputChars(domEventName, nativeEvent) : getFallbackBeforeInputChars(domEventName, nativeEvent))
	          eventType = accumulateTwoPhaseListeners(
	            targetInst,
	            "onBeforeInput"
	          ), 0 < eventType.length && (handleEventFunc = new SyntheticInputEvent(
	            "onBeforeInput",
	            "beforeinput",
	            null,
	            nativeEvent,
	            nativeEventTarget
	          ), dispatchQueue.push({
	            event: handleEventFunc,
	            listeners: eventType
	          }), handleEventFunc.data = fallbackData);
	        extractEvents$1(
	          dispatchQueue,
	          domEventName,
	          targetInst,
	          nativeEvent,
	          nativeEventTarget
	        );
	      }
	      processDispatchQueue(dispatchQueue, eventSystemFlags);
	    });
	  }
	  function createDispatchListener(instance, listener, currentTarget) {
	    return {
	      instance,
	      listener,
	      currentTarget
	    };
	  }
	  function accumulateTwoPhaseListeners(targetFiber, reactName) {
	    for (var captureName = reactName + "Capture", listeners = []; null !== targetFiber; ) {
	      var _instance3 = targetFiber, stateNode = _instance3.stateNode;
	      _instance3 = _instance3.tag;
	      5 !== _instance3 && 26 !== _instance3 && 27 !== _instance3 || null === stateNode || (_instance3 = getListener(targetFiber, captureName), null != _instance3 && listeners.unshift(
	        createDispatchListener(targetFiber, _instance3, stateNode)
	      ), _instance3 = getListener(targetFiber, reactName), null != _instance3 && listeners.push(
	        createDispatchListener(targetFiber, _instance3, stateNode)
	      ));
	      if (3 === targetFiber.tag) return listeners;
	      targetFiber = targetFiber.return;
	    }
	    return [];
	  }
	  function getParent(inst) {
	    if (null === inst) return null;
	    do
	      inst = inst.return;
	    while (inst && 5 !== inst.tag && 27 !== inst.tag);
	    return inst ? inst : null;
	  }
	  function accumulateEnterLeaveListenersForEvent(dispatchQueue, event, target, common, inCapturePhase) {
	    for (var registrationName = event._reactName, listeners = []; null !== target && target !== common; ) {
	      var _instance4 = target, alternate = _instance4.alternate, stateNode = _instance4.stateNode;
	      _instance4 = _instance4.tag;
	      if (null !== alternate && alternate === common) break;
	      5 !== _instance4 && 26 !== _instance4 && 27 !== _instance4 || null === stateNode || (alternate = stateNode, inCapturePhase ? (stateNode = getListener(target, registrationName), null != stateNode && listeners.unshift(
	        createDispatchListener(target, stateNode, alternate)
	      )) : inCapturePhase || (stateNode = getListener(target, registrationName), null != stateNode && listeners.push(
	        createDispatchListener(target, stateNode, alternate)
	      )));
	      target = target.return;
	    }
	    0 !== listeners.length && dispatchQueue.push({ event, listeners });
	  }
	  function validatePropertiesInDevelopment(type, props) {
	    validateProperties$2(type, props);
	    "input" !== type && "textarea" !== type && "select" !== type || null == props || null !== props.value || didWarnValueNull || (didWarnValueNull = true, "select" === type && props.multiple ? console.error(
	      "`value` prop on `%s` should not be null. Consider using an empty array when `multiple` is set to `true` to clear the component or `undefined` for uncontrolled components.",
	      type
	    ) : console.error(
	      "`value` prop on `%s` should not be null. Consider using an empty string to clear the component or `undefined` for uncontrolled components.",
	      type
	    ));
	    var eventRegistry = {
	      registrationNameDependencies,
	      possibleRegistrationNames
	    };
	    isCustomElement(type) || "string" === typeof props.is || warnUnknownProperties(type, props, eventRegistry);
	    props.contentEditable && !props.suppressContentEditableWarning && null != props.children && console.error(
	      "A component is `contentEditable` and contains `children` managed by React. It is now your responsibility to guarantee that none of those nodes are unexpectedly modified or duplicated. This is probably not intentional."
	    );
	  }
	  function warnForPropDifference(propName, serverValue, clientValue, serverDifferences) {
	    serverValue !== clientValue && (clientValue = normalizeMarkupForTextOrAttribute(clientValue), normalizeMarkupForTextOrAttribute(serverValue) !== clientValue && (serverDifferences[propName] = serverValue));
	  }
	  function warnForExtraAttributes(domElement, attributeNames, serverDifferences) {
	    attributeNames.forEach(function(attributeName) {
	      serverDifferences[getPropNameFromAttributeName(attributeName)] = "style" === attributeName ? getStylesObjectFromElement(domElement) : domElement.getAttribute(attributeName);
	    });
	  }
	  function warnForInvalidEventListener(registrationName, listener) {
	    false === listener ? console.error(
	      "Expected `%s` listener to be a function, instead got `false`.\n\nIf you used to conditionally omit it with %s={condition && value}, pass %s={condition ? value : undefined} instead.",
	      registrationName,
	      registrationName,
	      registrationName
	    ) : console.error(
	      "Expected `%s` listener to be a function, instead got a value of `%s` type.",
	      registrationName,
	      typeof listener
	    );
	  }
	  function normalizeHTML(parent, html) {
	    parent = parent.namespaceURI === MATH_NAMESPACE || parent.namespaceURI === SVG_NAMESPACE ? parent.ownerDocument.createElementNS(
	      parent.namespaceURI,
	      parent.tagName
	    ) : parent.ownerDocument.createElement(parent.tagName);
	    parent.innerHTML = html;
	    return parent.innerHTML;
	  }
	  function normalizeMarkupForTextOrAttribute(markup) {
	    willCoercionThrow(markup) && (console.error(
	      "The provided HTML markup uses a value of unsupported type %s. This value must be coerced to a string before using it here.",
	      typeName(markup)
	    ), testStringCoercion(markup));
	    return ("string" === typeof markup ? markup : "" + markup).replace(NORMALIZE_NEWLINES_REGEX, "\n").replace(NORMALIZE_NULL_AND_REPLACEMENT_REGEX, "");
	  }
	  function checkForUnmatchedText(serverText, clientText) {
	    clientText = normalizeMarkupForTextOrAttribute(clientText);
	    return normalizeMarkupForTextOrAttribute(serverText) === clientText ? true : false;
	  }
	  function noop$1() {
	  }
	  function setProp(domElement, tag, key, value, props, prevValue) {
	    switch (key) {
	      case "children":
	        if ("string" === typeof value)
	          validateTextNesting(value, tag, false), "body" === tag || "textarea" === tag && "" === value || setTextContent(domElement, value);
	        else if ("number" === typeof value || "bigint" === typeof value)
	          validateTextNesting("" + value, tag, false), "body" !== tag && setTextContent(domElement, "" + value);
	        break;
	      case "className":
	        setValueForKnownAttribute(domElement, "class", value);
	        break;
	      case "tabIndex":
	        setValueForKnownAttribute(domElement, "tabindex", value);
	        break;
	      case "dir":
	      case "role":
	      case "viewBox":
	      case "width":
	      case "height":
	        setValueForKnownAttribute(domElement, key, value);
	        break;
	      case "style":
	        setValueForStyles(domElement, value, prevValue);
	        break;
	      case "data":
	        if ("object" !== tag) {
	          setValueForKnownAttribute(domElement, "data", value);
	          break;
	        }
	      case "src":
	      case "href":
	        if ("" === value && ("a" !== tag || "href" !== key)) {
	          "src" === key ? console.error(
	            'An empty string ("") was passed to the %s attribute. This may cause the browser to download the whole page again over the network. To fix this, either do not render the element at all or pass null to %s instead of an empty string.',
	            key,
	            key
	          ) : console.error(
	            'An empty string ("") was passed to the %s attribute. To fix this, either do not render the element at all or pass null to %s instead of an empty string.',
	            key,
	            key
	          );
	          domElement.removeAttribute(key);
	          break;
	        }
	        if (null == value || "function" === typeof value || "symbol" === typeof value || "boolean" === typeof value) {
	          domElement.removeAttribute(key);
	          break;
	        }
	        checkAttributeStringCoercion(value, key);
	        value = sanitizeURL("" + value);
	        domElement.setAttribute(key, value);
	        break;
	      case "action":
	      case "formAction":
	        null != value && ("form" === tag ? "formAction" === key ? console.error(
	          "You can only pass the formAction prop to <input> or <button>. Use the action prop on <form>."
	        ) : "function" === typeof value && (null == props.encType && null == props.method || didWarnFormActionMethod || (didWarnFormActionMethod = true, console.error(
	          "Cannot specify a encType or method for a form that specifies a function as the action. React provides those automatically. They will get overridden."
	        )), null == props.target || didWarnFormActionTarget || (didWarnFormActionTarget = true, console.error(
	          "Cannot specify a target for a form that specifies a function as the action. The function will always be executed in the same window."
	        ))) : "input" === tag || "button" === tag ? "action" === key ? console.error(
	          "You can only pass the action prop to <form>. Use the formAction prop on <input> or <button>."
	        ) : "input" !== tag || "submit" === props.type || "image" === props.type || didWarnFormActionType ? "button" !== tag || null == props.type || "submit" === props.type || didWarnFormActionType ? "function" === typeof value && (null == props.name || didWarnFormActionName || (didWarnFormActionName = true, console.error(
	          'Cannot specify a "name" prop for a button that specifies a function as a formAction. React needs it to encode which action should be invoked. It will get overridden.'
	        )), null == props.formEncType && null == props.formMethod || didWarnFormActionMethod || (didWarnFormActionMethod = true, console.error(
	          "Cannot specify a formEncType or formMethod for a button that specifies a function as a formAction. React provides those automatically. They will get overridden."
	        )), null == props.formTarget || didWarnFormActionTarget || (didWarnFormActionTarget = true, console.error(
	          "Cannot specify a formTarget for a button that specifies a function as a formAction. The function will always be executed in the same window."
	        ))) : (didWarnFormActionType = true, console.error(
	          'A button can only specify a formAction along with type="submit" or no type.'
	        )) : (didWarnFormActionType = true, console.error(
	          'An input can only specify a formAction along with type="submit" or type="image".'
	        )) : "action" === key ? console.error(
	          "You can only pass the action prop to <form>."
	        ) : console.error(
	          "You can only pass the formAction prop to <input> or <button>."
	        ));
	        if ("function" === typeof value) {
	          domElement.setAttribute(
	            key,
	            "javascript:throw new Error('A React form was unexpectedly submitted. If you called form.submit() manually, consider using form.requestSubmit() instead. If you\\'re trying to use event.stopPropagation() in a submit event handler, consider also calling event.preventDefault().')"
	          );
	          break;
	        } else
	          "function" === typeof prevValue && ("formAction" === key ? ("input" !== tag && setProp(domElement, tag, "name", props.name, props, null), setProp(
	            domElement,
	            tag,
	            "formEncType",
	            props.formEncType,
	            props,
	            null
	          ), setProp(
	            domElement,
	            tag,
	            "formMethod",
	            props.formMethod,
	            props,
	            null
	          ), setProp(
	            domElement,
	            tag,
	            "formTarget",
	            props.formTarget,
	            props,
	            null
	          )) : (setProp(
	            domElement,
	            tag,
	            "encType",
	            props.encType,
	            props,
	            null
	          ), setProp(domElement, tag, "method", props.method, props, null), setProp(
	            domElement,
	            tag,
	            "target",
	            props.target,
	            props,
	            null
	          )));
	        if (null == value || "symbol" === typeof value || "boolean" === typeof value) {
	          domElement.removeAttribute(key);
	          break;
	        }
	        checkAttributeStringCoercion(value, key);
	        value = sanitizeURL("" + value);
	        domElement.setAttribute(key, value);
	        break;
	      case "onClick":
	        null != value && ("function" !== typeof value && warnForInvalidEventListener(key, value), domElement.onclick = noop$1);
	        break;
	      case "onScroll":
	        null != value && ("function" !== typeof value && warnForInvalidEventListener(key, value), listenToNonDelegatedEvent("scroll", domElement));
	        break;
	      case "onScrollEnd":
	        null != value && ("function" !== typeof value && warnForInvalidEventListener(key, value), listenToNonDelegatedEvent("scrollend", domElement));
	        break;
	      case "dangerouslySetInnerHTML":
	        if (null != value) {
	          if ("object" !== typeof value || !("__html" in value))
	            throw Error(
	              "`props.dangerouslySetInnerHTML` must be in the form `{__html: ...}`. Please visit https://react.dev/link/dangerously-set-inner-html for more information."
	            );
	          key = value.__html;
	          if (null != key) {
	            if (null != props.children)
	              throw Error(
	                "Can only set one of `children` or `props.dangerouslySetInnerHTML`."
	              );
	            domElement.innerHTML = key;
	          }
	        }
	        break;
	      case "multiple":
	        domElement.multiple = value && "function" !== typeof value && "symbol" !== typeof value;
	        break;
	      case "muted":
	        domElement.muted = value && "function" !== typeof value && "symbol" !== typeof value;
	        break;
	      case "suppressContentEditableWarning":
	      case "suppressHydrationWarning":
	      case "defaultValue":
	      case "defaultChecked":
	      case "innerHTML":
	      case "ref":
	        break;
	      case "autoFocus":
	        break;
	      case "xlinkHref":
	        if (null == value || "function" === typeof value || "boolean" === typeof value || "symbol" === typeof value) {
	          domElement.removeAttribute("xlink:href");
	          break;
	        }
	        checkAttributeStringCoercion(value, key);
	        key = sanitizeURL("" + value);
	        domElement.setAttributeNS(xlinkNamespace, "xlink:href", key);
	        break;
	      case "contentEditable":
	      case "spellCheck":
	      case "draggable":
	      case "value":
	      case "autoReverse":
	      case "externalResourcesRequired":
	      case "focusable":
	      case "preserveAlpha":
	        null != value && "function" !== typeof value && "symbol" !== typeof value ? (checkAttributeStringCoercion(value, key), domElement.setAttribute(key, "" + value)) : domElement.removeAttribute(key);
	        break;
	      case "inert":
	        "" !== value || didWarnForNewBooleanPropsWithEmptyValue[key] || (didWarnForNewBooleanPropsWithEmptyValue[key] = true, console.error(
	          "Received an empty string for a boolean attribute `%s`. This will treat the attribute as if it were false. Either pass `false` to silence this warning, or pass `true` if you used an empty string in earlier versions of React to indicate this attribute is true.",
	          key
	        ));
	      case "allowFullScreen":
	      case "async":
	      case "autoPlay":
	      case "controls":
	      case "default":
	      case "defer":
	      case "disabled":
	      case "disablePictureInPicture":
	      case "disableRemotePlayback":
	      case "formNoValidate":
	      case "hidden":
	      case "loop":
	      case "noModule":
	      case "noValidate":
	      case "open":
	      case "playsInline":
	      case "readOnly":
	      case "required":
	      case "reversed":
	      case "scoped":
	      case "seamless":
	      case "itemScope":
	        value && "function" !== typeof value && "symbol" !== typeof value ? domElement.setAttribute(key, "") : domElement.removeAttribute(key);
	        break;
	      case "capture":
	      case "download":
	        true === value ? domElement.setAttribute(key, "") : false !== value && null != value && "function" !== typeof value && "symbol" !== typeof value ? (checkAttributeStringCoercion(value, key), domElement.setAttribute(key, value)) : domElement.removeAttribute(key);
	        break;
	      case "cols":
	      case "rows":
	      case "size":
	      case "span":
	        null != value && "function" !== typeof value && "symbol" !== typeof value && !isNaN(value) && 1 <= value ? (checkAttributeStringCoercion(value, key), domElement.setAttribute(key, value)) : domElement.removeAttribute(key);
	        break;
	      case "rowSpan":
	      case "start":
	        null == value || "function" === typeof value || "symbol" === typeof value || isNaN(value) ? domElement.removeAttribute(key) : (checkAttributeStringCoercion(value, key), domElement.setAttribute(key, value));
	        break;
	      case "popover":
	        listenToNonDelegatedEvent("beforetoggle", domElement);
	        listenToNonDelegatedEvent("toggle", domElement);
	        setValueForAttribute(domElement, "popover", value);
	        break;
	      case "xlinkActuate":
	        setValueForNamespacedAttribute(
	          domElement,
	          xlinkNamespace,
	          "xlink:actuate",
	          value
	        );
	        break;
	      case "xlinkArcrole":
	        setValueForNamespacedAttribute(
	          domElement,
	          xlinkNamespace,
	          "xlink:arcrole",
	          value
	        );
	        break;
	      case "xlinkRole":
	        setValueForNamespacedAttribute(
	          domElement,
	          xlinkNamespace,
	          "xlink:role",
	          value
	        );
	        break;
	      case "xlinkShow":
	        setValueForNamespacedAttribute(
	          domElement,
	          xlinkNamespace,
	          "xlink:show",
	          value
	        );
	        break;
	      case "xlinkTitle":
	        setValueForNamespacedAttribute(
	          domElement,
	          xlinkNamespace,
	          "xlink:title",
	          value
	        );
	        break;
	      case "xlinkType":
	        setValueForNamespacedAttribute(
	          domElement,
	          xlinkNamespace,
	          "xlink:type",
	          value
	        );
	        break;
	      case "xmlBase":
	        setValueForNamespacedAttribute(
	          domElement,
	          xmlNamespace,
	          "xml:base",
	          value
	        );
	        break;
	      case "xmlLang":
	        setValueForNamespacedAttribute(
	          domElement,
	          xmlNamespace,
	          "xml:lang",
	          value
	        );
	        break;
	      case "xmlSpace":
	        setValueForNamespacedAttribute(
	          domElement,
	          xmlNamespace,
	          "xml:space",
	          value
	        );
	        break;
	      case "is":
	        null != prevValue && console.error(
	          'Cannot update the "is" prop after it has been initialized.'
	        );
	        setValueForAttribute(domElement, "is", value);
	        break;
	      case "innerText":
	      case "textContent":
	        break;
	      case "popoverTarget":
	        didWarnPopoverTargetObject || null == value || "object" !== typeof value || (didWarnPopoverTargetObject = true, console.error(
	          "The `popoverTarget` prop expects the ID of an Element as a string. Received %s instead.",
	          value
	        ));
	      default:
	        !(2 < key.length) || "o" !== key[0] && "O" !== key[0] || "n" !== key[1] && "N" !== key[1] ? (key = getAttributeAlias(key), setValueForAttribute(domElement, key, value)) : registrationNameDependencies.hasOwnProperty(key) && null != value && "function" !== typeof value && warnForInvalidEventListener(key, value);
	    }
	  }
	  function setPropOnCustomElement(domElement, tag, key, value, props, prevValue) {
	    switch (key) {
	      case "style":
	        setValueForStyles(domElement, value, prevValue);
	        break;
	      case "dangerouslySetInnerHTML":
	        if (null != value) {
	          if ("object" !== typeof value || !("__html" in value))
	            throw Error(
	              "`props.dangerouslySetInnerHTML` must be in the form `{__html: ...}`. Please visit https://react.dev/link/dangerously-set-inner-html for more information."
	            );
	          key = value.__html;
	          if (null != key) {
	            if (null != props.children)
	              throw Error(
	                "Can only set one of `children` or `props.dangerouslySetInnerHTML`."
	              );
	            domElement.innerHTML = key;
	          }
	        }
	        break;
	      case "children":
	        "string" === typeof value ? setTextContent(domElement, value) : ("number" === typeof value || "bigint" === typeof value) && setTextContent(domElement, "" + value);
	        break;
	      case "onScroll":
	        null != value && ("function" !== typeof value && warnForInvalidEventListener(key, value), listenToNonDelegatedEvent("scroll", domElement));
	        break;
	      case "onScrollEnd":
	        null != value && ("function" !== typeof value && warnForInvalidEventListener(key, value), listenToNonDelegatedEvent("scrollend", domElement));
	        break;
	      case "onClick":
	        null != value && ("function" !== typeof value && warnForInvalidEventListener(key, value), domElement.onclick = noop$1);
	        break;
	      case "suppressContentEditableWarning":
	      case "suppressHydrationWarning":
	      case "innerHTML":
	      case "ref":
	        break;
	      case "innerText":
	      case "textContent":
	        break;
	      default:
	        if (registrationNameDependencies.hasOwnProperty(key))
	          null != value && "function" !== typeof value && warnForInvalidEventListener(key, value);
	        else
	          a: {
	            if ("o" === key[0] && "n" === key[1] && (props = key.endsWith("Capture"), tag = key.slice(2, props ? key.length - 7 : void 0), prevValue = domElement[internalPropsKey] || null, prevValue = null != prevValue ? prevValue[key] : null, "function" === typeof prevValue && domElement.removeEventListener(tag, prevValue, props), "function" === typeof value)) {
	              "function" !== typeof prevValue && null !== prevValue && (key in domElement ? domElement[key] = null : domElement.hasAttribute(key) && domElement.removeAttribute(key));
	              domElement.addEventListener(tag, value, props);
	              break a;
	            }
	            key in domElement ? domElement[key] = value : true === value ? domElement.setAttribute(key, "") : setValueForAttribute(domElement, key, value);
	          }
	    }
	  }
	  function setInitialProperties(domElement, tag, props) {
	    validatePropertiesInDevelopment(tag, props);
	    switch (tag) {
	      case "div":
	      case "span":
	      case "svg":
	      case "path":
	      case "a":
	      case "g":
	      case "p":
	      case "li":
	        break;
	      case "img":
	        listenToNonDelegatedEvent("error", domElement);
	        listenToNonDelegatedEvent("load", domElement);
	        var hasSrc = false, hasSrcSet = false, propKey;
	        for (propKey in props)
	          if (props.hasOwnProperty(propKey)) {
	            var propValue = props[propKey];
	            if (null != propValue)
	              switch (propKey) {
	                case "src":
	                  hasSrc = true;
	                  break;
	                case "srcSet":
	                  hasSrcSet = true;
	                  break;
	                case "children":
	                case "dangerouslySetInnerHTML":
	                  throw Error(
	                    tag + " is a void element tag and must neither have `children` nor use `dangerouslySetInnerHTML`."
	                  );
	                default:
	                  setProp(domElement, tag, propKey, propValue, props, null);
	              }
	          }
	        hasSrcSet && setProp(domElement, tag, "srcSet", props.srcSet, props, null);
	        hasSrc && setProp(domElement, tag, "src", props.src, props, null);
	        return;
	      case "input":
	        checkControlledValueProps("input", props);
	        listenToNonDelegatedEvent("invalid", domElement);
	        var defaultValue = propKey = propValue = hasSrcSet = null, checked = null, defaultChecked = null;
	        for (hasSrc in props)
	          if (props.hasOwnProperty(hasSrc)) {
	            var _propValue = props[hasSrc];
	            if (null != _propValue)
	              switch (hasSrc) {
	                case "name":
	                  hasSrcSet = _propValue;
	                  break;
	                case "type":
	                  propValue = _propValue;
	                  break;
	                case "checked":
	                  checked = _propValue;
	                  break;
	                case "defaultChecked":
	                  defaultChecked = _propValue;
	                  break;
	                case "value":
	                  propKey = _propValue;
	                  break;
	                case "defaultValue":
	                  defaultValue = _propValue;
	                  break;
	                case "children":
	                case "dangerouslySetInnerHTML":
	                  if (null != _propValue)
	                    throw Error(
	                      tag + " is a void element tag and must neither have `children` nor use `dangerouslySetInnerHTML`."
	                    );
	                  break;
	                default:
	                  setProp(domElement, tag, hasSrc, _propValue, props, null);
	              }
	          }
	        validateInputProps(domElement, props);
	        initInput(
	          domElement,
	          propKey,
	          defaultValue,
	          checked,
	          defaultChecked,
	          propValue,
	          hasSrcSet,
	          false
	        );
	        track(domElement);
	        return;
	      case "select":
	        checkControlledValueProps("select", props);
	        listenToNonDelegatedEvent("invalid", domElement);
	        hasSrc = propValue = propKey = null;
	        for (hasSrcSet in props)
	          if (props.hasOwnProperty(hasSrcSet) && (defaultValue = props[hasSrcSet], null != defaultValue))
	            switch (hasSrcSet) {
	              case "value":
	                propKey = defaultValue;
	                break;
	              case "defaultValue":
	                propValue = defaultValue;
	                break;
	              case "multiple":
	                hasSrc = defaultValue;
	              default:
	                setProp(
	                  domElement,
	                  tag,
	                  hasSrcSet,
	                  defaultValue,
	                  props,
	                  null
	                );
	            }
	        validateSelectProps(domElement, props);
	        tag = propKey;
	        props = propValue;
	        domElement.multiple = !!hasSrc;
	        null != tag ? updateOptions(domElement, !!hasSrc, tag, false) : null != props && updateOptions(domElement, !!hasSrc, props, true);
	        return;
	      case "textarea":
	        checkControlledValueProps("textarea", props);
	        listenToNonDelegatedEvent("invalid", domElement);
	        propKey = hasSrcSet = hasSrc = null;
	        for (propValue in props)
	          if (props.hasOwnProperty(propValue) && (defaultValue = props[propValue], null != defaultValue))
	            switch (propValue) {
	              case "value":
	                hasSrc = defaultValue;
	                break;
	              case "defaultValue":
	                hasSrcSet = defaultValue;
	                break;
	              case "children":
	                propKey = defaultValue;
	                break;
	              case "dangerouslySetInnerHTML":
	                if (null != defaultValue)
	                  throw Error(
	                    "`dangerouslySetInnerHTML` does not make sense on <textarea>."
	                  );
	                break;
	              default:
	                setProp(
	                  domElement,
	                  tag,
	                  propValue,
	                  defaultValue,
	                  props,
	                  null
	                );
	            }
	        validateTextareaProps(domElement, props);
	        initTextarea(domElement, hasSrc, hasSrcSet, propKey);
	        track(domElement);
	        return;
	      case "option":
	        validateOptionProps(domElement, props);
	        for (checked in props)
	          if (props.hasOwnProperty(checked) && (hasSrc = props[checked], null != hasSrc))
	            switch (checked) {
	              case "selected":
	                domElement.selected = hasSrc && "function" !== typeof hasSrc && "symbol" !== typeof hasSrc;
	                break;
	              default:
	                setProp(domElement, tag, checked, hasSrc, props, null);
	            }
	        return;
	      case "dialog":
	        listenToNonDelegatedEvent("beforetoggle", domElement);
	        listenToNonDelegatedEvent("toggle", domElement);
	        listenToNonDelegatedEvent("cancel", domElement);
	        listenToNonDelegatedEvent("close", domElement);
	        break;
	      case "iframe":
	      case "object":
	        listenToNonDelegatedEvent("load", domElement);
	        break;
	      case "video":
	      case "audio":
	        for (hasSrc = 0; hasSrc < mediaEventTypes.length; hasSrc++)
	          listenToNonDelegatedEvent(mediaEventTypes[hasSrc], domElement);
	        break;
	      case "image":
	        listenToNonDelegatedEvent("error", domElement);
	        listenToNonDelegatedEvent("load", domElement);
	        break;
	      case "details":
	        listenToNonDelegatedEvent("toggle", domElement);
	        break;
	      case "embed":
	      case "source":
	      case "link":
	        listenToNonDelegatedEvent("error", domElement), listenToNonDelegatedEvent("load", domElement);
	      case "area":
	      case "base":
	      case "br":
	      case "col":
	      case "hr":
	      case "keygen":
	      case "meta":
	      case "param":
	      case "track":
	      case "wbr":
	      case "menuitem":
	        for (defaultChecked in props)
	          if (props.hasOwnProperty(defaultChecked) && (hasSrc = props[defaultChecked], null != hasSrc))
	            switch (defaultChecked) {
	              case "children":
	              case "dangerouslySetInnerHTML":
	                throw Error(
	                  tag + " is a void element tag and must neither have `children` nor use `dangerouslySetInnerHTML`."
	                );
	              default:
	                setProp(domElement, tag, defaultChecked, hasSrc, props, null);
	            }
	        return;
	      default:
	        if (isCustomElement(tag)) {
	          for (_propValue in props)
	            props.hasOwnProperty(_propValue) && (hasSrc = props[_propValue], void 0 !== hasSrc && setPropOnCustomElement(
	              domElement,
	              tag,
	              _propValue,
	              hasSrc,
	              props,
	              void 0
	            ));
	          return;
	        }
	    }
	    for (defaultValue in props)
	      props.hasOwnProperty(defaultValue) && (hasSrc = props[defaultValue], null != hasSrc && setProp(domElement, tag, defaultValue, hasSrc, props, null));
	  }
	  function updateProperties(domElement, tag, lastProps, nextProps) {
	    validatePropertiesInDevelopment(tag, nextProps);
	    switch (tag) {
	      case "div":
	      case "span":
	      case "svg":
	      case "path":
	      case "a":
	      case "g":
	      case "p":
	      case "li":
	        break;
	      case "input":
	        var name = null, type = null, value = null, defaultValue = null, lastDefaultValue = null, checked = null, defaultChecked = null;
	        for (propKey in lastProps) {
	          var lastProp = lastProps[propKey];
	          if (lastProps.hasOwnProperty(propKey) && null != lastProp)
	            switch (propKey) {
	              case "checked":
	                break;
	              case "value":
	                break;
	              case "defaultValue":
	                lastDefaultValue = lastProp;
	              default:
	                nextProps.hasOwnProperty(propKey) || setProp(
	                  domElement,
	                  tag,
	                  propKey,
	                  null,
	                  nextProps,
	                  lastProp
	                );
	            }
	        }
	        for (var _propKey8 in nextProps) {
	          var propKey = nextProps[_propKey8];
	          lastProp = lastProps[_propKey8];
	          if (nextProps.hasOwnProperty(_propKey8) && (null != propKey || null != lastProp))
	            switch (_propKey8) {
	              case "type":
	                type = propKey;
	                break;
	              case "name":
	                name = propKey;
	                break;
	              case "checked":
	                checked = propKey;
	                break;
	              case "defaultChecked":
	                defaultChecked = propKey;
	                break;
	              case "value":
	                value = propKey;
	                break;
	              case "defaultValue":
	                defaultValue = propKey;
	                break;
	              case "children":
	              case "dangerouslySetInnerHTML":
	                if (null != propKey)
	                  throw Error(
	                    tag + " is a void element tag and must neither have `children` nor use `dangerouslySetInnerHTML`."
	                  );
	                break;
	              default:
	                propKey !== lastProp && setProp(
	                  domElement,
	                  tag,
	                  _propKey8,
	                  propKey,
	                  nextProps,
	                  lastProp
	                );
	            }
	        }
	        tag = "checkbox" === lastProps.type || "radio" === lastProps.type ? null != lastProps.checked : null != lastProps.value;
	        nextProps = "checkbox" === nextProps.type || "radio" === nextProps.type ? null != nextProps.checked : null != nextProps.value;
	        tag || !nextProps || didWarnUncontrolledToControlled || (console.error(
	          "A component is changing an uncontrolled input to be controlled. This is likely caused by the value changing from undefined to a defined value, which should not happen. Decide between using a controlled or uncontrolled input element for the lifetime of the component. More info: https://react.dev/link/controlled-components"
	        ), didWarnUncontrolledToControlled = true);
	        !tag || nextProps || didWarnControlledToUncontrolled || (console.error(
	          "A component is changing a controlled input to be uncontrolled. This is likely caused by the value changing from a defined to undefined, which should not happen. Decide between using a controlled or uncontrolled input element for the lifetime of the component. More info: https://react.dev/link/controlled-components"
	        ), didWarnControlledToUncontrolled = true);
	        updateInput(
	          domElement,
	          value,
	          defaultValue,
	          lastDefaultValue,
	          checked,
	          defaultChecked,
	          type,
	          name
	        );
	        return;
	      case "select":
	        propKey = value = defaultValue = _propKey8 = null;
	        for (type in lastProps)
	          if (lastDefaultValue = lastProps[type], lastProps.hasOwnProperty(type) && null != lastDefaultValue)
	            switch (type) {
	              case "value":
	                break;
	              case "multiple":
	                propKey = lastDefaultValue;
	              default:
	                nextProps.hasOwnProperty(type) || setProp(
	                  domElement,
	                  tag,
	                  type,
	                  null,
	                  nextProps,
	                  lastDefaultValue
	                );
	            }
	        for (name in nextProps)
	          if (type = nextProps[name], lastDefaultValue = lastProps[name], nextProps.hasOwnProperty(name) && (null != type || null != lastDefaultValue))
	            switch (name) {
	              case "value":
	                _propKey8 = type;
	                break;
	              case "defaultValue":
	                defaultValue = type;
	                break;
	              case "multiple":
	                value = type;
	              default:
	                type !== lastDefaultValue && setProp(
	                  domElement,
	                  tag,
	                  name,
	                  type,
	                  nextProps,
	                  lastDefaultValue
	                );
	            }
	        nextProps = defaultValue;
	        tag = value;
	        lastProps = propKey;
	        null != _propKey8 ? updateOptions(domElement, !!tag, _propKey8, false) : !!lastProps !== !!tag && (null != nextProps ? updateOptions(domElement, !!tag, nextProps, true) : updateOptions(domElement, !!tag, tag ? [] : "", false));
	        return;
	      case "textarea":
	        propKey = _propKey8 = null;
	        for (defaultValue in lastProps)
	          if (name = lastProps[defaultValue], lastProps.hasOwnProperty(defaultValue) && null != name && !nextProps.hasOwnProperty(defaultValue))
	            switch (defaultValue) {
	              case "value":
	                break;
	              case "children":
	                break;
	              default:
	                setProp(domElement, tag, defaultValue, null, nextProps, name);
	            }
	        for (value in nextProps)
	          if (name = nextProps[value], type = lastProps[value], nextProps.hasOwnProperty(value) && (null != name || null != type))
	            switch (value) {
	              case "value":
	                _propKey8 = name;
	                break;
	              case "defaultValue":
	                propKey = name;
	                break;
	              case "children":
	                break;
	              case "dangerouslySetInnerHTML":
	                if (null != name)
	                  throw Error(
	                    "`dangerouslySetInnerHTML` does not make sense on <textarea>."
	                  );
	                break;
	              default:
	                name !== type && setProp(domElement, tag, value, name, nextProps, type);
	            }
	        updateTextarea(domElement, _propKey8, propKey);
	        return;
	      case "option":
	        for (var _propKey13 in lastProps)
	          if (_propKey8 = lastProps[_propKey13], lastProps.hasOwnProperty(_propKey13) && null != _propKey8 && !nextProps.hasOwnProperty(_propKey13))
	            switch (_propKey13) {
	              case "selected":
	                domElement.selected = false;
	                break;
	              default:
	                setProp(
	                  domElement,
	                  tag,
	                  _propKey13,
	                  null,
	                  nextProps,
	                  _propKey8
	                );
	            }
	        for (lastDefaultValue in nextProps)
	          if (_propKey8 = nextProps[lastDefaultValue], propKey = lastProps[lastDefaultValue], nextProps.hasOwnProperty(lastDefaultValue) && _propKey8 !== propKey && (null != _propKey8 || null != propKey))
	            switch (lastDefaultValue) {
	              case "selected":
	                domElement.selected = _propKey8 && "function" !== typeof _propKey8 && "symbol" !== typeof _propKey8;
	                break;
	              default:
	                setProp(
	                  domElement,
	                  tag,
	                  lastDefaultValue,
	                  _propKey8,
	                  nextProps,
	                  propKey
	                );
	            }
	        return;
	      case "img":
	      case "link":
	      case "area":
	      case "base":
	      case "br":
	      case "col":
	      case "embed":
	      case "hr":
	      case "keygen":
	      case "meta":
	      case "param":
	      case "source":
	      case "track":
	      case "wbr":
	      case "menuitem":
	        for (var _propKey15 in lastProps)
	          _propKey8 = lastProps[_propKey15], lastProps.hasOwnProperty(_propKey15) && null != _propKey8 && !nextProps.hasOwnProperty(_propKey15) && setProp(
	            domElement,
	            tag,
	            _propKey15,
	            null,
	            nextProps,
	            _propKey8
	          );
	        for (checked in nextProps)
	          if (_propKey8 = nextProps[checked], propKey = lastProps[checked], nextProps.hasOwnProperty(checked) && _propKey8 !== propKey && (null != _propKey8 || null != propKey))
	            switch (checked) {
	              case "children":
	              case "dangerouslySetInnerHTML":
	                if (null != _propKey8)
	                  throw Error(
	                    tag + " is a void element tag and must neither have `children` nor use `dangerouslySetInnerHTML`."
	                  );
	                break;
	              default:
	                setProp(
	                  domElement,
	                  tag,
	                  checked,
	                  _propKey8,
	                  nextProps,
	                  propKey
	                );
	            }
	        return;
	      default:
	        if (isCustomElement(tag)) {
	          for (var _propKey17 in lastProps)
	            _propKey8 = lastProps[_propKey17], lastProps.hasOwnProperty(_propKey17) && void 0 !== _propKey8 && !nextProps.hasOwnProperty(_propKey17) && setPropOnCustomElement(
	              domElement,
	              tag,
	              _propKey17,
	              void 0,
	              nextProps,
	              _propKey8
	            );
	          for (defaultChecked in nextProps)
	            _propKey8 = nextProps[defaultChecked], propKey = lastProps[defaultChecked], !nextProps.hasOwnProperty(defaultChecked) || _propKey8 === propKey || void 0 === _propKey8 && void 0 === propKey || setPropOnCustomElement(
	              domElement,
	              tag,
	              defaultChecked,
	              _propKey8,
	              nextProps,
	              propKey
	            );
	          return;
	        }
	    }
	    for (var _propKey19 in lastProps)
	      _propKey8 = lastProps[_propKey19], lastProps.hasOwnProperty(_propKey19) && null != _propKey8 && !nextProps.hasOwnProperty(_propKey19) && setProp(domElement, tag, _propKey19, null, nextProps, _propKey8);
	    for (lastProp in nextProps)
	      _propKey8 = nextProps[lastProp], propKey = lastProps[lastProp], !nextProps.hasOwnProperty(lastProp) || _propKey8 === propKey || null == _propKey8 && null == propKey || setProp(domElement, tag, lastProp, _propKey8, nextProps, propKey);
	  }
	  function getPropNameFromAttributeName(attrName) {
	    switch (attrName) {
	      case "class":
	        return "className";
	      case "for":
	        return "htmlFor";
	      default:
	        return attrName;
	    }
	  }
	  function getStylesObjectFromElement(domElement) {
	    var serverValueInObjectForm = {};
	    domElement = domElement.style;
	    for (var i = 0; i < domElement.length; i++) {
	      var styleName = domElement[i];
	      serverValueInObjectForm[styleName] = domElement.getPropertyValue(styleName);
	    }
	    return serverValueInObjectForm;
	  }
	  function diffHydratedStyles(domElement, value$jscomp$0, serverDifferences) {
	    if (null != value$jscomp$0 && "object" !== typeof value$jscomp$0)
	      console.error(
	        "The `style` prop expects a mapping from style properties to values, not a string. For example, style={{marginRight: spacing + 'em'}} when using JSX."
	      );
	    else {
	      var clientValue;
	      var delimiter = clientValue = "", styleName;
	      for (styleName in value$jscomp$0)
	        if (value$jscomp$0.hasOwnProperty(styleName)) {
	          var value = value$jscomp$0[styleName];
	          null != value && "boolean" !== typeof value && "" !== value && (0 === styleName.indexOf("--") ? (checkCSSPropertyStringCoercion(value, styleName), clientValue += delimiter + styleName + ":" + ("" + value).trim()) : "number" !== typeof value || 0 === value || unitlessNumbers.has(styleName) ? (checkCSSPropertyStringCoercion(value, styleName), clientValue += delimiter + styleName.replace(uppercasePattern, "-$1").toLowerCase().replace(msPattern$1, "-ms-") + ":" + ("" + value).trim()) : clientValue += delimiter + styleName.replace(uppercasePattern, "-$1").toLowerCase().replace(msPattern$1, "-ms-") + ":" + value + "px", delimiter = ";");
	        }
	      clientValue = clientValue || null;
	      value$jscomp$0 = domElement.getAttribute("style");
	      value$jscomp$0 !== clientValue && (clientValue = normalizeMarkupForTextOrAttribute(clientValue), normalizeMarkupForTextOrAttribute(value$jscomp$0) !== clientValue && (serverDifferences.style = getStylesObjectFromElement(domElement)));
	    }
	  }
	  function hydrateAttribute(domElement, propKey, attributeName, value, extraAttributes, serverDifferences) {
	    extraAttributes.delete(attributeName);
	    domElement = domElement.getAttribute(attributeName);
	    if (null === domElement)
	      switch (typeof value) {
	        case "undefined":
	        case "function":
	        case "symbol":
	        case "boolean":
	          return;
	      }
	    else if (null != value)
	      switch (typeof value) {
	        case "function":
	        case "symbol":
	        case "boolean":
	          break;
	        default:
	          if (checkAttributeStringCoercion(value, propKey), domElement === "" + value)
	            return;
	      }
	    warnForPropDifference(propKey, domElement, value, serverDifferences);
	  }
	  function hydrateBooleanAttribute(domElement, propKey, attributeName, value, extraAttributes, serverDifferences) {
	    extraAttributes.delete(attributeName);
	    domElement = domElement.getAttribute(attributeName);
	    if (null === domElement) {
	      switch (typeof value) {
	        case "function":
	        case "symbol":
	          return;
	      }
	      if (!value) return;
	    } else
	      switch (typeof value) {
	        case "function":
	        case "symbol":
	          break;
	        default:
	          if (value) return;
	      }
	    warnForPropDifference(propKey, domElement, value, serverDifferences);
	  }
	  function hydrateBooleanishAttribute(domElement, propKey, attributeName, value, extraAttributes, serverDifferences) {
	    extraAttributes.delete(attributeName);
	    domElement = domElement.getAttribute(attributeName);
	    if (null === domElement)
	      switch (typeof value) {
	        case "undefined":
	        case "function":
	        case "symbol":
	          return;
	      }
	    else if (null != value)
	      switch (typeof value) {
	        case "function":
	        case "symbol":
	          break;
	        default:
	          if (checkAttributeStringCoercion(value, attributeName), domElement === "" + value)
	            return;
	      }
	    warnForPropDifference(propKey, domElement, value, serverDifferences);
	  }
	  function hydrateNumericAttribute(domElement, propKey, attributeName, value, extraAttributes, serverDifferences) {
	    extraAttributes.delete(attributeName);
	    domElement = domElement.getAttribute(attributeName);
	    if (null === domElement)
	      switch (typeof value) {
	        case "undefined":
	        case "function":
	        case "symbol":
	        case "boolean":
	          return;
	        default:
	          if (isNaN(value)) return;
	      }
	    else if (null != value)
	      switch (typeof value) {
	        case "function":
	        case "symbol":
	        case "boolean":
	          break;
	        default:
	          if (!isNaN(value) && (checkAttributeStringCoercion(value, propKey), domElement === "" + value))
	            return;
	      }
	    warnForPropDifference(propKey, domElement, value, serverDifferences);
	  }
	  function hydrateSanitizedAttribute(domElement, propKey, attributeName, value, extraAttributes, serverDifferences) {
	    extraAttributes.delete(attributeName);
	    domElement = domElement.getAttribute(attributeName);
	    if (null === domElement)
	      switch (typeof value) {
	        case "undefined":
	        case "function":
	        case "symbol":
	        case "boolean":
	          return;
	      }
	    else if (null != value)
	      switch (typeof value) {
	        case "function":
	        case "symbol":
	        case "boolean":
	          break;
	        default:
	          if (checkAttributeStringCoercion(value, propKey), attributeName = sanitizeURL("" + value), domElement === attributeName)
	            return;
	      }
	    warnForPropDifference(propKey, domElement, value, serverDifferences);
	  }
	  function diffHydratedProperties(domElement, tag, props, hostContext) {
	    for (var serverDifferences = {}, extraAttributes = /* @__PURE__ */ new Set(), attributes = domElement.attributes, i = 0; i < attributes.length; i++)
	      switch (attributes[i].name.toLowerCase()) {
	        case "value":
	          break;
	        case "checked":
	          break;
	        case "selected":
	          break;
	        default:
	          extraAttributes.add(attributes[i].name);
	      }
	    if (isCustomElement(tag))
	      for (var propKey in props) {
	        if (props.hasOwnProperty(propKey)) {
	          var value = props[propKey];
	          if (null != value) {
	            if (registrationNameDependencies.hasOwnProperty(propKey))
	              "function" !== typeof value && warnForInvalidEventListener(propKey, value);
	            else if (true !== props.suppressHydrationWarning)
	              switch (propKey) {
	                case "children":
	                  "string" !== typeof value && "number" !== typeof value || warnForPropDifference(
	                    "children",
	                    domElement.textContent,
	                    value,
	                    serverDifferences
	                  );
	                  continue;
	                case "suppressContentEditableWarning":
	                case "suppressHydrationWarning":
	                case "defaultValue":
	                case "defaultChecked":
	                case "innerHTML":
	                case "ref":
	                  continue;
	                case "dangerouslySetInnerHTML":
	                  attributes = domElement.innerHTML;
	                  value = value ? value.__html : void 0;
	                  null != value && (value = normalizeHTML(domElement, value), warnForPropDifference(
	                    propKey,
	                    attributes,
	                    value,
	                    serverDifferences
	                  ));
	                  continue;
	                case "style":
	                  extraAttributes.delete(propKey);
	                  diffHydratedStyles(domElement, value, serverDifferences);
	                  continue;
	                case "offsetParent":
	                case "offsetTop":
	                case "offsetLeft":
	                case "offsetWidth":
	                case "offsetHeight":
	                case "isContentEditable":
	                case "outerText":
	                case "outerHTML":
	                  extraAttributes.delete(propKey.toLowerCase());
	                  console.error(
	                    "Assignment to read-only property will result in a no-op: `%s`",
	                    propKey
	                  );
	                  continue;
	                case "className":
	                  extraAttributes.delete("class");
	                  attributes = getValueForAttributeOnCustomComponent(
	                    domElement,
	                    "class",
	                    value
	                  );
	                  warnForPropDifference(
	                    "className",
	                    attributes,
	                    value,
	                    serverDifferences
	                  );
	                  continue;
	                default:
	                  hostContext.context === HostContextNamespaceNone && "svg" !== tag && "math" !== tag ? extraAttributes.delete(propKey.toLowerCase()) : extraAttributes.delete(propKey), attributes = getValueForAttributeOnCustomComponent(
	                    domElement,
	                    propKey,
	                    value
	                  ), warnForPropDifference(
	                    propKey,
	                    attributes,
	                    value,
	                    serverDifferences
	                  );
	              }
	          }
	        }
	      }
	    else
	      for (value in props)
	        if (props.hasOwnProperty(value) && (propKey = props[value], null != propKey)) {
	          if (registrationNameDependencies.hasOwnProperty(value))
	            "function" !== typeof propKey && warnForInvalidEventListener(value, propKey);
	          else if (true !== props.suppressHydrationWarning)
	            switch (value) {
	              case "children":
	                "string" !== typeof propKey && "number" !== typeof propKey || warnForPropDifference(
	                  "children",
	                  domElement.textContent,
	                  propKey,
	                  serverDifferences
	                );
	                continue;
	              case "suppressContentEditableWarning":
	              case "suppressHydrationWarning":
	              case "value":
	              case "checked":
	              case "selected":
	              case "defaultValue":
	              case "defaultChecked":
	              case "innerHTML":
	              case "ref":
	                continue;
	              case "dangerouslySetInnerHTML":
	                attributes = domElement.innerHTML;
	                propKey = propKey ? propKey.__html : void 0;
	                null != propKey && (propKey = normalizeHTML(domElement, propKey), attributes !== propKey && (serverDifferences[value] = { __html: attributes }));
	                continue;
	              case "className":
	                hydrateAttribute(
	                  domElement,
	                  value,
	                  "class",
	                  propKey,
	                  extraAttributes,
	                  serverDifferences
	                );
	                continue;
	              case "tabIndex":
	                hydrateAttribute(
	                  domElement,
	                  value,
	                  "tabindex",
	                  propKey,
	                  extraAttributes,
	                  serverDifferences
	                );
	                continue;
	              case "style":
	                extraAttributes.delete(value);
	                diffHydratedStyles(domElement, propKey, serverDifferences);
	                continue;
	              case "multiple":
	                extraAttributes.delete(value);
	                warnForPropDifference(
	                  value,
	                  domElement.multiple,
	                  propKey,
	                  serverDifferences
	                );
	                continue;
	              case "muted":
	                extraAttributes.delete(value);
	                warnForPropDifference(
	                  value,
	                  domElement.muted,
	                  propKey,
	                  serverDifferences
	                );
	                continue;
	              case "autoFocus":
	                extraAttributes.delete("autofocus");
	                warnForPropDifference(
	                  value,
	                  domElement.autofocus,
	                  propKey,
	                  serverDifferences
	                );
	                continue;
	              case "data":
	                if ("object" !== tag) {
	                  extraAttributes.delete(value);
	                  attributes = domElement.getAttribute("data");
	                  warnForPropDifference(
	                    value,
	                    attributes,
	                    propKey,
	                    serverDifferences
	                  );
	                  continue;
	                }
	              case "src":
	              case "href":
	                if (!("" !== propKey || "a" === tag && "href" === value || "object" === tag && "data" === value)) {
	                  "src" === value ? console.error(
	                    'An empty string ("") was passed to the %s attribute. This may cause the browser to download the whole page again over the network. To fix this, either do not render the element at all or pass null to %s instead of an empty string.',
	                    value,
	                    value
	                  ) : console.error(
	                    'An empty string ("") was passed to the %s attribute. To fix this, either do not render the element at all or pass null to %s instead of an empty string.',
	                    value,
	                    value
	                  );
	                  continue;
	                }
	                hydrateSanitizedAttribute(
	                  domElement,
	                  value,
	                  value,
	                  propKey,
	                  extraAttributes,
	                  serverDifferences
	                );
	                continue;
	              case "action":
	              case "formAction":
	                attributes = domElement.getAttribute(value);
	                if ("function" === typeof propKey) {
	                  extraAttributes.delete(value.toLowerCase());
	                  "formAction" === value ? (extraAttributes.delete("name"), extraAttributes.delete("formenctype"), extraAttributes.delete("formmethod"), extraAttributes.delete("formtarget")) : (extraAttributes.delete("enctype"), extraAttributes.delete("method"), extraAttributes.delete("target"));
	                  continue;
	                } else if (attributes === EXPECTED_FORM_ACTION_URL) {
	                  extraAttributes.delete(value.toLowerCase());
	                  warnForPropDifference(
	                    value,
	                    "function",
	                    propKey,
	                    serverDifferences
	                  );
	                  continue;
	                }
	                hydrateSanitizedAttribute(
	                  domElement,
	                  value,
	                  value.toLowerCase(),
	                  propKey,
	                  extraAttributes,
	                  serverDifferences
	                );
	                continue;
	              case "xlinkHref":
	                hydrateSanitizedAttribute(
	                  domElement,
	                  value,
	                  "xlink:href",
	                  propKey,
	                  extraAttributes,
	                  serverDifferences
	                );
	                continue;
	              case "contentEditable":
	                hydrateBooleanishAttribute(
	                  domElement,
	                  value,
	                  "contenteditable",
	                  propKey,
	                  extraAttributes,
	                  serverDifferences
	                );
	                continue;
	              case "spellCheck":
	                hydrateBooleanishAttribute(
	                  domElement,
	                  value,
	                  "spellcheck",
	                  propKey,
	                  extraAttributes,
	                  serverDifferences
	                );
	                continue;
	              case "draggable":
	              case "autoReverse":
	              case "externalResourcesRequired":
	              case "focusable":
	              case "preserveAlpha":
	                hydrateBooleanishAttribute(
	                  domElement,
	                  value,
	                  value,
	                  propKey,
	                  extraAttributes,
	                  serverDifferences
	                );
	                continue;
	              case "allowFullScreen":
	              case "async":
	              case "autoPlay":
	              case "controls":
	              case "default":
	              case "defer":
	              case "disabled":
	              case "disablePictureInPicture":
	              case "disableRemotePlayback":
	              case "formNoValidate":
	              case "hidden":
	              case "loop":
	              case "noModule":
	              case "noValidate":
	              case "open":
	              case "playsInline":
	              case "readOnly":
	              case "required":
	              case "reversed":
	              case "scoped":
	              case "seamless":
	              case "itemScope":
	                hydrateBooleanAttribute(
	                  domElement,
	                  value,
	                  value.toLowerCase(),
	                  propKey,
	                  extraAttributes,
	                  serverDifferences
	                );
	                continue;
	              case "capture":
	              case "download":
	                a: {
	                  i = domElement;
	                  var attributeName = attributes = value, serverDifferences$jscomp$0 = serverDifferences;
	                  extraAttributes.delete(attributeName);
	                  i = i.getAttribute(attributeName);
	                  if (null === i)
	                    switch (typeof propKey) {
	                      case "undefined":
	                      case "function":
	                      case "symbol":
	                        break a;
	                      default:
	                        if (false === propKey) break a;
	                    }
	                  else if (null != propKey)
	                    switch (typeof propKey) {
	                      case "function":
	                      case "symbol":
	                        break;
	                      case "boolean":
	                        if (true === propKey && "" === i) break a;
	                        break;
	                      default:
	                        if (checkAttributeStringCoercion(propKey, attributes), i === "" + propKey)
	                          break a;
	                    }
	                  warnForPropDifference(
	                    attributes,
	                    i,
	                    propKey,
	                    serverDifferences$jscomp$0
	                  );
	                }
	                continue;
	              case "cols":
	              case "rows":
	              case "size":
	              case "span":
	                a: {
	                  i = domElement;
	                  attributeName = attributes = value;
	                  serverDifferences$jscomp$0 = serverDifferences;
	                  extraAttributes.delete(attributeName);
	                  i = i.getAttribute(attributeName);
	                  if (null === i)
	                    switch (typeof propKey) {
	                      case "undefined":
	                      case "function":
	                      case "symbol":
	                      case "boolean":
	                        break a;
	                      default:
	                        if (isNaN(propKey) || 1 > propKey) break a;
	                    }
	                  else if (null != propKey)
	                    switch (typeof propKey) {
	                      case "function":
	                      case "symbol":
	                      case "boolean":
	                        break;
	                      default:
	                        if (!(isNaN(propKey) || 1 > propKey) && (checkAttributeStringCoercion(propKey, attributes), i === "" + propKey))
	                          break a;
	                    }
	                  warnForPropDifference(
	                    attributes,
	                    i,
	                    propKey,
	                    serverDifferences$jscomp$0
	                  );
	                }
	                continue;
	              case "rowSpan":
	                hydrateNumericAttribute(
	                  domElement,
	                  value,
	                  "rowspan",
	                  propKey,
	                  extraAttributes,
	                  serverDifferences
	                );
	                continue;
	              case "start":
	                hydrateNumericAttribute(
	                  domElement,
	                  value,
	                  value,
	                  propKey,
	                  extraAttributes,
	                  serverDifferences
	                );
	                continue;
	              case "xHeight":
	                hydrateAttribute(
	                  domElement,
	                  value,
	                  "x-height",
	                  propKey,
	                  extraAttributes,
	                  serverDifferences
	                );
	                continue;
	              case "xlinkActuate":
	                hydrateAttribute(
	                  domElement,
	                  value,
	                  "xlink:actuate",
	                  propKey,
	                  extraAttributes,
	                  serverDifferences
	                );
	                continue;
	              case "xlinkArcrole":
	                hydrateAttribute(
	                  domElement,
	                  value,
	                  "xlink:arcrole",
	                  propKey,
	                  extraAttributes,
	                  serverDifferences
	                );
	                continue;
	              case "xlinkRole":
	                hydrateAttribute(
	                  domElement,
	                  value,
	                  "xlink:role",
	                  propKey,
	                  extraAttributes,
	                  serverDifferences
	                );
	                continue;
	              case "xlinkShow":
	                hydrateAttribute(
	                  domElement,
	                  value,
	                  "xlink:show",
	                  propKey,
	                  extraAttributes,
	                  serverDifferences
	                );
	                continue;
	              case "xlinkTitle":
	                hydrateAttribute(
	                  domElement,
	                  value,
	                  "xlink:title",
	                  propKey,
	                  extraAttributes,
	                  serverDifferences
	                );
	                continue;
	              case "xlinkType":
	                hydrateAttribute(
	                  domElement,
	                  value,
	                  "xlink:type",
	                  propKey,
	                  extraAttributes,
	                  serverDifferences
	                );
	                continue;
	              case "xmlBase":
	                hydrateAttribute(
	                  domElement,
	                  value,
	                  "xml:base",
	                  propKey,
	                  extraAttributes,
	                  serverDifferences
	                );
	                continue;
	              case "xmlLang":
	                hydrateAttribute(
	                  domElement,
	                  value,
	                  "xml:lang",
	                  propKey,
	                  extraAttributes,
	                  serverDifferences
	                );
	                continue;
	              case "xmlSpace":
	                hydrateAttribute(
	                  domElement,
	                  value,
	                  "xml:space",
	                  propKey,
	                  extraAttributes,
	                  serverDifferences
	                );
	                continue;
	              case "inert":
	                "" !== propKey || didWarnForNewBooleanPropsWithEmptyValue[value] || (didWarnForNewBooleanPropsWithEmptyValue[value] = true, console.error(
	                  "Received an empty string for a boolean attribute `%s`. This will treat the attribute as if it were false. Either pass `false` to silence this warning, or pass `true` if you used an empty string in earlier versions of React to indicate this attribute is true.",
	                  value
	                ));
	                hydrateBooleanAttribute(
	                  domElement,
	                  value,
	                  value,
	                  propKey,
	                  extraAttributes,
	                  serverDifferences
	                );
	                continue;
	              default:
	                if (!(2 < value.length) || "o" !== value[0] && "O" !== value[0] || "n" !== value[1] && "N" !== value[1]) {
	                  i = getAttributeAlias(value);
	                  attributes = false;
	                  hostContext.context === HostContextNamespaceNone && "svg" !== tag && "math" !== tag ? extraAttributes.delete(i.toLowerCase()) : (attributeName = value.toLowerCase(), attributeName = possibleStandardNames.hasOwnProperty(
	                    attributeName
	                  ) ? possibleStandardNames[attributeName] || null : null, null !== attributeName && attributeName !== value && (attributes = true, extraAttributes.delete(attributeName)), extraAttributes.delete(i));
	                  a: if (attributeName = domElement, serverDifferences$jscomp$0 = i, i = propKey, isAttributeNameSafe(serverDifferences$jscomp$0))
	                    if (attributeName.hasAttribute(serverDifferences$jscomp$0))
	                      attributeName = attributeName.getAttribute(
	                        serverDifferences$jscomp$0
	                      ), checkAttributeStringCoercion(
	                        i,
	                        serverDifferences$jscomp$0
	                      ), i = attributeName === "" + i ? i : attributeName;
	                    else {
	                      switch (typeof i) {
	                        case "function":
	                        case "symbol":
	                          break a;
	                        case "boolean":
	                          if (attributeName = serverDifferences$jscomp$0.toLowerCase().slice(0, 5), "data-" !== attributeName && "aria-" !== attributeName)
	                            break a;
	                      }
	                      i = void 0 === i ? void 0 : null;
	                    }
	                  else i = void 0;
	                  attributes || warnForPropDifference(
	                    value,
	                    i,
	                    propKey,
	                    serverDifferences
	                  );
	                }
	            }
	        }
	    0 < extraAttributes.size && true !== props.suppressHydrationWarning && warnForExtraAttributes(domElement, extraAttributes, serverDifferences);
	    return 0 === Object.keys(serverDifferences).length ? null : serverDifferences;
	  }
	  function propNamesListJoin(list, combinator) {
	    switch (list.length) {
	      case 0:
	        return "";
	      case 1:
	        return list[0];
	      case 2:
	        return list[0] + " " + combinator + " " + list[1];
	      default:
	        return list.slice(0, -1).join(", ") + ", " + combinator + " " + list[list.length - 1];
	    }
	  }
	  function getOwnerDocumentFromRootContainer(rootContainerElement) {
	    return 9 === rootContainerElement.nodeType ? rootContainerElement : rootContainerElement.ownerDocument;
	  }
	  function getOwnHostContext(namespaceURI) {
	    switch (namespaceURI) {
	      case SVG_NAMESPACE:
	        return HostContextNamespaceSvg;
	      case MATH_NAMESPACE:
	        return HostContextNamespaceMath;
	      default:
	        return HostContextNamespaceNone;
	    }
	  }
	  function getChildHostContextProd(parentNamespace, type) {
	    if (parentNamespace === HostContextNamespaceNone)
	      switch (type) {
	        case "svg":
	          return HostContextNamespaceSvg;
	        case "math":
	          return HostContextNamespaceMath;
	        default:
	          return HostContextNamespaceNone;
	      }
	    return parentNamespace === HostContextNamespaceSvg && "foreignObject" === type ? HostContextNamespaceNone : parentNamespace;
	  }
	  function shouldSetTextContent(type, props) {
	    return "textarea" === type || "noscript" === type || "string" === typeof props.children || "number" === typeof props.children || "bigint" === typeof props.children || "object" === typeof props.dangerouslySetInnerHTML && null !== props.dangerouslySetInnerHTML && null != props.dangerouslySetInnerHTML.__html;
	  }
	  function shouldAttemptEagerTransition() {
	    var event = window.event;
	    if (event && "popstate" === event.type) {
	      if (event === currentPopstateTransitionEvent) return false;
	      currentPopstateTransitionEvent = event;
	      return true;
	    }
	    currentPopstateTransitionEvent = null;
	    return false;
	  }
	  function handleErrorInNextTick(error) {
	    setTimeout(function() {
	      throw error;
	    });
	  }
	  function commitMount(domElement, type, newProps) {
	    switch (type) {
	      case "button":
	      case "input":
	      case "select":
	      case "textarea":
	        newProps.autoFocus && domElement.focus();
	        break;
	      case "img":
	        newProps.src ? domElement.src = newProps.src : newProps.srcSet && (domElement.srcset = newProps.srcSet);
	    }
	  }
	  function commitUpdate(domElement, type, oldProps, newProps) {
	    updateProperties(domElement, type, oldProps, newProps);
	    domElement[internalPropsKey] = newProps;
	  }
	  function resetTextContent(domElement) {
	    setTextContent(domElement, "");
	  }
	  function commitTextUpdate(textInstance, oldText, newText) {
	    textInstance.nodeValue = newText;
	  }
	  function isSingletonScope(type) {
	    return "head" === type;
	  }
	  function removeChild(parentInstance, child) {
	    parentInstance.removeChild(child);
	  }
	  function removeChildFromContainer(container, child) {
	    (9 === container.nodeType ? container.body : "HTML" === container.nodeName ? container.ownerDocument.body : container).removeChild(child);
	  }
	  function clearSuspenseBoundary(parentInstance, suspenseInstance) {
	    var node = suspenseInstance, possiblePreambleContribution = 0, depth = 0;
	    do {
	      var nextNode = node.nextSibling;
	      parentInstance.removeChild(node);
	      if (nextNode && 8 === nextNode.nodeType)
	        if (node = nextNode.data, node === SUSPENSE_END_DATA) {
	          if (0 < possiblePreambleContribution && 8 > possiblePreambleContribution) {
	            node = possiblePreambleContribution;
	            var ownerDocument = parentInstance.ownerDocument;
	            node & PREAMBLE_CONTRIBUTION_HTML && releaseSingletonInstance(ownerDocument.documentElement);
	            node & PREAMBLE_CONTRIBUTION_BODY && releaseSingletonInstance(ownerDocument.body);
	            if (node & PREAMBLE_CONTRIBUTION_HEAD)
	              for (node = ownerDocument.head, releaseSingletonInstance(node), ownerDocument = node.firstChild; ownerDocument; ) {
	                var nextNode$jscomp$0 = ownerDocument.nextSibling, nodeName = ownerDocument.nodeName;
	                ownerDocument[internalHoistableMarker] || "SCRIPT" === nodeName || "STYLE" === nodeName || "LINK" === nodeName && "stylesheet" === ownerDocument.rel.toLowerCase() || node.removeChild(ownerDocument);
	                ownerDocument = nextNode$jscomp$0;
	              }
	          }
	          if (0 === depth) {
	            parentInstance.removeChild(nextNode);
	            retryIfBlockedOn(suspenseInstance);
	            return;
	          }
	          depth--;
	        } else
	          node === SUSPENSE_START_DATA || node === SUSPENSE_PENDING_START_DATA || node === SUSPENSE_FALLBACK_START_DATA ? depth++ : possiblePreambleContribution = node.charCodeAt(0) - 48;
	      else possiblePreambleContribution = 0;
	      node = nextNode;
	    } while (node);
	    retryIfBlockedOn(suspenseInstance);
	  }
	  function hideInstance(instance) {
	    instance = instance.style;
	    "function" === typeof instance.setProperty ? instance.setProperty("display", "none", "important") : instance.display = "none";
	  }
	  function hideTextInstance(textInstance) {
	    textInstance.nodeValue = "";
	  }
	  function unhideInstance(instance, props) {
	    props = props[STYLE];
	    props = void 0 !== props && null !== props && props.hasOwnProperty("display") ? props.display : null;
	    instance.style.display = null == props || "boolean" === typeof props ? "" : ("" + props).trim();
	  }
	  function unhideTextInstance(textInstance, text) {
	    textInstance.nodeValue = text;
	  }
	  function clearContainerSparingly(container) {
	    var nextNode = container.firstChild;
	    nextNode && 10 === nextNode.nodeType && (nextNode = nextNode.nextSibling);
	    for (; nextNode; ) {
	      var node = nextNode;
	      nextNode = nextNode.nextSibling;
	      switch (node.nodeName) {
	        case "HTML":
	        case "HEAD":
	        case "BODY":
	          clearContainerSparingly(node);
	          detachDeletedInstance(node);
	          continue;
	        case "SCRIPT":
	        case "STYLE":
	          continue;
	        case "LINK":
	          if ("stylesheet" === node.rel.toLowerCase()) continue;
	      }
	      container.removeChild(node);
	    }
	  }
	  function canHydrateInstance(instance, type, props, inRootOrSingleton) {
	    for (; 1 === instance.nodeType; ) {
	      var anyProps = props;
	      if (instance.nodeName.toLowerCase() !== type.toLowerCase()) {
	        if (!inRootOrSingleton && ("INPUT" !== instance.nodeName || "hidden" !== instance.type))
	          break;
	      } else if (!inRootOrSingleton)
	        if ("input" === type && "hidden" === instance.type) {
	          checkAttributeStringCoercion(anyProps.name, "name");
	          var name = null == anyProps.name ? null : "" + anyProps.name;
	          if ("hidden" === anyProps.type && instance.getAttribute("name") === name)
	            return instance;
	        } else return instance;
	      else if (!instance[internalHoistableMarker])
	        switch (type) {
	          case "meta":
	            if (!instance.hasAttribute("itemprop")) break;
	            return instance;
	          case "link":
	            name = instance.getAttribute("rel");
	            if ("stylesheet" === name && instance.hasAttribute("data-precedence"))
	              break;
	            else if (name !== anyProps.rel || instance.getAttribute("href") !== (null == anyProps.href || "" === anyProps.href ? null : anyProps.href) || instance.getAttribute("crossorigin") !== (null == anyProps.crossOrigin ? null : anyProps.crossOrigin) || instance.getAttribute("title") !== (null == anyProps.title ? null : anyProps.title))
	              break;
	            return instance;
	          case "style":
	            if (instance.hasAttribute("data-precedence")) break;
	            return instance;
	          case "script":
	            name = instance.getAttribute("src");
	            if ((name !== (null == anyProps.src ? null : anyProps.src) || instance.getAttribute("type") !== (null == anyProps.type ? null : anyProps.type) || instance.getAttribute("crossorigin") !== (null == anyProps.crossOrigin ? null : anyProps.crossOrigin)) && name && instance.hasAttribute("async") && !instance.hasAttribute("itemprop"))
	              break;
	            return instance;
	          default:
	            return instance;
	        }
	      instance = getNextHydratable(instance.nextSibling);
	      if (null === instance) break;
	    }
	    return null;
	  }
	  function canHydrateTextInstance(instance, text, inRootOrSingleton) {
	    if ("" === text) return null;
	    for (; 3 !== instance.nodeType; ) {
	      if ((1 !== instance.nodeType || "INPUT" !== instance.nodeName || "hidden" !== instance.type) && !inRootOrSingleton)
	        return null;
	      instance = getNextHydratable(instance.nextSibling);
	      if (null === instance) return null;
	    }
	    return instance;
	  }
	  function isSuspenseInstanceFallback(instance) {
	    return instance.data === SUSPENSE_FALLBACK_START_DATA || instance.data === SUSPENSE_PENDING_START_DATA && instance.ownerDocument.readyState === DOCUMENT_READY_STATE_COMPLETE;
	  }
	  function registerSuspenseInstanceRetry(instance, callback) {
	    var ownerDocument = instance.ownerDocument;
	    if (instance.data !== SUSPENSE_PENDING_START_DATA || ownerDocument.readyState === DOCUMENT_READY_STATE_COMPLETE)
	      callback();
	    else {
	      var listener = function() {
	        callback();
	        ownerDocument.removeEventListener("DOMContentLoaded", listener);
	      };
	      ownerDocument.addEventListener("DOMContentLoaded", listener);
	      instance._reactRetry = listener;
	    }
	  }
	  function getNextHydratable(node) {
	    for (; null != node; node = node.nextSibling) {
	      var nodeType = node.nodeType;
	      if (1 === nodeType || 3 === nodeType) break;
	      if (8 === nodeType) {
	        nodeType = node.data;
	        if (nodeType === SUSPENSE_START_DATA || nodeType === SUSPENSE_FALLBACK_START_DATA || nodeType === SUSPENSE_PENDING_START_DATA || nodeType === FORM_STATE_IS_MATCHING || nodeType === FORM_STATE_IS_NOT_MATCHING)
	          break;
	        if (nodeType === SUSPENSE_END_DATA) return null;
	      }
	    }
	    return node;
	  }
	  function describeHydratableInstanceForDevWarnings(instance) {
	    if (1 === instance.nodeType) {
	      for (var JSCompiler_temp_const = instance.nodeName.toLowerCase(), serverDifferences = {}, attributes = instance.attributes, i = 0; i < attributes.length; i++) {
	        var attr = attributes[i];
	        serverDifferences[getPropNameFromAttributeName(attr.name)] = "style" === attr.name.toLowerCase() ? getStylesObjectFromElement(instance) : attr.value;
	      }
	      return { type: JSCompiler_temp_const, props: serverDifferences };
	    }
	    return 8 === instance.nodeType ? { type: "Suspense", props: {} } : instance.nodeValue;
	  }
	  function diffHydratedTextForDevWarnings(textInstance, text, parentProps) {
	    return null === parentProps || true !== parentProps[SUPPRESS_HYDRATION_WARNING] ? (textInstance.nodeValue === text ? textInstance = null : (text = normalizeMarkupForTextOrAttribute(text), textInstance = normalizeMarkupForTextOrAttribute(textInstance.nodeValue) === text ? null : textInstance.nodeValue), textInstance) : null;
	  }
	  function getNextHydratableInstanceAfterSuspenseInstance(suspenseInstance) {
	    suspenseInstance = suspenseInstance.nextSibling;
	    for (var depth = 0; suspenseInstance; ) {
	      if (8 === suspenseInstance.nodeType) {
	        var data = suspenseInstance.data;
	        if (data === SUSPENSE_END_DATA) {
	          if (0 === depth)
	            return getNextHydratable(suspenseInstance.nextSibling);
	          depth--;
	        } else
	          data !== SUSPENSE_START_DATA && data !== SUSPENSE_FALLBACK_START_DATA && data !== SUSPENSE_PENDING_START_DATA || depth++;
	      }
	      suspenseInstance = suspenseInstance.nextSibling;
	    }
	    return null;
	  }
	  function getParentSuspenseInstance(targetInstance) {
	    targetInstance = targetInstance.previousSibling;
	    for (var depth = 0; targetInstance; ) {
	      if (8 === targetInstance.nodeType) {
	        var data = targetInstance.data;
	        if (data === SUSPENSE_START_DATA || data === SUSPENSE_FALLBACK_START_DATA || data === SUSPENSE_PENDING_START_DATA) {
	          if (0 === depth) return targetInstance;
	          depth--;
	        } else data === SUSPENSE_END_DATA && depth++;
	      }
	      targetInstance = targetInstance.previousSibling;
	    }
	    return null;
	  }
	  function commitHydratedContainer(container) {
	    retryIfBlockedOn(container);
	  }
	  function commitHydratedSuspenseInstance(suspenseInstance) {
	    retryIfBlockedOn(suspenseInstance);
	  }
	  function resolveSingletonInstance(type, props, rootContainerInstance, hostContext, validateDOMNestingDev) {
	    validateDOMNestingDev && validateDOMNesting(type, hostContext.ancestorInfo);
	    props = getOwnerDocumentFromRootContainer(rootContainerInstance);
	    switch (type) {
	      case "html":
	        type = props.documentElement;
	        if (!type)
	          throw Error(
	            "React expected an <html> element (document.documentElement) to exist in the Document but one was not found. React never removes the documentElement for any Document it renders into so the cause is likely in some other script running on this page."
	          );
	        return type;
	      case "head":
	        type = props.head;
	        if (!type)
	          throw Error(
	            "React expected a <head> element (document.head) to exist in the Document but one was not found. React never removes the head for any Document it renders into so the cause is likely in some other script running on this page."
	          );
	        return type;
	      case "body":
	        type = props.body;
	        if (!type)
	          throw Error(
	            "React expected a <body> element (document.body) to exist in the Document but one was not found. React never removes the body for any Document it renders into so the cause is likely in some other script running on this page."
	          );
	        return type;
	      default:
	        throw Error(
	          "resolveSingletonInstance was called with an element type that is not supported. This is a bug in React."
	        );
	    }
	  }
	  function acquireSingletonInstance(type, props, instance, internalInstanceHandle) {
	    if (!instance[internalContainerInstanceKey] && getInstanceFromNode(instance)) {
	      var tagName = instance.tagName.toLowerCase();
	      console.error(
	        "You are mounting a new %s component when a previous one has not first unmounted. It is an error to render more than one %s component at a time and attributes and children of these components will likely fail in unpredictable ways. Please only render a single instance of <%s> and if you need to mount a new one, ensure any previous ones have unmounted first.",
	        tagName,
	        tagName,
	        tagName
	      );
	    }
	    switch (type) {
	      case "html":
	      case "head":
	      case "body":
	        break;
	      default:
	        console.error(
	          "acquireSingletonInstance was called with an element type that is not supported. This is a bug in React."
	        );
	    }
	    for (tagName = instance.attributes; tagName.length; )
	      instance.removeAttributeNode(tagName[0]);
	    setInitialProperties(instance, type, props);
	    instance[internalInstanceKey] = internalInstanceHandle;
	    instance[internalPropsKey] = props;
	  }
	  function releaseSingletonInstance(instance) {
	    for (var attributes = instance.attributes; attributes.length; )
	      instance.removeAttributeNode(attributes[0]);
	    detachDeletedInstance(instance);
	  }
	  function getHoistableRoot(container) {
	    return "function" === typeof container.getRootNode ? container.getRootNode() : 9 === container.nodeType ? container : container.ownerDocument;
	  }
	  function preconnectAs(rel, href, crossOrigin) {
	    var ownerDocument = globalDocument;
	    if (ownerDocument && "string" === typeof href && href) {
	      var limitedEscapedHref = escapeSelectorAttributeValueInsideDoubleQuotes(href);
	      limitedEscapedHref = 'link[rel="' + rel + '"][href="' + limitedEscapedHref + '"]';
	      "string" === typeof crossOrigin && (limitedEscapedHref += '[crossorigin="' + crossOrigin + '"]');
	      preconnectsSet.has(limitedEscapedHref) || (preconnectsSet.add(limitedEscapedHref), rel = { rel, crossOrigin, href }, null === ownerDocument.querySelector(limitedEscapedHref) && (href = ownerDocument.createElement("link"), setInitialProperties(href, "link", rel), markNodeAsHoistable(href), ownerDocument.head.appendChild(href)));
	    }
	  }
	  function getResource(type, currentProps, pendingProps, currentResource) {
	    var resourceRoot = (resourceRoot = rootInstanceStackCursor.current) ? getHoistableRoot(resourceRoot) : null;
	    if (!resourceRoot)
	      throw Error(
	        '"resourceRoot" was expected to exist. This is a bug in React.'
	      );
	    switch (type) {
	      case "meta":
	      case "title":
	        return null;
	      case "style":
	        return "string" === typeof pendingProps.precedence && "string" === typeof pendingProps.href ? (pendingProps = getStyleKey(pendingProps.href), currentProps = getResourcesFromRoot(resourceRoot).hoistableStyles, currentResource = currentProps.get(pendingProps), currentResource || (currentResource = {
	          type: "style",
	          instance: null,
	          count: 0,
	          state: null
	        }, currentProps.set(pendingProps, currentResource)), currentResource) : { type: "void", instance: null, count: 0, state: null };
	      case "link":
	        if ("stylesheet" === pendingProps.rel && "string" === typeof pendingProps.href && "string" === typeof pendingProps.precedence) {
	          type = getStyleKey(pendingProps.href);
	          var _styles = getResourcesFromRoot(resourceRoot).hoistableStyles, _resource = _styles.get(type);
	          if (!_resource && (resourceRoot = resourceRoot.ownerDocument || resourceRoot, _resource = {
	            type: "stylesheet",
	            instance: null,
	            count: 0,
	            state: { loading: NotLoaded, preload: null }
	          }, _styles.set(type, _resource), (_styles = resourceRoot.querySelector(
	            getStylesheetSelectorFromKey(type)
	          )) && !_styles._p && (_resource.instance = _styles, _resource.state.loading = Loaded | Inserted), !preloadPropsMap.has(type))) {
	            var preloadProps = {
	              rel: "preload",
	              as: "style",
	              href: pendingProps.href,
	              crossOrigin: pendingProps.crossOrigin,
	              integrity: pendingProps.integrity,
	              media: pendingProps.media,
	              hrefLang: pendingProps.hrefLang,
	              referrerPolicy: pendingProps.referrerPolicy
	            };
	            preloadPropsMap.set(type, preloadProps);
	            _styles || preloadStylesheet(
	              resourceRoot,
	              type,
	              preloadProps,
	              _resource.state
	            );
	          }
	          if (currentProps && null === currentResource)
	            throw pendingProps = "\n\n  - " + describeLinkForResourceErrorDEV(currentProps) + "\n  + " + describeLinkForResourceErrorDEV(pendingProps), Error(
	              "Expected <link> not to update to be updated to a stylesheet with precedence. Check the `rel`, `href`, and `precedence` props of this component. Alternatively, check whether two different <link> components render in the same slot or share the same key." + pendingProps
	            );
	          return _resource;
	        }
	        if (currentProps && null !== currentResource)
	          throw pendingProps = "\n\n  - " + describeLinkForResourceErrorDEV(currentProps) + "\n  + " + describeLinkForResourceErrorDEV(pendingProps), Error(
	            "Expected stylesheet with precedence to not be updated to a different kind of <link>. Check the `rel`, `href`, and `precedence` props of this component. Alternatively, check whether two different <link> components render in the same slot or share the same key." + pendingProps
	          );
	        return null;
	      case "script":
	        return currentProps = pendingProps.async, pendingProps = pendingProps.src, "string" === typeof pendingProps && currentProps && "function" !== typeof currentProps && "symbol" !== typeof currentProps ? (pendingProps = getScriptKey(pendingProps), currentProps = getResourcesFromRoot(resourceRoot).hoistableScripts, currentResource = currentProps.get(pendingProps), currentResource || (currentResource = {
	          type: "script",
	          instance: null,
	          count: 0,
	          state: null
	        }, currentProps.set(pendingProps, currentResource)), currentResource) : { type: "void", instance: null, count: 0, state: null };
	      default:
	        throw Error(
	          'getResource encountered a type it did not expect: "' + type + '". this is a bug in React.'
	        );
	    }
	  }
	  function describeLinkForResourceErrorDEV(props) {
	    var describedProps = 0, description = "<link";
	    "string" === typeof props.rel ? (describedProps++, description += ' rel="' + props.rel + '"') : hasOwnProperty.call(props, "rel") && (describedProps++, description += ' rel="' + (null === props.rel ? "null" : "invalid type " + typeof props.rel) + '"');
	    "string" === typeof props.href ? (describedProps++, description += ' href="' + props.href + '"') : hasOwnProperty.call(props, "href") && (describedProps++, description += ' href="' + (null === props.href ? "null" : "invalid type " + typeof props.href) + '"');
	    "string" === typeof props.precedence ? (describedProps++, description += ' precedence="' + props.precedence + '"') : hasOwnProperty.call(props, "precedence") && (describedProps++, description += " precedence={" + (null === props.precedence ? "null" : "invalid type " + typeof props.precedence) + "}");
	    Object.getOwnPropertyNames(props).length > describedProps && (description += " ...");
	    return description + " />";
	  }
	  function getStyleKey(href) {
	    return 'href="' + escapeSelectorAttributeValueInsideDoubleQuotes(href) + '"';
	  }
	  function getStylesheetSelectorFromKey(key) {
	    return 'link[rel="stylesheet"][' + key + "]";
	  }
	  function stylesheetPropsFromRawProps(rawProps) {
	    return assign({}, rawProps, {
	      "data-precedence": rawProps.precedence,
	      precedence: null
	    });
	  }
	  function preloadStylesheet(ownerDocument, key, preloadProps, state) {
	    ownerDocument.querySelector(
	      'link[rel="preload"][as="style"][' + key + "]"
	    ) ? state.loading = Loaded : (key = ownerDocument.createElement("link"), state.preload = key, key.addEventListener("load", function() {
	      return state.loading |= Loaded;
	    }), key.addEventListener("error", function() {
	      return state.loading |= Errored;
	    }), setInitialProperties(key, "link", preloadProps), markNodeAsHoistable(key), ownerDocument.head.appendChild(key));
	  }
	  function getScriptKey(src) {
	    return '[src="' + escapeSelectorAttributeValueInsideDoubleQuotes(src) + '"]';
	  }
	  function getScriptSelectorFromKey(key) {
	    return "script[async]" + key;
	  }
	  function acquireResource(hoistableRoot, resource, props) {
	    resource.count++;
	    if (null === resource.instance)
	      switch (resource.type) {
	        case "style":
	          var instance = hoistableRoot.querySelector(
	            'style[data-href~="' + escapeSelectorAttributeValueInsideDoubleQuotes(props.href) + '"]'
	          );
	          if (instance)
	            return resource.instance = instance, markNodeAsHoistable(instance), instance;
	          var styleProps = assign({}, props, {
	            "data-href": props.href,
	            "data-precedence": props.precedence,
	            href: null,
	            precedence: null
	          });
	          instance = (hoistableRoot.ownerDocument || hoistableRoot).createElement("style");
	          markNodeAsHoistable(instance);
	          setInitialProperties(instance, "style", styleProps);
	          insertStylesheet(instance, props.precedence, hoistableRoot);
	          return resource.instance = instance;
	        case "stylesheet":
	          styleProps = getStyleKey(props.href);
	          var _instance = hoistableRoot.querySelector(
	            getStylesheetSelectorFromKey(styleProps)
	          );
	          if (_instance)
	            return resource.state.loading |= Inserted, resource.instance = _instance, markNodeAsHoistable(_instance), _instance;
	          instance = stylesheetPropsFromRawProps(props);
	          (styleProps = preloadPropsMap.get(styleProps)) && adoptPreloadPropsForStylesheet(instance, styleProps);
	          _instance = (hoistableRoot.ownerDocument || hoistableRoot).createElement("link");
	          markNodeAsHoistable(_instance);
	          var linkInstance = _instance;
	          linkInstance._p = new Promise(function(resolve, reject) {
	            linkInstance.onload = resolve;
	            linkInstance.onerror = reject;
	          });
	          setInitialProperties(_instance, "link", instance);
	          resource.state.loading |= Inserted;
	          insertStylesheet(_instance, props.precedence, hoistableRoot);
	          return resource.instance = _instance;
	        case "script":
	          _instance = getScriptKey(props.src);
	          if (styleProps = hoistableRoot.querySelector(
	            getScriptSelectorFromKey(_instance)
	          ))
	            return resource.instance = styleProps, markNodeAsHoistable(styleProps), styleProps;
	          instance = props;
	          if (styleProps = preloadPropsMap.get(_instance))
	            instance = assign({}, props), adoptPreloadPropsForScript(instance, styleProps);
	          hoistableRoot = hoistableRoot.ownerDocument || hoistableRoot;
	          styleProps = hoistableRoot.createElement("script");
	          markNodeAsHoistable(styleProps);
	          setInitialProperties(styleProps, "link", instance);
	          hoistableRoot.head.appendChild(styleProps);
	          return resource.instance = styleProps;
	        case "void":
	          return null;
	        default:
	          throw Error(
	            'acquireResource encountered a resource type it did not expect: "' + resource.type + '". this is a bug in React.'
	          );
	      }
	    else
	      "stylesheet" === resource.type && (resource.state.loading & Inserted) === NotLoaded && (instance = resource.instance, resource.state.loading |= Inserted, insertStylesheet(instance, props.precedence, hoistableRoot));
	    return resource.instance;
	  }
	  function insertStylesheet(instance, precedence, root2) {
	    for (var nodes = root2.querySelectorAll(
	      'link[rel="stylesheet"][data-precedence],style[data-precedence]'
	    ), last = nodes.length ? nodes[nodes.length - 1] : null, prior = last, i = 0; i < nodes.length; i++) {
	      var node = nodes[i];
	      if (node.dataset.precedence === precedence) prior = node;
	      else if (prior !== last) break;
	    }
	    prior ? prior.parentNode.insertBefore(instance, prior.nextSibling) : (precedence = 9 === root2.nodeType ? root2.head : root2, precedence.insertBefore(instance, precedence.firstChild));
	  }
	  function adoptPreloadPropsForStylesheet(stylesheetProps, preloadProps) {
	    null == stylesheetProps.crossOrigin && (stylesheetProps.crossOrigin = preloadProps.crossOrigin);
	    null == stylesheetProps.referrerPolicy && (stylesheetProps.referrerPolicy = preloadProps.referrerPolicy);
	    null == stylesheetProps.title && (stylesheetProps.title = preloadProps.title);
	  }
	  function adoptPreloadPropsForScript(scriptProps, preloadProps) {
	    null == scriptProps.crossOrigin && (scriptProps.crossOrigin = preloadProps.crossOrigin);
	    null == scriptProps.referrerPolicy && (scriptProps.referrerPolicy = preloadProps.referrerPolicy);
	    null == scriptProps.integrity && (scriptProps.integrity = preloadProps.integrity);
	  }
	  function getHydratableHoistableCache(type, keyAttribute, ownerDocument) {
	    if (null === tagCaches) {
	      var cache = /* @__PURE__ */ new Map();
	      var caches = tagCaches = /* @__PURE__ */ new Map();
	      caches.set(ownerDocument, cache);
	    } else
	      caches = tagCaches, cache = caches.get(ownerDocument), cache || (cache = /* @__PURE__ */ new Map(), caches.set(ownerDocument, cache));
	    if (cache.has(type)) return cache;
	    cache.set(type, null);
	    ownerDocument = ownerDocument.getElementsByTagName(type);
	    for (caches = 0; caches < ownerDocument.length; caches++) {
	      var node = ownerDocument[caches];
	      if (!(node[internalHoistableMarker] || node[internalInstanceKey] || "link" === type && "stylesheet" === node.getAttribute("rel")) && node.namespaceURI !== SVG_NAMESPACE) {
	        var nodeKey = node.getAttribute(keyAttribute) || "";
	        nodeKey = type + nodeKey;
	        var existing = cache.get(nodeKey);
	        existing ? existing.push(node) : cache.set(nodeKey, [node]);
	      }
	    }
	    return cache;
	  }
	  function mountHoistable(hoistableRoot, type, instance) {
	    hoistableRoot = hoistableRoot.ownerDocument || hoistableRoot;
	    hoistableRoot.head.insertBefore(
	      instance,
	      "title" === type ? hoistableRoot.querySelector("head > title") : null
	    );
	  }
	  function isHostHoistableType(type, props, hostContext) {
	    var outsideHostContainerContext = !hostContext.ancestorInfo.containerTagInScope;
	    if (hostContext.context === HostContextNamespaceSvg || null != props.itemProp)
	      return !outsideHostContainerContext || null == props.itemProp || "meta" !== type && "title" !== type && "style" !== type && "link" !== type && "script" !== type || console.error(
	        "Cannot render a <%s> outside the main document if it has an `itemProp` prop. `itemProp` suggests the tag belongs to an `itemScope` which can appear anywhere in the DOM. If you were intending for React to hoist this <%s> remove the `itemProp` prop. Otherwise, try moving this tag into the <head> or <body> of the Document.",
	        type,
	        type
	      ), false;
	    switch (type) {
	      case "meta":
	      case "title":
	        return true;
	      case "style":
	        if ("string" !== typeof props.precedence || "string" !== typeof props.href || "" === props.href) {
	          outsideHostContainerContext && console.error(
	            'Cannot render a <style> outside the main document without knowing its precedence and a unique href key. React can hoist and deduplicate <style> tags if you provide a `precedence` prop along with an `href` prop that does not conflict with the `href` values used in any other hoisted <style> or <link rel="stylesheet" ...> tags.  Note that hoisting <style> tags is considered an advanced feature that most will not use directly. Consider moving the <style> tag to the <head> or consider adding a `precedence="default"` and `href="some unique resource identifier"`.'
	          );
	          break;
	        }
	        return true;
	      case "link":
	        if ("string" !== typeof props.rel || "string" !== typeof props.href || "" === props.href || props.onLoad || props.onError) {
	          if ("stylesheet" === props.rel && "string" === typeof props.precedence) {
	            type = props.href;
	            var onError = props.onError, disabled = props.disabled;
	            hostContext = [];
	            props.onLoad && hostContext.push("`onLoad`");
	            onError && hostContext.push("`onError`");
	            null != disabled && hostContext.push("`disabled`");
	            onError = propNamesListJoin(hostContext, "and");
	            onError += 1 === hostContext.length ? " prop" : " props";
	            disabled = 1 === hostContext.length ? "an " + onError : "the " + onError;
	            hostContext.length && console.error(
	              'React encountered a <link rel="stylesheet" href="%s" ... /> with a `precedence` prop that also included %s. The presence of loading and error handlers indicates an intent to manage the stylesheet loading state from your from your Component code and React will not hoist or deduplicate this stylesheet. If your intent was to have React hoist and deduplciate this stylesheet using the `precedence` prop remove the %s, otherwise remove the `precedence` prop.',
	              type,
	              disabled,
	              onError
	            );
	          }
	          outsideHostContainerContext && ("string" !== typeof props.rel || "string" !== typeof props.href || "" === props.href ? console.error(
	            "Cannot render a <link> outside the main document without a `rel` and `href` prop. Try adding a `rel` and/or `href` prop to this <link> or moving the link into the <head> tag"
	          ) : (props.onError || props.onLoad) && console.error(
	            "Cannot render a <link> with onLoad or onError listeners outside the main document. Try removing onLoad={...} and onError={...} or moving it into the root <head> tag or somewhere in the <body>."
	          ));
	          break;
	        }
	        switch (props.rel) {
	          case "stylesheet":
	            return type = props.precedence, props = props.disabled, "string" !== typeof type && outsideHostContainerContext && console.error(
	              'Cannot render a <link rel="stylesheet" /> outside the main document without knowing its precedence. Consider adding precedence="default" or moving it into the root <head> tag.'
	            ), "string" === typeof type && null == props;
	          default:
	            return true;
	        }
	      case "script":
	        type = props.async && "function" !== typeof props.async && "symbol" !== typeof props.async;
	        if (!type || props.onLoad || props.onError || !props.src || "string" !== typeof props.src) {
	          outsideHostContainerContext && (type ? props.onLoad || props.onError ? console.error(
	            "Cannot render a <script> with onLoad or onError listeners outside the main document. Try removing onLoad={...} and onError={...} or moving it into the root <head> tag or somewhere in the <body>."
	          ) : console.error(
	            "Cannot render a <script> outside the main document without `async={true}` and a non-empty `src` prop. Ensure there is a valid `src` and either make the script async or move it into the root <head> tag or somewhere in the <body>."
	          ) : console.error(
	            'Cannot render a sync or defer <script> outside the main document without knowing its order. Try adding async="" or moving it into the root <head> tag.'
	          ));
	          break;
	        }
	        return true;
	      case "noscript":
	      case "template":
	        outsideHostContainerContext && console.error(
	          "Cannot render <%s> outside the main document. Try moving it into the root <head> tag.",
	          type
	        );
	    }
	    return false;
	  }
	  function preloadResource(resource) {
	    return "stylesheet" === resource.type && (resource.state.loading & Settled) === NotLoaded ? false : true;
	  }
	  function noop() {
	  }
	  function suspendResource(hoistableRoot, resource, props) {
	    if (null === suspendedState)
	      throw Error(
	        "Internal React Error: suspendedState null when it was expected to exists. Please report this as a React bug."
	      );
	    var state = suspendedState;
	    if ("stylesheet" === resource.type && ("string" !== typeof props.media || false !== matchMedia(props.media).matches) && (resource.state.loading & Inserted) === NotLoaded) {
	      if (null === resource.instance) {
	        var key = getStyleKey(props.href), instance = hoistableRoot.querySelector(
	          getStylesheetSelectorFromKey(key)
	        );
	        if (instance) {
	          hoistableRoot = instance._p;
	          null !== hoistableRoot && "object" === typeof hoistableRoot && "function" === typeof hoistableRoot.then && (state.count++, state = onUnsuspend.bind(state), hoistableRoot.then(state, state));
	          resource.state.loading |= Inserted;
	          resource.instance = instance;
	          markNodeAsHoistable(instance);
	          return;
	        }
	        instance = hoistableRoot.ownerDocument || hoistableRoot;
	        props = stylesheetPropsFromRawProps(props);
	        (key = preloadPropsMap.get(key)) && adoptPreloadPropsForStylesheet(props, key);
	        instance = instance.createElement("link");
	        markNodeAsHoistable(instance);
	        var linkInstance = instance;
	        linkInstance._p = new Promise(function(resolve, reject) {
	          linkInstance.onload = resolve;
	          linkInstance.onerror = reject;
	        });
	        setInitialProperties(instance, "link", props);
	        resource.instance = instance;
	      }
	      null === state.stylesheets && (state.stylesheets = /* @__PURE__ */ new Map());
	      state.stylesheets.set(resource, hoistableRoot);
	      (hoistableRoot = resource.state.preload) && (resource.state.loading & Settled) === NotLoaded && (state.count++, resource = onUnsuspend.bind(state), hoistableRoot.addEventListener("load", resource), hoistableRoot.addEventListener("error", resource));
	    }
	  }
	  function waitForCommitToBeReady() {
	    if (null === suspendedState)
	      throw Error(
	        "Internal React Error: suspendedState null when it was expected to exists. Please report this as a React bug."
	      );
	    var state = suspendedState;
	    state.stylesheets && 0 === state.count && insertSuspendedStylesheets(state, state.stylesheets);
	    return 0 < state.count ? function(commit) {
	      var stylesheetTimer = setTimeout(function() {
	        state.stylesheets && insertSuspendedStylesheets(state, state.stylesheets);
	        if (state.unsuspend) {
	          var unsuspend = state.unsuspend;
	          state.unsuspend = null;
	          unsuspend();
	        }
	      }, 6e4);
	      state.unsuspend = commit;
	      return function() {
	        state.unsuspend = null;
	        clearTimeout(stylesheetTimer);
	      };
	    } : null;
	  }
	  function onUnsuspend() {
	    this.count--;
	    if (0 === this.count) {
	      if (this.stylesheets)
	        insertSuspendedStylesheets(this, this.stylesheets);
	      else if (this.unsuspend) {
	        var unsuspend = this.unsuspend;
	        this.unsuspend = null;
	        unsuspend();
	      }
	    }
	  }
	  function insertSuspendedStylesheets(state, resources) {
	    state.stylesheets = null;
	    null !== state.unsuspend && (state.count++, precedencesByRoot = /* @__PURE__ */ new Map(), resources.forEach(insertStylesheetIntoRoot, state), precedencesByRoot = null, onUnsuspend.call(state));
	  }
	  function insertStylesheetIntoRoot(root2, resource) {
	    if (!(resource.state.loading & Inserted)) {
	      var precedences = precedencesByRoot.get(root2);
	      if (precedences) var last = precedences.get(LAST_PRECEDENCE);
	      else {
	        precedences = /* @__PURE__ */ new Map();
	        precedencesByRoot.set(root2, precedences);
	        for (var nodes = root2.querySelectorAll(
	          "link[data-precedence],style[data-precedence]"
	        ), i = 0; i < nodes.length; i++) {
	          var node = nodes[i];
	          if ("LINK" === node.nodeName || "not all" !== node.getAttribute("media"))
	            precedences.set(node.dataset.precedence, node), last = node;
	        }
	        last && precedences.set(LAST_PRECEDENCE, last);
	      }
	      nodes = resource.instance;
	      node = nodes.getAttribute("data-precedence");
	      i = precedences.get(node) || last;
	      i === last && precedences.set(LAST_PRECEDENCE, nodes);
	      precedences.set(node, nodes);
	      this.count++;
	      last = onUnsuspend.bind(this);
	      nodes.addEventListener("load", last);
	      nodes.addEventListener("error", last);
	      i ? i.parentNode.insertBefore(nodes, i.nextSibling) : (root2 = 9 === root2.nodeType ? root2.head : root2, root2.insertBefore(nodes, root2.firstChild));
	      resource.state.loading |= Inserted;
	    }
	  }
	  function FiberRootNode(containerInfo, tag, hydrate, identifierPrefix, onUncaughtError, onCaughtError, onRecoverableError, formState) {
	    this.tag = 1;
	    this.containerInfo = containerInfo;
	    this.pingCache = this.current = this.pendingChildren = null;
	    this.timeoutHandle = noTimeout;
	    this.callbackNode = this.next = this.pendingContext = this.context = this.cancelPendingCommit = null;
	    this.callbackPriority = 0;
	    this.expirationTimes = createLaneMap(-1);
	    this.entangledLanes = this.shellSuspendCounter = this.errorRecoveryDisabledLanes = this.expiredLanes = this.warmLanes = this.pingedLanes = this.suspendedLanes = this.pendingLanes = 0;
	    this.entanglements = createLaneMap(0);
	    this.hiddenUpdates = createLaneMap(null);
	    this.identifierPrefix = identifierPrefix;
	    this.onUncaughtError = onUncaughtError;
	    this.onCaughtError = onCaughtError;
	    this.onRecoverableError = onRecoverableError;
	    this.pooledCache = null;
	    this.pooledCacheLanes = 0;
	    this.formState = formState;
	    this.incompleteTransitions = /* @__PURE__ */ new Map();
	    this.passiveEffectDuration = this.effectDuration = -0;
	    this.memoizedUpdaters = /* @__PURE__ */ new Set();
	    containerInfo = this.pendingUpdatersLaneMap = [];
	    for (tag = 0; 31 > tag; tag++) containerInfo.push(/* @__PURE__ */ new Set());
	    this._debugRootType = hydrate ? "hydrateRoot()" : "createRoot()";
	  }
	  function createFiberRoot(containerInfo, tag, hydrate, initialChildren, hydrationCallbacks, isStrictMode, identifierPrefix, onUncaughtError, onCaughtError, onRecoverableError, transitionCallbacks, formState) {
	    containerInfo = new FiberRootNode(
	      containerInfo,
	      tag,
	      hydrate,
	      identifierPrefix,
	      onUncaughtError,
	      onCaughtError,
	      onRecoverableError,
	      formState
	    );
	    tag = ConcurrentMode;
	    true === isStrictMode && (tag |= StrictLegacyMode | StrictEffectsMode);
	    isDevToolsPresent && (tag |= ProfileMode);
	    isStrictMode = createFiber(3, null, null, tag);
	    containerInfo.current = isStrictMode;
	    isStrictMode.stateNode = containerInfo;
	    tag = createCache();
	    retainCache(tag);
	    containerInfo.pooledCache = tag;
	    retainCache(tag);
	    isStrictMode.memoizedState = {
	      element: initialChildren,
	      isDehydrated: hydrate,
	      cache: tag
	    };
	    initializeUpdateQueue(isStrictMode);
	    return containerInfo;
	  }
	  function getContextForSubtree(parentComponent) {
	    if (!parentComponent) return emptyContextObject;
	    parentComponent = emptyContextObject;
	    return parentComponent;
	  }
	  function updateContainerImpl(rootFiber, lane, element, container, parentComponent, callback) {
	    if (injectedHook && "function" === typeof injectedHook.onScheduleFiberRoot)
	      try {
	        injectedHook.onScheduleFiberRoot(rendererID, container, element);
	      } catch (err) {
	        hasLoggedError || (hasLoggedError = true, console.error(
	          "React instrumentation encountered an error: %s",
	          err
	        ));
	      }
	    null !== injectedProfilingHooks && "function" === typeof injectedProfilingHooks.markRenderScheduled && injectedProfilingHooks.markRenderScheduled(lane);
	    parentComponent = getContextForSubtree(parentComponent);
	    null === container.context ? container.context = parentComponent : container.pendingContext = parentComponent;
	    isRendering && null !== current && !didWarnAboutNestedUpdates && (didWarnAboutNestedUpdates = true, console.error(
	      "Render methods should be a pure function of props and state; triggering nested component updates from render is not allowed. If necessary, trigger nested updates in componentDidUpdate.\n\nCheck the render method of %s.",
	      getComponentNameFromFiber(current) || "Unknown"
	    ));
	    container = createUpdate(lane);
	    container.payload = { element };
	    callback = void 0 === callback ? null : callback;
	    null !== callback && ("function" !== typeof callback && console.error(
	      "Expected the last optional `callback` argument to be a function. Instead received: %s.",
	      callback
	    ), container.callback = callback);
	    element = enqueueUpdate(rootFiber, container, lane);
	    null !== element && (scheduleUpdateOnFiber(element, rootFiber, lane), entangleTransitions(element, rootFiber, lane));
	  }
	  function markRetryLaneImpl(fiber, retryLane) {
	    fiber = fiber.memoizedState;
	    if (null !== fiber && null !== fiber.dehydrated) {
	      var a = fiber.retryLane;
	      fiber.retryLane = 0 !== a && a < retryLane ? a : retryLane;
	    }
	  }
	  function markRetryLaneIfNotHydrated(fiber, retryLane) {
	    markRetryLaneImpl(fiber, retryLane);
	    (fiber = fiber.alternate) && markRetryLaneImpl(fiber, retryLane);
	  }
	  function attemptContinuousHydration(fiber) {
	    if (13 === fiber.tag) {
	      var root2 = enqueueConcurrentRenderForLane(fiber, 67108864);
	      null !== root2 && scheduleUpdateOnFiber(root2, fiber, 67108864);
	      markRetryLaneIfNotHydrated(fiber, 67108864);
	    }
	  }
	  function getCurrentFiberForDevTools() {
	    return current;
	  }
	  function getLaneLabelMap() {
	    for (var map = /* @__PURE__ */ new Map(), lane = 1, index = 0; 31 > index; index++) {
	      var label = getLabelForLane(lane);
	      map.set(lane, label);
	      lane *= 2;
	    }
	    return map;
	  }
	  function dispatchDiscreteEvent(domEventName, eventSystemFlags, container, nativeEvent) {
	    var prevTransition = ReactSharedInternals.T;
	    ReactSharedInternals.T = null;
	    var previousPriority = ReactDOMSharedInternals.p;
	    try {
	      ReactDOMSharedInternals.p = DiscreteEventPriority, dispatchEvent(domEventName, eventSystemFlags, container, nativeEvent);
	    } finally {
	      ReactDOMSharedInternals.p = previousPriority, ReactSharedInternals.T = prevTransition;
	    }
	  }
	  function dispatchContinuousEvent(domEventName, eventSystemFlags, container, nativeEvent) {
	    var prevTransition = ReactSharedInternals.T;
	    ReactSharedInternals.T = null;
	    var previousPriority = ReactDOMSharedInternals.p;
	    try {
	      ReactDOMSharedInternals.p = ContinuousEventPriority, dispatchEvent(domEventName, eventSystemFlags, container, nativeEvent);
	    } finally {
	      ReactDOMSharedInternals.p = previousPriority, ReactSharedInternals.T = prevTransition;
	    }
	  }
	  function dispatchEvent(domEventName, eventSystemFlags, targetContainer, nativeEvent) {
	    if (_enabled) {
	      var blockedOn = findInstanceBlockingEvent(nativeEvent);
	      if (null === blockedOn)
	        dispatchEventForPluginEventSystem(
	          domEventName,
	          eventSystemFlags,
	          nativeEvent,
	          return_targetInst,
	          targetContainer
	        ), clearIfContinuousEvent(domEventName, nativeEvent);
	      else if (queueIfContinuousEvent(
	        blockedOn,
	        domEventName,
	        eventSystemFlags,
	        targetContainer,
	        nativeEvent
	      ))
	        nativeEvent.stopPropagation();
	      else if (clearIfContinuousEvent(domEventName, nativeEvent), eventSystemFlags & 4 && -1 < discreteReplayableEvents.indexOf(domEventName)) {
	        for (; null !== blockedOn; ) {
	          var fiber = getInstanceFromNode(blockedOn);
	          if (null !== fiber)
	            switch (fiber.tag) {
	              case 3:
	                fiber = fiber.stateNode;
	                if (fiber.current.memoizedState.isDehydrated) {
	                  var lanes = getHighestPriorityLanes(fiber.pendingLanes);
	                  if (0 !== lanes) {
	                    var root2 = fiber;
	                    root2.pendingLanes |= 2;
	                    for (root2.entangledLanes |= 2; lanes; ) {
	                      var lane = 1 << 31 - clz32(lanes);
	                      root2.entanglements[1] |= lane;
	                      lanes &= ~lane;
	                    }
	                    ensureRootIsScheduled(fiber);
	                    (executionContext & (RenderContext | CommitContext)) === NoContext && (workInProgressRootRenderTargetTime = now$1() + RENDER_TIMEOUT_MS, flushSyncWorkAcrossRoots_impl(0));
	                  }
	                }
	                break;
	              case 13:
	                root2 = enqueueConcurrentRenderForLane(fiber, 2), null !== root2 && scheduleUpdateOnFiber(root2, fiber, 2), flushSyncWork$1(), markRetryLaneIfNotHydrated(fiber, 2);
	            }
	          fiber = findInstanceBlockingEvent(nativeEvent);
	          null === fiber && dispatchEventForPluginEventSystem(
	            domEventName,
	            eventSystemFlags,
	            nativeEvent,
	            return_targetInst,
	            targetContainer
	          );
	          if (fiber === blockedOn) break;
	          blockedOn = fiber;
	        }
	        null !== blockedOn && nativeEvent.stopPropagation();
	      } else
	        dispatchEventForPluginEventSystem(
	          domEventName,
	          eventSystemFlags,
	          nativeEvent,
	          null,
	          targetContainer
	        );
	    }
	  }
	  function findInstanceBlockingEvent(nativeEvent) {
	    nativeEvent = getEventTarget(nativeEvent);
	    return findInstanceBlockingTarget(nativeEvent);
	  }
	  function findInstanceBlockingTarget(targetNode) {
	    return_targetInst = null;
	    targetNode = getClosestInstanceFromNode(targetNode);
	    if (null !== targetNode) {
	      var nearestMounted = getNearestMountedFiber(targetNode);
	      if (null === nearestMounted) targetNode = null;
	      else {
	        var tag = nearestMounted.tag;
	        if (13 === tag) {
	          targetNode = getSuspenseInstanceFromFiber(nearestMounted);
	          if (null !== targetNode) return targetNode;
	          targetNode = null;
	        } else if (3 === tag) {
	          if (nearestMounted.stateNode.current.memoizedState.isDehydrated)
	            return 3 === nearestMounted.tag ? nearestMounted.stateNode.containerInfo : null;
	          targetNode = null;
	        } else nearestMounted !== targetNode && (targetNode = null);
	      }
	    }
	    return_targetInst = targetNode;
	    return null;
	  }
	  function getEventPriority(domEventName) {
	    switch (domEventName) {
	      case "beforetoggle":
	      case "cancel":
	      case "click":
	      case "close":
	      case "contextmenu":
	      case "copy":
	      case "cut":
	      case "auxclick":
	      case "dblclick":
	      case "dragend":
	      case "dragstart":
	      case "drop":
	      case "focusin":
	      case "focusout":
	      case "input":
	      case "invalid":
	      case "keydown":
	      case "keypress":
	      case "keyup":
	      case "mousedown":
	      case "mouseup":
	      case "paste":
	      case "pause":
	      case "play":
	      case "pointercancel":
	      case "pointerdown":
	      case "pointerup":
	      case "ratechange":
	      case "reset":
	      case "resize":
	      case "seeked":
	      case "submit":
	      case "toggle":
	      case "touchcancel":
	      case "touchend":
	      case "touchstart":
	      case "volumechange":
	      case "change":
	      case "selectionchange":
	      case "textInput":
	      case "compositionstart":
	      case "compositionend":
	      case "compositionupdate":
	      case "beforeblur":
	      case "afterblur":
	      case "beforeinput":
	      case "blur":
	      case "fullscreenchange":
	      case "focus":
	      case "hashchange":
	      case "popstate":
	      case "select":
	      case "selectstart":
	        return DiscreteEventPriority;
	      case "drag":
	      case "dragenter":
	      case "dragexit":
	      case "dragleave":
	      case "dragover":
	      case "mousemove":
	      case "mouseout":
	      case "mouseover":
	      case "pointermove":
	      case "pointerout":
	      case "pointerover":
	      case "scroll":
	      case "touchmove":
	      case "wheel":
	      case "mouseenter":
	      case "mouseleave":
	      case "pointerenter":
	      case "pointerleave":
	        return ContinuousEventPriority;
	      case "message":
	        switch (getCurrentPriorityLevel()) {
	          case ImmediatePriority:
	            return DiscreteEventPriority;
	          case UserBlockingPriority:
	            return ContinuousEventPriority;
	          case NormalPriority$1:
	          case LowPriority:
	            return DefaultEventPriority;
	          case IdlePriority:
	            return IdleEventPriority;
	          default:
	            return DefaultEventPriority;
	        }
	      default:
	        return DefaultEventPriority;
	    }
	  }
	  function clearIfContinuousEvent(domEventName, nativeEvent) {
	    switch (domEventName) {
	      case "focusin":
	      case "focusout":
	        queuedFocus = null;
	        break;
	      case "dragenter":
	      case "dragleave":
	        queuedDrag = null;
	        break;
	      case "mouseover":
	      case "mouseout":
	        queuedMouse = null;
	        break;
	      case "pointerover":
	      case "pointerout":
	        queuedPointers.delete(nativeEvent.pointerId);
	        break;
	      case "gotpointercapture":
	      case "lostpointercapture":
	        queuedPointerCaptures.delete(nativeEvent.pointerId);
	    }
	  }
	  function accumulateOrCreateContinuousQueuedReplayableEvent(existingQueuedEvent, blockedOn, domEventName, eventSystemFlags, targetContainer, nativeEvent) {
	    if (null === existingQueuedEvent || existingQueuedEvent.nativeEvent !== nativeEvent)
	      return existingQueuedEvent = {
	        blockedOn,
	        domEventName,
	        eventSystemFlags,
	        nativeEvent,
	        targetContainers: [targetContainer]
	      }, null !== blockedOn && (blockedOn = getInstanceFromNode(blockedOn), null !== blockedOn && attemptContinuousHydration(blockedOn)), existingQueuedEvent;
	    existingQueuedEvent.eventSystemFlags |= eventSystemFlags;
	    blockedOn = existingQueuedEvent.targetContainers;
	    null !== targetContainer && -1 === blockedOn.indexOf(targetContainer) && blockedOn.push(targetContainer);
	    return existingQueuedEvent;
	  }
	  function queueIfContinuousEvent(blockedOn, domEventName, eventSystemFlags, targetContainer, nativeEvent) {
	    switch (domEventName) {
	      case "focusin":
	        return queuedFocus = accumulateOrCreateContinuousQueuedReplayableEvent(
	          queuedFocus,
	          blockedOn,
	          domEventName,
	          eventSystemFlags,
	          targetContainer,
	          nativeEvent
	        ), true;
	      case "dragenter":
	        return queuedDrag = accumulateOrCreateContinuousQueuedReplayableEvent(
	          queuedDrag,
	          blockedOn,
	          domEventName,
	          eventSystemFlags,
	          targetContainer,
	          nativeEvent
	        ), true;
	      case "mouseover":
	        return queuedMouse = accumulateOrCreateContinuousQueuedReplayableEvent(
	          queuedMouse,
	          blockedOn,
	          domEventName,
	          eventSystemFlags,
	          targetContainer,
	          nativeEvent
	        ), true;
	      case "pointerover":
	        var pointerId = nativeEvent.pointerId;
	        queuedPointers.set(
	          pointerId,
	          accumulateOrCreateContinuousQueuedReplayableEvent(
	            queuedPointers.get(pointerId) || null,
	            blockedOn,
	            domEventName,
	            eventSystemFlags,
	            targetContainer,
	            nativeEvent
	          )
	        );
	        return true;
	      case "gotpointercapture":
	        return pointerId = nativeEvent.pointerId, queuedPointerCaptures.set(
	          pointerId,
	          accumulateOrCreateContinuousQueuedReplayableEvent(
	            queuedPointerCaptures.get(pointerId) || null,
	            blockedOn,
	            domEventName,
	            eventSystemFlags,
	            targetContainer,
	            nativeEvent
	          )
	        ), true;
	    }
	    return false;
	  }
	  function attemptExplicitHydrationTarget(queuedTarget) {
	    var targetInst = getClosestInstanceFromNode(queuedTarget.target);
	    if (null !== targetInst) {
	      var nearestMounted = getNearestMountedFiber(targetInst);
	      if (null !== nearestMounted) {
	        if (targetInst = nearestMounted.tag, 13 === targetInst) {
	          if (targetInst = getSuspenseInstanceFromFiber(nearestMounted), null !== targetInst) {
	            queuedTarget.blockedOn = targetInst;
	            runWithPriority(queuedTarget.priority, function() {
	              if (13 === nearestMounted.tag) {
	                var lane = requestUpdateLane(nearestMounted);
	                lane = getBumpedLaneForHydrationByLane(lane);
	                var root2 = enqueueConcurrentRenderForLane(
	                  nearestMounted,
	                  lane
	                );
	                null !== root2 && scheduleUpdateOnFiber(root2, nearestMounted, lane);
	                markRetryLaneIfNotHydrated(nearestMounted, lane);
	              }
	            });
	            return;
	          }
	        } else if (3 === targetInst && nearestMounted.stateNode.current.memoizedState.isDehydrated) {
	          queuedTarget.blockedOn = 3 === nearestMounted.tag ? nearestMounted.stateNode.containerInfo : null;
	          return;
	        }
	      }
	    }
	    queuedTarget.blockedOn = null;
	  }
	  function attemptReplayContinuousQueuedEvent(queuedEvent) {
	    if (null !== queuedEvent.blockedOn) return false;
	    for (var targetContainers = queuedEvent.targetContainers; 0 < targetContainers.length; ) {
	      var nextBlockedOn = findInstanceBlockingEvent(queuedEvent.nativeEvent);
	      if (null === nextBlockedOn) {
	        nextBlockedOn = queuedEvent.nativeEvent;
	        var nativeEventClone = new nextBlockedOn.constructor(
	          nextBlockedOn.type,
	          nextBlockedOn
	        ), event = nativeEventClone;
	        null !== currentReplayingEvent && console.error(
	          "Expected currently replaying event to be null. This error is likely caused by a bug in React. Please file an issue."
	        );
	        currentReplayingEvent = event;
	        nextBlockedOn.target.dispatchEvent(nativeEventClone);
	        null === currentReplayingEvent && console.error(
	          "Expected currently replaying event to not be null. This error is likely caused by a bug in React. Please file an issue."
	        );
	        currentReplayingEvent = null;
	      } else
	        return targetContainers = getInstanceFromNode(nextBlockedOn), null !== targetContainers && attemptContinuousHydration(targetContainers), queuedEvent.blockedOn = nextBlockedOn, false;
	      targetContainers.shift();
	    }
	    return true;
	  }
	  function attemptReplayContinuousQueuedEventInMap(queuedEvent, key, map) {
	    attemptReplayContinuousQueuedEvent(queuedEvent) && map.delete(key);
	  }
	  function replayUnblockedEvents() {
	    hasScheduledReplayAttempt = false;
	    null !== queuedFocus && attemptReplayContinuousQueuedEvent(queuedFocus) && (queuedFocus = null);
	    null !== queuedDrag && attemptReplayContinuousQueuedEvent(queuedDrag) && (queuedDrag = null);
	    null !== queuedMouse && attemptReplayContinuousQueuedEvent(queuedMouse) && (queuedMouse = null);
	    queuedPointers.forEach(attemptReplayContinuousQueuedEventInMap);
	    queuedPointerCaptures.forEach(attemptReplayContinuousQueuedEventInMap);
	  }
	  function scheduleCallbackIfUnblocked(queuedEvent, unblocked) {
	    queuedEvent.blockedOn === unblocked && (queuedEvent.blockedOn = null, hasScheduledReplayAttempt || (hasScheduledReplayAttempt = true, Scheduler.unstable_scheduleCallback(
	      Scheduler.unstable_NormalPriority,
	      replayUnblockedEvents
	    )));
	  }
	  function scheduleReplayQueueIfNeeded(formReplayingQueue) {
	    lastScheduledReplayQueue !== formReplayingQueue && (lastScheduledReplayQueue = formReplayingQueue, Scheduler.unstable_scheduleCallback(
	      Scheduler.unstable_NormalPriority,
	      function() {
	        lastScheduledReplayQueue === formReplayingQueue && (lastScheduledReplayQueue = null);
	        for (var i = 0; i < formReplayingQueue.length; i += 3) {
	          var form = formReplayingQueue[i], submitterOrAction = formReplayingQueue[i + 1], formData = formReplayingQueue[i + 2];
	          if ("function" !== typeof submitterOrAction)
	            if (null === findInstanceBlockingTarget(submitterOrAction || form))
	              continue;
	            else break;
	          var formInst = getInstanceFromNode(form);
	          null !== formInst && (formReplayingQueue.splice(i, 3), i -= 3, form = {
	            pending: true,
	            data: formData,
	            method: form.method,
	            action: submitterOrAction
	          }, Object.freeze(form), startHostTransition(
	            formInst,
	            form,
	            submitterOrAction,
	            formData
	          ));
	        }
	      }
	    ));
	  }
	  function retryIfBlockedOn(unblocked) {
	    function unblock(queuedEvent) {
	      return scheduleCallbackIfUnblocked(queuedEvent, unblocked);
	    }
	    null !== queuedFocus && scheduleCallbackIfUnblocked(queuedFocus, unblocked);
	    null !== queuedDrag && scheduleCallbackIfUnblocked(queuedDrag, unblocked);
	    null !== queuedMouse && scheduleCallbackIfUnblocked(queuedMouse, unblocked);
	    queuedPointers.forEach(unblock);
	    queuedPointerCaptures.forEach(unblock);
	    for (var i = 0; i < queuedExplicitHydrationTargets.length; i++) {
	      var queuedTarget = queuedExplicitHydrationTargets[i];
	      queuedTarget.blockedOn === unblocked && (queuedTarget.blockedOn = null);
	    }
	    for (; 0 < queuedExplicitHydrationTargets.length && (i = queuedExplicitHydrationTargets[0], null === i.blockedOn); )
	      attemptExplicitHydrationTarget(i), null === i.blockedOn && queuedExplicitHydrationTargets.shift();
	    i = (unblocked.ownerDocument || unblocked).$$reactFormReplay;
	    if (null != i)
	      for (queuedTarget = 0; queuedTarget < i.length; queuedTarget += 3) {
	        var form = i[queuedTarget], submitterOrAction = i[queuedTarget + 1], formProps = form[internalPropsKey] || null;
	        if ("function" === typeof submitterOrAction)
	          formProps || scheduleReplayQueueIfNeeded(i);
	        else if (formProps) {
	          var action = null;
	          if (submitterOrAction && submitterOrAction.hasAttribute("formAction"))
	            if (form = submitterOrAction, formProps = submitterOrAction[internalPropsKey] || null)
	              action = formProps.formAction;
	            else {
	              if (null !== findInstanceBlockingTarget(form)) continue;
	            }
	          else action = formProps.action;
	          "function" === typeof action ? i[queuedTarget + 1] = action : (i.splice(queuedTarget, 3), queuedTarget -= 3);
	          scheduleReplayQueueIfNeeded(i);
	        }
	      }
	  }
	  function ReactDOMRoot(internalRoot) {
	    this._internalRoot = internalRoot;
	  }
	  function ReactDOMHydrationRoot(internalRoot) {
	    this._internalRoot = internalRoot;
	  }
	  function warnIfReactDOMContainerInDEV(container) {
	    container[internalContainerInstanceKey] && (container._reactRootContainer ? console.error(
	      "You are calling ReactDOMClient.createRoot() on a container that was previously passed to ReactDOM.render(). This is not supported."
	    ) : console.error(
	      "You are calling ReactDOMClient.createRoot() on a container that has already been passed to createRoot() before. Instead, call root.render() on the existing root instead if you want to update it."
	    ));
	  }
	  "undefined" !== typeof __REACT_DEVTOOLS_GLOBAL_HOOK__ && "function" === typeof __REACT_DEVTOOLS_GLOBAL_HOOK__.registerInternalModuleStart && __REACT_DEVTOOLS_GLOBAL_HOOK__.registerInternalModuleStart(Error());
	  var Scheduler = requireScheduler(), React = requireReact(), ReactDOM = requireReactDom(), assign = Object.assign, REACT_LEGACY_ELEMENT_TYPE = Symbol.for("react.element"), REACT_ELEMENT_TYPE = Symbol.for("react.transitional.element"), REACT_PORTAL_TYPE = Symbol.for("react.portal"), REACT_FRAGMENT_TYPE = Symbol.for("react.fragment"), REACT_STRICT_MODE_TYPE = Symbol.for("react.strict_mode"), REACT_PROFILER_TYPE = Symbol.for("react.profiler"), REACT_PROVIDER_TYPE = Symbol.for("react.provider"), REACT_CONSUMER_TYPE = Symbol.for("react.consumer"), REACT_CONTEXT_TYPE = Symbol.for("react.context"), REACT_FORWARD_REF_TYPE = Symbol.for("react.forward_ref"), REACT_SUSPENSE_TYPE = Symbol.for("react.suspense"), REACT_SUSPENSE_LIST_TYPE = Symbol.for("react.suspense_list"), REACT_MEMO_TYPE = Symbol.for("react.memo"), REACT_LAZY_TYPE = Symbol.for("react.lazy");
	  var REACT_ACTIVITY_TYPE = Symbol.for("react.activity");
	  var REACT_MEMO_CACHE_SENTINEL = Symbol.for("react.memo_cache_sentinel");
	  var MAYBE_ITERATOR_SYMBOL = Symbol.iterator, REACT_CLIENT_REFERENCE = Symbol.for("react.client.reference"), isArrayImpl = Array.isArray, ReactSharedInternals = React.__CLIENT_INTERNALS_DO_NOT_USE_OR_WARN_USERS_THEY_CANNOT_UPGRADE, ReactDOMSharedInternals = ReactDOM.__DOM_INTERNALS_DO_NOT_USE_OR_WARN_USERS_THEY_CANNOT_UPGRADE, NotPending = Object.freeze({
	    pending: false,
	    data: null,
	    method: null,
	    action: null
	  }), valueStack = [];
	  var fiberStack = [];
	  var index$jscomp$0 = -1, contextStackCursor = createCursor(null), contextFiberStackCursor = createCursor(null), rootInstanceStackCursor = createCursor(null), hostTransitionProviderCursor = createCursor(null), hasOwnProperty = Object.prototype.hasOwnProperty, scheduleCallback$3 = Scheduler.unstable_scheduleCallback, cancelCallback$1 = Scheduler.unstable_cancelCallback, shouldYield = Scheduler.unstable_shouldYield, requestPaint = Scheduler.unstable_requestPaint, now$1 = Scheduler.unstable_now, getCurrentPriorityLevel = Scheduler.unstable_getCurrentPriorityLevel, ImmediatePriority = Scheduler.unstable_ImmediatePriority, UserBlockingPriority = Scheduler.unstable_UserBlockingPriority, NormalPriority$1 = Scheduler.unstable_NormalPriority, LowPriority = Scheduler.unstable_LowPriority, IdlePriority = Scheduler.unstable_IdlePriority, log$1 = Scheduler.log, unstable_setDisableYieldValue = Scheduler.unstable_setDisableYieldValue, rendererID = null, injectedHook = null, injectedProfilingHooks = null, hasLoggedError = false, isDevToolsPresent = "undefined" !== typeof __REACT_DEVTOOLS_GLOBAL_HOOK__, clz32 = Math.clz32 ? Math.clz32 : clz32Fallback, log = Math.log, LN2 = Math.LN2, nextTransitionLane = 256, nextRetryLane = 4194304, DiscreteEventPriority = 2, ContinuousEventPriority = 8, DefaultEventPriority = 32, IdleEventPriority = 268435456, randomKey = Math.random().toString(36).slice(2), internalInstanceKey = "__reactFiber$" + randomKey, internalPropsKey = "__reactProps$" + randomKey, internalContainerInstanceKey = "__reactContainer$" + randomKey, internalEventHandlersKey = "__reactEvents$" + randomKey, internalEventHandlerListenersKey = "__reactListeners$" + randomKey, internalEventHandlesSetKey = "__reactHandles$" + randomKey, internalRootNodeResourcesKey = "__reactResources$" + randomKey, internalHoistableMarker = "__reactMarker$" + randomKey, allNativeEvents = /* @__PURE__ */ new Set(), registrationNameDependencies = {}, possibleRegistrationNames = {}, hasReadOnlyValue = {
	    button: true,
	    checkbox: true,
	    image: true,
	    hidden: true,
	    radio: true,
	    reset: true,
	    submit: true
	  }, VALID_ATTRIBUTE_NAME_REGEX = RegExp(
	    "^[:A-Z_a-z\\u00C0-\\u00D6\\u00D8-\\u00F6\\u00F8-\\u02FF\\u0370-\\u037D\\u037F-\\u1FFF\\u200C-\\u200D\\u2070-\\u218F\\u2C00-\\u2FEF\\u3001-\\uD7FF\\uF900-\\uFDCF\\uFDF0-\\uFFFD][:A-Z_a-z\\u00C0-\\u00D6\\u00D8-\\u00F6\\u00F8-\\u02FF\\u0370-\\u037D\\u037F-\\u1FFF\\u200C-\\u200D\\u2070-\\u218F\\u2C00-\\u2FEF\\u3001-\\uD7FF\\uF900-\\uFDCF\\uFDF0-\\uFFFD\\-.0-9\\u00B7\\u0300-\\u036F\\u203F-\\u2040]*$"
	  ), illegalAttributeNameCache = {}, validatedAttributeNameCache = {}, disabledDepth = 0, prevLog, prevInfo, prevWarn, prevError, prevGroup, prevGroupCollapsed, prevGroupEnd;
	  disabledLog.__reactDisabledLog = true;
	  var prefix, suffix, reentry = false;
	  var componentFrameCache = new ("function" === typeof WeakMap ? WeakMap : Map)();
	  var current = null, isRendering = false, escapeSelectorAttributeValueInsideDoubleQuotesRegex = /[\n"\\]/g, didWarnValueDefaultValue$1 = false, didWarnCheckedDefaultChecked = false, didWarnSelectedSetOnOption = false, didWarnInvalidChild = false, didWarnInvalidInnerHTML = false;
	  var didWarnValueDefaultValue = false;
	  var valuePropNames = ["value", "defaultValue"], didWarnValDefaultVal = false, needsEscaping = /["'&<>\n\t]|^\s|\s$/, specialTags = "address applet area article aside base basefont bgsound blockquote body br button caption center col colgroup dd details dir div dl dt embed fieldset figcaption figure footer form frame frameset h1 h2 h3 h4 h5 h6 head header hgroup hr html iframe img input isindex li link listing main marquee menu menuitem meta nav noembed noframes noscript object ol p param plaintext pre script section select source style summary table tbody td template textarea tfoot th thead title tr track ul wbr xmp".split(
	    " "
	  ), inScopeTags = "applet caption html table td th marquee object template foreignObject desc title".split(
	    " "
	  ), buttonScopeTags = inScopeTags.concat(["button"]), impliedEndTags = "dd dt li option optgroup p rp rt".split(" "), emptyAncestorInfoDev = {
	    current: null,
	    formTag: null,
	    aTagInScope: null,
	    buttonTagInScope: null,
	    nobrTagInScope: null,
	    pTagInButtonScope: null,
	    listItemTagAutoclosing: null,
	    dlItemTagAutoclosing: null,
	    containerTagInScope: null,
	    implicitRootScope: false
	  }, didWarn = {}, shorthandToLonghand = {
	    animation: "animationDelay animationDirection animationDuration animationFillMode animationIterationCount animationName animationPlayState animationTimingFunction".split(
	      " "
	    ),
	    background: "backgroundAttachment backgroundClip backgroundColor backgroundImage backgroundOrigin backgroundPositionX backgroundPositionY backgroundRepeat backgroundSize".split(
	      " "
	    ),
	    backgroundPosition: ["backgroundPositionX", "backgroundPositionY"],
	    border: "borderBottomColor borderBottomStyle borderBottomWidth borderImageOutset borderImageRepeat borderImageSlice borderImageSource borderImageWidth borderLeftColor borderLeftStyle borderLeftWidth borderRightColor borderRightStyle borderRightWidth borderTopColor borderTopStyle borderTopWidth".split(
	      " "
	    ),
	    borderBlockEnd: [
	      "borderBlockEndColor",
	      "borderBlockEndStyle",
	      "borderBlockEndWidth"
	    ],
	    borderBlockStart: [
	      "borderBlockStartColor",
	      "borderBlockStartStyle",
	      "borderBlockStartWidth"
	    ],
	    borderBottom: [
	      "borderBottomColor",
	      "borderBottomStyle",
	      "borderBottomWidth"
	    ],
	    borderColor: [
	      "borderBottomColor",
	      "borderLeftColor",
	      "borderRightColor",
	      "borderTopColor"
	    ],
	    borderImage: [
	      "borderImageOutset",
	      "borderImageRepeat",
	      "borderImageSlice",
	      "borderImageSource",
	      "borderImageWidth"
	    ],
	    borderInlineEnd: [
	      "borderInlineEndColor",
	      "borderInlineEndStyle",
	      "borderInlineEndWidth"
	    ],
	    borderInlineStart: [
	      "borderInlineStartColor",
	      "borderInlineStartStyle",
	      "borderInlineStartWidth"
	    ],
	    borderLeft: ["borderLeftColor", "borderLeftStyle", "borderLeftWidth"],
	    borderRadius: [
	      "borderBottomLeftRadius",
	      "borderBottomRightRadius",
	      "borderTopLeftRadius",
	      "borderTopRightRadius"
	    ],
	    borderRight: [
	      "borderRightColor",
	      "borderRightStyle",
	      "borderRightWidth"
	    ],
	    borderStyle: [
	      "borderBottomStyle",
	      "borderLeftStyle",
	      "borderRightStyle",
	      "borderTopStyle"
	    ],
	    borderTop: ["borderTopColor", "borderTopStyle", "borderTopWidth"],
	    borderWidth: [
	      "borderBottomWidth",
	      "borderLeftWidth",
	      "borderRightWidth",
	      "borderTopWidth"
	    ],
	    columnRule: ["columnRuleColor", "columnRuleStyle", "columnRuleWidth"],
	    columns: ["columnCount", "columnWidth"],
	    flex: ["flexBasis", "flexGrow", "flexShrink"],
	    flexFlow: ["flexDirection", "flexWrap"],
	    font: "fontFamily fontFeatureSettings fontKerning fontLanguageOverride fontSize fontSizeAdjust fontStretch fontStyle fontVariant fontVariantAlternates fontVariantCaps fontVariantEastAsian fontVariantLigatures fontVariantNumeric fontVariantPosition fontWeight lineHeight".split(
	      " "
	    ),
	    fontVariant: "fontVariantAlternates fontVariantCaps fontVariantEastAsian fontVariantLigatures fontVariantNumeric fontVariantPosition".split(
	      " "
	    ),
	    gap: ["columnGap", "rowGap"],
	    grid: "gridAutoColumns gridAutoFlow gridAutoRows gridTemplateAreas gridTemplateColumns gridTemplateRows".split(
	      " "
	    ),
	    gridArea: [
	      "gridColumnEnd",
	      "gridColumnStart",
	      "gridRowEnd",
	      "gridRowStart"
	    ],
	    gridColumn: ["gridColumnEnd", "gridColumnStart"],
	    gridColumnGap: ["columnGap"],
	    gridGap: ["columnGap", "rowGap"],
	    gridRow: ["gridRowEnd", "gridRowStart"],
	    gridRowGap: ["rowGap"],
	    gridTemplate: [
	      "gridTemplateAreas",
	      "gridTemplateColumns",
	      "gridTemplateRows"
	    ],
	    listStyle: ["listStyleImage", "listStylePosition", "listStyleType"],
	    margin: ["marginBottom", "marginLeft", "marginRight", "marginTop"],
	    marker: ["markerEnd", "markerMid", "markerStart"],
	    mask: "maskClip maskComposite maskImage maskMode maskOrigin maskPositionX maskPositionY maskRepeat maskSize".split(
	      " "
	    ),
	    maskPosition: ["maskPositionX", "maskPositionY"],
	    outline: ["outlineColor", "outlineStyle", "outlineWidth"],
	    overflow: ["overflowX", "overflowY"],
	    padding: ["paddingBottom", "paddingLeft", "paddingRight", "paddingTop"],
	    placeContent: ["alignContent", "justifyContent"],
	    placeItems: ["alignItems", "justifyItems"],
	    placeSelf: ["alignSelf", "justifySelf"],
	    textDecoration: [
	      "textDecorationColor",
	      "textDecorationLine",
	      "textDecorationStyle"
	    ],
	    textEmphasis: ["textEmphasisColor", "textEmphasisStyle"],
	    transition: [
	      "transitionDelay",
	      "transitionDuration",
	      "transitionProperty",
	      "transitionTimingFunction"
	    ],
	    wordWrap: ["overflowWrap"]
	  }, uppercasePattern = /([A-Z])/g, msPattern$1 = /^ms-/, badVendoredStyleNamePattern = /^(?:webkit|moz|o)[A-Z]/, msPattern = /^-ms-/, hyphenPattern = /-(.)/g, badStyleValueWithSemicolonPattern = /;\s*$/, warnedStyleNames = {}, warnedStyleValues = {}, warnedForNaNValue = false, warnedForInfinityValue = false, unitlessNumbers = new Set(
	    "animationIterationCount aspectRatio borderImageOutset borderImageSlice borderImageWidth boxFlex boxFlexGroup boxOrdinalGroup columnCount columns flex flexGrow flexPositive flexShrink flexNegative flexOrder gridArea gridRow gridRowEnd gridRowSpan gridRowStart gridColumn gridColumnEnd gridColumnSpan gridColumnStart fontWeight lineClamp lineHeight opacity order orphans scale tabSize widows zIndex zoom fillOpacity floodOpacity stopOpacity strokeDasharray strokeDashoffset strokeMiterlimit strokeOpacity strokeWidth MozAnimationIterationCount MozBoxFlex MozBoxFlexGroup MozLineClamp msAnimationIterationCount msFlex msZoom msFlexGrow msFlexNegative msFlexOrder msFlexPositive msFlexShrink msGridColumn msGridColumnSpan msGridRow msGridRowSpan WebkitAnimationIterationCount WebkitBoxFlex WebKitBoxFlexGroup WebkitBoxOrdinalGroup WebkitColumnCount WebkitColumns WebkitFlex WebkitFlexGrow WebkitFlexPositive WebkitFlexShrink WebkitLineClamp".split(
	      " "
	    )
	  ), MATH_NAMESPACE = "http://www.w3.org/1998/Math/MathML", SVG_NAMESPACE = "http://www.w3.org/2000/svg", aliases = /* @__PURE__ */ new Map([
	    ["acceptCharset", "accept-charset"],
	    ["htmlFor", "for"],
	    ["httpEquiv", "http-equiv"],
	    ["crossOrigin", "crossorigin"],
	    ["accentHeight", "accent-height"],
	    ["alignmentBaseline", "alignment-baseline"],
	    ["arabicForm", "arabic-form"],
	    ["baselineShift", "baseline-shift"],
	    ["capHeight", "cap-height"],
	    ["clipPath", "clip-path"],
	    ["clipRule", "clip-rule"],
	    ["colorInterpolation", "color-interpolation"],
	    ["colorInterpolationFilters", "color-interpolation-filters"],
	    ["colorProfile", "color-profile"],
	    ["colorRendering", "color-rendering"],
	    ["dominantBaseline", "dominant-baseline"],
	    ["enableBackground", "enable-background"],
	    ["fillOpacity", "fill-opacity"],
	    ["fillRule", "fill-rule"],
	    ["floodColor", "flood-color"],
	    ["floodOpacity", "flood-opacity"],
	    ["fontFamily", "font-family"],
	    ["fontSize", "font-size"],
	    ["fontSizeAdjust", "font-size-adjust"],
	    ["fontStretch", "font-stretch"],
	    ["fontStyle", "font-style"],
	    ["fontVariant", "font-variant"],
	    ["fontWeight", "font-weight"],
	    ["glyphName", "glyph-name"],
	    ["glyphOrientationHorizontal", "glyph-orientation-horizontal"],
	    ["glyphOrientationVertical", "glyph-orientation-vertical"],
	    ["horizAdvX", "horiz-adv-x"],
	    ["horizOriginX", "horiz-origin-x"],
	    ["imageRendering", "image-rendering"],
	    ["letterSpacing", "letter-spacing"],
	    ["lightingColor", "lighting-color"],
	    ["markerEnd", "marker-end"],
	    ["markerMid", "marker-mid"],
	    ["markerStart", "marker-start"],
	    ["overlinePosition", "overline-position"],
	    ["overlineThickness", "overline-thickness"],
	    ["paintOrder", "paint-order"],
	    ["panose-1", "panose-1"],
	    ["pointerEvents", "pointer-events"],
	    ["renderingIntent", "rendering-intent"],
	    ["shapeRendering", "shape-rendering"],
	    ["stopColor", "stop-color"],
	    ["stopOpacity", "stop-opacity"],
	    ["strikethroughPosition", "strikethrough-position"],
	    ["strikethroughThickness", "strikethrough-thickness"],
	    ["strokeDasharray", "stroke-dasharray"],
	    ["strokeDashoffset", "stroke-dashoffset"],
	    ["strokeLinecap", "stroke-linecap"],
	    ["strokeLinejoin", "stroke-linejoin"],
	    ["strokeMiterlimit", "stroke-miterlimit"],
	    ["strokeOpacity", "stroke-opacity"],
	    ["strokeWidth", "stroke-width"],
	    ["textAnchor", "text-anchor"],
	    ["textDecoration", "text-decoration"],
	    ["textRendering", "text-rendering"],
	    ["transformOrigin", "transform-origin"],
	    ["underlinePosition", "underline-position"],
	    ["underlineThickness", "underline-thickness"],
	    ["unicodeBidi", "unicode-bidi"],
	    ["unicodeRange", "unicode-range"],
	    ["unitsPerEm", "units-per-em"],
	    ["vAlphabetic", "v-alphabetic"],
	    ["vHanging", "v-hanging"],
	    ["vIdeographic", "v-ideographic"],
	    ["vMathematical", "v-mathematical"],
	    ["vectorEffect", "vector-effect"],
	    ["vertAdvY", "vert-adv-y"],
	    ["vertOriginX", "vert-origin-x"],
	    ["vertOriginY", "vert-origin-y"],
	    ["wordSpacing", "word-spacing"],
	    ["writingMode", "writing-mode"],
	    ["xmlnsXlink", "xmlns:xlink"],
	    ["xHeight", "x-height"]
	  ]), possibleStandardNames = {
	    accept: "accept",
	    acceptcharset: "acceptCharset",
	    "accept-charset": "acceptCharset",
	    accesskey: "accessKey",
	    action: "action",
	    allowfullscreen: "allowFullScreen",
	    alt: "alt",
	    as: "as",
	    async: "async",
	    autocapitalize: "autoCapitalize",
	    autocomplete: "autoComplete",
	    autocorrect: "autoCorrect",
	    autofocus: "autoFocus",
	    autoplay: "autoPlay",
	    autosave: "autoSave",
	    capture: "capture",
	    cellpadding: "cellPadding",
	    cellspacing: "cellSpacing",
	    challenge: "challenge",
	    charset: "charSet",
	    checked: "checked",
	    children: "children",
	    cite: "cite",
	    class: "className",
	    classid: "classID",
	    classname: "className",
	    cols: "cols",
	    colspan: "colSpan",
	    content: "content",
	    contenteditable: "contentEditable",
	    contextmenu: "contextMenu",
	    controls: "controls",
	    controlslist: "controlsList",
	    coords: "coords",
	    crossorigin: "crossOrigin",
	    dangerouslysetinnerhtml: "dangerouslySetInnerHTML",
	    data: "data",
	    datetime: "dateTime",
	    default: "default",
	    defaultchecked: "defaultChecked",
	    defaultvalue: "defaultValue",
	    defer: "defer",
	    dir: "dir",
	    disabled: "disabled",
	    disablepictureinpicture: "disablePictureInPicture",
	    disableremoteplayback: "disableRemotePlayback",
	    download: "download",
	    draggable: "draggable",
	    enctype: "encType",
	    enterkeyhint: "enterKeyHint",
	    fetchpriority: "fetchPriority",
	    for: "htmlFor",
	    form: "form",
	    formmethod: "formMethod",
	    formaction: "formAction",
	    formenctype: "formEncType",
	    formnovalidate: "formNoValidate",
	    formtarget: "formTarget",
	    frameborder: "frameBorder",
	    headers: "headers",
	    height: "height",
	    hidden: "hidden",
	    high: "high",
	    href: "href",
	    hreflang: "hrefLang",
	    htmlfor: "htmlFor",
	    httpequiv: "httpEquiv",
	    "http-equiv": "httpEquiv",
	    icon: "icon",
	    id: "id",
	    imagesizes: "imageSizes",
	    imagesrcset: "imageSrcSet",
	    inert: "inert",
	    innerhtml: "innerHTML",
	    inputmode: "inputMode",
	    integrity: "integrity",
	    is: "is",
	    itemid: "itemID",
	    itemprop: "itemProp",
	    itemref: "itemRef",
	    itemscope: "itemScope",
	    itemtype: "itemType",
	    keyparams: "keyParams",
	    keytype: "keyType",
	    kind: "kind",
	    label: "label",
	    lang: "lang",
	    list: "list",
	    loop: "loop",
	    low: "low",
	    manifest: "manifest",
	    marginwidth: "marginWidth",
	    marginheight: "marginHeight",
	    max: "max",
	    maxlength: "maxLength",
	    media: "media",
	    mediagroup: "mediaGroup",
	    method: "method",
	    min: "min",
	    minlength: "minLength",
	    multiple: "multiple",
	    muted: "muted",
	    name: "name",
	    nomodule: "noModule",
	    nonce: "nonce",
	    novalidate: "noValidate",
	    open: "open",
	    optimum: "optimum",
	    pattern: "pattern",
	    placeholder: "placeholder",
	    playsinline: "playsInline",
	    poster: "poster",
	    preload: "preload",
	    profile: "profile",
	    radiogroup: "radioGroup",
	    readonly: "readOnly",
	    referrerpolicy: "referrerPolicy",
	    rel: "rel",
	    required: "required",
	    reversed: "reversed",
	    role: "role",
	    rows: "rows",
	    rowspan: "rowSpan",
	    sandbox: "sandbox",
	    scope: "scope",
	    scoped: "scoped",
	    scrolling: "scrolling",
	    seamless: "seamless",
	    selected: "selected",
	    shape: "shape",
	    size: "size",
	    sizes: "sizes",
	    span: "span",
	    spellcheck: "spellCheck",
	    src: "src",
	    srcdoc: "srcDoc",
	    srclang: "srcLang",
	    srcset: "srcSet",
	    start: "start",
	    step: "step",
	    style: "style",
	    summary: "summary",
	    tabindex: "tabIndex",
	    target: "target",
	    title: "title",
	    type: "type",
	    usemap: "useMap",
	    value: "value",
	    width: "width",
	    wmode: "wmode",
	    wrap: "wrap",
	    about: "about",
	    accentheight: "accentHeight",
	    "accent-height": "accentHeight",
	    accumulate: "accumulate",
	    additive: "additive",
	    alignmentbaseline: "alignmentBaseline",
	    "alignment-baseline": "alignmentBaseline",
	    allowreorder: "allowReorder",
	    alphabetic: "alphabetic",
	    amplitude: "amplitude",
	    arabicform: "arabicForm",
	    "arabic-form": "arabicForm",
	    ascent: "ascent",
	    attributename: "attributeName",
	    attributetype: "attributeType",
	    autoreverse: "autoReverse",
	    azimuth: "azimuth",
	    basefrequency: "baseFrequency",
	    baselineshift: "baselineShift",
	    "baseline-shift": "baselineShift",
	    baseprofile: "baseProfile",
	    bbox: "bbox",
	    begin: "begin",
	    bias: "bias",
	    by: "by",
	    calcmode: "calcMode",
	    capheight: "capHeight",
	    "cap-height": "capHeight",
	    clip: "clip",
	    clippath: "clipPath",
	    "clip-path": "clipPath",
	    clippathunits: "clipPathUnits",
	    cliprule: "clipRule",
	    "clip-rule": "clipRule",
	    color: "color",
	    colorinterpolation: "colorInterpolation",
	    "color-interpolation": "colorInterpolation",
	    colorinterpolationfilters: "colorInterpolationFilters",
	    "color-interpolation-filters": "colorInterpolationFilters",
	    colorprofile: "colorProfile",
	    "color-profile": "colorProfile",
	    colorrendering: "colorRendering",
	    "color-rendering": "colorRendering",
	    contentscripttype: "contentScriptType",
	    contentstyletype: "contentStyleType",
	    cursor: "cursor",
	    cx: "cx",
	    cy: "cy",
	    d: "d",
	    datatype: "datatype",
	    decelerate: "decelerate",
	    descent: "descent",
	    diffuseconstant: "diffuseConstant",
	    direction: "direction",
	    display: "display",
	    divisor: "divisor",
	    dominantbaseline: "dominantBaseline",
	    "dominant-baseline": "dominantBaseline",
	    dur: "dur",
	    dx: "dx",
	    dy: "dy",
	    edgemode: "edgeMode",
	    elevation: "elevation",
	    enablebackground: "enableBackground",
	    "enable-background": "enableBackground",
	    end: "end",
	    exponent: "exponent",
	    externalresourcesrequired: "externalResourcesRequired",
	    fill: "fill",
	    fillopacity: "fillOpacity",
	    "fill-opacity": "fillOpacity",
	    fillrule: "fillRule",
	    "fill-rule": "fillRule",
	    filter: "filter",
	    filterres: "filterRes",
	    filterunits: "filterUnits",
	    floodopacity: "floodOpacity",
	    "flood-opacity": "floodOpacity",
	    floodcolor: "floodColor",
	    "flood-color": "floodColor",
	    focusable: "focusable",
	    fontfamily: "fontFamily",
	    "font-family": "fontFamily",
	    fontsize: "fontSize",
	    "font-size": "fontSize",
	    fontsizeadjust: "fontSizeAdjust",
	    "font-size-adjust": "fontSizeAdjust",
	    fontstretch: "fontStretch",
	    "font-stretch": "fontStretch",
	    fontstyle: "fontStyle",
	    "font-style": "fontStyle",
	    fontvariant: "fontVariant",
	    "font-variant": "fontVariant",
	    fontweight: "fontWeight",
	    "font-weight": "fontWeight",
	    format: "format",
	    from: "from",
	    fx: "fx",
	    fy: "fy",
	    g1: "g1",
	    g2: "g2",
	    glyphname: "glyphName",
	    "glyph-name": "glyphName",
	    glyphorientationhorizontal: "glyphOrientationHorizontal",
	    "glyph-orientation-horizontal": "glyphOrientationHorizontal",
	    glyphorientationvertical: "glyphOrientationVertical",
	    "glyph-orientation-vertical": "glyphOrientationVertical",
	    glyphref: "glyphRef",
	    gradienttransform: "gradientTransform",
	    gradientunits: "gradientUnits",
	    hanging: "hanging",
	    horizadvx: "horizAdvX",
	    "horiz-adv-x": "horizAdvX",
	    horizoriginx: "horizOriginX",
	    "horiz-origin-x": "horizOriginX",
	    ideographic: "ideographic",
	    imagerendering: "imageRendering",
	    "image-rendering": "imageRendering",
	    in2: "in2",
	    in: "in",
	    inlist: "inlist",
	    intercept: "intercept",
	    k1: "k1",
	    k2: "k2",
	    k3: "k3",
	    k4: "k4",
	    k: "k",
	    kernelmatrix: "kernelMatrix",
	    kernelunitlength: "kernelUnitLength",
	    kerning: "kerning",
	    keypoints: "keyPoints",
	    keysplines: "keySplines",
	    keytimes: "keyTimes",
	    lengthadjust: "lengthAdjust",
	    letterspacing: "letterSpacing",
	    "letter-spacing": "letterSpacing",
	    lightingcolor: "lightingColor",
	    "lighting-color": "lightingColor",
	    limitingconeangle: "limitingConeAngle",
	    local: "local",
	    markerend: "markerEnd",
	    "marker-end": "markerEnd",
	    markerheight: "markerHeight",
	    markermid: "markerMid",
	    "marker-mid": "markerMid",
	    markerstart: "markerStart",
	    "marker-start": "markerStart",
	    markerunits: "markerUnits",
	    markerwidth: "markerWidth",
	    mask: "mask",
	    maskcontentunits: "maskContentUnits",
	    maskunits: "maskUnits",
	    mathematical: "mathematical",
	    mode: "mode",
	    numoctaves: "numOctaves",
	    offset: "offset",
	    opacity: "opacity",
	    operator: "operator",
	    order: "order",
	    orient: "orient",
	    orientation: "orientation",
	    origin: "origin",
	    overflow: "overflow",
	    overlineposition: "overlinePosition",
	    "overline-position": "overlinePosition",
	    overlinethickness: "overlineThickness",
	    "overline-thickness": "overlineThickness",
	    paintorder: "paintOrder",
	    "paint-order": "paintOrder",
	    panose1: "panose1",
	    "panose-1": "panose1",
	    pathlength: "pathLength",
	    patterncontentunits: "patternContentUnits",
	    patterntransform: "patternTransform",
	    patternunits: "patternUnits",
	    pointerevents: "pointerEvents",
	    "pointer-events": "pointerEvents",
	    points: "points",
	    pointsatx: "pointsAtX",
	    pointsaty: "pointsAtY",
	    pointsatz: "pointsAtZ",
	    popover: "popover",
	    popovertarget: "popoverTarget",
	    popovertargetaction: "popoverTargetAction",
	    prefix: "prefix",
	    preservealpha: "preserveAlpha",
	    preserveaspectratio: "preserveAspectRatio",
	    primitiveunits: "primitiveUnits",
	    property: "property",
	    r: "r",
	    radius: "radius",
	    refx: "refX",
	    refy: "refY",
	    renderingintent: "renderingIntent",
	    "rendering-intent": "renderingIntent",
	    repeatcount: "repeatCount",
	    repeatdur: "repeatDur",
	    requiredextensions: "requiredExtensions",
	    requiredfeatures: "requiredFeatures",
	    resource: "resource",
	    restart: "restart",
	    result: "result",
	    results: "results",
	    rotate: "rotate",
	    rx: "rx",
	    ry: "ry",
	    scale: "scale",
	    security: "security",
	    seed: "seed",
	    shaperendering: "shapeRendering",
	    "shape-rendering": "shapeRendering",
	    slope: "slope",
	    spacing: "spacing",
	    specularconstant: "specularConstant",
	    specularexponent: "specularExponent",
	    speed: "speed",
	    spreadmethod: "spreadMethod",
	    startoffset: "startOffset",
	    stddeviation: "stdDeviation",
	    stemh: "stemh",
	    stemv: "stemv",
	    stitchtiles: "stitchTiles",
	    stopcolor: "stopColor",
	    "stop-color": "stopColor",
	    stopopacity: "stopOpacity",
	    "stop-opacity": "stopOpacity",
	    strikethroughposition: "strikethroughPosition",
	    "strikethrough-position": "strikethroughPosition",
	    strikethroughthickness: "strikethroughThickness",
	    "strikethrough-thickness": "strikethroughThickness",
	    string: "string",
	    stroke: "stroke",
	    strokedasharray: "strokeDasharray",
	    "stroke-dasharray": "strokeDasharray",
	    strokedashoffset: "strokeDashoffset",
	    "stroke-dashoffset": "strokeDashoffset",
	    strokelinecap: "strokeLinecap",
	    "stroke-linecap": "strokeLinecap",
	    strokelinejoin: "strokeLinejoin",
	    "stroke-linejoin": "strokeLinejoin",
	    strokemiterlimit: "strokeMiterlimit",
	    "stroke-miterlimit": "strokeMiterlimit",
	    strokewidth: "strokeWidth",
	    "stroke-width": "strokeWidth",
	    strokeopacity: "strokeOpacity",
	    "stroke-opacity": "strokeOpacity",
	    suppresscontenteditablewarning: "suppressContentEditableWarning",
	    suppresshydrationwarning: "suppressHydrationWarning",
	    surfacescale: "surfaceScale",
	    systemlanguage: "systemLanguage",
	    tablevalues: "tableValues",
	    targetx: "targetX",
	    targety: "targetY",
	    textanchor: "textAnchor",
	    "text-anchor": "textAnchor",
	    textdecoration: "textDecoration",
	    "text-decoration": "textDecoration",
	    textlength: "textLength",
	    textrendering: "textRendering",
	    "text-rendering": "textRendering",
	    to: "to",
	    transform: "transform",
	    transformorigin: "transformOrigin",
	    "transform-origin": "transformOrigin",
	    typeof: "typeof",
	    u1: "u1",
	    u2: "u2",
	    underlineposition: "underlinePosition",
	    "underline-position": "underlinePosition",
	    underlinethickness: "underlineThickness",
	    "underline-thickness": "underlineThickness",
	    unicode: "unicode",
	    unicodebidi: "unicodeBidi",
	    "unicode-bidi": "unicodeBidi",
	    unicoderange: "unicodeRange",
	    "unicode-range": "unicodeRange",
	    unitsperem: "unitsPerEm",
	    "units-per-em": "unitsPerEm",
	    unselectable: "unselectable",
	    valphabetic: "vAlphabetic",
	    "v-alphabetic": "vAlphabetic",
	    values: "values",
	    vectoreffect: "vectorEffect",
	    "vector-effect": "vectorEffect",
	    version: "version",
	    vertadvy: "vertAdvY",
	    "vert-adv-y": "vertAdvY",
	    vertoriginx: "vertOriginX",
	    "vert-origin-x": "vertOriginX",
	    vertoriginy: "vertOriginY",
	    "vert-origin-y": "vertOriginY",
	    vhanging: "vHanging",
	    "v-hanging": "vHanging",
	    videographic: "vIdeographic",
	    "v-ideographic": "vIdeographic",
	    viewbox: "viewBox",
	    viewtarget: "viewTarget",
	    visibility: "visibility",
	    vmathematical: "vMathematical",
	    "v-mathematical": "vMathematical",
	    vocab: "vocab",
	    widths: "widths",
	    wordspacing: "wordSpacing",
	    "word-spacing": "wordSpacing",
	    writingmode: "writingMode",
	    "writing-mode": "writingMode",
	    x1: "x1",
	    x2: "x2",
	    x: "x",
	    xchannelselector: "xChannelSelector",
	    xheight: "xHeight",
	    "x-height": "xHeight",
	    xlinkactuate: "xlinkActuate",
	    "xlink:actuate": "xlinkActuate",
	    xlinkarcrole: "xlinkArcrole",
	    "xlink:arcrole": "xlinkArcrole",
	    xlinkhref: "xlinkHref",
	    "xlink:href": "xlinkHref",
	    xlinkrole: "xlinkRole",
	    "xlink:role": "xlinkRole",
	    xlinkshow: "xlinkShow",
	    "xlink:show": "xlinkShow",
	    xlinktitle: "xlinkTitle",
	    "xlink:title": "xlinkTitle",
	    xlinktype: "xlinkType",
	    "xlink:type": "xlinkType",
	    xmlbase: "xmlBase",
	    "xml:base": "xmlBase",
	    xmllang: "xmlLang",
	    "xml:lang": "xmlLang",
	    xmlns: "xmlns",
	    "xml:space": "xmlSpace",
	    xmlnsxlink: "xmlnsXlink",
	    "xmlns:xlink": "xmlnsXlink",
	    xmlspace: "xmlSpace",
	    y1: "y1",
	    y2: "y2",
	    y: "y",
	    ychannelselector: "yChannelSelector",
	    z: "z",
	    zoomandpan: "zoomAndPan"
	  }, ariaProperties = {
	    "aria-current": 0,
	    "aria-description": 0,
	    "aria-details": 0,
	    "aria-disabled": 0,
	    "aria-hidden": 0,
	    "aria-invalid": 0,
	    "aria-keyshortcuts": 0,
	    "aria-label": 0,
	    "aria-roledescription": 0,
	    "aria-autocomplete": 0,
	    "aria-checked": 0,
	    "aria-expanded": 0,
	    "aria-haspopup": 0,
	    "aria-level": 0,
	    "aria-modal": 0,
	    "aria-multiline": 0,
	    "aria-multiselectable": 0,
	    "aria-orientation": 0,
	    "aria-placeholder": 0,
	    "aria-pressed": 0,
	    "aria-readonly": 0,
	    "aria-required": 0,
	    "aria-selected": 0,
	    "aria-sort": 0,
	    "aria-valuemax": 0,
	    "aria-valuemin": 0,
	    "aria-valuenow": 0,
	    "aria-valuetext": 0,
	    "aria-atomic": 0,
	    "aria-busy": 0,
	    "aria-live": 0,
	    "aria-relevant": 0,
	    "aria-dropeffect": 0,
	    "aria-grabbed": 0,
	    "aria-activedescendant": 0,
	    "aria-colcount": 0,
	    "aria-colindex": 0,
	    "aria-colspan": 0,
	    "aria-controls": 0,
	    "aria-describedby": 0,
	    "aria-errormessage": 0,
	    "aria-flowto": 0,
	    "aria-labelledby": 0,
	    "aria-owns": 0,
	    "aria-posinset": 0,
	    "aria-rowcount": 0,
	    "aria-rowindex": 0,
	    "aria-rowspan": 0,
	    "aria-setsize": 0
	  }, warnedProperties$1 = {}, rARIA$1 = RegExp(
	    "^(aria)-[:A-Z_a-z\\u00C0-\\u00D6\\u00D8-\\u00F6\\u00F8-\\u02FF\\u0370-\\u037D\\u037F-\\u1FFF\\u200C-\\u200D\\u2070-\\u218F\\u2C00-\\u2FEF\\u3001-\\uD7FF\\uF900-\\uFDCF\\uFDF0-\\uFFFD\\-.0-9\\u00B7\\u0300-\\u036F\\u203F-\\u2040]*$"
	  ), rARIACamel$1 = RegExp(
	    "^(aria)[A-Z][:A-Z_a-z\\u00C0-\\u00D6\\u00D8-\\u00F6\\u00F8-\\u02FF\\u0370-\\u037D\\u037F-\\u1FFF\\u200C-\\u200D\\u2070-\\u218F\\u2C00-\\u2FEF\\u3001-\\uD7FF\\uF900-\\uFDCF\\uFDF0-\\uFFFD\\-.0-9\\u00B7\\u0300-\\u036F\\u203F-\\u2040]*$"
	  ), didWarnValueNull = false, warnedProperties = {}, EVENT_NAME_REGEX = /^on./, INVALID_EVENT_NAME_REGEX = /^on[^A-Z]/, rARIA = RegExp(
	    "^(aria)-[:A-Z_a-z\\u00C0-\\u00D6\\u00D8-\\u00F6\\u00F8-\\u02FF\\u0370-\\u037D\\u037F-\\u1FFF\\u200C-\\u200D\\u2070-\\u218F\\u2C00-\\u2FEF\\u3001-\\uD7FF\\uF900-\\uFDCF\\uFDF0-\\uFFFD\\-.0-9\\u00B7\\u0300-\\u036F\\u203F-\\u2040]*$"
	  ), rARIACamel = RegExp(
	    "^(aria)[A-Z][:A-Z_a-z\\u00C0-\\u00D6\\u00D8-\\u00F6\\u00F8-\\u02FF\\u0370-\\u037D\\u037F-\\u1FFF\\u200C-\\u200D\\u2070-\\u218F\\u2C00-\\u2FEF\\u3001-\\uD7FF\\uF900-\\uFDCF\\uFDF0-\\uFFFD\\-.0-9\\u00B7\\u0300-\\u036F\\u203F-\\u2040]*$"
	  ), isJavaScriptProtocol = /^[\u0000-\u001F ]*j[\r\n\t]*a[\r\n\t]*v[\r\n\t]*a[\r\n\t]*s[\r\n\t]*c[\r\n\t]*r[\r\n\t]*i[\r\n\t]*p[\r\n\t]*t[\r\n\t]*:/i, currentReplayingEvent = null, restoreTarget = null, restoreQueue = null, isInsideEventHandler = false, canUseDOM = !("undefined" === typeof window || "undefined" === typeof window.document || "undefined" === typeof window.document.createElement), passiveBrowserEventsSupported = false;
	  if (canUseDOM)
	    try {
	      var options$jscomp$0 = {};
	      Object.defineProperty(options$jscomp$0, "passive", {
	        get: function() {
	          passiveBrowserEventsSupported = true;
	        }
	      });
	      window.addEventListener("test", options$jscomp$0, options$jscomp$0);
	      window.removeEventListener("test", options$jscomp$0, options$jscomp$0);
	    } catch (e) {
	      passiveBrowserEventsSupported = false;
	    }
	  var root = null, startText = null, fallbackText = null, EventInterface = {
	    eventPhase: 0,
	    bubbles: 0,
	    cancelable: 0,
	    timeStamp: function(event) {
	      return event.timeStamp || Date.now();
	    },
	    defaultPrevented: 0,
	    isTrusted: 0
	  }, SyntheticEvent = createSyntheticEvent(EventInterface), UIEventInterface = assign({}, EventInterface, { view: 0, detail: 0 }), SyntheticUIEvent = createSyntheticEvent(UIEventInterface), lastMovementX, lastMovementY, lastMouseEvent, MouseEventInterface = assign({}, UIEventInterface, {
	    screenX: 0,
	    screenY: 0,
	    clientX: 0,
	    clientY: 0,
	    pageX: 0,
	    pageY: 0,
	    ctrlKey: 0,
	    shiftKey: 0,
	    altKey: 0,
	    metaKey: 0,
	    getModifierState: getEventModifierState,
	    button: 0,
	    buttons: 0,
	    relatedTarget: function(event) {
	      return void 0 === event.relatedTarget ? event.fromElement === event.srcElement ? event.toElement : event.fromElement : event.relatedTarget;
	    },
	    movementX: function(event) {
	      if ("movementX" in event) return event.movementX;
	      event !== lastMouseEvent && (lastMouseEvent && "mousemove" === event.type ? (lastMovementX = event.screenX - lastMouseEvent.screenX, lastMovementY = event.screenY - lastMouseEvent.screenY) : lastMovementY = lastMovementX = 0, lastMouseEvent = event);
	      return lastMovementX;
	    },
	    movementY: function(event) {
	      return "movementY" in event ? event.movementY : lastMovementY;
	    }
	  }), SyntheticMouseEvent = createSyntheticEvent(MouseEventInterface), DragEventInterface = assign({}, MouseEventInterface, { dataTransfer: 0 }), SyntheticDragEvent = createSyntheticEvent(DragEventInterface), FocusEventInterface = assign({}, UIEventInterface, { relatedTarget: 0 }), SyntheticFocusEvent = createSyntheticEvent(FocusEventInterface), AnimationEventInterface = assign({}, EventInterface, {
	    animationName: 0,
	    elapsedTime: 0,
	    pseudoElement: 0
	  }), SyntheticAnimationEvent = createSyntheticEvent(AnimationEventInterface), ClipboardEventInterface = assign({}, EventInterface, {
	    clipboardData: function(event) {
	      return "clipboardData" in event ? event.clipboardData : window.clipboardData;
	    }
	  }), SyntheticClipboardEvent = createSyntheticEvent(ClipboardEventInterface), CompositionEventInterface = assign({}, EventInterface, { data: 0 }), SyntheticCompositionEvent = createSyntheticEvent(
	    CompositionEventInterface
	  ), SyntheticInputEvent = SyntheticCompositionEvent, normalizeKey = {
	    Esc: "Escape",
	    Spacebar: " ",
	    Left: "ArrowLeft",
	    Up: "ArrowUp",
	    Right: "ArrowRight",
	    Down: "ArrowDown",
	    Del: "Delete",
	    Win: "OS",
	    Menu: "ContextMenu",
	    Apps: "ContextMenu",
	    Scroll: "ScrollLock",
	    MozPrintableKey: "Unidentified"
	  }, translateToKey = {
	    8: "Backspace",
	    9: "Tab",
	    12: "Clear",
	    13: "Enter",
	    16: "Shift",
	    17: "Control",
	    18: "Alt",
	    19: "Pause",
	    20: "CapsLock",
	    27: "Escape",
	    32: " ",
	    33: "PageUp",
	    34: "PageDown",
	    35: "End",
	    36: "Home",
	    37: "ArrowLeft",
	    38: "ArrowUp",
	    39: "ArrowRight",
	    40: "ArrowDown",
	    45: "Insert",
	    46: "Delete",
	    112: "F1",
	    113: "F2",
	    114: "F3",
	    115: "F4",
	    116: "F5",
	    117: "F6",
	    118: "F7",
	    119: "F8",
	    120: "F9",
	    121: "F10",
	    122: "F11",
	    123: "F12",
	    144: "NumLock",
	    145: "ScrollLock",
	    224: "Meta"
	  }, modifierKeyToProp = {
	    Alt: "altKey",
	    Control: "ctrlKey",
	    Meta: "metaKey",
	    Shift: "shiftKey"
	  }, KeyboardEventInterface = assign({}, UIEventInterface, {
	    key: function(nativeEvent) {
	      if (nativeEvent.key) {
	        var key = normalizeKey[nativeEvent.key] || nativeEvent.key;
	        if ("Unidentified" !== key) return key;
	      }
	      return "keypress" === nativeEvent.type ? (nativeEvent = getEventCharCode(nativeEvent), 13 === nativeEvent ? "Enter" : String.fromCharCode(nativeEvent)) : "keydown" === nativeEvent.type || "keyup" === nativeEvent.type ? translateToKey[nativeEvent.keyCode] || "Unidentified" : "";
	    },
	    code: 0,
	    location: 0,
	    ctrlKey: 0,
	    shiftKey: 0,
	    altKey: 0,
	    metaKey: 0,
	    repeat: 0,
	    locale: 0,
	    getModifierState: getEventModifierState,
	    charCode: function(event) {
	      return "keypress" === event.type ? getEventCharCode(event) : 0;
	    },
	    keyCode: function(event) {
	      return "keydown" === event.type || "keyup" === event.type ? event.keyCode : 0;
	    },
	    which: function(event) {
	      return "keypress" === event.type ? getEventCharCode(event) : "keydown" === event.type || "keyup" === event.type ? event.keyCode : 0;
	    }
	  }), SyntheticKeyboardEvent = createSyntheticEvent(KeyboardEventInterface), PointerEventInterface = assign({}, MouseEventInterface, {
	    pointerId: 0,
	    width: 0,
	    height: 0,
	    pressure: 0,
	    tangentialPressure: 0,
	    tiltX: 0,
	    tiltY: 0,
	    twist: 0,
	    pointerType: 0,
	    isPrimary: 0
	  }), SyntheticPointerEvent = createSyntheticEvent(PointerEventInterface), TouchEventInterface = assign({}, UIEventInterface, {
	    touches: 0,
	    targetTouches: 0,
	    changedTouches: 0,
	    altKey: 0,
	    metaKey: 0,
	    ctrlKey: 0,
	    shiftKey: 0,
	    getModifierState: getEventModifierState
	  }), SyntheticTouchEvent = createSyntheticEvent(TouchEventInterface), TransitionEventInterface = assign({}, EventInterface, {
	    propertyName: 0,
	    elapsedTime: 0,
	    pseudoElement: 0
	  }), SyntheticTransitionEvent = createSyntheticEvent(TransitionEventInterface), WheelEventInterface = assign({}, MouseEventInterface, {
	    deltaX: function(event) {
	      return "deltaX" in event ? event.deltaX : "wheelDeltaX" in event ? -event.wheelDeltaX : 0;
	    },
	    deltaY: function(event) {
	      return "deltaY" in event ? event.deltaY : "wheelDeltaY" in event ? -event.wheelDeltaY : "wheelDelta" in event ? -event.wheelDelta : 0;
	    },
	    deltaZ: 0,
	    deltaMode: 0
	  }), SyntheticWheelEvent = createSyntheticEvent(WheelEventInterface), ToggleEventInterface = assign({}, EventInterface, {
	    newState: 0,
	    oldState: 0
	  }), SyntheticToggleEvent = createSyntheticEvent(ToggleEventInterface), END_KEYCODES = [9, 13, 27, 32], START_KEYCODE = 229, canUseCompositionEvent = canUseDOM && "CompositionEvent" in window, documentMode = null;
	  canUseDOM && "documentMode" in document && (documentMode = document.documentMode);
	  var canUseTextInputEvent = canUseDOM && "TextEvent" in window && !documentMode, useFallbackCompositionData = canUseDOM && (!canUseCompositionEvent || documentMode && 8 < documentMode && 11 >= documentMode), SPACEBAR_CODE = 32, SPACEBAR_CHAR = String.fromCharCode(SPACEBAR_CODE), hasSpaceKeypress = false, isComposing = false, supportedInputTypes = {
	    color: true,
	    date: true,
	    datetime: true,
	    "datetime-local": true,
	    email: true,
	    month: true,
	    number: true,
	    password: true,
	    range: true,
	    search: true,
	    tel: true,
	    text: true,
	    time: true,
	    url: true,
	    week: true
	  }, activeElement$1 = null, activeElementInst$1 = null, isInputEventSupported = false;
	  canUseDOM && (isInputEventSupported = isEventSupported("input") && (!document.documentMode || 9 < document.documentMode));
	  var objectIs = "function" === typeof Object.is ? Object.is : is, skipSelectionChangeEvent = canUseDOM && "documentMode" in document && 11 >= document.documentMode, activeElement = null, activeElementInst = null, lastSelection = null, mouseDown = false, vendorPrefixes = {
	    animationend: makePrefixMap("Animation", "AnimationEnd"),
	    animationiteration: makePrefixMap("Animation", "AnimationIteration"),
	    animationstart: makePrefixMap("Animation", "AnimationStart"),
	    transitionrun: makePrefixMap("Transition", "TransitionRun"),
	    transitionstart: makePrefixMap("Transition", "TransitionStart"),
	    transitioncancel: makePrefixMap("Transition", "TransitionCancel"),
	    transitionend: makePrefixMap("Transition", "TransitionEnd")
	  }, prefixedEventNames = {}, style = {};
	  canUseDOM && (style = document.createElement("div").style, "AnimationEvent" in window || (delete vendorPrefixes.animationend.animation, delete vendorPrefixes.animationiteration.animation, delete vendorPrefixes.animationstart.animation), "TransitionEvent" in window || delete vendorPrefixes.transitionend.transition);
	  var ANIMATION_END = getVendorPrefixedEventName("animationend"), ANIMATION_ITERATION = getVendorPrefixedEventName("animationiteration"), ANIMATION_START = getVendorPrefixedEventName("animationstart"), TRANSITION_RUN = getVendorPrefixedEventName("transitionrun"), TRANSITION_START = getVendorPrefixedEventName("transitionstart"), TRANSITION_CANCEL = getVendorPrefixedEventName("transitioncancel"), TRANSITION_END = getVendorPrefixedEventName("transitionend"), topLevelEventsToReactNames = /* @__PURE__ */ new Map(), simpleEventPluginEvents = "abort auxClick beforeToggle cancel canPlay canPlayThrough click close contextMenu copy cut drag dragEnd dragEnter dragExit dragLeave dragOver dragStart drop durationChange emptied encrypted ended error gotPointerCapture input invalid keyDown keyPress keyUp load loadedData loadedMetadata loadStart lostPointerCapture mouseDown mouseMove mouseOut mouseOver mouseUp paste pause play playing pointerCancel pointerDown pointerMove pointerOut pointerOver pointerUp progress rateChange reset resize seeked seeking stalled submit suspend timeUpdate touchCancel touchEnd touchStart volumeChange scroll toggle touchMove waiting wheel".split(
	    " "
	  );
	  simpleEventPluginEvents.push("scrollEnd");
	  var CapturedStacks = /* @__PURE__ */ new WeakMap(), OffscreenVisible = 1, OffscreenPassiveEffectsConnected = 2, concurrentQueues = [], concurrentQueuesIndex = 0, concurrentlyUpdatedLanes = 0, emptyContextObject = {};
	  Object.freeze(emptyContextObject);
	  var resolveFamily = null, failedBoundaries = null, NoMode = 0, ConcurrentMode = 1, ProfileMode = 2, StrictLegacyMode = 8, StrictEffectsMode = 16, NoStrictPassiveEffectsMode = 64;
	  var hasBadMapPolyfill = false;
	  try {
	    var nonExtensibleObject = Object.preventExtensions({});
	    /* @__PURE__ */ new Map([[nonExtensibleObject, null]]);
	    /* @__PURE__ */ new Set([nonExtensibleObject]);
	  } catch (e$3) {
	    hasBadMapPolyfill = true;
	  }
	  var forkStack = [], forkStackIndex = 0, treeForkProvider = null, treeForkCount = 0, idStack = [], idStackIndex = 0, treeContextProvider = null, treeContextId = 1, treeContextOverflow = "", hydrationParentFiber = null, nextHydratableInstance = null, isHydrating = false, didSuspendOrErrorDEV = false, hydrationDiffRootDEV = null, hydrationErrors = null, rootOrSingletonContext = false, HydrationMismatchException = Error(
	    "Hydration Mismatch Exception: This is not a real error, and should not leak into userspace. If you're seeing this, it's likely a bug in React."
	  ), lastResetTime = 0;
	  if ("object" === typeof performance && "function" === typeof performance.now) {
	    var localPerformance = performance;
	    var getCurrentTime = function() {
	      return localPerformance.now();
	    };
	  } else {
	    var localDate = Date;
	    getCurrentTime = function() {
	      return localDate.now();
	    };
	  }
	  var valueCursor = createCursor(null);
	  var rendererCursorDEV = createCursor(null);
	  var rendererSigil = {};
	  var currentlyRenderingFiber$1 = null, lastContextDependency = null, isDisallowedContextReadInDEV = false, AbortControllerLocal = "undefined" !== typeof AbortController ? AbortController : function() {
	    var listeners = [], signal = this.signal = {
	      aborted: false,
	      addEventListener: function(type, listener) {
	        listeners.push(listener);
	      }
	    };
	    this.abort = function() {
	      signal.aborted = true;
	      listeners.forEach(function(listener) {
	        return listener();
	      });
	    };
	  }, scheduleCallback$2 = Scheduler.unstable_scheduleCallback, NormalPriority = Scheduler.unstable_NormalPriority, CacheContext = {
	    $$typeof: REACT_CONTEXT_TYPE,
	    Consumer: null,
	    Provider: null,
	    _currentValue: null,
	    _currentValue2: null,
	    _threadCount: 0,
	    _currentRenderer: null,
	    _currentRenderer2: null
	  }, now = Scheduler.unstable_now, renderStartTime = -0, commitStartTime = -0, profilerStartTime = -1.1, profilerEffectDuration = -0, currentUpdateIsNested = false, nestedUpdateScheduled = false, currentEntangledListeners = null, currentEntangledPendingCount = 0, currentEntangledLane = 0, currentEntangledActionThenable = null, prevOnStartTransitionFinish = ReactSharedInternals.S;
	  ReactSharedInternals.S = function(transition, returnValue) {
	    "object" === typeof returnValue && null !== returnValue && "function" === typeof returnValue.then && entangleAsyncAction(transition, returnValue);
	    null !== prevOnStartTransitionFinish && prevOnStartTransitionFinish(transition, returnValue);
	  };
	  var resumedCache = createCursor(null), ReactStrictModeWarnings = {
	    recordUnsafeLifecycleWarnings: function() {
	    },
	    flushPendingUnsafeLifecycleWarnings: function() {
	    },
	    recordLegacyContextWarning: function() {
	    },
	    flushLegacyContextWarning: function() {
	    },
	    discardPendingWarnings: function() {
	    }
	  }, pendingComponentWillMountWarnings = [], pendingUNSAFE_ComponentWillMountWarnings = [], pendingComponentWillReceivePropsWarnings = [], pendingUNSAFE_ComponentWillReceivePropsWarnings = [], pendingComponentWillUpdateWarnings = [], pendingUNSAFE_ComponentWillUpdateWarnings = [], didWarnAboutUnsafeLifecycles = /* @__PURE__ */ new Set();
	  ReactStrictModeWarnings.recordUnsafeLifecycleWarnings = function(fiber, instance) {
	    didWarnAboutUnsafeLifecycles.has(fiber.type) || ("function" === typeof instance.componentWillMount && true !== instance.componentWillMount.__suppressDeprecationWarning && pendingComponentWillMountWarnings.push(fiber), fiber.mode & StrictLegacyMode && "function" === typeof instance.UNSAFE_componentWillMount && pendingUNSAFE_ComponentWillMountWarnings.push(fiber), "function" === typeof instance.componentWillReceiveProps && true !== instance.componentWillReceiveProps.__suppressDeprecationWarning && pendingComponentWillReceivePropsWarnings.push(fiber), fiber.mode & StrictLegacyMode && "function" === typeof instance.UNSAFE_componentWillReceiveProps && pendingUNSAFE_ComponentWillReceivePropsWarnings.push(fiber), "function" === typeof instance.componentWillUpdate && true !== instance.componentWillUpdate.__suppressDeprecationWarning && pendingComponentWillUpdateWarnings.push(fiber), fiber.mode & StrictLegacyMode && "function" === typeof instance.UNSAFE_componentWillUpdate && pendingUNSAFE_ComponentWillUpdateWarnings.push(fiber));
	  };
	  ReactStrictModeWarnings.flushPendingUnsafeLifecycleWarnings = function() {
	    var componentWillMountUniqueNames = /* @__PURE__ */ new Set();
	    0 < pendingComponentWillMountWarnings.length && (pendingComponentWillMountWarnings.forEach(function(fiber) {
	      componentWillMountUniqueNames.add(
	        getComponentNameFromFiber(fiber) || "Component"
	      );
	      didWarnAboutUnsafeLifecycles.add(fiber.type);
	    }), pendingComponentWillMountWarnings = []);
	    var UNSAFE_componentWillMountUniqueNames = /* @__PURE__ */ new Set();
	    0 < pendingUNSAFE_ComponentWillMountWarnings.length && (pendingUNSAFE_ComponentWillMountWarnings.forEach(function(fiber) {
	      UNSAFE_componentWillMountUniqueNames.add(
	        getComponentNameFromFiber(fiber) || "Component"
	      );
	      didWarnAboutUnsafeLifecycles.add(fiber.type);
	    }), pendingUNSAFE_ComponentWillMountWarnings = []);
	    var componentWillReceivePropsUniqueNames = /* @__PURE__ */ new Set();
	    0 < pendingComponentWillReceivePropsWarnings.length && (pendingComponentWillReceivePropsWarnings.forEach(function(fiber) {
	      componentWillReceivePropsUniqueNames.add(
	        getComponentNameFromFiber(fiber) || "Component"
	      );
	      didWarnAboutUnsafeLifecycles.add(fiber.type);
	    }), pendingComponentWillReceivePropsWarnings = []);
	    var UNSAFE_componentWillReceivePropsUniqueNames = /* @__PURE__ */ new Set();
	    0 < pendingUNSAFE_ComponentWillReceivePropsWarnings.length && (pendingUNSAFE_ComponentWillReceivePropsWarnings.forEach(
	      function(fiber) {
	        UNSAFE_componentWillReceivePropsUniqueNames.add(
	          getComponentNameFromFiber(fiber) || "Component"
	        );
	        didWarnAboutUnsafeLifecycles.add(fiber.type);
	      }
	    ), pendingUNSAFE_ComponentWillReceivePropsWarnings = []);
	    var componentWillUpdateUniqueNames = /* @__PURE__ */ new Set();
	    0 < pendingComponentWillUpdateWarnings.length && (pendingComponentWillUpdateWarnings.forEach(function(fiber) {
	      componentWillUpdateUniqueNames.add(
	        getComponentNameFromFiber(fiber) || "Component"
	      );
	      didWarnAboutUnsafeLifecycles.add(fiber.type);
	    }), pendingComponentWillUpdateWarnings = []);
	    var UNSAFE_componentWillUpdateUniqueNames = /* @__PURE__ */ new Set();
	    0 < pendingUNSAFE_ComponentWillUpdateWarnings.length && (pendingUNSAFE_ComponentWillUpdateWarnings.forEach(function(fiber) {
	      UNSAFE_componentWillUpdateUniqueNames.add(
	        getComponentNameFromFiber(fiber) || "Component"
	      );
	      didWarnAboutUnsafeLifecycles.add(fiber.type);
	    }), pendingUNSAFE_ComponentWillUpdateWarnings = []);
	    if (0 < UNSAFE_componentWillMountUniqueNames.size) {
	      var sortedNames = setToSortedString(
	        UNSAFE_componentWillMountUniqueNames
	      );
	      console.error(
	        "Using UNSAFE_componentWillMount in strict mode is not recommended and may indicate bugs in your code. See https://react.dev/link/unsafe-component-lifecycles for details.\n\n* Move code with side effects to componentDidMount, and set initial state in the constructor.\n\nPlease update the following components: %s",
	        sortedNames
	      );
	    }
	    0 < UNSAFE_componentWillReceivePropsUniqueNames.size && (sortedNames = setToSortedString(
	      UNSAFE_componentWillReceivePropsUniqueNames
	    ), console.error(
	      "Using UNSAFE_componentWillReceiveProps in strict mode is not recommended and may indicate bugs in your code. See https://react.dev/link/unsafe-component-lifecycles for details.\n\n* Move data fetching code or side effects to componentDidUpdate.\n* If you're updating state whenever props change, refactor your code to use memoization techniques or move it to static getDerivedStateFromProps. Learn more at: https://react.dev/link/derived-state\n\nPlease update the following components: %s",
	      sortedNames
	    ));
	    0 < UNSAFE_componentWillUpdateUniqueNames.size && (sortedNames = setToSortedString(
	      UNSAFE_componentWillUpdateUniqueNames
	    ), console.error(
	      "Using UNSAFE_componentWillUpdate in strict mode is not recommended and may indicate bugs in your code. See https://react.dev/link/unsafe-component-lifecycles for details.\n\n* Move data fetching code or side effects to componentDidUpdate.\n\nPlease update the following components: %s",
	      sortedNames
	    ));
	    0 < componentWillMountUniqueNames.size && (sortedNames = setToSortedString(componentWillMountUniqueNames), console.warn(
	      "componentWillMount has been renamed, and is not recommended for use. See https://react.dev/link/unsafe-component-lifecycles for details.\n\n* Move code with side effects to componentDidMount, and set initial state in the constructor.\n* Rename componentWillMount to UNSAFE_componentWillMount to suppress this warning in non-strict mode. In React 18.x, only the UNSAFE_ name will work. To rename all deprecated lifecycles to their new names, you can run `npx react-codemod rename-unsafe-lifecycles` in your project source folder.\n\nPlease update the following components: %s",
	      sortedNames
	    ));
	    0 < componentWillReceivePropsUniqueNames.size && (sortedNames = setToSortedString(
	      componentWillReceivePropsUniqueNames
	    ), console.warn(
	      "componentWillReceiveProps has been renamed, and is not recommended for use. See https://react.dev/link/unsafe-component-lifecycles for details.\n\n* Move data fetching code or side effects to componentDidUpdate.\n* If you're updating state whenever props change, refactor your code to use memoization techniques or move it to static getDerivedStateFromProps. Learn more at: https://react.dev/link/derived-state\n* Rename componentWillReceiveProps to UNSAFE_componentWillReceiveProps to suppress this warning in non-strict mode. In React 18.x, only the UNSAFE_ name will work. To rename all deprecated lifecycles to their new names, you can run `npx react-codemod rename-unsafe-lifecycles` in your project source folder.\n\nPlease update the following components: %s",
	      sortedNames
	    ));
	    0 < componentWillUpdateUniqueNames.size && (sortedNames = setToSortedString(componentWillUpdateUniqueNames), console.warn(
	      "componentWillUpdate has been renamed, and is not recommended for use. See https://react.dev/link/unsafe-component-lifecycles for details.\n\n* Move data fetching code or side effects to componentDidUpdate.\n* Rename componentWillUpdate to UNSAFE_componentWillUpdate to suppress this warning in non-strict mode. In React 18.x, only the UNSAFE_ name will work. To rename all deprecated lifecycles to their new names, you can run `npx react-codemod rename-unsafe-lifecycles` in your project source folder.\n\nPlease update the following components: %s",
	      sortedNames
	    ));
	  };
	  var pendingLegacyContextWarning = /* @__PURE__ */ new Map(), didWarnAboutLegacyContext = /* @__PURE__ */ new Set();
	  ReactStrictModeWarnings.recordLegacyContextWarning = function(fiber, instance) {
	    var strictRoot = null;
	    for (var node = fiber; null !== node; )
	      node.mode & StrictLegacyMode && (strictRoot = node), node = node.return;
	    null === strictRoot ? console.error(
	      "Expected to find a StrictMode component in a strict mode tree. This error is likely caused by a bug in React. Please file an issue."
	    ) : !didWarnAboutLegacyContext.has(fiber.type) && (node = pendingLegacyContextWarning.get(strictRoot), null != fiber.type.contextTypes || null != fiber.type.childContextTypes || null !== instance && "function" === typeof instance.getChildContext) && (void 0 === node && (node = [], pendingLegacyContextWarning.set(strictRoot, node)), node.push(fiber));
	  };
	  ReactStrictModeWarnings.flushLegacyContextWarning = function() {
	    pendingLegacyContextWarning.forEach(function(fiberArray) {
	      if (0 !== fiberArray.length) {
	        var firstFiber = fiberArray[0], uniqueNames = /* @__PURE__ */ new Set();
	        fiberArray.forEach(function(fiber) {
	          uniqueNames.add(getComponentNameFromFiber(fiber) || "Component");
	          didWarnAboutLegacyContext.add(fiber.type);
	        });
	        var sortedNames = setToSortedString(uniqueNames);
	        runWithFiberInDEV(firstFiber, function() {
	          console.error(
	            "Legacy context API has been detected within a strict-mode tree.\n\nThe old API will be supported in all 16.x releases, but applications using it should migrate to the new version.\n\nPlease update the following components: %s\n\nLearn more about this warning here: https://react.dev/link/legacy-context",
	            sortedNames
	          );
	        });
	      }
	    });
	  };
	  ReactStrictModeWarnings.discardPendingWarnings = function() {
	    pendingComponentWillMountWarnings = [];
	    pendingUNSAFE_ComponentWillMountWarnings = [];
	    pendingComponentWillReceivePropsWarnings = [];
	    pendingUNSAFE_ComponentWillReceivePropsWarnings = [];
	    pendingComponentWillUpdateWarnings = [];
	    pendingUNSAFE_ComponentWillUpdateWarnings = [];
	    pendingLegacyContextWarning = /* @__PURE__ */ new Map();
	  };
	  var SuspenseException = Error(
	    "Suspense Exception: This is not a real error! It's an implementation detail of `use` to interrupt the current render. You must either rethrow it immediately, or move the `use` call outside of the `try/catch` block. Capturing without rethrowing will lead to unexpected behavior.\n\nTo handle async errors, wrap your component in an error boundary, or call the promise's `.catch` method and pass the result to `use`."
	  ), SuspenseyCommitException = Error(
	    "Suspense Exception: This is not a real error, and should not leak into userspace. If you're seeing this, it's likely a bug in React."
	  ), SuspenseActionException = Error(
	    "Suspense Exception: This is not a real error! It's an implementation detail of `useActionState` to interrupt the current render. You must either rethrow it immediately, or move the `useActionState` call outside of the `try/catch` block. Capturing without rethrowing will lead to unexpected behavior.\n\nTo handle async errors, wrap your component in an error boundary."
	  ), noopSuspenseyCommitThenable = {
	    then: function() {
	      console.error(
	        'Internal React error: A listener was unexpectedly attached to a "noop" thenable. This is a bug in React. Please file an issue.'
	      );
	    }
	  }, suspendedThenable = null, needsToResetSuspendedThenableDEV = false, NoFlags = 0, HasEffect = 1, Insertion = 2, Layout = 4, Passive = 8, UpdateState = 0, ReplaceState = 1, ForceUpdate = 2, CaptureUpdate = 3, hasForceUpdate = false;
	  var didWarnUpdateInsideUpdate = false;
	  var currentlyProcessingQueue = null;
	  var didReadFromEntangledAsyncAction = false, currentTreeHiddenStackCursor = createCursor(null), prevEntangledRenderLanesCursor = createCursor(0), didWarnUncachedGetSnapshot;
	  var didWarnAboutMismatchedHooksForComponent = /* @__PURE__ */ new Set();
	  var didWarnAboutUseWrappedInTryCatch = /* @__PURE__ */ new Set();
	  var didWarnAboutAsyncClientComponent = /* @__PURE__ */ new Set();
	  var didWarnAboutUseFormState = /* @__PURE__ */ new Set();
	  var renderLanes = 0, currentlyRenderingFiber = null, currentHook = null, workInProgressHook = null, didScheduleRenderPhaseUpdate = false, didScheduleRenderPhaseUpdateDuringThisPass = false, shouldDoubleInvokeUserFnsInHooksDEV = false, localIdCounter = 0, thenableIndexCounter$1 = 0, thenableState$1 = null, globalClientIdCounter = 0, RE_RENDER_LIMIT = 25, currentHookNameInDev = null, hookTypesDev = null, hookTypesUpdateIndexDev = -1, ignorePreviousDependencies = false, ContextOnlyDispatcher = {
	    readContext,
	    use,
	    useCallback: throwInvalidHookError,
	    useContext: throwInvalidHookError,
	    useEffect: throwInvalidHookError,
	    useImperativeHandle: throwInvalidHookError,
	    useLayoutEffect: throwInvalidHookError,
	    useInsertionEffect: throwInvalidHookError,
	    useMemo: throwInvalidHookError,
	    useReducer: throwInvalidHookError,
	    useRef: throwInvalidHookError,
	    useState: throwInvalidHookError,
	    useDebugValue: throwInvalidHookError,
	    useDeferredValue: throwInvalidHookError,
	    useTransition: throwInvalidHookError,
	    useSyncExternalStore: throwInvalidHookError,
	    useId: throwInvalidHookError,
	    useHostTransitionStatus: throwInvalidHookError,
	    useFormState: throwInvalidHookError,
	    useActionState: throwInvalidHookError,
	    useOptimistic: throwInvalidHookError,
	    useMemoCache: throwInvalidHookError,
	    useCacheRefresh: throwInvalidHookError
	  }, HooksDispatcherOnMountInDEV = null, HooksDispatcherOnMountWithHookTypesInDEV = null, HooksDispatcherOnUpdateInDEV = null, HooksDispatcherOnRerenderInDEV = null, InvalidNestedHooksDispatcherOnMountInDEV = null, InvalidNestedHooksDispatcherOnUpdateInDEV = null, InvalidNestedHooksDispatcherOnRerenderInDEV = null;
	  HooksDispatcherOnMountInDEV = {
	    readContext: function(context) {
	      return readContext(context);
	    },
	    use,
	    useCallback: function(callback, deps) {
	      currentHookNameInDev = "useCallback";
	      mountHookTypesDev();
	      checkDepsAreArrayDev(deps);
	      return mountCallback(callback, deps);
	    },
	    useContext: function(context) {
	      currentHookNameInDev = "useContext";
	      mountHookTypesDev();
	      return readContext(context);
	    },
	    useEffect: function(create, createDeps) {
	      currentHookNameInDev = "useEffect";
	      mountHookTypesDev();
	      checkDepsAreArrayDev(createDeps);
	      return mountEffect(create, createDeps);
	    },
	    useImperativeHandle: function(ref, create, deps) {
	      currentHookNameInDev = "useImperativeHandle";
	      mountHookTypesDev();
	      checkDepsAreArrayDev(deps);
	      return mountImperativeHandle(ref, create, deps);
	    },
	    useInsertionEffect: function(create, deps) {
	      currentHookNameInDev = "useInsertionEffect";
	      mountHookTypesDev();
	      checkDepsAreArrayDev(deps);
	      mountEffectImpl(4, Insertion, create, deps);
	    },
	    useLayoutEffect: function(create, deps) {
	      currentHookNameInDev = "useLayoutEffect";
	      mountHookTypesDev();
	      checkDepsAreArrayDev(deps);
	      return mountLayoutEffect(create, deps);
	    },
	    useMemo: function(create, deps) {
	      currentHookNameInDev = "useMemo";
	      mountHookTypesDev();
	      checkDepsAreArrayDev(deps);
	      var prevDispatcher = ReactSharedInternals.H;
	      ReactSharedInternals.H = InvalidNestedHooksDispatcherOnMountInDEV;
	      try {
	        return mountMemo(create, deps);
	      } finally {
	        ReactSharedInternals.H = prevDispatcher;
	      }
	    },
	    useReducer: function(reducer, initialArg, init) {
	      currentHookNameInDev = "useReducer";
	      mountHookTypesDev();
	      var prevDispatcher = ReactSharedInternals.H;
	      ReactSharedInternals.H = InvalidNestedHooksDispatcherOnMountInDEV;
	      try {
	        return mountReducer(reducer, initialArg, init);
	      } finally {
	        ReactSharedInternals.H = prevDispatcher;
	      }
	    },
	    useRef: function(initialValue) {
	      currentHookNameInDev = "useRef";
	      mountHookTypesDev();
	      return mountRef(initialValue);
	    },
	    useState: function(initialState) {
	      currentHookNameInDev = "useState";
	      mountHookTypesDev();
	      var prevDispatcher = ReactSharedInternals.H;
	      ReactSharedInternals.H = InvalidNestedHooksDispatcherOnMountInDEV;
	      try {
	        return mountState(initialState);
	      } finally {
	        ReactSharedInternals.H = prevDispatcher;
	      }
	    },
	    useDebugValue: function() {
	      currentHookNameInDev = "useDebugValue";
	      mountHookTypesDev();
	    },
	    useDeferredValue: function(value, initialValue) {
	      currentHookNameInDev = "useDeferredValue";
	      mountHookTypesDev();
	      return mountDeferredValue(value, initialValue);
	    },
	    useTransition: function() {
	      currentHookNameInDev = "useTransition";
	      mountHookTypesDev();
	      return mountTransition();
	    },
	    useSyncExternalStore: function(subscribe, getSnapshot, getServerSnapshot) {
	      currentHookNameInDev = "useSyncExternalStore";
	      mountHookTypesDev();
	      return mountSyncExternalStore(
	        subscribe,
	        getSnapshot,
	        getServerSnapshot
	      );
	    },
	    useId: function() {
	      currentHookNameInDev = "useId";
	      mountHookTypesDev();
	      return mountId();
	    },
	    useFormState: function(action, initialState) {
	      currentHookNameInDev = "useFormState";
	      mountHookTypesDev();
	      warnOnUseFormStateInDev();
	      return mountActionState(action, initialState);
	    },
	    useActionState: function(action, initialState) {
	      currentHookNameInDev = "useActionState";
	      mountHookTypesDev();
	      return mountActionState(action, initialState);
	    },
	    useOptimistic: function(passthrough) {
	      currentHookNameInDev = "useOptimistic";
	      mountHookTypesDev();
	      return mountOptimistic(passthrough);
	    },
	    useHostTransitionStatus,
	    useMemoCache,
	    useCacheRefresh: function() {
	      currentHookNameInDev = "useCacheRefresh";
	      mountHookTypesDev();
	      return mountRefresh();
	    }
	  };
	  HooksDispatcherOnMountWithHookTypesInDEV = {
	    readContext: function(context) {
	      return readContext(context);
	    },
	    use,
	    useCallback: function(callback, deps) {
	      currentHookNameInDev = "useCallback";
	      updateHookTypesDev();
	      return mountCallback(callback, deps);
	    },
	    useContext: function(context) {
	      currentHookNameInDev = "useContext";
	      updateHookTypesDev();
	      return readContext(context);
	    },
	    useEffect: function(create, createDeps) {
	      currentHookNameInDev = "useEffect";
	      updateHookTypesDev();
	      return mountEffect(create, createDeps);
	    },
	    useImperativeHandle: function(ref, create, deps) {
	      currentHookNameInDev = "useImperativeHandle";
	      updateHookTypesDev();
	      return mountImperativeHandle(ref, create, deps);
	    },
	    useInsertionEffect: function(create, deps) {
	      currentHookNameInDev = "useInsertionEffect";
	      updateHookTypesDev();
	      mountEffectImpl(4, Insertion, create, deps);
	    },
	    useLayoutEffect: function(create, deps) {
	      currentHookNameInDev = "useLayoutEffect";
	      updateHookTypesDev();
	      return mountLayoutEffect(create, deps);
	    },
	    useMemo: function(create, deps) {
	      currentHookNameInDev = "useMemo";
	      updateHookTypesDev();
	      var prevDispatcher = ReactSharedInternals.H;
	      ReactSharedInternals.H = InvalidNestedHooksDispatcherOnMountInDEV;
	      try {
	        return mountMemo(create, deps);
	      } finally {
	        ReactSharedInternals.H = prevDispatcher;
	      }
	    },
	    useReducer: function(reducer, initialArg, init) {
	      currentHookNameInDev = "useReducer";
	      updateHookTypesDev();
	      var prevDispatcher = ReactSharedInternals.H;
	      ReactSharedInternals.H = InvalidNestedHooksDispatcherOnMountInDEV;
	      try {
	        return mountReducer(reducer, initialArg, init);
	      } finally {
	        ReactSharedInternals.H = prevDispatcher;
	      }
	    },
	    useRef: function(initialValue) {
	      currentHookNameInDev = "useRef";
	      updateHookTypesDev();
	      return mountRef(initialValue);
	    },
	    useState: function(initialState) {
	      currentHookNameInDev = "useState";
	      updateHookTypesDev();
	      var prevDispatcher = ReactSharedInternals.H;
	      ReactSharedInternals.H = InvalidNestedHooksDispatcherOnMountInDEV;
	      try {
	        return mountState(initialState);
	      } finally {
	        ReactSharedInternals.H = prevDispatcher;
	      }
	    },
	    useDebugValue: function() {
	      currentHookNameInDev = "useDebugValue";
	      updateHookTypesDev();
	    },
	    useDeferredValue: function(value, initialValue) {
	      currentHookNameInDev = "useDeferredValue";
	      updateHookTypesDev();
	      return mountDeferredValue(value, initialValue);
	    },
	    useTransition: function() {
	      currentHookNameInDev = "useTransition";
	      updateHookTypesDev();
	      return mountTransition();
	    },
	    useSyncExternalStore: function(subscribe, getSnapshot, getServerSnapshot) {
	      currentHookNameInDev = "useSyncExternalStore";
	      updateHookTypesDev();
	      return mountSyncExternalStore(
	        subscribe,
	        getSnapshot,
	        getServerSnapshot
	      );
	    },
	    useId: function() {
	      currentHookNameInDev = "useId";
	      updateHookTypesDev();
	      return mountId();
	    },
	    useActionState: function(action, initialState) {
	      currentHookNameInDev = "useActionState";
	      updateHookTypesDev();
	      return mountActionState(action, initialState);
	    },
	    useFormState: function(action, initialState) {
	      currentHookNameInDev = "useFormState";
	      updateHookTypesDev();
	      warnOnUseFormStateInDev();
	      return mountActionState(action, initialState);
	    },
	    useOptimistic: function(passthrough) {
	      currentHookNameInDev = "useOptimistic";
	      updateHookTypesDev();
	      return mountOptimistic(passthrough);
	    },
	    useHostTransitionStatus,
	    useMemoCache,
	    useCacheRefresh: function() {
	      currentHookNameInDev = "useCacheRefresh";
	      updateHookTypesDev();
	      return mountRefresh();
	    }
	  };
	  HooksDispatcherOnUpdateInDEV = {
	    readContext: function(context) {
	      return readContext(context);
	    },
	    use,
	    useCallback: function(callback, deps) {
	      currentHookNameInDev = "useCallback";
	      updateHookTypesDev();
	      return updateCallback(callback, deps);
	    },
	    useContext: function(context) {
	      currentHookNameInDev = "useContext";
	      updateHookTypesDev();
	      return readContext(context);
	    },
	    useEffect: function(create, createDeps) {
	      currentHookNameInDev = "useEffect";
	      updateHookTypesDev();
	      updateEffectImpl(2048, Passive, create, createDeps);
	    },
	    useImperativeHandle: function(ref, create, deps) {
	      currentHookNameInDev = "useImperativeHandle";
	      updateHookTypesDev();
	      return updateImperativeHandle(ref, create, deps);
	    },
	    useInsertionEffect: function(create, deps) {
	      currentHookNameInDev = "useInsertionEffect";
	      updateHookTypesDev();
	      return updateEffectImpl(4, Insertion, create, deps);
	    },
	    useLayoutEffect: function(create, deps) {
	      currentHookNameInDev = "useLayoutEffect";
	      updateHookTypesDev();
	      return updateEffectImpl(4, Layout, create, deps);
	    },
	    useMemo: function(create, deps) {
	      currentHookNameInDev = "useMemo";
	      updateHookTypesDev();
	      var prevDispatcher = ReactSharedInternals.H;
	      ReactSharedInternals.H = InvalidNestedHooksDispatcherOnUpdateInDEV;
	      try {
	        return updateMemo(create, deps);
	      } finally {
	        ReactSharedInternals.H = prevDispatcher;
	      }
	    },
	    useReducer: function(reducer, initialArg, init) {
	      currentHookNameInDev = "useReducer";
	      updateHookTypesDev();
	      var prevDispatcher = ReactSharedInternals.H;
	      ReactSharedInternals.H = InvalidNestedHooksDispatcherOnUpdateInDEV;
	      try {
	        return updateReducer(reducer, initialArg, init);
	      } finally {
	        ReactSharedInternals.H = prevDispatcher;
	      }
	    },
	    useRef: function() {
	      currentHookNameInDev = "useRef";
	      updateHookTypesDev();
	      return updateWorkInProgressHook().memoizedState;
	    },
	    useState: function() {
	      currentHookNameInDev = "useState";
	      updateHookTypesDev();
	      var prevDispatcher = ReactSharedInternals.H;
	      ReactSharedInternals.H = InvalidNestedHooksDispatcherOnUpdateInDEV;
	      try {
	        return updateReducer(basicStateReducer);
	      } finally {
	        ReactSharedInternals.H = prevDispatcher;
	      }
	    },
	    useDebugValue: function() {
	      currentHookNameInDev = "useDebugValue";
	      updateHookTypesDev();
	    },
	    useDeferredValue: function(value, initialValue) {
	      currentHookNameInDev = "useDeferredValue";
	      updateHookTypesDev();
	      return updateDeferredValue(value, initialValue);
	    },
	    useTransition: function() {
	      currentHookNameInDev = "useTransition";
	      updateHookTypesDev();
	      return updateTransition();
	    },
	    useSyncExternalStore: function(subscribe, getSnapshot, getServerSnapshot) {
	      currentHookNameInDev = "useSyncExternalStore";
	      updateHookTypesDev();
	      return updateSyncExternalStore(
	        subscribe,
	        getSnapshot,
	        getServerSnapshot
	      );
	    },
	    useId: function() {
	      currentHookNameInDev = "useId";
	      updateHookTypesDev();
	      return updateWorkInProgressHook().memoizedState;
	    },
	    useFormState: function(action) {
	      currentHookNameInDev = "useFormState";
	      updateHookTypesDev();
	      warnOnUseFormStateInDev();
	      return updateActionState(action);
	    },
	    useActionState: function(action) {
	      currentHookNameInDev = "useActionState";
	      updateHookTypesDev();
	      return updateActionState(action);
	    },
	    useOptimistic: function(passthrough, reducer) {
	      currentHookNameInDev = "useOptimistic";
	      updateHookTypesDev();
	      return updateOptimistic(passthrough, reducer);
	    },
	    useHostTransitionStatus,
	    useMemoCache,
	    useCacheRefresh: function() {
	      currentHookNameInDev = "useCacheRefresh";
	      updateHookTypesDev();
	      return updateWorkInProgressHook().memoizedState;
	    }
	  };
	  HooksDispatcherOnRerenderInDEV = {
	    readContext: function(context) {
	      return readContext(context);
	    },
	    use,
	    useCallback: function(callback, deps) {
	      currentHookNameInDev = "useCallback";
	      updateHookTypesDev();
	      return updateCallback(callback, deps);
	    },
	    useContext: function(context) {
	      currentHookNameInDev = "useContext";
	      updateHookTypesDev();
	      return readContext(context);
	    },
	    useEffect: function(create, createDeps) {
	      currentHookNameInDev = "useEffect";
	      updateHookTypesDev();
	      updateEffectImpl(2048, Passive, create, createDeps);
	    },
	    useImperativeHandle: function(ref, create, deps) {
	      currentHookNameInDev = "useImperativeHandle";
	      updateHookTypesDev();
	      return updateImperativeHandle(ref, create, deps);
	    },
	    useInsertionEffect: function(create, deps) {
	      currentHookNameInDev = "useInsertionEffect";
	      updateHookTypesDev();
	      return updateEffectImpl(4, Insertion, create, deps);
	    },
	    useLayoutEffect: function(create, deps) {
	      currentHookNameInDev = "useLayoutEffect";
	      updateHookTypesDev();
	      return updateEffectImpl(4, Layout, create, deps);
	    },
	    useMemo: function(create, deps) {
	      currentHookNameInDev = "useMemo";
	      updateHookTypesDev();
	      var prevDispatcher = ReactSharedInternals.H;
	      ReactSharedInternals.H = InvalidNestedHooksDispatcherOnRerenderInDEV;
	      try {
	        return updateMemo(create, deps);
	      } finally {
	        ReactSharedInternals.H = prevDispatcher;
	      }
	    },
	    useReducer: function(reducer, initialArg, init) {
	      currentHookNameInDev = "useReducer";
	      updateHookTypesDev();
	      var prevDispatcher = ReactSharedInternals.H;
	      ReactSharedInternals.H = InvalidNestedHooksDispatcherOnRerenderInDEV;
	      try {
	        return rerenderReducer(reducer, initialArg, init);
	      } finally {
	        ReactSharedInternals.H = prevDispatcher;
	      }
	    },
	    useRef: function() {
	      currentHookNameInDev = "useRef";
	      updateHookTypesDev();
	      return updateWorkInProgressHook().memoizedState;
	    },
	    useState: function() {
	      currentHookNameInDev = "useState";
	      updateHookTypesDev();
	      var prevDispatcher = ReactSharedInternals.H;
	      ReactSharedInternals.H = InvalidNestedHooksDispatcherOnRerenderInDEV;
	      try {
	        return rerenderReducer(basicStateReducer);
	      } finally {
	        ReactSharedInternals.H = prevDispatcher;
	      }
	    },
	    useDebugValue: function() {
	      currentHookNameInDev = "useDebugValue";
	      updateHookTypesDev();
	    },
	    useDeferredValue: function(value, initialValue) {
	      currentHookNameInDev = "useDeferredValue";
	      updateHookTypesDev();
	      return rerenderDeferredValue(value, initialValue);
	    },
	    useTransition: function() {
	      currentHookNameInDev = "useTransition";
	      updateHookTypesDev();
	      return rerenderTransition();
	    },
	    useSyncExternalStore: function(subscribe, getSnapshot, getServerSnapshot) {
	      currentHookNameInDev = "useSyncExternalStore";
	      updateHookTypesDev();
	      return updateSyncExternalStore(
	        subscribe,
	        getSnapshot,
	        getServerSnapshot
	      );
	    },
	    useId: function() {
	      currentHookNameInDev = "useId";
	      updateHookTypesDev();
	      return updateWorkInProgressHook().memoizedState;
	    },
	    useFormState: function(action) {
	      currentHookNameInDev = "useFormState";
	      updateHookTypesDev();
	      warnOnUseFormStateInDev();
	      return rerenderActionState(action);
	    },
	    useActionState: function(action) {
	      currentHookNameInDev = "useActionState";
	      updateHookTypesDev();
	      return rerenderActionState(action);
	    },
	    useOptimistic: function(passthrough, reducer) {
	      currentHookNameInDev = "useOptimistic";
	      updateHookTypesDev();
	      return rerenderOptimistic(passthrough, reducer);
	    },
	    useHostTransitionStatus,
	    useMemoCache,
	    useCacheRefresh: function() {
	      currentHookNameInDev = "useCacheRefresh";
	      updateHookTypesDev();
	      return updateWorkInProgressHook().memoizedState;
	    }
	  };
	  InvalidNestedHooksDispatcherOnMountInDEV = {
	    readContext: function(context) {
	      warnInvalidContextAccess();
	      return readContext(context);
	    },
	    use: function(usable) {
	      warnInvalidHookAccess();
	      return use(usable);
	    },
	    useCallback: function(callback, deps) {
	      currentHookNameInDev = "useCallback";
	      warnInvalidHookAccess();
	      mountHookTypesDev();
	      return mountCallback(callback, deps);
	    },
	    useContext: function(context) {
	      currentHookNameInDev = "useContext";
	      warnInvalidHookAccess();
	      mountHookTypesDev();
	      return readContext(context);
	    },
	    useEffect: function(create, createDeps) {
	      currentHookNameInDev = "useEffect";
	      warnInvalidHookAccess();
	      mountHookTypesDev();
	      return mountEffect(create, createDeps);
	    },
	    useImperativeHandle: function(ref, create, deps) {
	      currentHookNameInDev = "useImperativeHandle";
	      warnInvalidHookAccess();
	      mountHookTypesDev();
	      return mountImperativeHandle(ref, create, deps);
	    },
	    useInsertionEffect: function(create, deps) {
	      currentHookNameInDev = "useInsertionEffect";
	      warnInvalidHookAccess();
	      mountHookTypesDev();
	      mountEffectImpl(4, Insertion, create, deps);
	    },
	    useLayoutEffect: function(create, deps) {
	      currentHookNameInDev = "useLayoutEffect";
	      warnInvalidHookAccess();
	      mountHookTypesDev();
	      return mountLayoutEffect(create, deps);
	    },
	    useMemo: function(create, deps) {
	      currentHookNameInDev = "useMemo";
	      warnInvalidHookAccess();
	      mountHookTypesDev();
	      var prevDispatcher = ReactSharedInternals.H;
	      ReactSharedInternals.H = InvalidNestedHooksDispatcherOnMountInDEV;
	      try {
	        return mountMemo(create, deps);
	      } finally {
	        ReactSharedInternals.H = prevDispatcher;
	      }
	    },
	    useReducer: function(reducer, initialArg, init) {
	      currentHookNameInDev = "useReducer";
	      warnInvalidHookAccess();
	      mountHookTypesDev();
	      var prevDispatcher = ReactSharedInternals.H;
	      ReactSharedInternals.H = InvalidNestedHooksDispatcherOnMountInDEV;
	      try {
	        return mountReducer(reducer, initialArg, init);
	      } finally {
	        ReactSharedInternals.H = prevDispatcher;
	      }
	    },
	    useRef: function(initialValue) {
	      currentHookNameInDev = "useRef";
	      warnInvalidHookAccess();
	      mountHookTypesDev();
	      return mountRef(initialValue);
	    },
	    useState: function(initialState) {
	      currentHookNameInDev = "useState";
	      warnInvalidHookAccess();
	      mountHookTypesDev();
	      var prevDispatcher = ReactSharedInternals.H;
	      ReactSharedInternals.H = InvalidNestedHooksDispatcherOnMountInDEV;
	      try {
	        return mountState(initialState);
	      } finally {
	        ReactSharedInternals.H = prevDispatcher;
	      }
	    },
	    useDebugValue: function() {
	      currentHookNameInDev = "useDebugValue";
	      warnInvalidHookAccess();
	      mountHookTypesDev();
	    },
	    useDeferredValue: function(value, initialValue) {
	      currentHookNameInDev = "useDeferredValue";
	      warnInvalidHookAccess();
	      mountHookTypesDev();
	      return mountDeferredValue(value, initialValue);
	    },
	    useTransition: function() {
	      currentHookNameInDev = "useTransition";
	      warnInvalidHookAccess();
	      mountHookTypesDev();
	      return mountTransition();
	    },
	    useSyncExternalStore: function(subscribe, getSnapshot, getServerSnapshot) {
	      currentHookNameInDev = "useSyncExternalStore";
	      warnInvalidHookAccess();
	      mountHookTypesDev();
	      return mountSyncExternalStore(
	        subscribe,
	        getSnapshot,
	        getServerSnapshot
	      );
	    },
	    useId: function() {
	      currentHookNameInDev = "useId";
	      warnInvalidHookAccess();
	      mountHookTypesDev();
	      return mountId();
	    },
	    useFormState: function(action, initialState) {
	      currentHookNameInDev = "useFormState";
	      warnInvalidHookAccess();
	      mountHookTypesDev();
	      return mountActionState(action, initialState);
	    },
	    useActionState: function(action, initialState) {
	      currentHookNameInDev = "useActionState";
	      warnInvalidHookAccess();
	      mountHookTypesDev();
	      return mountActionState(action, initialState);
	    },
	    useOptimistic: function(passthrough) {
	      currentHookNameInDev = "useOptimistic";
	      warnInvalidHookAccess();
	      mountHookTypesDev();
	      return mountOptimistic(passthrough);
	    },
	    useMemoCache: function(size) {
	      warnInvalidHookAccess();
	      return useMemoCache(size);
	    },
	    useHostTransitionStatus,
	    useCacheRefresh: function() {
	      currentHookNameInDev = "useCacheRefresh";
	      mountHookTypesDev();
	      return mountRefresh();
	    }
	  };
	  InvalidNestedHooksDispatcherOnUpdateInDEV = {
	    readContext: function(context) {
	      warnInvalidContextAccess();
	      return readContext(context);
	    },
	    use: function(usable) {
	      warnInvalidHookAccess();
	      return use(usable);
	    },
	    useCallback: function(callback, deps) {
	      currentHookNameInDev = "useCallback";
	      warnInvalidHookAccess();
	      updateHookTypesDev();
	      return updateCallback(callback, deps);
	    },
	    useContext: function(context) {
	      currentHookNameInDev = "useContext";
	      warnInvalidHookAccess();
	      updateHookTypesDev();
	      return readContext(context);
	    },
	    useEffect: function(create, createDeps) {
	      currentHookNameInDev = "useEffect";
	      warnInvalidHookAccess();
	      updateHookTypesDev();
	      updateEffectImpl(2048, Passive, create, createDeps);
	    },
	    useImperativeHandle: function(ref, create, deps) {
	      currentHookNameInDev = "useImperativeHandle";
	      warnInvalidHookAccess();
	      updateHookTypesDev();
	      return updateImperativeHandle(ref, create, deps);
	    },
	    useInsertionEffect: function(create, deps) {
	      currentHookNameInDev = "useInsertionEffect";
	      warnInvalidHookAccess();
	      updateHookTypesDev();
	      return updateEffectImpl(4, Insertion, create, deps);
	    },
	    useLayoutEffect: function(create, deps) {
	      currentHookNameInDev = "useLayoutEffect";
	      warnInvalidHookAccess();
	      updateHookTypesDev();
	      return updateEffectImpl(4, Layout, create, deps);
	    },
	    useMemo: function(create, deps) {
	      currentHookNameInDev = "useMemo";
	      warnInvalidHookAccess();
	      updateHookTypesDev();
	      var prevDispatcher = ReactSharedInternals.H;
	      ReactSharedInternals.H = InvalidNestedHooksDispatcherOnUpdateInDEV;
	      try {
	        return updateMemo(create, deps);
	      } finally {
	        ReactSharedInternals.H = prevDispatcher;
	      }
	    },
	    useReducer: function(reducer, initialArg, init) {
	      currentHookNameInDev = "useReducer";
	      warnInvalidHookAccess();
	      updateHookTypesDev();
	      var prevDispatcher = ReactSharedInternals.H;
	      ReactSharedInternals.H = InvalidNestedHooksDispatcherOnUpdateInDEV;
	      try {
	        return updateReducer(reducer, initialArg, init);
	      } finally {
	        ReactSharedInternals.H = prevDispatcher;
	      }
	    },
	    useRef: function() {
	      currentHookNameInDev = "useRef";
	      warnInvalidHookAccess();
	      updateHookTypesDev();
	      return updateWorkInProgressHook().memoizedState;
	    },
	    useState: function() {
	      currentHookNameInDev = "useState";
	      warnInvalidHookAccess();
	      updateHookTypesDev();
	      var prevDispatcher = ReactSharedInternals.H;
	      ReactSharedInternals.H = InvalidNestedHooksDispatcherOnUpdateInDEV;
	      try {
	        return updateReducer(basicStateReducer);
	      } finally {
	        ReactSharedInternals.H = prevDispatcher;
	      }
	    },
	    useDebugValue: function() {
	      currentHookNameInDev = "useDebugValue";
	      warnInvalidHookAccess();
	      updateHookTypesDev();
	    },
	    useDeferredValue: function(value, initialValue) {
	      currentHookNameInDev = "useDeferredValue";
	      warnInvalidHookAccess();
	      updateHookTypesDev();
	      return updateDeferredValue(value, initialValue);
	    },
	    useTransition: function() {
	      currentHookNameInDev = "useTransition";
	      warnInvalidHookAccess();
	      updateHookTypesDev();
	      return updateTransition();
	    },
	    useSyncExternalStore: function(subscribe, getSnapshot, getServerSnapshot) {
	      currentHookNameInDev = "useSyncExternalStore";
	      warnInvalidHookAccess();
	      updateHookTypesDev();
	      return updateSyncExternalStore(
	        subscribe,
	        getSnapshot,
	        getServerSnapshot
	      );
	    },
	    useId: function() {
	      currentHookNameInDev = "useId";
	      warnInvalidHookAccess();
	      updateHookTypesDev();
	      return updateWorkInProgressHook().memoizedState;
	    },
	    useFormState: function(action) {
	      currentHookNameInDev = "useFormState";
	      warnInvalidHookAccess();
	      updateHookTypesDev();
	      return updateActionState(action);
	    },
	    useActionState: function(action) {
	      currentHookNameInDev = "useActionState";
	      warnInvalidHookAccess();
	      updateHookTypesDev();
	      return updateActionState(action);
	    },
	    useOptimistic: function(passthrough, reducer) {
	      currentHookNameInDev = "useOptimistic";
	      warnInvalidHookAccess();
	      updateHookTypesDev();
	      return updateOptimistic(passthrough, reducer);
	    },
	    useMemoCache: function(size) {
	      warnInvalidHookAccess();
	      return useMemoCache(size);
	    },
	    useHostTransitionStatus,
	    useCacheRefresh: function() {
	      currentHookNameInDev = "useCacheRefresh";
	      updateHookTypesDev();
	      return updateWorkInProgressHook().memoizedState;
	    }
	  };
	  InvalidNestedHooksDispatcherOnRerenderInDEV = {
	    readContext: function(context) {
	      warnInvalidContextAccess();
	      return readContext(context);
	    },
	    use: function(usable) {
	      warnInvalidHookAccess();
	      return use(usable);
	    },
	    useCallback: function(callback, deps) {
	      currentHookNameInDev = "useCallback";
	      warnInvalidHookAccess();
	      updateHookTypesDev();
	      return updateCallback(callback, deps);
	    },
	    useContext: function(context) {
	      currentHookNameInDev = "useContext";
	      warnInvalidHookAccess();
	      updateHookTypesDev();
	      return readContext(context);
	    },
	    useEffect: function(create, createDeps) {
	      currentHookNameInDev = "useEffect";
	      warnInvalidHookAccess();
	      updateHookTypesDev();
	      updateEffectImpl(2048, Passive, create, createDeps);
	    },
	    useImperativeHandle: function(ref, create, deps) {
	      currentHookNameInDev = "useImperativeHandle";
	      warnInvalidHookAccess();
	      updateHookTypesDev();
	      return updateImperativeHandle(ref, create, deps);
	    },
	    useInsertionEffect: function(create, deps) {
	      currentHookNameInDev = "useInsertionEffect";
	      warnInvalidHookAccess();
	      updateHookTypesDev();
	      return updateEffectImpl(4, Insertion, create, deps);
	    },
	    useLayoutEffect: function(create, deps) {
	      currentHookNameInDev = "useLayoutEffect";
	      warnInvalidHookAccess();
	      updateHookTypesDev();
	      return updateEffectImpl(4, Layout, create, deps);
	    },
	    useMemo: function(create, deps) {
	      currentHookNameInDev = "useMemo";
	      warnInvalidHookAccess();
	      updateHookTypesDev();
	      var prevDispatcher = ReactSharedInternals.H;
	      ReactSharedInternals.H = InvalidNestedHooksDispatcherOnUpdateInDEV;
	      try {
	        return updateMemo(create, deps);
	      } finally {
	        ReactSharedInternals.H = prevDispatcher;
	      }
	    },
	    useReducer: function(reducer, initialArg, init) {
	      currentHookNameInDev = "useReducer";
	      warnInvalidHookAccess();
	      updateHookTypesDev();
	      var prevDispatcher = ReactSharedInternals.H;
	      ReactSharedInternals.H = InvalidNestedHooksDispatcherOnUpdateInDEV;
	      try {
	        return rerenderReducer(reducer, initialArg, init);
	      } finally {
	        ReactSharedInternals.H = prevDispatcher;
	      }
	    },
	    useRef: function() {
	      currentHookNameInDev = "useRef";
	      warnInvalidHookAccess();
	      updateHookTypesDev();
	      return updateWorkInProgressHook().memoizedState;
	    },
	    useState: function() {
	      currentHookNameInDev = "useState";
	      warnInvalidHookAccess();
	      updateHookTypesDev();
	      var prevDispatcher = ReactSharedInternals.H;
	      ReactSharedInternals.H = InvalidNestedHooksDispatcherOnUpdateInDEV;
	      try {
	        return rerenderReducer(basicStateReducer);
	      } finally {
	        ReactSharedInternals.H = prevDispatcher;
	      }
	    },
	    useDebugValue: function() {
	      currentHookNameInDev = "useDebugValue";
	      warnInvalidHookAccess();
	      updateHookTypesDev();
	    },
	    useDeferredValue: function(value, initialValue) {
	      currentHookNameInDev = "useDeferredValue";
	      warnInvalidHookAccess();
	      updateHookTypesDev();
	      return rerenderDeferredValue(value, initialValue);
	    },
	    useTransition: function() {
	      currentHookNameInDev = "useTransition";
	      warnInvalidHookAccess();
	      updateHookTypesDev();
	      return rerenderTransition();
	    },
	    useSyncExternalStore: function(subscribe, getSnapshot, getServerSnapshot) {
	      currentHookNameInDev = "useSyncExternalStore";
	      warnInvalidHookAccess();
	      updateHookTypesDev();
	      return updateSyncExternalStore(
	        subscribe,
	        getSnapshot,
	        getServerSnapshot
	      );
	    },
	    useId: function() {
	      currentHookNameInDev = "useId";
	      warnInvalidHookAccess();
	      updateHookTypesDev();
	      return updateWorkInProgressHook().memoizedState;
	    },
	    useFormState: function(action) {
	      currentHookNameInDev = "useFormState";
	      warnInvalidHookAccess();
	      updateHookTypesDev();
	      return rerenderActionState(action);
	    },
	    useActionState: function(action) {
	      currentHookNameInDev = "useActionState";
	      warnInvalidHookAccess();
	      updateHookTypesDev();
	      return rerenderActionState(action);
	    },
	    useOptimistic: function(passthrough, reducer) {
	      currentHookNameInDev = "useOptimistic";
	      warnInvalidHookAccess();
	      updateHookTypesDev();
	      return rerenderOptimistic(passthrough, reducer);
	    },
	    useMemoCache: function(size) {
	      warnInvalidHookAccess();
	      return useMemoCache(size);
	    },
	    useHostTransitionStatus,
	    useCacheRefresh: function() {
	      currentHookNameInDev = "useCacheRefresh";
	      updateHookTypesDev();
	      return updateWorkInProgressHook().memoizedState;
	    }
	  };
	  var callComponent = {
	    react_stack_bottom_frame: function(Component, props, secondArg) {
	      var wasRendering = isRendering;
	      isRendering = true;
	      try {
	        return Component(props, secondArg);
	      } finally {
	        isRendering = wasRendering;
	      }
	    }
	  }, callComponentInDEV = callComponent.react_stack_bottom_frame.bind(callComponent), callRender = {
	    react_stack_bottom_frame: function(instance) {
	      var wasRendering = isRendering;
	      isRendering = true;
	      try {
	        return instance.render();
	      } finally {
	        isRendering = wasRendering;
	      }
	    }
	  }, callRenderInDEV = callRender.react_stack_bottom_frame.bind(callRender), callComponentDidMount = {
	    react_stack_bottom_frame: function(finishedWork, instance) {
	      try {
	        instance.componentDidMount();
	      } catch (error) {
	        captureCommitPhaseError(finishedWork, finishedWork.return, error);
	      }
	    }
	  }, callComponentDidMountInDEV = callComponentDidMount.react_stack_bottom_frame.bind(
	    callComponentDidMount
	  ), callComponentDidUpdate = {
	    react_stack_bottom_frame: function(finishedWork, instance, prevProps, prevState, snapshot) {
	      try {
	        instance.componentDidUpdate(prevProps, prevState, snapshot);
	      } catch (error) {
	        captureCommitPhaseError(finishedWork, finishedWork.return, error);
	      }
	    }
	  }, callComponentDidUpdateInDEV = callComponentDidUpdate.react_stack_bottom_frame.bind(
	    callComponentDidUpdate
	  ), callComponentDidCatch = {
	    react_stack_bottom_frame: function(instance, errorInfo) {
	      var stack = errorInfo.stack;
	      instance.componentDidCatch(errorInfo.value, {
	        componentStack: null !== stack ? stack : ""
	      });
	    }
	  }, callComponentDidCatchInDEV = callComponentDidCatch.react_stack_bottom_frame.bind(
	    callComponentDidCatch
	  ), callComponentWillUnmount = {
	    react_stack_bottom_frame: function(current2, nearestMountedAncestor, instance) {
	      try {
	        instance.componentWillUnmount();
	      } catch (error) {
	        captureCommitPhaseError(current2, nearestMountedAncestor, error);
	      }
	    }
	  }, callComponentWillUnmountInDEV = callComponentWillUnmount.react_stack_bottom_frame.bind(
	    callComponentWillUnmount
	  ), callCreate = {
	    react_stack_bottom_frame: function(effect) {
	      null != effect.resourceKind && console.error(
	        "Expected only SimpleEffects when enableUseEffectCRUDOverload is disabled, got %s",
	        effect.resourceKind
	      );
	      var create = effect.create;
	      effect = effect.inst;
	      create = create();
	      return effect.destroy = create;
	    }
	  }, callCreateInDEV = callCreate.react_stack_bottom_frame.bind(callCreate), callDestroy = {
	    react_stack_bottom_frame: function(current2, nearestMountedAncestor, destroy) {
	      try {
	        destroy();
	      } catch (error) {
	        captureCommitPhaseError(current2, nearestMountedAncestor, error);
	      }
	    }
	  }, callDestroyInDEV = callDestroy.react_stack_bottom_frame.bind(callDestroy), callLazyInit = {
	    react_stack_bottom_frame: function(lazy) {
	      var init = lazy._init;
	      return init(lazy._payload);
	    }
	  }, callLazyInitInDEV = callLazyInit.react_stack_bottom_frame.bind(callLazyInit), thenableState = null, thenableIndexCounter = 0, currentDebugInfo = null, didWarnAboutMaps;
	  var didWarnAboutGenerators = didWarnAboutMaps = false;
	  var ownerHasKeyUseWarning = {};
	  var ownerHasFunctionTypeWarning = {};
	  var ownerHasSymbolTypeWarning = {};
	  warnForMissingKey = function(returnFiber, workInProgress2, child) {
	    if (null !== child && "object" === typeof child && child._store && (!child._store.validated && null == child.key || 2 === child._store.validated)) {
	      if ("object" !== typeof child._store)
	        throw Error(
	          "React Component in warnForMissingKey should have a _store. This error is likely caused by a bug in React. Please file an issue."
	        );
	      child._store.validated = 1;
	      var componentName2 = getComponentNameFromFiber(returnFiber), componentKey = componentName2 || "null";
	      if (!ownerHasKeyUseWarning[componentKey]) {
	        ownerHasKeyUseWarning[componentKey] = true;
	        child = child._owner;
	        returnFiber = returnFiber._debugOwner;
	        var currentComponentErrorInfo = "";
	        returnFiber && "number" === typeof returnFiber.tag && (componentKey = getComponentNameFromFiber(returnFiber)) && (currentComponentErrorInfo = "\n\nCheck the render method of `" + componentKey + "`.");
	        currentComponentErrorInfo || componentName2 && (currentComponentErrorInfo = "\n\nCheck the top-level render call using <" + componentName2 + ">.");
	        var childOwnerAppendix = "";
	        null != child && returnFiber !== child && (componentName2 = null, "number" === typeof child.tag ? componentName2 = getComponentNameFromFiber(child) : "string" === typeof child.name && (componentName2 = child.name), componentName2 && (childOwnerAppendix = " It was passed a child from " + componentName2 + "."));
	        runWithFiberInDEV(workInProgress2, function() {
	          console.error(
	            'Each child in a list should have a unique "key" prop.%s%s See https://react.dev/link/warning-keys for more information.',
	            currentComponentErrorInfo,
	            childOwnerAppendix
	          );
	        });
	      }
	    }
	  };
	  var reconcileChildFibers = createChildReconciler(true), mountChildFibers = createChildReconciler(false), suspenseHandlerStackCursor = createCursor(null), shellBoundary = null, SubtreeSuspenseContextMask = 1, ForceSuspenseFallback = 2, suspenseStackCursor = createCursor(0), fakeInternalInstance = {};
	  var didWarnAboutStateAssignmentForComponent = /* @__PURE__ */ new Set();
	  var didWarnAboutUninitializedState = /* @__PURE__ */ new Set();
	  var didWarnAboutGetSnapshotBeforeUpdateWithoutDidUpdate = /* @__PURE__ */ new Set();
	  var didWarnAboutLegacyLifecyclesAndDerivedState = /* @__PURE__ */ new Set();
	  var didWarnAboutDirectlyAssigningPropsToState = /* @__PURE__ */ new Set();
	  var didWarnAboutUndefinedDerivedState = /* @__PURE__ */ new Set();
	  var didWarnAboutContextTypes$1 = /* @__PURE__ */ new Set();
	  var didWarnAboutChildContextTypes = /* @__PURE__ */ new Set();
	  var didWarnAboutInvalidateContextType = /* @__PURE__ */ new Set();
	  var didWarnOnInvalidCallback = /* @__PURE__ */ new Set();
	  Object.freeze(fakeInternalInstance);
	  var classComponentUpdater = {
	    enqueueSetState: function(inst, payload, callback) {
	      inst = inst._reactInternals;
	      var lane = requestUpdateLane(inst), update = createUpdate(lane);
	      update.payload = payload;
	      void 0 !== callback && null !== callback && (warnOnInvalidCallback(callback), update.callback = callback);
	      payload = enqueueUpdate(inst, update, lane);
	      null !== payload && (scheduleUpdateOnFiber(payload, inst, lane), entangleTransitions(payload, inst, lane));
	      markStateUpdateScheduled(inst, lane);
	    },
	    enqueueReplaceState: function(inst, payload, callback) {
	      inst = inst._reactInternals;
	      var lane = requestUpdateLane(inst), update = createUpdate(lane);
	      update.tag = ReplaceState;
	      update.payload = payload;
	      void 0 !== callback && null !== callback && (warnOnInvalidCallback(callback), update.callback = callback);
	      payload = enqueueUpdate(inst, update, lane);
	      null !== payload && (scheduleUpdateOnFiber(payload, inst, lane), entangleTransitions(payload, inst, lane));
	      markStateUpdateScheduled(inst, lane);
	    },
	    enqueueForceUpdate: function(inst, callback) {
	      inst = inst._reactInternals;
	      var lane = requestUpdateLane(inst), update = createUpdate(lane);
	      update.tag = ForceUpdate;
	      void 0 !== callback && null !== callback && (warnOnInvalidCallback(callback), update.callback = callback);
	      callback = enqueueUpdate(inst, update, lane);
	      null !== callback && (scheduleUpdateOnFiber(callback, inst, lane), entangleTransitions(callback, inst, lane));
	      null !== injectedProfilingHooks && "function" === typeof injectedProfilingHooks.markForceUpdateScheduled && injectedProfilingHooks.markForceUpdateScheduled(inst, lane);
	    }
	  }, reportGlobalError = "function" === typeof reportError ? reportError : function(error) {
	    if ("object" === typeof window && "function" === typeof window.ErrorEvent) {
	      var event = new window.ErrorEvent("error", {
	        bubbles: true,
	        cancelable: true,
	        message: "object" === typeof error && null !== error && "string" === typeof error.message ? String(error.message) : String(error),
	        error
	      });
	      if (!window.dispatchEvent(event)) return;
	    } else if ("object" === typeof process && "function" === typeof process.emit) {
	      process.emit("uncaughtException", error);
	      return;
	    }
	    console.error(error);
	  }, componentName = null, errorBoundaryName = null, SelectiveHydrationException = Error(
	    "This is not a real error. It's an implementation detail of React's selective hydration feature. If this leaks into userspace, it's a bug in React. Please file an issue."
	  ), didReceiveUpdate = false;
	  var didWarnAboutBadClass = {};
	  var didWarnAboutContextTypeOnFunctionComponent = {};
	  var didWarnAboutContextTypes = {};
	  var didWarnAboutGetDerivedStateOnFunctionComponent = {};
	  var didWarnAboutReassigningProps = false;
	  var didWarnAboutRevealOrder = {};
	  var didWarnAboutTailOptions = {};
	  var SUSPENDED_MARKER = {
	    dehydrated: null,
	    treeContext: null,
	    retryLane: 0,
	    hydrationErrors: null
	  }, hasWarnedAboutUsingNoValuePropOnContextProvider = false, didWarnAboutUndefinedSnapshotBeforeUpdate = null;
	  didWarnAboutUndefinedSnapshotBeforeUpdate = /* @__PURE__ */ new Set();
	  var offscreenSubtreeIsHidden = false, offscreenSubtreeWasHidden = false, needsFormReset = false, PossiblyWeakSet = "function" === typeof WeakSet ? WeakSet : Set, nextEffect = null, inProgressLanes = null, inProgressRoot = null, hostParent = null, hostParentIsContainer = false, currentHoistableRoot = null, suspenseyCommitFlag = 8192, DefaultAsyncDispatcher = {
	    getCacheForType: function(resourceType) {
	      var cache = readContext(CacheContext), cacheForType = cache.data.get(resourceType);
	      void 0 === cacheForType && (cacheForType = resourceType(), cache.data.set(resourceType, cacheForType));
	      return cacheForType;
	    },
	    getOwner: function() {
	      return current;
	    }
	  };
	  if ("function" === typeof Symbol && Symbol.for) {
	    var symbolFor = Symbol.for;
	    symbolFor("selector.component");
	    symbolFor("selector.has_pseudo_class");
	    symbolFor("selector.role");
	    symbolFor("selector.test_id");
	    symbolFor("selector.text");
	  }
	  var commitHooks = [], PossiblyWeakMap = "function" === typeof WeakMap ? WeakMap : Map, NoContext = 0, RenderContext = 2, CommitContext = 4, RootInProgress = 0, RootFatalErrored = 1, RootErrored = 2, RootSuspended = 3, RootSuspendedWithDelay = 4, RootSuspendedAtTheShell = 6, RootCompleted = 5, executionContext = NoContext, workInProgressRoot = null, workInProgress = null, workInProgressRootRenderLanes = 0, NotSuspended = 0, SuspendedOnError = 1, SuspendedOnData = 2, SuspendedOnImmediate = 3, SuspendedOnInstance = 4, SuspendedOnInstanceAndReadyToContinue = 5, SuspendedOnDeprecatedThrowPromise = 6, SuspendedAndReadyToContinue = 7, SuspendedOnHydration = 8, SuspendedOnAction = 9, workInProgressSuspendedReason = NotSuspended, workInProgressThrownValue = null, workInProgressRootDidSkipSuspendedSiblings = false, workInProgressRootIsPrerendering = false, workInProgressRootDidAttachPingListener = false, entangledRenderLanes = 0, workInProgressRootExitStatus = RootInProgress, workInProgressRootSkippedLanes = 0, workInProgressRootInterleavedUpdatedLanes = 0, workInProgressRootPingedLanes = 0, workInProgressDeferredLane = 0, workInProgressSuspendedRetryLanes = 0, workInProgressRootConcurrentErrors = null, workInProgressRootRecoverableErrors = null, workInProgressRootDidIncludeRecursiveRenderUpdate = false, globalMostRecentFallbackTime = 0, FALLBACK_THROTTLE_MS = 300, workInProgressRootRenderTargetTime = Infinity, RENDER_TIMEOUT_MS = 500, workInProgressTransitions = null, legacyErrorBoundariesThatAlreadyFailed = null, IMMEDIATE_COMMIT = 0, SUSPENDED_COMMIT = 1, THROTTLED_COMMIT = 2, NO_PENDING_EFFECTS = 0, PENDING_MUTATION_PHASE = 1, PENDING_LAYOUT_PHASE = 2, PENDING_AFTER_MUTATION_PHASE = 3, PENDING_SPAWNED_WORK = 4, PENDING_PASSIVE_PHASE = 5, pendingEffectsStatus = 0, pendingEffectsRoot = null, pendingFinishedWork = null, pendingEffectsLanes = 0, pendingEffectsRemainingLanes = 0, pendingPassiveTransitions = null, pendingRecoverableErrors = null, NESTED_UPDATE_LIMIT = 50, nestedUpdateCount = 0, rootWithNestedUpdates = null, isFlushingPassiveEffects = false, didScheduleUpdateDuringPassiveEffects = false, NESTED_PASSIVE_UPDATE_LIMIT = 50, nestedPassiveUpdateCount = 0, rootWithPassiveNestedUpdates = null, isRunningInsertionEffect = false, didWarnStateUpdateForNotYetMountedComponent = null, didWarnAboutUpdateInRender = false;
	  var didWarnAboutUpdateInRenderForAnotherComponent = /* @__PURE__ */ new Set();
	  var fakeActCallbackNode$1 = {}, firstScheduledRoot = null, lastScheduledRoot = null, didScheduleMicrotask = false, didScheduleMicrotask_act = false, mightHavePendingSyncWork = false, isFlushingWork = false, currentEventTransitionLane = 0, fakeActCallbackNode = {};
	  (function() {
	    for (var i = 0; i < simpleEventPluginEvents.length; i++) {
	      var eventName = simpleEventPluginEvents[i], domEventName = eventName.toLowerCase();
	      eventName = eventName[0].toUpperCase() + eventName.slice(1);
	      registerSimpleEvent(domEventName, "on" + eventName);
	    }
	    registerSimpleEvent(ANIMATION_END, "onAnimationEnd");
	    registerSimpleEvent(ANIMATION_ITERATION, "onAnimationIteration");
	    registerSimpleEvent(ANIMATION_START, "onAnimationStart");
	    registerSimpleEvent("dblclick", "onDoubleClick");
	    registerSimpleEvent("focusin", "onFocus");
	    registerSimpleEvent("focusout", "onBlur");
	    registerSimpleEvent(TRANSITION_RUN, "onTransitionRun");
	    registerSimpleEvent(TRANSITION_START, "onTransitionStart");
	    registerSimpleEvent(TRANSITION_CANCEL, "onTransitionCancel");
	    registerSimpleEvent(TRANSITION_END, "onTransitionEnd");
	  })();
	  registerDirectEvent("onMouseEnter", ["mouseout", "mouseover"]);
	  registerDirectEvent("onMouseLeave", ["mouseout", "mouseover"]);
	  registerDirectEvent("onPointerEnter", ["pointerout", "pointerover"]);
	  registerDirectEvent("onPointerLeave", ["pointerout", "pointerover"]);
	  registerTwoPhaseEvent(
	    "onChange",
	    "change click focusin focusout input keydown keyup selectionchange".split(
	      " "
	    )
	  );
	  registerTwoPhaseEvent(
	    "onSelect",
	    "focusout contextmenu dragend focusin keydown keyup mousedown mouseup selectionchange".split(
	      " "
	    )
	  );
	  registerTwoPhaseEvent("onBeforeInput", [
	    "compositionend",
	    "keypress",
	    "textInput",
	    "paste"
	  ]);
	  registerTwoPhaseEvent(
	    "onCompositionEnd",
	    "compositionend focusout keydown keypress keyup mousedown".split(" ")
	  );
	  registerTwoPhaseEvent(
	    "onCompositionStart",
	    "compositionstart focusout keydown keypress keyup mousedown".split(" ")
	  );
	  registerTwoPhaseEvent(
	    "onCompositionUpdate",
	    "compositionupdate focusout keydown keypress keyup mousedown".split(" ")
	  );
	  var mediaEventTypes = "abort canplay canplaythrough durationchange emptied encrypted ended error loadeddata loadedmetadata loadstart pause play playing progress ratechange resize seeked seeking stalled suspend timeupdate volumechange waiting".split(
	    " "
	  ), nonDelegatedEvents = new Set(
	    "beforetoggle cancel close invalid load scroll scrollend toggle".split(" ").concat(mediaEventTypes)
	  ), listeningMarker = "_reactListening" + Math.random().toString(36).slice(2), didWarnControlledToUncontrolled = false, didWarnUncontrolledToControlled = false, didWarnFormActionType = false, didWarnFormActionName = false, didWarnFormActionTarget = false, didWarnFormActionMethod = false, didWarnPopoverTargetObject = false;
	  var didWarnForNewBooleanPropsWithEmptyValue = {};
	  var NORMALIZE_NEWLINES_REGEX = /\r\n?/g, NORMALIZE_NULL_AND_REPLACEMENT_REGEX = /\u0000|\uFFFD/g, xlinkNamespace = "http://www.w3.org/1999/xlink", xmlNamespace = "http://www.w3.org/XML/1998/namespace", EXPECTED_FORM_ACTION_URL = "javascript:throw new Error('React form unexpectedly submitted.')", SUPPRESS_HYDRATION_WARNING = "suppressHydrationWarning", SUSPENSE_START_DATA = "$", SUSPENSE_END_DATA = "/$", SUSPENSE_PENDING_START_DATA = "$?", SUSPENSE_FALLBACK_START_DATA = "$!", PREAMBLE_CONTRIBUTION_HTML = 1, PREAMBLE_CONTRIBUTION_BODY = 2, PREAMBLE_CONTRIBUTION_HEAD = 4, FORM_STATE_IS_MATCHING = "F!", FORM_STATE_IS_NOT_MATCHING = "F", DOCUMENT_READY_STATE_COMPLETE = "complete", STYLE = "style", HostContextNamespaceNone = 0, HostContextNamespaceSvg = 1, HostContextNamespaceMath = 2, eventsEnabled = null, selectionInformation = null, warnedUnknownTags = { dialog: true, webview: true }, currentPopstateTransitionEvent = null, scheduleTimeout = "function" === typeof setTimeout ? setTimeout : void 0, cancelTimeout = "function" === typeof clearTimeout ? clearTimeout : void 0, noTimeout = -1, localPromise = "function" === typeof Promise ? Promise : void 0, scheduleMicrotask = "function" === typeof queueMicrotask ? queueMicrotask : "undefined" !== typeof localPromise ? function(callback) {
	    return localPromise.resolve(null).then(callback).catch(handleErrorInNextTick);
	  } : scheduleTimeout, previousHydratableOnEnteringScopedSingleton = null, NotLoaded = 0, Loaded = 1, Errored = 2, Settled = 3, Inserted = 4, preloadPropsMap = /* @__PURE__ */ new Map(), preconnectsSet = /* @__PURE__ */ new Set(), previousDispatcher = ReactDOMSharedInternals.d;
	  ReactDOMSharedInternals.d = {
	    f: function() {
	      var previousWasRendering = previousDispatcher.f(), wasRendering = flushSyncWork$1();
	      return previousWasRendering || wasRendering;
	    },
	    r: function(form) {
	      var formInst = getInstanceFromNode(form);
	      null !== formInst && 5 === formInst.tag && "form" === formInst.type ? requestFormReset$1(formInst) : previousDispatcher.r(form);
	    },
	    D: function(href) {
	      previousDispatcher.D(href);
	      preconnectAs("dns-prefetch", href, null);
	    },
	    C: function(href, crossOrigin) {
	      previousDispatcher.C(href, crossOrigin);
	      preconnectAs("preconnect", href, crossOrigin);
	    },
	    L: function(href, as, options) {
	      previousDispatcher.L(href, as, options);
	      var ownerDocument = globalDocument;
	      if (ownerDocument && href && as) {
	        var preloadSelector = 'link[rel="preload"][as="' + escapeSelectorAttributeValueInsideDoubleQuotes(as) + '"]';
	        "image" === as ? options && options.imageSrcSet ? (preloadSelector += '[imagesrcset="' + escapeSelectorAttributeValueInsideDoubleQuotes(
	          options.imageSrcSet
	        ) + '"]', "string" === typeof options.imageSizes && (preloadSelector += '[imagesizes="' + escapeSelectorAttributeValueInsideDoubleQuotes(
	          options.imageSizes
	        ) + '"]')) : preloadSelector += '[href="' + escapeSelectorAttributeValueInsideDoubleQuotes(href) + '"]' : preloadSelector += '[href="' + escapeSelectorAttributeValueInsideDoubleQuotes(href) + '"]';
	        var key = preloadSelector;
	        switch (as) {
	          case "style":
	            key = getStyleKey(href);
	            break;
	          case "script":
	            key = getScriptKey(href);
	        }
	        preloadPropsMap.has(key) || (href = assign(
	          {
	            rel: "preload",
	            href: "image" === as && options && options.imageSrcSet ? void 0 : href,
	            as
	          },
	          options
	        ), preloadPropsMap.set(key, href), null !== ownerDocument.querySelector(preloadSelector) || "style" === as && ownerDocument.querySelector(
	          getStylesheetSelectorFromKey(key)
	        ) || "script" === as && ownerDocument.querySelector(getScriptSelectorFromKey(key)) || (as = ownerDocument.createElement("link"), setInitialProperties(as, "link", href), markNodeAsHoistable(as), ownerDocument.head.appendChild(as)));
	      }
	    },
	    m: function(href, options) {
	      previousDispatcher.m(href, options);
	      var ownerDocument = globalDocument;
	      if (ownerDocument && href) {
	        var as = options && "string" === typeof options.as ? options.as : "script", preloadSelector = 'link[rel="modulepreload"][as="' + escapeSelectorAttributeValueInsideDoubleQuotes(as) + '"][href="' + escapeSelectorAttributeValueInsideDoubleQuotes(href) + '"]', key = preloadSelector;
	        switch (as) {
	          case "audioworklet":
	          case "paintworklet":
	          case "serviceworker":
	          case "sharedworker":
	          case "worker":
	          case "script":
	            key = getScriptKey(href);
	        }
	        if (!preloadPropsMap.has(key) && (href = assign({ rel: "modulepreload", href }, options), preloadPropsMap.set(key, href), null === ownerDocument.querySelector(preloadSelector))) {
	          switch (as) {
	            case "audioworklet":
	            case "paintworklet":
	            case "serviceworker":
	            case "sharedworker":
	            case "worker":
	            case "script":
	              if (ownerDocument.querySelector(getScriptSelectorFromKey(key)))
	                return;
	          }
	          as = ownerDocument.createElement("link");
	          setInitialProperties(as, "link", href);
	          markNodeAsHoistable(as);
	          ownerDocument.head.appendChild(as);
	        }
	      }
	    },
	    X: function(src, options) {
	      previousDispatcher.X(src, options);
	      var ownerDocument = globalDocument;
	      if (ownerDocument && src) {
	        var scripts = getResourcesFromRoot(ownerDocument).hoistableScripts, key = getScriptKey(src), resource = scripts.get(key);
	        resource || (resource = ownerDocument.querySelector(
	          getScriptSelectorFromKey(key)
	        ), resource || (src = assign({ src, async: true }, options), (options = preloadPropsMap.get(key)) && adoptPreloadPropsForScript(src, options), resource = ownerDocument.createElement("script"), markNodeAsHoistable(resource), setInitialProperties(resource, "link", src), ownerDocument.head.appendChild(resource)), resource = {
	          type: "script",
	          instance: resource,
	          count: 1,
	          state: null
	        }, scripts.set(key, resource));
	      }
	    },
	    S: function(href, precedence, options) {
	      previousDispatcher.S(href, precedence, options);
	      var ownerDocument = globalDocument;
	      if (ownerDocument && href) {
	        var styles = getResourcesFromRoot(ownerDocument).hoistableStyles, key = getStyleKey(href);
	        precedence = precedence || "default";
	        var resource = styles.get(key);
	        if (!resource) {
	          var state = { loading: NotLoaded, preload: null };
	          if (resource = ownerDocument.querySelector(
	            getStylesheetSelectorFromKey(key)
	          ))
	            state.loading = Loaded | Inserted;
	          else {
	            href = assign(
	              {
	                rel: "stylesheet",
	                href,
	                "data-precedence": precedence
	              },
	              options
	            );
	            (options = preloadPropsMap.get(key)) && adoptPreloadPropsForStylesheet(href, options);
	            var link = resource = ownerDocument.createElement("link");
	            markNodeAsHoistable(link);
	            setInitialProperties(link, "link", href);
	            link._p = new Promise(function(resolve, reject) {
	              link.onload = resolve;
	              link.onerror = reject;
	            });
	            link.addEventListener("load", function() {
	              state.loading |= Loaded;
	            });
	            link.addEventListener("error", function() {
	              state.loading |= Errored;
	            });
	            state.loading |= Inserted;
	            insertStylesheet(resource, precedence, ownerDocument);
	          }
	          resource = {
	            type: "stylesheet",
	            instance: resource,
	            count: 1,
	            state
	          };
	          styles.set(key, resource);
	        }
	      }
	    },
	    M: function(src, options) {
	      previousDispatcher.M(src, options);
	      var ownerDocument = globalDocument;
	      if (ownerDocument && src) {
	        var scripts = getResourcesFromRoot(ownerDocument).hoistableScripts, key = getScriptKey(src), resource = scripts.get(key);
	        resource || (resource = ownerDocument.querySelector(
	          getScriptSelectorFromKey(key)
	        ), resource || (src = assign({ src, async: true, type: "module" }, options), (options = preloadPropsMap.get(key)) && adoptPreloadPropsForScript(src, options), resource = ownerDocument.createElement("script"), markNodeAsHoistable(resource), setInitialProperties(resource, "link", src), ownerDocument.head.appendChild(resource)), resource = {
	          type: "script",
	          instance: resource,
	          count: 1,
	          state: null
	        }, scripts.set(key, resource));
	      }
	    }
	  };
	  var globalDocument = "undefined" === typeof document ? null : document, tagCaches = null, suspendedState = null, LAST_PRECEDENCE = null, precedencesByRoot = null, NotPendingTransition = NotPending, HostTransitionContext = {
	    $$typeof: REACT_CONTEXT_TYPE,
	    Provider: null,
	    Consumer: null,
	    _currentValue: NotPendingTransition,
	    _currentValue2: NotPendingTransition,
	    _threadCount: 0
	  }, badgeFormat = "%c%s%c ", badgeStyle = "background: #e6e6e6;background: light-dark(rgba(0,0,0,0.1), rgba(255,255,255,0.25));color: #000000;color: light-dark(#000000, #ffffff);border-radius: 2px", resetStyle = "", pad = " ", bind = Function.prototype.bind;
	  var didWarnAboutNestedUpdates = false;
	  var overrideHookState = null, overrideHookStateDeletePath = null, overrideHookStateRenamePath = null, overrideProps = null, overridePropsDeletePath = null, overridePropsRenamePath = null, scheduleUpdate = null, setErrorHandler = null, setSuspenseHandler = null;
	  overrideHookState = function(fiber, id, path, value) {
	    id = findHook(fiber, id);
	    null !== id && (path = copyWithSetImpl(id.memoizedState, path, 0, value), id.memoizedState = path, id.baseState = path, fiber.memoizedProps = assign({}, fiber.memoizedProps), path = enqueueConcurrentRenderForLane(fiber, 2), null !== path && scheduleUpdateOnFiber(path, fiber, 2));
	  };
	  overrideHookStateDeletePath = function(fiber, id, path) {
	    id = findHook(fiber, id);
	    null !== id && (path = copyWithDeleteImpl(id.memoizedState, path, 0), id.memoizedState = path, id.baseState = path, fiber.memoizedProps = assign({}, fiber.memoizedProps), path = enqueueConcurrentRenderForLane(fiber, 2), null !== path && scheduleUpdateOnFiber(path, fiber, 2));
	  };
	  overrideHookStateRenamePath = function(fiber, id, oldPath, newPath) {
	    id = findHook(fiber, id);
	    null !== id && (oldPath = copyWithRename(id.memoizedState, oldPath, newPath), id.memoizedState = oldPath, id.baseState = oldPath, fiber.memoizedProps = assign({}, fiber.memoizedProps), oldPath = enqueueConcurrentRenderForLane(fiber, 2), null !== oldPath && scheduleUpdateOnFiber(oldPath, fiber, 2));
	  };
	  overrideProps = function(fiber, path, value) {
	    fiber.pendingProps = copyWithSetImpl(fiber.memoizedProps, path, 0, value);
	    fiber.alternate && (fiber.alternate.pendingProps = fiber.pendingProps);
	    path = enqueueConcurrentRenderForLane(fiber, 2);
	    null !== path && scheduleUpdateOnFiber(path, fiber, 2);
	  };
	  overridePropsDeletePath = function(fiber, path) {
	    fiber.pendingProps = copyWithDeleteImpl(fiber.memoizedProps, path, 0);
	    fiber.alternate && (fiber.alternate.pendingProps = fiber.pendingProps);
	    path = enqueueConcurrentRenderForLane(fiber, 2);
	    null !== path && scheduleUpdateOnFiber(path, fiber, 2);
	  };
	  overridePropsRenamePath = function(fiber, oldPath, newPath) {
	    fiber.pendingProps = copyWithRename(
	      fiber.memoizedProps,
	      oldPath,
	      newPath
	    );
	    fiber.alternate && (fiber.alternate.pendingProps = fiber.pendingProps);
	    oldPath = enqueueConcurrentRenderForLane(fiber, 2);
	    null !== oldPath && scheduleUpdateOnFiber(oldPath, fiber, 2);
	  };
	  scheduleUpdate = function(fiber) {
	    var root2 = enqueueConcurrentRenderForLane(fiber, 2);
	    null !== root2 && scheduleUpdateOnFiber(root2, fiber, 2);
	  };
	  setErrorHandler = function(newShouldErrorImpl) {
	    shouldErrorImpl = newShouldErrorImpl;
	  };
	  setSuspenseHandler = function(newShouldSuspendImpl) {
	    shouldSuspendImpl = newShouldSuspendImpl;
	  };
	  var _enabled = true, return_targetInst = null, hasScheduledReplayAttempt = false, queuedFocus = null, queuedDrag = null, queuedMouse = null, queuedPointers = /* @__PURE__ */ new Map(), queuedPointerCaptures = /* @__PURE__ */ new Map(), queuedExplicitHydrationTargets = [], discreteReplayableEvents = "mousedown mouseup touchcancel touchend touchstart auxclick dblclick pointercancel pointerdown pointerup dragend dragstart drop compositionend compositionstart keydown keypress keyup input textInput copy cut paste click change contextmenu reset".split(
	    " "
	  ), lastScheduledReplayQueue = null;
	  ReactDOMHydrationRoot.prototype.render = ReactDOMRoot.prototype.render = function(children) {
	    var root2 = this._internalRoot;
	    if (null === root2) throw Error("Cannot update an unmounted root.");
	    var args = arguments;
	    "function" === typeof args[1] ? console.error(
	      "does not support the second callback argument. To execute a side effect after rendering, declare it in a component body with useEffect()."
	    ) : isValidContainer(args[1]) ? console.error(
	      "You passed a container to the second argument of root.render(...). You don't need to pass it again since you already passed it to create the root."
	    ) : "undefined" !== typeof args[1] && console.error(
	      "You passed a second argument to root.render(...) but it only accepts one argument."
	    );
	    args = children;
	    var current2 = root2.current, lane = requestUpdateLane(current2);
	    updateContainerImpl(current2, lane, args, root2, null, null);
	  };
	  ReactDOMHydrationRoot.prototype.unmount = ReactDOMRoot.prototype.unmount = function() {
	    var args = arguments;
	    "function" === typeof args[0] && console.error(
	      "does not support a callback argument. To execute a side effect after rendering, declare it in a component body with useEffect()."
	    );
	    args = this._internalRoot;
	    if (null !== args) {
	      this._internalRoot = null;
	      var container = args.containerInfo;
	      (executionContext & (RenderContext | CommitContext)) !== NoContext && console.error(
	        "Attempted to synchronously unmount a root while React was already rendering. React cannot finish unmounting the root until the current render has completed, which may lead to a race condition."
	      );
	      updateContainerImpl(args.current, 2, null, args, null, null);
	      flushSyncWork$1();
	      container[internalContainerInstanceKey] = null;
	    }
	  };
	  ReactDOMHydrationRoot.prototype.unstable_scheduleHydration = function(target) {
	    if (target) {
	      var updatePriority = resolveUpdatePriority();
	      target = { blockedOn: null, target, priority: updatePriority };
	      for (var i = 0; i < queuedExplicitHydrationTargets.length && 0 !== updatePriority && updatePriority < queuedExplicitHydrationTargets[i].priority; i++) ;
	      queuedExplicitHydrationTargets.splice(i, 0, target);
	      0 === i && attemptExplicitHydrationTarget(target);
	    }
	  };
	  (function() {
	    var isomorphicReactPackageVersion = React.version;
	    if ("19.1.1" !== isomorphicReactPackageVersion)
	      throw Error(
	        'Incompatible React versions: The "react" and "react-dom" packages must have the exact same version. Instead got:\n  - react:      ' + (isomorphicReactPackageVersion + "\n  - react-dom:  19.1.1\nLearn more: https://react.dev/warnings/version-mismatch")
	      );
	  })();
	  "function" === typeof Map && null != Map.prototype && "function" === typeof Map.prototype.forEach && "function" === typeof Set && null != Set.prototype && "function" === typeof Set.prototype.clear && "function" === typeof Set.prototype.forEach || console.error(
	    "React depends on Map and Set built-in types. Make sure that you load a polyfill in older browsers. https://react.dev/link/react-polyfills"
	  );
	  ReactDOMSharedInternals.findDOMNode = function(componentOrElement) {
	    var fiber = componentOrElement._reactInternals;
	    if (void 0 === fiber) {
	      if ("function" === typeof componentOrElement.render)
	        throw Error("Unable to find node on an unmounted component.");
	      componentOrElement = Object.keys(componentOrElement).join(",");
	      throw Error(
	        "Argument appears to not be a ReactComponent. Keys: " + componentOrElement
	      );
	    }
	    componentOrElement = findCurrentFiberUsingSlowPath(fiber);
	    componentOrElement = null !== componentOrElement ? findCurrentHostFiberImpl(componentOrElement) : null;
	    componentOrElement = null === componentOrElement ? null : componentOrElement.stateNode;
	    return componentOrElement;
	  };
	  if (!(function() {
	    var internals = {
	      bundleType: 1,
	      version: "19.1.1",
	      rendererPackageName: "react-dom",
	      currentDispatcherRef: ReactSharedInternals,
	      reconcilerVersion: "19.1.1"
	    };
	    internals.overrideHookState = overrideHookState;
	    internals.overrideHookStateDeletePath = overrideHookStateDeletePath;
	    internals.overrideHookStateRenamePath = overrideHookStateRenamePath;
	    internals.overrideProps = overrideProps;
	    internals.overridePropsDeletePath = overridePropsDeletePath;
	    internals.overridePropsRenamePath = overridePropsRenamePath;
	    internals.scheduleUpdate = scheduleUpdate;
	    internals.setErrorHandler = setErrorHandler;
	    internals.setSuspenseHandler = setSuspenseHandler;
	    internals.scheduleRefresh = scheduleRefresh;
	    internals.scheduleRoot = scheduleRoot;
	    internals.setRefreshHandler = setRefreshHandler;
	    internals.getCurrentFiber = getCurrentFiberForDevTools;
	    internals.getLaneLabelMap = getLaneLabelMap;
	    internals.injectProfilingHooks = injectProfilingHooks;
	    return injectInternals(internals);
	  })() && canUseDOM && window.top === window.self && (-1 < navigator.userAgent.indexOf("Chrome") && -1 === navigator.userAgent.indexOf("Edge") || -1 < navigator.userAgent.indexOf("Firefox"))) {
	    var protocol = window.location.protocol;
	    /^(https?|file):$/.test(protocol) && console.info(
	      "%cDownload the React DevTools for a better development experience: https://react.dev/link/react-devtools" + ("file:" === protocol ? "\nYou might need to use a local HTTP server (instead of file://): https://react.dev/link/react-devtools-faq" : ""),
	      "font-weight:bold"
	    );
	  }
	  reactDomClient_development.createRoot = function(container, options) {
	    if (!isValidContainer(container))
	      throw Error("Target container is not a DOM element.");
	    warnIfReactDOMContainerInDEV(container);
	    var isStrictMode = false, identifierPrefix = "", onUncaughtError = defaultOnUncaughtError, onCaughtError = defaultOnCaughtError, onRecoverableError = defaultOnRecoverableError, transitionCallbacks = null;
	    null !== options && void 0 !== options && (options.hydrate ? console.warn(
	      "hydrate through createRoot is deprecated. Use ReactDOMClient.hydrateRoot(container, <App />) instead."
	    ) : "object" === typeof options && null !== options && options.$$typeof === REACT_ELEMENT_TYPE && console.error(
	      "You passed a JSX element to createRoot. You probably meant to call root.render instead. Example usage:\n\n  let root = createRoot(domContainer);\n  root.render(<App />);"
	    ), true === options.unstable_strictMode && (isStrictMode = true), void 0 !== options.identifierPrefix && (identifierPrefix = options.identifierPrefix), void 0 !== options.onUncaughtError && (onUncaughtError = options.onUncaughtError), void 0 !== options.onCaughtError && (onCaughtError = options.onCaughtError), void 0 !== options.onRecoverableError && (onRecoverableError = options.onRecoverableError), void 0 !== options.unstable_transitionCallbacks && (transitionCallbacks = options.unstable_transitionCallbacks));
	    options = createFiberRoot(
	      container,
	      1,
	      false,
	      null,
	      null,
	      isStrictMode,
	      identifierPrefix,
	      onUncaughtError,
	      onCaughtError,
	      onRecoverableError,
	      transitionCallbacks,
	      null
	    );
	    container[internalContainerInstanceKey] = options.current;
	    listenToAllSupportedEvents(container);
	    return new ReactDOMRoot(options);
	  };
	  reactDomClient_development.hydrateRoot = function(container, initialChildren, options) {
	    if (!isValidContainer(container))
	      throw Error("Target container is not a DOM element.");
	    warnIfReactDOMContainerInDEV(container);
	    void 0 === initialChildren && console.error(
	      "Must provide initial children as second argument to hydrateRoot. Example usage: hydrateRoot(domContainer, <App />)"
	    );
	    var isStrictMode = false, identifierPrefix = "", onUncaughtError = defaultOnUncaughtError, onCaughtError = defaultOnCaughtError, onRecoverableError = defaultOnRecoverableError, transitionCallbacks = null, formState = null;
	    null !== options && void 0 !== options && (true === options.unstable_strictMode && (isStrictMode = true), void 0 !== options.identifierPrefix && (identifierPrefix = options.identifierPrefix), void 0 !== options.onUncaughtError && (onUncaughtError = options.onUncaughtError), void 0 !== options.onCaughtError && (onCaughtError = options.onCaughtError), void 0 !== options.onRecoverableError && (onRecoverableError = options.onRecoverableError), void 0 !== options.unstable_transitionCallbacks && (transitionCallbacks = options.unstable_transitionCallbacks), void 0 !== options.formState && (formState = options.formState));
	    initialChildren = createFiberRoot(
	      container,
	      1,
	      true,
	      initialChildren,
	      null != options ? options : null,
	      isStrictMode,
	      identifierPrefix,
	      onUncaughtError,
	      onCaughtError,
	      onRecoverableError,
	      transitionCallbacks,
	      formState
	    );
	    initialChildren.context = getContextForSubtree(null);
	    options = initialChildren.current;
	    isStrictMode = requestUpdateLane(options);
	    isStrictMode = getBumpedLaneForHydrationByLane(isStrictMode);
	    identifierPrefix = createUpdate(isStrictMode);
	    identifierPrefix.callback = null;
	    enqueueUpdate(options, identifierPrefix, isStrictMode);
	    options = isStrictMode;
	    initialChildren.current.lanes = options;
	    markRootUpdated$1(initialChildren, options);
	    ensureRootIsScheduled(initialChildren);
	    container[internalContainerInstanceKey] = initialChildren.current;
	    listenToAllSupportedEvents(container);
	    return new ReactDOMHydrationRoot(initialChildren);
	  };
	  reactDomClient_development.version = "19.1.1";
	  "undefined" !== typeof __REACT_DEVTOOLS_GLOBAL_HOOK__ && "function" === typeof __REACT_DEVTOOLS_GLOBAL_HOOK__.registerInternalModuleStop && __REACT_DEVTOOLS_GLOBAL_HOOK__.registerInternalModuleStop(Error());
	})();
	return reactDomClient_development;
}

var hasRequiredClient;

function requireClient () {
	if (hasRequiredClient) return client.exports;
	hasRequiredClient = 1;
	{
	  client.exports = requireReactDomClient_development();
	}
	return client.exports;
}

var clientExports = requireClient();

const Navigation = () => {
  const [isMenuOpen, setIsMenuOpen] = reactExports.useState(false);
  const [touchStart, setTouchStart] = reactExports.useState(null);
  const [touchEnd, setTouchEnd] = reactExports.useState(null);
  const location = useLocation();
  const mobileMenuRef = reactExports.useRef(null);
  const navigationItems = [
    { path: "/", label: "Home" },
    { path: "/projects", label: "Projects" },
    // { path: '/blog', label: 'Blog' },
    { path: "/contact", label: "Contact" }
  ];
  const minSwipeDistance = 50;
  const isActive = (path) => {
    if (path === "/") {
      return location.pathname === "/";
    }
    return location.pathname.startsWith(path);
  };
  const toggleMenu = () => {
    setIsMenuOpen(!isMenuOpen);
  };
  const closeMenu = () => {
    setIsMenuOpen(false);
  };
  const onTouchStart = (e) => {
    setTouchEnd(null);
    setTouchStart(e.targetTouches[0].clientX);
  };
  const onTouchMove = (e) => {
    setTouchEnd(e.targetTouches[0].clientX);
  };
  const onTouchEnd = () => {
    if (!touchStart || !touchEnd) return;
    const distance = touchStart - touchEnd;
    const isLeftSwipe = distance > minSwipeDistance;
    if (isLeftSwipe && isMenuOpen) {
      closeMenu();
    }
    setTouchStart(null);
    setTouchEnd(null);
  };
  reactExports.useEffect(() => {
    const handleClickOutside = (event) => {
      if (mobileMenuRef.current && !mobileMenuRef.current.contains(event.target)) {
        closeMenu();
      }
    };
    if (isMenuOpen) {
      document.addEventListener("mousedown", handleClickOutside);
      document.body.style.overflow = "hidden";
    }
    return () => {
      document.removeEventListener("mousedown", handleClickOutside);
      document.body.style.overflow = "unset";
    };
  }, [isMenuOpen]);
  reactExports.useEffect(() => {
    closeMenu();
  }, [location.pathname]);
  return /* @__PURE__ */ jsxDevRuntimeExports.jsxDEV("nav", { className: "fixed top-0 right-0 z-50 w-full bg-vs-editor-surface/95 backdrop-blur-sm border-b border-vs-editor-border shadow-sm", children: [
    /* @__PURE__ */ jsxDevRuntimeExports.jsxDEV("div", { className: "max-w-7xl mx-auto px-4 sm:px-6 lg:px-8", children: /* @__PURE__ */ jsxDevRuntimeExports.jsxDEV("div", { className: "flex justify-between items-center h-16", children: [
      /* @__PURE__ */ jsxDevRuntimeExports.jsxDEV("div", { className: "flex-shrink-0", children: /* @__PURE__ */ jsxDevRuntimeExports.jsxDEV(Link, { to: "/", className: "text-xl font-bold text-vs-editor-text hover:text-crystal-blue-400 transition-colors", children: "Jordan Yu" }, void 0, false, {
        fileName: "/workspace/personal-blog/src/components/Navigation/Navigation.tsx",
        lineNumber: 92,
        columnNumber: 13
      }, undefined) }, void 0, false, {
        fileName: "/workspace/personal-blog/src/components/Navigation/Navigation.tsx",
        lineNumber: 91,
        columnNumber: 11
      }, undefined),
      /* @__PURE__ */ jsxDevRuntimeExports.jsxDEV("div", { className: "hidden md:block", children: /* @__PURE__ */ jsxDevRuntimeExports.jsxDEV("div", { className: "ml-10 flex items-baseline space-x-8", children: navigationItems.map((item) => /* @__PURE__ */ jsxDevRuntimeExports.jsxDEV(
        Link,
        {
          to: item.path,
          className: `px-3 py-2 rounded-md text-sm font-medium transition-colors ${isActive(item.path) ? "text-crystal-blue-400 bg-vs-editor-selection" : "text-vs-editor-text hover:text-crystal-blue-400 hover:bg-vs-editor-hover"}`,
          children: item.label
        },
        item.path,
        false,
        {
          fileName: "/workspace/personal-blog/src/components/Navigation/Navigation.tsx",
          lineNumber: 101,
          columnNumber: 17
        },
        undefined
      )) }, void 0, false, {
        fileName: "/workspace/personal-blog/src/components/Navigation/Navigation.tsx",
        lineNumber: 99,
        columnNumber: 13
      }, undefined) }, void 0, false, {
        fileName: "/workspace/personal-blog/src/components/Navigation/Navigation.tsx",
        lineNumber: 98,
        columnNumber: 11
      }, undefined),
      /* @__PURE__ */ jsxDevRuntimeExports.jsxDEV("div", { className: "md:hidden", children: /* @__PURE__ */ jsxDevRuntimeExports.jsxDEV(
        "button",
        {
          onClick: toggleMenu,
          className: "inline-flex items-center justify-center p-2 rounded-md text-vs-editor-text hover:text-crystal-blue-400 hover:bg-vs-editor-hover focus:outline-none focus:ring-2 focus:ring-inset focus:ring-crystal-blue-500 transition-colors active:bg-vs-editor-surface2",
          "aria-expanded": isMenuOpen,
          "aria-label": isMenuOpen ? "Close main menu" : "Open main menu",
          children: [
            /* @__PURE__ */ jsxDevRuntimeExports.jsxDEV("span", { className: "sr-only", children: isMenuOpen ? "Close main menu" : "Open main menu" }, void 0, false, {
              fileName: "/workspace/personal-blog/src/components/Navigation/Navigation.tsx",
              lineNumber: 124,
              columnNumber: 15
            }, undefined),
            isMenuOpen ? /* @__PURE__ */ jsxDevRuntimeExports.jsxDEV(X$2, { className: "block h-6 w-6", "aria-hidden": "true" }, void 0, false, {
              fileName: "/workspace/personal-blog/src/components/Navigation/Navigation.tsx",
              lineNumber: 126,
              columnNumber: 17
            }, undefined) : /* @__PURE__ */ jsxDevRuntimeExports.jsxDEV(Menu, { className: "block h-6 w-6", "aria-hidden": "true" }, void 0, false, {
              fileName: "/workspace/personal-blog/src/components/Navigation/Navigation.tsx",
              lineNumber: 128,
              columnNumber: 17
            }, undefined)
          ]
        },
        void 0,
        true,
        {
          fileName: "/workspace/personal-blog/src/components/Navigation/Navigation.tsx",
          lineNumber: 118,
          columnNumber: 13
        },
        undefined
      ) }, void 0, false, {
        fileName: "/workspace/personal-blog/src/components/Navigation/Navigation.tsx",
        lineNumber: 117,
        columnNumber: 11
      }, undefined)
    ] }, void 0, true, {
      fileName: "/workspace/personal-blog/src/components/Navigation/Navigation.tsx",
      lineNumber: 89,
      columnNumber: 9
    }, undefined) }, void 0, false, {
      fileName: "/workspace/personal-blog/src/components/Navigation/Navigation.tsx",
      lineNumber: 88,
      columnNumber: 7
    }, undefined),
    isMenuOpen && /* @__PURE__ */ jsxDevRuntimeExports.jsxDEV(
      "div",
      {
        ref: mobileMenuRef,
        className: "md:hidden fixed inset-0 z-40 bg-black bg-opacity-25 backdrop-blur-sm transition-all duration-300 ease-in-out",
        onClick: closeMenu,
        children: /* @__PURE__ */ jsxDevRuntimeExports.jsxDEV(
          "div",
          {
            className: "absolute right-0 top-16 w-64 h-full bg-vs-editor-surface shadow-2xl transform transition-all duration-500 ease-out",
            onTouchStart,
            onTouchMove,
            onTouchEnd,
            onClick: (e) => e.stopPropagation(),
            children: [
              /* @__PURE__ */ jsxDevRuntimeExports.jsxDEV("div", { className: "px-4 pt-6 pb-8 space-y-2", children: [
                /* @__PURE__ */ jsxDevRuntimeExports.jsxDEV("div", { className: "text-xs font-semibold text-vs-editor-text2 uppercase tracking-wider mb-4 px-3 transition-colors duration-300", children: "Navigation" }, void 0, false, {
                  fileName: "/workspace/personal-blog/src/components/Navigation/Navigation.tsx",
                  lineNumber: 150,
                  columnNumber: 15
                }, undefined),
                navigationItems.map((item, index) => /* @__PURE__ */ jsxDevRuntimeExports.jsxDEV(
                  Link,
                  {
                    to: item.path,
                    className: `block px-3 py-3 rounded-lg text-base font-medium transition-all duration-300 ease-in-out transform hover:scale-105 hover:-translate-x-1 ${isActive(item.path) ? "text-crystal-blue-400 bg-vs-editor-selection border-l-4 border-crystal-blue-400 shadow-md" : "text-vs-editor-text hover:text-crystal-blue-400 hover:bg-vs-editor-hover hover:shadow-md active:bg-vs-editor-surface2 active:scale-95"}`,
                    onClick: closeMenu,
                    style: {
                      animationDelay: `${index * 100}ms`
                    },
                    children: item.label
                  },
                  `mobile-${item.path}`,
                  false,
                  {
                    fileName: "/workspace/personal-blog/src/components/Navigation/Navigation.tsx",
                    lineNumber: 154,
                    columnNumber: 17
                  },
                  undefined
                ))
              ] }, void 0, true, {
                fileName: "/workspace/personal-blog/src/components/Navigation/Navigation.tsx",
                lineNumber: 149,
                columnNumber: 13
              }, undefined),
              /* @__PURE__ */ jsxDevRuntimeExports.jsxDEV("div", { className: "absolute bottom-0 left-0 right-0 p-4 border-t border-vs-editor-border bg-gradient-to-r from-vs-editor-surface to-vs-editor-surface2", children: /* @__PURE__ */ jsxDevRuntimeExports.jsxDEV("div", { className: "text-xs text-vs-editor-text2 text-center transition-colors duration-300 hover:text-crystal-blue-400", children: "Swipe left to close" }, void 0, false, {
                fileName: "/workspace/personal-blog/src/components/Navigation/Navigation.tsx",
                lineNumber: 173,
                columnNumber: 15
              }, undefined) }, void 0, false, {
                fileName: "/workspace/personal-blog/src/components/Navigation/Navigation.tsx",
                lineNumber: 172,
                columnNumber: 13
              }, undefined)
            ]
          },
          void 0,
          true,
          {
            fileName: "/workspace/personal-blog/src/components/Navigation/Navigation.tsx",
            lineNumber: 142,
            columnNumber: 11
          },
          undefined
        )
      },
      void 0,
      false,
      {
        fileName: "/workspace/personal-blog/src/components/Navigation/Navigation.tsx",
        lineNumber: 137,
        columnNumber: 9
      },
      undefined
    )
  ] }, void 0, true, {
    fileName: "/workspace/personal-blog/src/components/Navigation/Navigation.tsx",
    lineNumber: 87,
    columnNumber: 5
  }, undefined);
};

const REQUIRED_BLOG_POST_FIELDS = [
  "id",
  "title",
  "slug",
  "date",
  "featured",
  "tags",
  "excerpt",
  "author",
  "readTime",
  "category",
  "difficulty"
];
const REQUIRED_PROJECT_FIELDS = [
  "id",
  "title",
  "slug",
  "date",
  "featured",
  "tags",
  "description",
  "shortDescription",
  "image",
  "techStack",
  "showDetails"
];

const parseMarkdown = (content, _options = {}) => {
  const plainText = content.replace(/<[^>]*>/g, "");
  const wordCount = plainText.trim().split(/\s+/).filter((word) => word.length > 0).length;
  const readTime = Math.ceil(wordCount / 200);
  return {
    wordCount,
    readTime
  };
};
const getContentStats = (content) => {
  const plainText = content.replace(/<[^>]*>/g, "");
  const wordCount = plainText.trim().split(/\s+/).filter((word) => word.length > 0).length;
  const readTime = Math.ceil(wordCount / 200);
  return { wordCount, readTime };
};
const validateMarkdownContent = (content) => {
  const errors = [];
  if (!content || content.trim().length === 0) {
    errors.push("Content is empty");
  }
  const openHeaders = (content.match(/^#{1,6} /gm) || []).length;
  const closeHeaders = (content.match(/<\/h[1-6]>/g) || []).length;
  if (openHeaders !== closeHeaders) {
    errors.push("Mismatched header tags");
  }
  const codeBlockOpen = (content.match(/```/g) || []).length;
  if (codeBlockOpen % 2 !== 0) {
    errors.push("Unclosed code block");
  }
  return {
    isValid: errors.length === 0,
    errors
  };
};

const DEFAULT_OPTIONS = {
  cacheEnabled: true,
  cacheExpiry: 36e5,
  // 1 hour
  parseMarkdown: false,
  validateFrontmatter: false
};
let contentCache = {};
const parseFrontmatter = (content) => {
  return {
    frontmatter: "",
    markdown: content.trim()
  };
};
const parseYamlFrontmatter = (yamlString) => {
  const lines = yamlString.split("\n");
  const result = {};
  if (!yamlString.trim()) {
    console.warn("Empty frontmatter, using default values");
    return result;
  }
  for (const line of lines) {
    const trimmedLine = line.trim();
    if (!trimmedLine || trimmedLine.startsWith("#")) continue;
    const colonIndex = trimmedLine.indexOf(":");
    if (colonIndex === -1) {
      console.warn(`Skipping malformed frontmatter line: "${trimmedLine}"`);
      continue;
    }
    const key = trimmedLine.substring(0, colonIndex).trim();
    let value = trimmedLine.substring(colonIndex + 1).trim();
    if (!key) {
      console.warn("Skipping line with empty key");
      continue;
    }
    if (value.startsWith('"') && value.endsWith('"')) {
      value = value.slice(1, -1);
    } else if (value.startsWith("'") && value.endsWith("'")) {
      value = value.slice(1, -1);
    }
    if (value.startsWith("[") && value.endsWith("]")) {
      try {
        value = value.slice(1, -1).split(",").map((item) => item.trim());
      } catch (error) {
        console.warn(`Failed to parse array value for key "${key}":`, error);
        value = [];
      }
    }
    if (value === "true") {
      value = true;
    } else if (value === "false") {
      value = false;
    }
    if (typeof value === "string" && !isNaN(Number(value)) && value !== "") {
      value = Number(value);
    }
    result[key] = value;
  }
  return result;
};
const processContent = (markdownContent, options = {}) => {
  const { parseMarkdown: shouldParseMarkdown = false } = options;
  if (!shouldParseMarkdown) {
    return { content: markdownContent };
  }
  try {
    const validation = validateMarkdownContent(markdownContent);
    if (!validation.isValid) {
      console.warn("Markdown validation warnings:", validation.errors);
    }
    const parsed = parseMarkdown(markdownContent);
    return {
      content: markdownContent,
      wordCount: parsed.wordCount,
      readTime: parsed.readTime
    };
  } catch (error) {
    console.error("Error processing markdown content:", error);
    const stats = getContentStats(markdownContent);
    return {
      content: markdownContent,
      wordCount: stats.wordCount,
      readTime: stats.readTime
    };
  }
};
const validateBlogPostFrontmatter = (frontmatter) => {
  const errors = [];
  const warnings = [];
  for (const field of REQUIRED_BLOG_POST_FIELDS) {
    if (frontmatter[field] === void 0 || frontmatter[field] === null) {
      errors.push(`Missing required field: ${field}`);
    }
  }
  if (frontmatter.readTime !== void 0 && frontmatter.readTime !== null) {
    if (typeof frontmatter.readTime !== "number") {
      warnings.push("readTime should be a number, attempting to convert");
      const converted = Number(frontmatter.readTime);
      if (!isNaN(converted)) {
        frontmatter.readTime = converted;
      } else {
        errors.push("readTime must be a valid number");
      }
    }
  }
  if (frontmatter.category !== void 0 && frontmatter.category !== null) {
    if (!["tutorial", "project-showcase", "tech-review", "career-advice"].includes(frontmatter.category)) {
      warnings.push(`Invalid category value: ${frontmatter.category}, defaulting to tutorial`);
      frontmatter.category = "tutorial";
    }
  }
  if (frontmatter.difficulty !== void 0 && frontmatter.difficulty !== null) {
    if (!["beginner", "intermediate", "advanced"].includes(frontmatter.difficulty)) {
      warnings.push(`Invalid difficulty value: ${frontmatter.difficulty}, defaulting to intermediate`);
      frontmatter.difficulty = "intermediate";
    }
  }
  if (frontmatter.tags !== void 0 && frontmatter.tags !== null) {
    if (!Array.isArray(frontmatter.tags)) {
      warnings.push("tags should be an array, attempting to convert");
      if (typeof frontmatter.tags === "string") {
        frontmatter.tags = [frontmatter.tags];
      } else {
        errors.push("tags must be an array or string");
      }
    }
  }
  if (frontmatter.featured !== void 0 && frontmatter.featured !== null) {
    if (typeof frontmatter.featured !== "boolean") {
      warnings.push(`featured should be a boolean, converting "${frontmatter.featured}" to false`);
      frontmatter.featured = false;
    }
  }
  if (!frontmatter.id && frontmatter.slug) {
    frontmatter.id = frontmatter.slug;
    warnings.push("Using slug as id since id is missing");
  }
  if (!frontmatter.date) {
    frontmatter.date = (/* @__PURE__ */ new Date()).toISOString().split("T")[0];
    warnings.push("Using current date as default since date is missing");
  }
  if (!frontmatter.author) {
    frontmatter.author = "Unknown Author";
    warnings.push("Using default author since author is missing");
  }
  return {
    isValid: errors.length === 0,
    errors,
    warnings
  };
};
const validateProjectFrontmatter = (frontmatter) => {
  const errors = [];
  const warnings = [];
  for (const field of REQUIRED_PROJECT_FIELDS) {
    if (frontmatter[field] === void 0 || frontmatter[field] === null) {
      errors.push(`Missing required field: ${field}`);
    }
  }
  if (frontmatter.techStack !== void 0 && frontmatter.techStack !== null) {
    if (!Array.isArray(frontmatter.techStack)) {
      warnings.push("techStack should be an array, attempting to convert");
      if (typeof frontmatter.techStack === "string") {
        frontmatter.techStack = [frontmatter.techStack];
      } else {
        errors.push("techStack must be an array or string");
      }
    }
  }
  if (frontmatter.featured !== void 0 && frontmatter.featured !== null) {
    if (typeof frontmatter.featured !== "boolean") {
      warnings.push(`featured should be a boolean, converting "${frontmatter.featured}" to false`);
      frontmatter.featured = false;
    }
  }
  if (!frontmatter.id && frontmatter.slug) {
    frontmatter.id = frontmatter.slug;
    warnings.push("Using slug as id since id is missing");
  }
  if (!frontmatter.date) {
    frontmatter.date = (/* @__PURE__ */ new Date()).toISOString().split("T")[0];
    warnings.push("Using current date as default since date is missing");
  }
  if (!frontmatter.description && frontmatter.shortDescription) {
    frontmatter.description = frontmatter.shortDescription;
    warnings.push("Using shortDescription as description since description is missing");
  }
  if (!frontmatter.shortDescription && frontmatter.description) {
    frontmatter.shortDescription = frontmatter.description.substring(0, 100) + "...";
    warnings.push("Generated shortDescription from description");
  }
  return {
    isValid: errors.length === 0,
    errors,
    warnings
  };
};
const loadBlogPostContent = async (filePath, options = {}) => {
  const opts = { ...DEFAULT_OPTIONS, ...options };
  try {
    console.log(`Loading blog post content from: "${filePath}"`);
    if (opts.cacheEnabled && contentCache[filePath]) {
      const cached = contentCache[filePath];
      if (Date.now() < cached.expiresAt) {
        console.log(`Cache hit for blog post: "${filePath}"`);
        return cached.content;
      } else {
        delete contentCache[filePath];
      }
    }
    const response = await fetch(filePath);
    if (!response.ok) {
      const errorMsg = `Failed to load content from ${filePath}: ${response.statusText}`;
      console.error(errorMsg);
      throw new Error(errorMsg);
    }
    const content = await response.text();
    console.log(`Successfully loaded content from: "${filePath}"`);
    const { frontmatter: yamlFrontmatter, markdown } = parseFrontmatter(content);
    const frontmatterData = parseYamlFrontmatter(yamlFrontmatter);
    if (opts.validateFrontmatter) {
      const validation = validateBlogPostFrontmatter(frontmatterData);
      if (!validation.isValid) {
        const errorMsg = `Invalid frontmatter: ${validation.errors.join(", ")}`;
        console.error(`Validation failed for "${filePath}":`, errorMsg);
        throw new Error(errorMsg);
      }
    }
    const processedContent = processContent(markdown, opts);
    const blogPostContent = {
      frontmatter: frontmatterData,
      content: processedContent.content,
      excerpt: frontmatterData.excerpt,
      wordCount: processedContent.wordCount,
      readTime: processedContent.readTime
    };
    if (opts.cacheEnabled) {
      contentCache[filePath] = {
        content: blogPostContent,
        timestamp: Date.now(),
        expiresAt: Date.now() + opts.cacheExpiry
      };
      console.log(`Cached blog post content for: "${filePath}"`);
    }
    console.log(`Successfully processed blog post content from: "${filePath}"`);
    return blogPostContent;
  } catch (error) {
    console.error(`Error loading blog post content from "${filePath}":`, error);
    throw new Error(`Failed to load blog post content: ${error instanceof Error ? error.message : String(error)}`);
  }
};
const loadProjectContent$1 = async (filePath, options = {}) => {
  const opts = { ...DEFAULT_OPTIONS, ...options };
  try {
    console.log(`Loading project content from: "${filePath}"`);
    if (opts.cacheEnabled && contentCache[filePath]) {
      const cached = contentCache[filePath];
      if (Date.now() < cached.expiresAt) {
        console.log(`Cache hit for project: "${filePath}"`);
        return cached.content;
      } else {
        delete contentCache[filePath];
      }
    }
    const response = await fetch(filePath);
    if (!response.ok) {
      const errorMsg = `Failed to load content from ${filePath}: ${response.statusText}`;
      console.error(errorMsg);
      throw new Error(errorMsg);
    }
    const content = await response.text();
    console.log(`Successfully loaded content from: "${filePath}"`);
    const { frontmatter: yamlFrontmatter, markdown } = parseFrontmatter(content);
    const frontmatterData = parseYamlFrontmatter(yamlFrontmatter);
    if (opts.validateFrontmatter) {
      const validation = validateProjectFrontmatter(frontmatterData);
      if (!validation.isValid) {
        const errorMsg = `Invalid frontmatter: ${validation.errors.join(", ")}`;
        console.error(`Validation failed for "${filePath}":`, errorMsg);
        throw new Error(errorMsg);
      }
    }
    const processedContent = processContent(markdown, opts);
    const projectContent = {
      frontmatter: frontmatterData,
      content: processedContent.content,
      // excerpt: frontmatterData.excerpt,
      excerpt: "excerpt",
      wordCount: processedContent.wordCount,
      readTime: processedContent.readTime
    };
    if (opts.cacheEnabled) {
      contentCache[filePath] = {
        content: projectContent,
        timestamp: Date.now(),
        expiresAt: Date.now() + opts.cacheExpiry
      };
      console.log(`Cached project content for: "${filePath}"`);
    }
    console.log(`Successfully processed project content from: "${filePath}"`);
    return projectContent;
  } catch (error) {
    console.error(`Error loading project content from "${filePath}":`, error);
    throw new Error(`Failed to load project content: ${error instanceof Error ? error.message : String(error)}`);
  }
};
const loadContent = async (filePath, contentType, options = {}) => {
  switch (contentType) {
    case "blog-post":
      return await loadBlogPostContent(filePath, options);
    case "project":
      return await loadProjectContent$1(filePath, options);
    default:
      throw new Error(`Unsupported content type: ${contentType}`);
  }
};

const scriptRel = 'modulepreload';const assetsURL = function(dep) { return "/"+dep };const seen = {};const __vitePreload = function preload(baseModule, deps, importerUrl) {
	let promise = Promise.resolve();
	if (true               && deps && deps.length > 0) {
		document.getElementsByTagName("link");
		const cspNonceMeta = document.querySelector("meta[property=csp-nonce]");
		const cspNonce = cspNonceMeta?.nonce || cspNonceMeta?.getAttribute("nonce");
		function allSettled(promises$2) {
			return Promise.all(promises$2.map((p) => Promise.resolve(p).then((value$1) => ({
				status: "fulfilled",
				value: value$1
			}), (reason) => ({
				status: "rejected",
				reason
			}))));
		}
		promise = allSettled(deps.map((dep) => {
			dep = assetsURL(dep);
			if (dep in seen) return;
			seen[dep] = true;
			const isCss = dep.endsWith(".css");
			const cssSelector = isCss ? "[rel=\"stylesheet\"]" : "";
			if (document.querySelector(`link[href="${dep}"]${cssSelector}`)) return;
			const link = document.createElement("link");
			link.rel = isCss ? "stylesheet" : scriptRel;
			if (!isCss) link.as = "script";
			link.crossOrigin = "";
			link.href = dep;
			if (cspNonce) link.setAttribute("nonce", cspNonce);
			document.head.appendChild(link);
			if (isCss) return new Promise((res, rej) => {
				link.addEventListener("load", res);
				link.addEventListener("error", () => rej(/* @__PURE__ */ new Error(`Unable to preload CSS for ${dep}`)));
			});
		}));
	}
	function handlePreloadError(err$2) {
		const e$1 = new Event("vite:preloadError", { cancelable: true });
		e$1.payload = err$2;
		window.dispatchEvent(e$1);
		if (!e$1.defaultPrevented) throw err$2;
	}
	return promise.then((res) => {
		for (const item of res || []) {
			if (item.status !== "rejected") continue;
			handlePreloadError(item.reason);
		}
		return baseModule().catch(handlePreloadError);
	});
};

var dayjs_min$1 = {exports: {}};

var dayjs_min = dayjs_min$1.exports;

var hasRequiredDayjs_min;

function requireDayjs_min () {
	if (hasRequiredDayjs_min) return dayjs_min$1.exports;
	hasRequiredDayjs_min = 1;
	(function (module, exports) {
		!function(t,e){module.exports=e();}(dayjs_min,(function(){var t=1e3,e=6e4,n=36e5,r="millisecond",i="second",s="minute",u="hour",a="day",o="week",c="month",f="quarter",h="year",d="date",l="Invalid Date",$=/^(\d{4})[-/]?(\d{1,2})?[-/]?(\d{0,2})[Tt\s]*(\d{1,2})?:?(\d{1,2})?:?(\d{1,2})?[.:]?(\d+)?$/,y=/\[([^\]]+)]|Y{1,4}|M{1,4}|D{1,2}|d{1,4}|H{1,2}|h{1,2}|a|A|m{1,2}|s{1,2}|Z{1,2}|SSS/g,M={name:"en",weekdays:"Sunday_Monday_Tuesday_Wednesday_Thursday_Friday_Saturday".split("_"),months:"January_February_March_April_May_June_July_August_September_October_November_December".split("_"),ordinal:function(t){var e=["th","st","nd","rd"],n=t%100;return "["+t+(e[(n-20)%10]||e[n]||e[0])+"]"}},m=function(t,e,n){var r=String(t);return !r||r.length>=e?t:""+Array(e+1-r.length).join(n)+t},v={s:m,z:function(t){var e=-t.utcOffset(),n=Math.abs(e),r=Math.floor(n/60),i=n%60;return (e<=0?"+":"-")+m(r,2,"0")+":"+m(i,2,"0")},m:function t(e,n){if(e.date()<n.date())return -t(n,e);var r=12*(n.year()-e.year())+(n.month()-e.month()),i=e.clone().add(r,c),s=n-i<0,u=e.clone().add(r+(s?-1:1),c);return +(-(r+(n-i)/(s?i-u:u-i))||0)},a:function(t){return t<0?Math.ceil(t)||0:Math.floor(t)},p:function(t){return {M:c,y:h,w:o,d:a,D:d,h:u,m:s,s:i,ms:r,Q:f}[t]||String(t||"").toLowerCase().replace(/s$/,"")},u:function(t){return void 0===t}},g="en",D={};D[g]=M;var p="$isDayjsObject",S=function(t){return t instanceof _||!(!t||!t[p])},w=function t(e,n,r){var i;if(!e)return g;if("string"==typeof e){var s=e.toLowerCase();D[s]&&(i=s),n&&(D[s]=n,i=s);var u=e.split("-");if(!i&&u.length>1)return t(u[0])}else {var a=e.name;D[a]=e,i=a;}return !r&&i&&(g=i),i||!r&&g},O=function(t,e){if(S(t))return t.clone();var n="object"==typeof e?e:{};return n.date=t,n.args=arguments,new _(n)},b=v;b.l=w,b.i=S,b.w=function(t,e){return O(t,{locale:e.$L,utc:e.$u,x:e.$x,$offset:e.$offset})};var _=function(){function M(t){this.$L=w(t.locale,null,true),this.parse(t),this.$x=this.$x||t.x||{},this[p]=true;}var m=M.prototype;return m.parse=function(t){this.$d=function(t){var e=t.date,n=t.utc;if(null===e)return new Date(NaN);if(b.u(e))return new Date;if(e instanceof Date)return new Date(e);if("string"==typeof e&&!/Z$/i.test(e)){var r=e.match($);if(r){var i=r[2]-1||0,s=(r[7]||"0").substring(0,3);return n?new Date(Date.UTC(r[1],i,r[3]||1,r[4]||0,r[5]||0,r[6]||0,s)):new Date(r[1],i,r[3]||1,r[4]||0,r[5]||0,r[6]||0,s)}}return new Date(e)}(t),this.init();},m.init=function(){var t=this.$d;this.$y=t.getFullYear(),this.$M=t.getMonth(),this.$D=t.getDate(),this.$W=t.getDay(),this.$H=t.getHours(),this.$m=t.getMinutes(),this.$s=t.getSeconds(),this.$ms=t.getMilliseconds();},m.$utils=function(){return b},m.isValid=function(){return !(this.$d.toString()===l)},m.isSame=function(t,e){var n=O(t);return this.startOf(e)<=n&&n<=this.endOf(e)},m.isAfter=function(t,e){return O(t)<this.startOf(e)},m.isBefore=function(t,e){return this.endOf(e)<O(t)},m.$g=function(t,e,n){return b.u(t)?this[e]:this.set(n,t)},m.unix=function(){return Math.floor(this.valueOf()/1e3)},m.valueOf=function(){return this.$d.getTime()},m.startOf=function(t,e){var n=this,r=!!b.u(e)||e,f=b.p(t),l=function(t,e){var i=b.w(n.$u?Date.UTC(n.$y,e,t):new Date(n.$y,e,t),n);return r?i:i.endOf(a)},$=function(t,e){return b.w(n.toDate()[t].apply(n.toDate("s"),(r?[0,0,0,0]:[23,59,59,999]).slice(e)),n)},y=this.$W,M=this.$M,m=this.$D,v="set"+(this.$u?"UTC":"");switch(f){case h:return r?l(1,0):l(31,11);case c:return r?l(1,M):l(0,M+1);case o:var g=this.$locale().weekStart||0,D=(y<g?y+7:y)-g;return l(r?m-D:m+(6-D),M);case a:case d:return $(v+"Hours",0);case u:return $(v+"Minutes",1);case s:return $(v+"Seconds",2);case i:return $(v+"Milliseconds",3);default:return this.clone()}},m.endOf=function(t){return this.startOf(t,false)},m.$set=function(t,e){var n,o=b.p(t),f="set"+(this.$u?"UTC":""),l=(n={},n[a]=f+"Date",n[d]=f+"Date",n[c]=f+"Month",n[h]=f+"FullYear",n[u]=f+"Hours",n[s]=f+"Minutes",n[i]=f+"Seconds",n[r]=f+"Milliseconds",n)[o],$=o===a?this.$D+(e-this.$W):e;if(o===c||o===h){var y=this.clone().set(d,1);y.$d[l]($),y.init(),this.$d=y.set(d,Math.min(this.$D,y.daysInMonth())).$d;}else l&&this.$d[l]($);return this.init(),this},m.set=function(t,e){return this.clone().$set(t,e)},m.get=function(t){return this[b.p(t)]()},m.add=function(r,f){var d,l=this;r=Number(r);var $=b.p(f),y=function(t){var e=O(l);return b.w(e.date(e.date()+Math.round(t*r)),l)};if($===c)return this.set(c,this.$M+r);if($===h)return this.set(h,this.$y+r);if($===a)return y(1);if($===o)return y(7);var M=(d={},d[s]=e,d[u]=n,d[i]=t,d)[$]||1,m=this.$d.getTime()+r*M;return b.w(m,this)},m.subtract=function(t,e){return this.add(-1*t,e)},m.format=function(t){var e=this,n=this.$locale();if(!this.isValid())return n.invalidDate||l;var r=t||"YYYY-MM-DDTHH:mm:ssZ",i=b.z(this),s=this.$H,u=this.$m,a=this.$M,o=n.weekdays,c=n.months,f=n.meridiem,h=function(t,n,i,s){return t&&(t[n]||t(e,r))||i[n].slice(0,s)},d=function(t){return b.s(s%12||12,t,"0")},$=f||function(t,e,n){var r=t<12?"AM":"PM";return n?r.toLowerCase():r};return r.replace(y,(function(t,r){return r||function(t){switch(t){case "YY":return String(e.$y).slice(-2);case "YYYY":return b.s(e.$y,4,"0");case "M":return a+1;case "MM":return b.s(a+1,2,"0");case "MMM":return h(n.monthsShort,a,c,3);case "MMMM":return h(c,a);case "D":return e.$D;case "DD":return b.s(e.$D,2,"0");case "d":return String(e.$W);case "dd":return h(n.weekdaysMin,e.$W,o,2);case "ddd":return h(n.weekdaysShort,e.$W,o,3);case "dddd":return o[e.$W];case "H":return String(s);case "HH":return b.s(s,2,"0");case "h":return d(1);case "hh":return d(2);case "a":return $(s,u,true);case "A":return $(s,u,false);case "m":return String(u);case "mm":return b.s(u,2,"0");case "s":return String(e.$s);case "ss":return b.s(e.$s,2,"0");case "SSS":return b.s(e.$ms,3,"0");case "Z":return i}return null}(t)||i.replace(":","")}))},m.utcOffset=function(){return 15*-Math.round(this.$d.getTimezoneOffset()/15)},m.diff=function(r,d,l){var $,y=this,M=b.p(d),m=O(r),v=(m.utcOffset()-this.utcOffset())*e,g=this-m,D=function(){return b.m(y,m)};switch(M){case h:$=D()/12;break;case c:$=D();break;case f:$=D()/3;break;case o:$=(g-v)/6048e5;break;case a:$=(g-v)/864e5;break;case u:$=g/n;break;case s:$=g/e;break;case i:$=g/t;break;default:$=g;}return l?$:b.a($)},m.daysInMonth=function(){return this.endOf(c).$D},m.$locale=function(){return D[this.$L]},m.locale=function(t,e){if(!t)return this.$L;var n=this.clone(),r=w(t,e,true);return r&&(n.$L=r),n},m.clone=function(){return b.w(this.$d,this)},m.toDate=function(){return new Date(this.valueOf())},m.toJSON=function(){return this.isValid()?this.toISOString():null},m.toISOString=function(){return this.$d.toISOString()},m.toString=function(){return this.$d.toUTCString()},M}(),k=_.prototype;return O.prototype=k,[["$ms",r],["$s",i],["$m",s],["$H",u],["$W",a],["$M",c],["$y",h],["$D",d]].forEach((function(t){k[t[1]]=function(e){return this.$g(e,t[0],t[1])};})),O.extend=function(t,e){return t.$i||(t(e,_,O),t.$i=true),O},O.locale=w,O.isDayjs=S,O.unix=function(t){return O(1e3*t)},O.en=D[g],O.Ls=D,O.p={},O})); 
	} (dayjs_min$1));
	return dayjs_min$1.exports;
}

var dayjs_minExports = requireDayjs_min();
const dayjs2 = /*@__PURE__*/getDefaultExportFromCjs(dayjs_minExports);

/* IMPORT */
/* MAIN */
const Channel = {
    /* CLAMP */
    min: {
        r: 0,
        g: 0,
        b: 0,
        s: 0,
        l: 0,
        a: 0
    },
    max: {
        r: 255,
        g: 255,
        b: 255,
        h: 360,
        s: 100,
        l: 100,
        a: 1
    },
    clamp: {
        r: (r) => r >= 255 ? 255 : (r < 0 ? 0 : r),
        g: (g) => g >= 255 ? 255 : (g < 0 ? 0 : g),
        b: (b) => b >= 255 ? 255 : (b < 0 ? 0 : b),
        h: (h) => h % 360,
        s: (s) => s >= 100 ? 100 : (s < 0 ? 0 : s),
        l: (l) => l >= 100 ? 100 : (l < 0 ? 0 : l),
        a: (a) => a >= 1 ? 1 : (a < 0 ? 0 : a)
    },
    /* CONVERSION */
    //SOURCE: https://planetcalc.com/7779
    toLinear: (c) => {
        const n = c / 255;
        return c > .03928 ? Math.pow(((n + .055) / 1.055), 2.4) : n / 12.92;
    },
    //SOURCE: https://gist.github.com/mjackson/5311256
    hue2rgb: (p, q, t) => {
        if (t < 0)
            t += 1;
        if (t > 1)
            t -= 1;
        if (t < 1 / 6)
            return p + (q - p) * 6 * t;
        if (t < 1 / 2)
            return q;
        if (t < 2 / 3)
            return p + (q - p) * (2 / 3 - t) * 6;
        return p;
    },
    hsl2rgb: ({ h, s, l }, channel) => {
        if (!s)
            return l * 2.55; // Achromatic
        h /= 360;
        s /= 100;
        l /= 100;
        const q = (l < .5) ? l * (1 + s) : (l + s) - (l * s);
        const p = 2 * l - q;
        switch (channel) {
            case 'r': return Channel.hue2rgb(p, q, h + 1 / 3) * 255;
            case 'g': return Channel.hue2rgb(p, q, h) * 255;
            case 'b': return Channel.hue2rgb(p, q, h - 1 / 3) * 255;
        }
    },
    rgb2hsl: ({ r, g, b }, channel) => {
        r /= 255;
        g /= 255;
        b /= 255;
        const max = Math.max(r, g, b);
        const min = Math.min(r, g, b);
        const l = (max + min) / 2;
        if (channel === 'l')
            return l * 100;
        if (max === min)
            return 0; // Achromatic
        const d = max - min;
        const s = (l > .5) ? d / (2 - max - min) : d / (max + min);
        if (channel === 's')
            return s * 100;
        switch (max) {
            case r: return ((g - b) / d + (g < b ? 6 : 0)) * 60;
            case g: return ((b - r) / d + 2) * 60;
            case b: return ((r - g) / d + 4) * 60;
            default: return -1; //TSC: TypeScript is stupid and complains if there isn't this useless default statement
        }
    }
};

/* MAIN */
const Lang = {
    /* API */
    clamp: (number, lower, upper) => {
        if (lower > upper)
            return Math.min(lower, Math.max(upper, number));
        return Math.min(upper, Math.max(lower, number));
    },
    round: (number) => {
        return Math.round(number * 10000000000) / 10000000000;
    }
};

/* MAIN */
const Unit = {
    /* API */
    dec2hex: (dec) => {
        const hex = Math.round(dec).toString(16);
        return hex.length > 1 ? hex : `0${hex}`;
    }
};

/* IMPORT */
/* MAIN */
const Utils = {
    channel: Channel,
    lang: Lang,
    unit: Unit
};

/* IMPORT */
/* MAIN */
const DEC2HEX = {};
for (let i = 0; i <= 255; i++)
    DEC2HEX[i] = Utils.unit.dec2hex(i); // Populating dynamically, striking a balance between code size and performance
const TYPE = {
    ALL: 0,
    RGB: 1,
    HSL: 2
};

/* IMPORT */
/* MAIN */
class Type {
    constructor() {
        /* VARIABLES */
        this.type = TYPE.ALL;
    }
    /* API */
    get() {
        return this.type;
    }
    set(type) {
        if (this.type && this.type !== type)
            throw new Error('Cannot change both RGB and HSL channels at the same time');
        this.type = type;
    }
    reset() {
        this.type = TYPE.ALL;
    }
    is(type) {
        return this.type === type;
    }
}

/* IMPORT */
/* MAIN */
class Channels {
    /* CONSTRUCTOR */
    constructor(data, color) {
        this.color = color;
        this.changed = false;
        this.data = data; //TSC
        this.type = new Type();
    }
    /* API */
    set(data, color) {
        this.color = color;
        this.changed = false;
        this.data = data; //TSC
        this.type.type = TYPE.ALL;
        return this;
    }
    /* HELPERS */
    _ensureHSL() {
        const data = this.data;
        const { h, s, l } = data;
        if (h === undefined)
            data.h = Utils.channel.rgb2hsl(data, 'h');
        if (s === undefined)
            data.s = Utils.channel.rgb2hsl(data, 's');
        if (l === undefined)
            data.l = Utils.channel.rgb2hsl(data, 'l');
    }
    _ensureRGB() {
        const data = this.data;
        const { r, g, b } = data;
        if (r === undefined)
            data.r = Utils.channel.hsl2rgb(data, 'r');
        if (g === undefined)
            data.g = Utils.channel.hsl2rgb(data, 'g');
        if (b === undefined)
            data.b = Utils.channel.hsl2rgb(data, 'b');
    }
    /* GETTERS */
    get r() {
        const data = this.data;
        const r = data.r;
        if (!this.type.is(TYPE.HSL) && r !== undefined)
            return r;
        this._ensureHSL();
        return Utils.channel.hsl2rgb(data, 'r');
    }
    get g() {
        const data = this.data;
        const g = data.g;
        if (!this.type.is(TYPE.HSL) && g !== undefined)
            return g;
        this._ensureHSL();
        return Utils.channel.hsl2rgb(data, 'g');
    }
    get b() {
        const data = this.data;
        const b = data.b;
        if (!this.type.is(TYPE.HSL) && b !== undefined)
            return b;
        this._ensureHSL();
        return Utils.channel.hsl2rgb(data, 'b');
    }
    get h() {
        const data = this.data;
        const h = data.h;
        if (!this.type.is(TYPE.RGB) && h !== undefined)
            return h;
        this._ensureRGB();
        return Utils.channel.rgb2hsl(data, 'h');
    }
    get s() {
        const data = this.data;
        const s = data.s;
        if (!this.type.is(TYPE.RGB) && s !== undefined)
            return s;
        this._ensureRGB();
        return Utils.channel.rgb2hsl(data, 's');
    }
    get l() {
        const data = this.data;
        const l = data.l;
        if (!this.type.is(TYPE.RGB) && l !== undefined)
            return l;
        this._ensureRGB();
        return Utils.channel.rgb2hsl(data, 'l');
    }
    get a() {
        return this.data.a;
    }
    /* SETTERS */
    set r(r) {
        this.type.set(TYPE.RGB);
        this.changed = true;
        this.data.r = r;
    }
    set g(g) {
        this.type.set(TYPE.RGB);
        this.changed = true;
        this.data.g = g;
    }
    set b(b) {
        this.type.set(TYPE.RGB);
        this.changed = true;
        this.data.b = b;
    }
    set h(h) {
        this.type.set(TYPE.HSL);
        this.changed = true;
        this.data.h = h;
    }
    set s(s) {
        this.type.set(TYPE.HSL);
        this.changed = true;
        this.data.s = s;
    }
    set l(l) {
        this.type.set(TYPE.HSL);
        this.changed = true;
        this.data.l = l;
    }
    set a(a) {
        this.changed = true;
        this.data.a = a;
    }
}

/* IMPORT */
/* MAIN */
const channels = new Channels({ r: 0, g: 0, b: 0, a: 0 }, 'transparent');

/* IMPORT */
/* MAIN */
const Hex = {
    /* VARIABLES */
    re: /^#((?:[a-f0-9]{2}){2,4}|[a-f0-9]{3})$/i,
    /* API */
    parse: (color) => {
        if (color.charCodeAt(0) !== 35)
            return; // '#'
        const match = color.match(Hex.re);
        if (!match)
            return;
        const hex = match[1];
        const dec = parseInt(hex, 16);
        const length = hex.length;
        const hasAlpha = length % 4 === 0;
        const isFullLength = length > 4;
        const multiplier = isFullLength ? 1 : 17;
        const bits = isFullLength ? 8 : 4;
        const bitsOffset = hasAlpha ? 0 : -1;
        const mask = isFullLength ? 255 : 15;
        return channels.set({
            r: ((dec >> (bits * (bitsOffset + 3))) & mask) * multiplier,
            g: ((dec >> (bits * (bitsOffset + 2))) & mask) * multiplier,
            b: ((dec >> (bits * (bitsOffset + 1))) & mask) * multiplier,
            a: hasAlpha ? (dec & mask) * multiplier / 255 : 1
        }, color);
    },
    stringify: (channels) => {
        const { r, g, b, a } = channels;
        if (a < 1) { // #RRGGBBAA
            return `#${DEC2HEX[Math.round(r)]}${DEC2HEX[Math.round(g)]}${DEC2HEX[Math.round(b)]}${DEC2HEX[Math.round(a * 255)]}`;
        }
        else { // #RRGGBB
            return `#${DEC2HEX[Math.round(r)]}${DEC2HEX[Math.round(g)]}${DEC2HEX[Math.round(b)]}`;
        }
    }
};

/* IMPORT */
/* MAIN */
const HSL = {
    /* VARIABLES */
    re: /^hsla?\(\s*?(-?(?:\d+(?:\.\d+)?|(?:\.\d+))(?:e-?\d+)?(?:deg|grad|rad|turn)?)\s*?(?:,|\s)\s*?(-?(?:\d+(?:\.\d+)?|(?:\.\d+))(?:e-?\d+)?%)\s*?(?:,|\s)\s*?(-?(?:\d+(?:\.\d+)?|(?:\.\d+))(?:e-?\d+)?%)(?:\s*?(?:,|\/)\s*?\+?(-?(?:\d+(?:\.\d+)?|(?:\.\d+))(?:e-?\d+)?(%)?))?\s*?\)$/i,
    hueRe: /^(.+?)(deg|grad|rad|turn)$/i,
    /* HELPERS */
    _hue2deg: (hue) => {
        const match = hue.match(HSL.hueRe);
        if (match) {
            const [, number, unit] = match;
            switch (unit) {
                case 'grad': return Utils.channel.clamp.h(parseFloat(number) * .9);
                case 'rad': return Utils.channel.clamp.h(parseFloat(number) * 180 / Math.PI);
                case 'turn': return Utils.channel.clamp.h(parseFloat(number) * 360);
            }
        }
        return Utils.channel.clamp.h(parseFloat(hue));
    },
    /* API */
    parse: (color) => {
        const charCode = color.charCodeAt(0);
        if (charCode !== 104 && charCode !== 72)
            return; // 'h'/'H'
        const match = color.match(HSL.re);
        if (!match)
            return;
        const [, h, s, l, a, isAlphaPercentage] = match;
        return channels.set({
            h: HSL._hue2deg(h),
            s: Utils.channel.clamp.s(parseFloat(s)),
            l: Utils.channel.clamp.l(parseFloat(l)),
            a: a ? Utils.channel.clamp.a(isAlphaPercentage ? parseFloat(a) / 100 : parseFloat(a)) : 1
        }, color);
    },
    stringify: (channels) => {
        const { h, s, l, a } = channels;
        if (a < 1) { // HSLA
            return `hsla(${Utils.lang.round(h)}, ${Utils.lang.round(s)}%, ${Utils.lang.round(l)}%, ${a})`;
        }
        else { // HSL
            return `hsl(${Utils.lang.round(h)}, ${Utils.lang.round(s)}%, ${Utils.lang.round(l)}%)`;
        }
    }
};

/* IMPORT */
/* MAIN */
const Keyword = {
    /* VARIABLES */
    colors: {
        aliceblue: '#f0f8ff',
        antiquewhite: '#faebd7',
        aqua: '#00ffff',
        aquamarine: '#7fffd4',
        azure: '#f0ffff',
        beige: '#f5f5dc',
        bisque: '#ffe4c4',
        black: '#000000',
        blanchedalmond: '#ffebcd',
        blue: '#0000ff',
        blueviolet: '#8a2be2',
        brown: '#a52a2a',
        burlywood: '#deb887',
        cadetblue: '#5f9ea0',
        chartreuse: '#7fff00',
        chocolate: '#d2691e',
        coral: '#ff7f50',
        cornflowerblue: '#6495ed',
        cornsilk: '#fff8dc',
        crimson: '#dc143c',
        cyanaqua: '#00ffff',
        darkblue: '#00008b',
        darkcyan: '#008b8b',
        darkgoldenrod: '#b8860b',
        darkgray: '#a9a9a9',
        darkgreen: '#006400',
        darkgrey: '#a9a9a9',
        darkkhaki: '#bdb76b',
        darkmagenta: '#8b008b',
        darkolivegreen: '#556b2f',
        darkorange: '#ff8c00',
        darkorchid: '#9932cc',
        darkred: '#8b0000',
        darksalmon: '#e9967a',
        darkseagreen: '#8fbc8f',
        darkslateblue: '#483d8b',
        darkslategray: '#2f4f4f',
        darkslategrey: '#2f4f4f',
        darkturquoise: '#00ced1',
        darkviolet: '#9400d3',
        deeppink: '#ff1493',
        deepskyblue: '#00bfff',
        dimgray: '#696969',
        dimgrey: '#696969',
        dodgerblue: '#1e90ff',
        firebrick: '#b22222',
        floralwhite: '#fffaf0',
        forestgreen: '#228b22',
        fuchsia: '#ff00ff',
        gainsboro: '#dcdcdc',
        ghostwhite: '#f8f8ff',
        gold: '#ffd700',
        goldenrod: '#daa520',
        gray: '#808080',
        green: '#008000',
        greenyellow: '#adff2f',
        grey: '#808080',
        honeydew: '#f0fff0',
        hotpink: '#ff69b4',
        indianred: '#cd5c5c',
        indigo: '#4b0082',
        ivory: '#fffff0',
        khaki: '#f0e68c',
        lavender: '#e6e6fa',
        lavenderblush: '#fff0f5',
        lawngreen: '#7cfc00',
        lemonchiffon: '#fffacd',
        lightblue: '#add8e6',
        lightcoral: '#f08080',
        lightcyan: '#e0ffff',
        lightgoldenrodyellow: '#fafad2',
        lightgray: '#d3d3d3',
        lightgreen: '#90ee90',
        lightgrey: '#d3d3d3',
        lightpink: '#ffb6c1',
        lightsalmon: '#ffa07a',
        lightseagreen: '#20b2aa',
        lightskyblue: '#87cefa',
        lightslategray: '#778899',
        lightslategrey: '#778899',
        lightsteelblue: '#b0c4de',
        lightyellow: '#ffffe0',
        lime: '#00ff00',
        limegreen: '#32cd32',
        linen: '#faf0e6',
        magenta: '#ff00ff',
        maroon: '#800000',
        mediumaquamarine: '#66cdaa',
        mediumblue: '#0000cd',
        mediumorchid: '#ba55d3',
        mediumpurple: '#9370db',
        mediumseagreen: '#3cb371',
        mediumslateblue: '#7b68ee',
        mediumspringgreen: '#00fa9a',
        mediumturquoise: '#48d1cc',
        mediumvioletred: '#c71585',
        midnightblue: '#191970',
        mintcream: '#f5fffa',
        mistyrose: '#ffe4e1',
        moccasin: '#ffe4b5',
        navajowhite: '#ffdead',
        navy: '#000080',
        oldlace: '#fdf5e6',
        olive: '#808000',
        olivedrab: '#6b8e23',
        orange: '#ffa500',
        orangered: '#ff4500',
        orchid: '#da70d6',
        palegoldenrod: '#eee8aa',
        palegreen: '#98fb98',
        paleturquoise: '#afeeee',
        palevioletred: '#db7093',
        papayawhip: '#ffefd5',
        peachpuff: '#ffdab9',
        peru: '#cd853f',
        pink: '#ffc0cb',
        plum: '#dda0dd',
        powderblue: '#b0e0e6',
        purple: '#800080',
        rebeccapurple: '#663399',
        red: '#ff0000',
        rosybrown: '#bc8f8f',
        royalblue: '#4169e1',
        saddlebrown: '#8b4513',
        salmon: '#fa8072',
        sandybrown: '#f4a460',
        seagreen: '#2e8b57',
        seashell: '#fff5ee',
        sienna: '#a0522d',
        silver: '#c0c0c0',
        skyblue: '#87ceeb',
        slateblue: '#6a5acd',
        slategray: '#708090',
        slategrey: '#708090',
        snow: '#fffafa',
        springgreen: '#00ff7f',
        tan: '#d2b48c',
        teal: '#008080',
        thistle: '#d8bfd8',
        transparent: '#00000000',
        turquoise: '#40e0d0',
        violet: '#ee82ee',
        wheat: '#f5deb3',
        white: '#ffffff',
        whitesmoke: '#f5f5f5',
        yellow: '#ffff00',
        yellowgreen: '#9acd32'
    },
    /* API */
    parse: (color) => {
        color = color.toLowerCase();
        const hex = Keyword.colors[color];
        if (!hex)
            return;
        return Hex.parse(hex);
    },
    stringify: (channels) => {
        const hex = Hex.stringify(channels);
        for (const name in Keyword.colors) {
            if (Keyword.colors[name] === hex)
                return name;
        }
        return;
    }
};

/* IMPORT */
/* MAIN */
const RGB = {
    /* VARIABLES */
    re: /^rgba?\(\s*?(-?(?:\d+(?:\.\d+)?|(?:\.\d+))(?:e\d+)?(%?))\s*?(?:,|\s)\s*?(-?(?:\d+(?:\.\d+)?|(?:\.\d+))(?:e\d+)?(%?))\s*?(?:,|\s)\s*?(-?(?:\d+(?:\.\d+)?|(?:\.\d+))(?:e\d+)?(%?))(?:\s*?(?:,|\/)\s*?\+?(-?(?:\d+(?:\.\d+)?|(?:\.\d+))(?:e\d+)?(%?)))?\s*?\)$/i,
    /* API */
    parse: (color) => {
        const charCode = color.charCodeAt(0);
        if (charCode !== 114 && charCode !== 82)
            return; // 'r'/'R'
        const match = color.match(RGB.re);
        if (!match)
            return;
        const [, r, isRedPercentage, g, isGreenPercentage, b, isBluePercentage, a, isAlphaPercentage] = match;
        return channels.set({
            r: Utils.channel.clamp.r(isRedPercentage ? parseFloat(r) * 2.55 : parseFloat(r)),
            g: Utils.channel.clamp.g(isGreenPercentage ? parseFloat(g) * 2.55 : parseFloat(g)),
            b: Utils.channel.clamp.b(isBluePercentage ? parseFloat(b) * 2.55 : parseFloat(b)),
            a: a ? Utils.channel.clamp.a(isAlphaPercentage ? parseFloat(a) / 100 : parseFloat(a)) : 1
        }, color);
    },
    stringify: (channels) => {
        const { r, g, b, a } = channels;
        if (a < 1) { // RGBA
            return `rgba(${Utils.lang.round(r)}, ${Utils.lang.round(g)}, ${Utils.lang.round(b)}, ${Utils.lang.round(a)})`;
        }
        else { // RGB
            return `rgb(${Utils.lang.round(r)}, ${Utils.lang.round(g)}, ${Utils.lang.round(b)})`;
        }
    }
};

/* IMPORT */
/* MAIN */
const Color$1 = {
    /* VARIABLES */
    format: {
        keyword: Keyword,
        hex: Hex,
        rgb: RGB,
        rgba: RGB,
        hsl: HSL,
        hsla: HSL
    },
    /* API */
    parse: (color) => {
        if (typeof color !== 'string')
            return color;
        const channels = Hex.parse(color) || RGB.parse(color) || HSL.parse(color) || Keyword.parse(color); // Color providers ordered with performance in mind
        if (channels)
            return channels;
        throw new Error(`Unsupported color format: "${color}"`);
    },
    stringify: (channels) => {
        // SASS returns a keyword if possible, but we avoid doing that as it's slower and doesn't really add any value
        if (!channels.changed && channels.color)
            return channels.color;
        if (channels.type.is(TYPE.HSL) || channels.data.r === undefined) {
            return HSL.stringify(channels);
        }
        else if (channels.a < 1 || !Number.isInteger(channels.r) || !Number.isInteger(channels.g) || !Number.isInteger(channels.b)) {
            return RGB.stringify(channels);
        }
        else {
            return Hex.stringify(channels);
        }
    }
};

/* IMPORT */
/* MAIN */
const change = (color, channels) => {
    const ch = Color$1.parse(color);
    for (const c in channels) {
        ch[c] = Utils.channel.clamp[c](channels[c]);
    }
    return Color$1.stringify(ch);
};

/* IMPORT */
/* MAIN */
const rgba$1 = (r, g, b = 0, a = 1) => {
    if (typeof r !== 'number')
        return change(r, { a: g });
    const channels$1 = channels.set({
        r: Utils.channel.clamp.r(r),
        g: Utils.channel.clamp.g(g),
        b: Utils.channel.clamp.b(b),
        a: Utils.channel.clamp.a(a)
    });
    return Color$1.stringify(channels$1);
};

/* IMPORT */
/* MAIN */
//SOURCE: https://planetcalc.com/7779
const luminance = (color) => {
    const { r, g, b } = Color$1.parse(color);
    const luminance = .2126 * Utils.channel.toLinear(r) + .7152 * Utils.channel.toLinear(g) + .0722 * Utils.channel.toLinear(b);
    return Utils.lang.round(luminance);
};

/* IMPORT */
/* MAIN */
const isLight = (color) => {
    return luminance(color) >= .5;
};

/* IMPORT */
/* MAIN */
const isDark = (color) => {
    return !isLight(color);
};

/* IMPORT */
/* MAIN */
const adjustChannel = (color, channel, amount) => {
    const channels = Color$1.parse(color);
    const amountCurrent = channels[channel];
    const amountNext = Utils.channel.clamp[channel](amountCurrent + amount);
    if (amountCurrent !== amountNext)
        channels[channel] = amountNext;
    return Color$1.stringify(channels);
};

/* IMPORT */
/* MAIN */
const lighten = (color, amount) => {
    return adjustChannel(color, 'l', amount);
};

/* IMPORT */
/* MAIN */
const darken = (color, amount) => {
    return adjustChannel(color, 'l', -amount);
};

/* IMPORT */
/* MAIN */
const adjust = (color, channels) => {
    const ch = Color$1.parse(color);
    const changes = {};
    for (const c in channels) {
        if (!channels[c])
            continue;
        changes[c] = ch[c] + channels[c];
    }
    return change(color, changes);
};

/* IMPORT */
/* MAIN */
//SOURCE: https://github.com/sass/dart-sass/blob/7457d2e9e7e623d9844ffd037a070cf32d39c348/lib/src/functions/color.dart#L718-L756
const mix = (color1, color2, weight = 50) => {
    const { r: r1, g: g1, b: b1, a: a1 } = Color$1.parse(color1);
    const { r: r2, g: g2, b: b2, a: a2 } = Color$1.parse(color2);
    const weightScale = weight / 100;
    const weightNormalized = (weightScale * 2) - 1;
    const alphaDelta = a1 - a2;
    const weight1combined = ((weightNormalized * alphaDelta) === -1) ? weightNormalized : (weightNormalized + alphaDelta) / (1 + weightNormalized * alphaDelta);
    const weight1 = (weight1combined + 1) / 2;
    const weight2 = 1 - weight1;
    const r = (r1 * weight1) + (r2 * weight2);
    const g = (g1 * weight1) + (g2 * weight2);
    const b = (b1 * weight1) + (b2 * weight2);
    const a = (a1 * weightScale) + (a2 * (1 - weightScale));
    return rgba$1(r, g, b, a);
};

/* IMPORT */
/* MAIN */
const invert = (color, weight = 100) => {
    const inverse = Color$1.parse(color);
    inverse.r = 255 - inverse.r;
    inverse.g = 255 - inverse.g;
    inverse.b = 255 - inverse.b;
    return mix(inverse, color, weight);
};

/*! @license DOMPurify 3.2.6 | (c) Cure53 and other contributors | Released under the Apache license 2.0 and Mozilla Public License 2.0 | github.com/cure53/DOMPurify/blob/3.2.6/LICENSE */

const {
  entries,
  setPrototypeOf,
  isFrozen,
  getPrototypeOf,
  getOwnPropertyDescriptor
} = Object;
let {
  freeze,
  seal,
  create: create$1
} = Object; // eslint-disable-line import/no-mutable-exports
let {
  apply: apply$1,
  construct
} = typeof Reflect !== 'undefined' && Reflect;
if (!freeze) {
  freeze = function freeze(x) {
    return x;
  };
}
if (!seal) {
  seal = function seal(x) {
    return x;
  };
}
if (!apply$1) {
  apply$1 = function apply(fun, thisValue, args) {
    return fun.apply(thisValue, args);
  };
}
if (!construct) {
  construct = function construct(Func, args) {
    return new Func(...args);
  };
}
const arrayForEach = unapply(Array.prototype.forEach);
const arrayLastIndexOf = unapply(Array.prototype.lastIndexOf);
const arrayPop = unapply(Array.prototype.pop);
const arrayPush = unapply(Array.prototype.push);
const arraySplice = unapply(Array.prototype.splice);
const stringToLowerCase = unapply(String.prototype.toLowerCase);
const stringToString = unapply(String.prototype.toString);
const stringMatch = unapply(String.prototype.match);
const stringReplace = unapply(String.prototype.replace);
const stringIndexOf = unapply(String.prototype.indexOf);
const stringTrim = unapply(String.prototype.trim);
const objectHasOwnProperty = unapply(Object.prototype.hasOwnProperty);
const regExpTest = unapply(RegExp.prototype.test);
const typeErrorCreate = unconstruct(TypeError);
/**
 * Creates a new function that calls the given function with a specified thisArg and arguments.
 *
 * @param func - The function to be wrapped and called.
 * @returns A new function that calls the given function with a specified thisArg and arguments.
 */
function unapply(func) {
  return function (thisArg) {
    if (thisArg instanceof RegExp) {
      thisArg.lastIndex = 0;
    }
    for (var _len = arguments.length, args = new Array(_len > 1 ? _len - 1 : 0), _key = 1; _key < _len; _key++) {
      args[_key - 1] = arguments[_key];
    }
    return apply$1(func, thisArg, args);
  };
}
/**
 * Creates a new function that constructs an instance of the given constructor function with the provided arguments.
 *
 * @param func - The constructor function to be wrapped and called.
 * @returns A new function that constructs an instance of the given constructor function with the provided arguments.
 */
function unconstruct(func) {
  return function () {
    for (var _len2 = arguments.length, args = new Array(_len2), _key2 = 0; _key2 < _len2; _key2++) {
      args[_key2] = arguments[_key2];
    }
    return construct(func, args);
  };
}
/**
 * Add properties to a lookup table
 *
 * @param set - The set to which elements will be added.
 * @param array - The array containing elements to be added to the set.
 * @param transformCaseFunc - An optional function to transform the case of each element before adding to the set.
 * @returns The modified set with added elements.
 */
function addToSet(set, array) {
  let transformCaseFunc = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : stringToLowerCase;
  if (setPrototypeOf) {
    // Make 'in' and truthy checks like Boolean(set.constructor)
    // independent of any properties defined on Object.prototype.
    // Prevent prototype setters from intercepting set as a this value.
    setPrototypeOf(set, null);
  }
  let l = array.length;
  while (l--) {
    let element = array[l];
    if (typeof element === 'string') {
      const lcElement = transformCaseFunc(element);
      if (lcElement !== element) {
        // Config presets (e.g. tags.js, attrs.js) are immutable.
        if (!isFrozen(array)) {
          array[l] = lcElement;
        }
        element = lcElement;
      }
    }
    set[element] = true;
  }
  return set;
}
/**
 * Clean up an array to harden against CSPP
 *
 * @param array - The array to be cleaned.
 * @returns The cleaned version of the array
 */
function cleanArray(array) {
  for (let index = 0; index < array.length; index++) {
    const isPropertyExist = objectHasOwnProperty(array, index);
    if (!isPropertyExist) {
      array[index] = null;
    }
  }
  return array;
}
/**
 * Shallow clone an object
 *
 * @param object - The object to be cloned.
 * @returns A new object that copies the original.
 */
function clone(object) {
  const newObject = create$1(null);
  for (const [property, value] of entries(object)) {
    const isPropertyExist = objectHasOwnProperty(object, property);
    if (isPropertyExist) {
      if (Array.isArray(value)) {
        newObject[property] = cleanArray(value);
      } else if (value && typeof value === 'object' && value.constructor === Object) {
        newObject[property] = clone(value);
      } else {
        newObject[property] = value;
      }
    }
  }
  return newObject;
}
/**
 * This method automatically checks if the prop is function or getter and behaves accordingly.
 *
 * @param object - The object to look up the getter function in its prototype chain.
 * @param prop - The property name for which to find the getter function.
 * @returns The getter function found in the prototype chain or a fallback function.
 */
function lookupGetter(object, prop) {
  while (object !== null) {
    const desc = getOwnPropertyDescriptor(object, prop);
    if (desc) {
      if (desc.get) {
        return unapply(desc.get);
      }
      if (typeof desc.value === 'function') {
        return unapply(desc.value);
      }
    }
    object = getPrototypeOf(object);
  }
  function fallbackValue() {
    return null;
  }
  return fallbackValue;
}

const html$1 = freeze(['a', 'abbr', 'acronym', 'address', 'area', 'article', 'aside', 'audio', 'b', 'bdi', 'bdo', 'big', 'blink', 'blockquote', 'body', 'br', 'button', 'canvas', 'caption', 'center', 'cite', 'code', 'col', 'colgroup', 'content', 'data', 'datalist', 'dd', 'decorator', 'del', 'details', 'dfn', 'dialog', 'dir', 'div', 'dl', 'dt', 'element', 'em', 'fieldset', 'figcaption', 'figure', 'font', 'footer', 'form', 'h1', 'h2', 'h3', 'h4', 'h5', 'h6', 'head', 'header', 'hgroup', 'hr', 'html', 'i', 'img', 'input', 'ins', 'kbd', 'label', 'legend', 'li', 'main', 'map', 'mark', 'marquee', 'menu', 'menuitem', 'meter', 'nav', 'nobr', 'ol', 'optgroup', 'option', 'output', 'p', 'picture', 'pre', 'progress', 'q', 'rp', 'rt', 'ruby', 's', 'samp', 'section', 'select', 'shadow', 'small', 'source', 'spacer', 'span', 'strike', 'strong', 'style', 'sub', 'summary', 'sup', 'table', 'tbody', 'td', 'template', 'textarea', 'tfoot', 'th', 'thead', 'time', 'tr', 'track', 'tt', 'u', 'ul', 'var', 'video', 'wbr']);
const svg$1 = freeze(['svg', 'a', 'altglyph', 'altglyphdef', 'altglyphitem', 'animatecolor', 'animatemotion', 'animatetransform', 'circle', 'clippath', 'defs', 'desc', 'ellipse', 'filter', 'font', 'g', 'glyph', 'glyphref', 'hkern', 'image', 'line', 'lineargradient', 'marker', 'mask', 'metadata', 'mpath', 'path', 'pattern', 'polygon', 'polyline', 'radialgradient', 'rect', 'stop', 'style', 'switch', 'symbol', 'text', 'textpath', 'title', 'tref', 'tspan', 'view', 'vkern']);
const svgFilters = freeze(['feBlend', 'feColorMatrix', 'feComponentTransfer', 'feComposite', 'feConvolveMatrix', 'feDiffuseLighting', 'feDisplacementMap', 'feDistantLight', 'feDropShadow', 'feFlood', 'feFuncA', 'feFuncB', 'feFuncG', 'feFuncR', 'feGaussianBlur', 'feImage', 'feMerge', 'feMergeNode', 'feMorphology', 'feOffset', 'fePointLight', 'feSpecularLighting', 'feSpotLight', 'feTile', 'feTurbulence']);
// List of SVG elements that are disallowed by default.
// We still need to know them so that we can do namespace
// checks properly in case one wants to add them to
// allow-list.
const svgDisallowed = freeze(['animate', 'color-profile', 'cursor', 'discard', 'font-face', 'font-face-format', 'font-face-name', 'font-face-src', 'font-face-uri', 'foreignobject', 'hatch', 'hatchpath', 'mesh', 'meshgradient', 'meshpatch', 'meshrow', 'missing-glyph', 'script', 'set', 'solidcolor', 'unknown', 'use']);
const mathMl$1 = freeze(['math', 'menclose', 'merror', 'mfenced', 'mfrac', 'mglyph', 'mi', 'mlabeledtr', 'mmultiscripts', 'mn', 'mo', 'mover', 'mpadded', 'mphantom', 'mroot', 'mrow', 'ms', 'mspace', 'msqrt', 'mstyle', 'msub', 'msup', 'msubsup', 'mtable', 'mtd', 'mtext', 'mtr', 'munder', 'munderover', 'mprescripts']);
// Similarly to SVG, we want to know all MathML elements,
// even those that we disallow by default.
const mathMlDisallowed = freeze(['maction', 'maligngroup', 'malignmark', 'mlongdiv', 'mscarries', 'mscarry', 'msgroup', 'mstack', 'msline', 'msrow', 'semantics', 'annotation', 'annotation-xml', 'mprescripts', 'none']);
const text$1 = freeze(['#text']);

const html = freeze(['accept', 'action', 'align', 'alt', 'autocapitalize', 'autocomplete', 'autopictureinpicture', 'autoplay', 'background', 'bgcolor', 'border', 'capture', 'cellpadding', 'cellspacing', 'checked', 'cite', 'class', 'clear', 'color', 'cols', 'colspan', 'controls', 'controlslist', 'coords', 'crossorigin', 'datetime', 'decoding', 'default', 'dir', 'disabled', 'disablepictureinpicture', 'disableremoteplayback', 'download', 'draggable', 'enctype', 'enterkeyhint', 'face', 'for', 'headers', 'height', 'hidden', 'high', 'href', 'hreflang', 'id', 'inputmode', 'integrity', 'ismap', 'kind', 'label', 'lang', 'list', 'loading', 'loop', 'low', 'max', 'maxlength', 'media', 'method', 'min', 'minlength', 'multiple', 'muted', 'name', 'nonce', 'noshade', 'novalidate', 'nowrap', 'open', 'optimum', 'pattern', 'placeholder', 'playsinline', 'popover', 'popovertarget', 'popovertargetaction', 'poster', 'preload', 'pubdate', 'radiogroup', 'readonly', 'rel', 'required', 'rev', 'reversed', 'role', 'rows', 'rowspan', 'spellcheck', 'scope', 'selected', 'shape', 'size', 'sizes', 'span', 'srclang', 'start', 'src', 'srcset', 'step', 'style', 'summary', 'tabindex', 'title', 'translate', 'type', 'usemap', 'valign', 'value', 'width', 'wrap', 'xmlns', 'slot']);
const svg = freeze(['accent-height', 'accumulate', 'additive', 'alignment-baseline', 'amplitude', 'ascent', 'attributename', 'attributetype', 'azimuth', 'basefrequency', 'baseline-shift', 'begin', 'bias', 'by', 'class', 'clip', 'clippathunits', 'clip-path', 'clip-rule', 'color', 'color-interpolation', 'color-interpolation-filters', 'color-profile', 'color-rendering', 'cx', 'cy', 'd', 'dx', 'dy', 'diffuseconstant', 'direction', 'display', 'divisor', 'dur', 'edgemode', 'elevation', 'end', 'exponent', 'fill', 'fill-opacity', 'fill-rule', 'filter', 'filterunits', 'flood-color', 'flood-opacity', 'font-family', 'font-size', 'font-size-adjust', 'font-stretch', 'font-style', 'font-variant', 'font-weight', 'fx', 'fy', 'g1', 'g2', 'glyph-name', 'glyphref', 'gradientunits', 'gradienttransform', 'height', 'href', 'id', 'image-rendering', 'in', 'in2', 'intercept', 'k', 'k1', 'k2', 'k3', 'k4', 'kerning', 'keypoints', 'keysplines', 'keytimes', 'lang', 'lengthadjust', 'letter-spacing', 'kernelmatrix', 'kernelunitlength', 'lighting-color', 'local', 'marker-end', 'marker-mid', 'marker-start', 'markerheight', 'markerunits', 'markerwidth', 'maskcontentunits', 'maskunits', 'max', 'mask', 'media', 'method', 'mode', 'min', 'name', 'numoctaves', 'offset', 'operator', 'opacity', 'order', 'orient', 'orientation', 'origin', 'overflow', 'paint-order', 'path', 'pathlength', 'patterncontentunits', 'patterntransform', 'patternunits', 'points', 'preservealpha', 'preserveaspectratio', 'primitiveunits', 'r', 'rx', 'ry', 'radius', 'refx', 'refy', 'repeatcount', 'repeatdur', 'restart', 'result', 'rotate', 'scale', 'seed', 'shape-rendering', 'slope', 'specularconstant', 'specularexponent', 'spreadmethod', 'startoffset', 'stddeviation', 'stitchtiles', 'stop-color', 'stop-opacity', 'stroke-dasharray', 'stroke-dashoffset', 'stroke-linecap', 'stroke-linejoin', 'stroke-miterlimit', 'stroke-opacity', 'stroke', 'stroke-width', 'style', 'surfacescale', 'systemlanguage', 'tabindex', 'tablevalues', 'targetx', 'targety', 'transform', 'transform-origin', 'text-anchor', 'text-decoration', 'text-rendering', 'textlength', 'type', 'u1', 'u2', 'unicode', 'values', 'viewbox', 'visibility', 'version', 'vert-adv-y', 'vert-origin-x', 'vert-origin-y', 'width', 'word-spacing', 'wrap', 'writing-mode', 'xchannelselector', 'ychannelselector', 'x', 'x1', 'x2', 'xmlns', 'y', 'y1', 'y2', 'z', 'zoomandpan']);
const mathMl = freeze(['accent', 'accentunder', 'align', 'bevelled', 'close', 'columnsalign', 'columnlines', 'columnspan', 'denomalign', 'depth', 'dir', 'display', 'displaystyle', 'encoding', 'fence', 'frame', 'height', 'href', 'id', 'largeop', 'length', 'linethickness', 'lspace', 'lquote', 'mathbackground', 'mathcolor', 'mathsize', 'mathvariant', 'maxsize', 'minsize', 'movablelimits', 'notation', 'numalign', 'open', 'rowalign', 'rowlines', 'rowspacing', 'rowspan', 'rspace', 'rquote', 'scriptlevel', 'scriptminsize', 'scriptsizemultiplier', 'selection', 'separator', 'separators', 'stretchy', 'subscriptshift', 'supscriptshift', 'symmetric', 'voffset', 'width', 'xmlns']);
const xml = freeze(['xlink:href', 'xml:id', 'xlink:title', 'xml:space', 'xmlns:xlink']);

// eslint-disable-next-line unicorn/better-regex
const MUSTACHE_EXPR = seal(/\{\{[\w\W]*|[\w\W]*\}\}/gm); // Specify template detection regex for SAFE_FOR_TEMPLATES mode
const ERB_EXPR = seal(/<%[\w\W]*|[\w\W]*%>/gm);
const TMPLIT_EXPR = seal(/\$\{[\w\W]*/gm); // eslint-disable-line unicorn/better-regex
const DATA_ATTR = seal(/^data-[\-\w.\u00B7-\uFFFF]+$/); // eslint-disable-line no-useless-escape
const ARIA_ATTR = seal(/^aria-[\-\w]+$/); // eslint-disable-line no-useless-escape
const IS_ALLOWED_URI = seal(/^(?:(?:(?:f|ht)tps?|mailto|tel|callto|sms|cid|xmpp|matrix):|[^a-z]|[a-z+.\-]+(?:[^a-z+.\-:]|$))/i // eslint-disable-line no-useless-escape
);
const IS_SCRIPT_OR_DATA = seal(/^(?:\w+script|data):/i);
const ATTR_WHITESPACE = seal(/[\u0000-\u0020\u00A0\u1680\u180E\u2000-\u2029\u205F\u3000]/g // eslint-disable-line no-control-regex
);
const DOCTYPE_NAME = seal(/^html$/i);
const CUSTOM_ELEMENT = seal(/^[a-z][.\w]*(-[.\w]+)+$/i);

var EXPRESSIONS = /*#__PURE__*/Object.freeze({
  __proto__: null,
  ARIA_ATTR: ARIA_ATTR,
  ATTR_WHITESPACE: ATTR_WHITESPACE,
  CUSTOM_ELEMENT: CUSTOM_ELEMENT,
  DATA_ATTR: DATA_ATTR,
  DOCTYPE_NAME: DOCTYPE_NAME,
  ERB_EXPR: ERB_EXPR,
  IS_ALLOWED_URI: IS_ALLOWED_URI,
  IS_SCRIPT_OR_DATA: IS_SCRIPT_OR_DATA,
  MUSTACHE_EXPR: MUSTACHE_EXPR,
  TMPLIT_EXPR: TMPLIT_EXPR
});

/* eslint-disable @typescript-eslint/indent */
// https://developer.mozilla.org/en-US/docs/Web/API/Node/nodeType
const NODE_TYPE = {
  element: 1,
  text: 3,
  // Deprecated
  progressingInstruction: 7,
  comment: 8,
  document: 9};
const getGlobal = function getGlobal() {
  return typeof window === 'undefined' ? null : window;
};
/**
 * Creates a no-op policy for internal use only.
 * Don't export this function outside this module!
 * @param trustedTypes The policy factory.
 * @param purifyHostElement The Script element used to load DOMPurify (to determine policy name suffix).
 * @return The policy created (or null, if Trusted Types
 * are not supported or creating the policy failed).
 */
const _createTrustedTypesPolicy = function _createTrustedTypesPolicy(trustedTypes, purifyHostElement) {
  if (typeof trustedTypes !== 'object' || typeof trustedTypes.createPolicy !== 'function') {
    return null;
  }
  // Allow the callers to control the unique policy name
  // by adding a data-tt-policy-suffix to the script element with the DOMPurify.
  // Policy creation with duplicate names throws in Trusted Types.
  let suffix = null;
  const ATTR_NAME = 'data-tt-policy-suffix';
  if (purifyHostElement && purifyHostElement.hasAttribute(ATTR_NAME)) {
    suffix = purifyHostElement.getAttribute(ATTR_NAME);
  }
  const policyName = 'dompurify' + (suffix ? '#' + suffix : '');
  try {
    return trustedTypes.createPolicy(policyName, {
      createHTML(html) {
        return html;
      },
      createScriptURL(scriptUrl) {
        return scriptUrl;
      }
    });
  } catch (_) {
    // Policy creation failed (most likely another DOMPurify script has
    // already run). Skip creating the policy, as this will only cause errors
    // if TT are enforced.
    console.warn('TrustedTypes policy ' + policyName + ' could not be created.');
    return null;
  }
};
const _createHooksMap = function _createHooksMap() {
  return {
    afterSanitizeAttributes: [],
    afterSanitizeElements: [],
    afterSanitizeShadowDOM: [],
    beforeSanitizeAttributes: [],
    beforeSanitizeElements: [],
    beforeSanitizeShadowDOM: [],
    uponSanitizeAttribute: [],
    uponSanitizeElement: [],
    uponSanitizeShadowNode: []
  };
};
function createDOMPurify() {
  let window = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : getGlobal();
  const DOMPurify = root => createDOMPurify(root);
  DOMPurify.version = '3.2.6';
  DOMPurify.removed = [];
  if (!window || !window.document || window.document.nodeType !== NODE_TYPE.document || !window.Element) {
    // Not running in a browser, provide a factory function
    // so that you can pass your own Window
    DOMPurify.isSupported = false;
    return DOMPurify;
  }
  let {
    document
  } = window;
  const originalDocument = document;
  const currentScript = originalDocument.currentScript;
  const {
    DocumentFragment,
    HTMLTemplateElement,
    Node,
    Element,
    NodeFilter,
    NamedNodeMap = window.NamedNodeMap || window.MozNamedAttrMap,
    HTMLFormElement,
    DOMParser,
    trustedTypes
  } = window;
  const ElementPrototype = Element.prototype;
  const cloneNode = lookupGetter(ElementPrototype, 'cloneNode');
  const remove = lookupGetter(ElementPrototype, 'remove');
  const getNextSibling = lookupGetter(ElementPrototype, 'nextSibling');
  const getChildNodes = lookupGetter(ElementPrototype, 'childNodes');
  const getParentNode = lookupGetter(ElementPrototype, 'parentNode');
  // As per issue #47, the web-components registry is inherited by a
  // new document created via createHTMLDocument. As per the spec
  // (http://w3c.github.io/webcomponents/spec/custom/#creating-and-passing-registries)
  // a new empty registry is used when creating a template contents owner
  // document, so we use that as our parent document to ensure nothing
  // is inherited.
  if (typeof HTMLTemplateElement === 'function') {
    const template = document.createElement('template');
    if (template.content && template.content.ownerDocument) {
      document = template.content.ownerDocument;
    }
  }
  let trustedTypesPolicy;
  let emptyHTML = '';
  const {
    implementation,
    createNodeIterator,
    createDocumentFragment,
    getElementsByTagName
  } = document;
  const {
    importNode
  } = originalDocument;
  let hooks = _createHooksMap();
  /**
   * Expose whether this browser supports running the full DOMPurify.
   */
  DOMPurify.isSupported = typeof entries === 'function' && typeof getParentNode === 'function' && implementation && implementation.createHTMLDocument !== undefined;
  const {
    MUSTACHE_EXPR,
    ERB_EXPR,
    TMPLIT_EXPR,
    DATA_ATTR,
    ARIA_ATTR,
    IS_SCRIPT_OR_DATA,
    ATTR_WHITESPACE,
    CUSTOM_ELEMENT
  } = EXPRESSIONS;
  let {
    IS_ALLOWED_URI: IS_ALLOWED_URI$1
  } = EXPRESSIONS;
  /**
   * We consider the elements and attributes below to be safe. Ideally
   * don't add any new ones but feel free to remove unwanted ones.
   */
  /* allowed element names */
  let ALLOWED_TAGS = null;
  const DEFAULT_ALLOWED_TAGS = addToSet({}, [...html$1, ...svg$1, ...svgFilters, ...mathMl$1, ...text$1]);
  /* Allowed attribute names */
  let ALLOWED_ATTR = null;
  const DEFAULT_ALLOWED_ATTR = addToSet({}, [...html, ...svg, ...mathMl, ...xml]);
  /*
   * Configure how DOMPurify should handle custom elements and their attributes as well as customized built-in elements.
   * @property {RegExp|Function|null} tagNameCheck one of [null, regexPattern, predicate]. Default: `null` (disallow any custom elements)
   * @property {RegExp|Function|null} attributeNameCheck one of [null, regexPattern, predicate]. Default: `null` (disallow any attributes not on the allow list)
   * @property {boolean} allowCustomizedBuiltInElements allow custom elements derived from built-ins if they pass CUSTOM_ELEMENT_HANDLING.tagNameCheck. Default: `false`.
   */
  let CUSTOM_ELEMENT_HANDLING = Object.seal(create$1(null, {
    tagNameCheck: {
      writable: true,
      configurable: false,
      enumerable: true,
      value: null
    },
    attributeNameCheck: {
      writable: true,
      configurable: false,
      enumerable: true,
      value: null
    },
    allowCustomizedBuiltInElements: {
      writable: true,
      configurable: false,
      enumerable: true,
      value: false
    }
  }));
  /* Explicitly forbidden tags (overrides ALLOWED_TAGS/ADD_TAGS) */
  let FORBID_TAGS = null;
  /* Explicitly forbidden attributes (overrides ALLOWED_ATTR/ADD_ATTR) */
  let FORBID_ATTR = null;
  /* Decide if ARIA attributes are okay */
  let ALLOW_ARIA_ATTR = true;
  /* Decide if custom data attributes are okay */
  let ALLOW_DATA_ATTR = true;
  /* Decide if unknown protocols are okay */
  let ALLOW_UNKNOWN_PROTOCOLS = false;
  /* Decide if self-closing tags in attributes are allowed.
   * Usually removed due to a mXSS issue in jQuery 3.0 */
  let ALLOW_SELF_CLOSE_IN_ATTR = true;
  /* Output should be safe for common template engines.
   * This means, DOMPurify removes data attributes, mustaches and ERB
   */
  let SAFE_FOR_TEMPLATES = false;
  /* Output should be safe even for XML used within HTML and alike.
   * This means, DOMPurify removes comments when containing risky content.
   */
  let SAFE_FOR_XML = true;
  /* Decide if document with <html>... should be returned */
  let WHOLE_DOCUMENT = false;
  /* Track whether config is already set on this instance of DOMPurify. */
  let SET_CONFIG = false;
  /* Decide if all elements (e.g. style, script) must be children of
   * document.body. By default, browsers might move them to document.head */
  let FORCE_BODY = false;
  /* Decide if a DOM `HTMLBodyElement` should be returned, instead of a html
   * string (or a TrustedHTML object if Trusted Types are supported).
   * If `WHOLE_DOCUMENT` is enabled a `HTMLHtmlElement` will be returned instead
   */
  let RETURN_DOM = false;
  /* Decide if a DOM `DocumentFragment` should be returned, instead of a html
   * string  (or a TrustedHTML object if Trusted Types are supported) */
  let RETURN_DOM_FRAGMENT = false;
  /* Try to return a Trusted Type object instead of a string, return a string in
   * case Trusted Types are not supported  */
  let RETURN_TRUSTED_TYPE = false;
  /* Output should be free from DOM clobbering attacks?
   * This sanitizes markups named with colliding, clobberable built-in DOM APIs.
   */
  let SANITIZE_DOM = true;
  /* Achieve full DOM Clobbering protection by isolating the namespace of named
   * properties and JS variables, mitigating attacks that abuse the HTML/DOM spec rules.
   *
   * HTML/DOM spec rules that enable DOM Clobbering:
   *   - Named Access on Window (§7.3.3)
   *   - DOM Tree Accessors (§3.1.5)
   *   - Form Element Parent-Child Relations (§4.10.3)
   *   - Iframe srcdoc / Nested WindowProxies (§4.8.5)
   *   - HTMLCollection (§4.2.10.2)
   *
   * Namespace isolation is implemented by prefixing `id` and `name` attributes
   * with a constant string, i.e., `user-content-`
   */
  let SANITIZE_NAMED_PROPS = false;
  const SANITIZE_NAMED_PROPS_PREFIX = 'user-content-';
  /* Keep element content when removing element? */
  let KEEP_CONTENT = true;
  /* If a `Node` is passed to sanitize(), then performs sanitization in-place instead
   * of importing it into a new Document and returning a sanitized copy */
  let IN_PLACE = false;
  /* Allow usage of profiles like html, svg and mathMl */
  let USE_PROFILES = {};
  /* Tags to ignore content of when KEEP_CONTENT is true */
  let FORBID_CONTENTS = null;
  const DEFAULT_FORBID_CONTENTS = addToSet({}, ['annotation-xml', 'audio', 'colgroup', 'desc', 'foreignobject', 'head', 'iframe', 'math', 'mi', 'mn', 'mo', 'ms', 'mtext', 'noembed', 'noframes', 'noscript', 'plaintext', 'script', 'style', 'svg', 'template', 'thead', 'title', 'video', 'xmp']);
  /* Tags that are safe for data: URIs */
  let DATA_URI_TAGS = null;
  const DEFAULT_DATA_URI_TAGS = addToSet({}, ['audio', 'video', 'img', 'source', 'image', 'track']);
  /* Attributes safe for values like "javascript:" */
  let URI_SAFE_ATTRIBUTES = null;
  const DEFAULT_URI_SAFE_ATTRIBUTES = addToSet({}, ['alt', 'class', 'for', 'id', 'label', 'name', 'pattern', 'placeholder', 'role', 'summary', 'title', 'value', 'style', 'xmlns']);
  const MATHML_NAMESPACE = 'http://www.w3.org/1998/Math/MathML';
  const SVG_NAMESPACE = 'http://www.w3.org/2000/svg';
  const HTML_NAMESPACE = 'http://www.w3.org/1999/xhtml';
  /* Document namespace */
  let NAMESPACE = HTML_NAMESPACE;
  let IS_EMPTY_INPUT = false;
  /* Allowed XHTML+XML namespaces */
  let ALLOWED_NAMESPACES = null;
  const DEFAULT_ALLOWED_NAMESPACES = addToSet({}, [MATHML_NAMESPACE, SVG_NAMESPACE, HTML_NAMESPACE], stringToString);
  let MATHML_TEXT_INTEGRATION_POINTS = addToSet({}, ['mi', 'mo', 'mn', 'ms', 'mtext']);
  let HTML_INTEGRATION_POINTS = addToSet({}, ['annotation-xml']);
  // Certain elements are allowed in both SVG and HTML
  // namespace. We need to specify them explicitly
  // so that they don't get erroneously deleted from
  // HTML namespace.
  const COMMON_SVG_AND_HTML_ELEMENTS = addToSet({}, ['title', 'style', 'font', 'a', 'script']);
  /* Parsing of strict XHTML documents */
  let PARSER_MEDIA_TYPE = null;
  const SUPPORTED_PARSER_MEDIA_TYPES = ['application/xhtml+xml', 'text/html'];
  const DEFAULT_PARSER_MEDIA_TYPE = 'text/html';
  let transformCaseFunc = null;
  /* Keep a reference to config to pass to hooks */
  let CONFIG = null;
  /* Ideally, do not touch anything below this line */
  /* ______________________________________________ */
  const formElement = document.createElement('form');
  const isRegexOrFunction = function isRegexOrFunction(testValue) {
    return testValue instanceof RegExp || testValue instanceof Function;
  };
  /**
   * _parseConfig
   *
   * @param cfg optional config literal
   */
  // eslint-disable-next-line complexity
  const _parseConfig = function _parseConfig() {
    let cfg = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : {};
    if (CONFIG && CONFIG === cfg) {
      return;
    }
    /* Shield configuration object from tampering */
    if (!cfg || typeof cfg !== 'object') {
      cfg = {};
    }
    /* Shield configuration object from prototype pollution */
    cfg = clone(cfg);
    PARSER_MEDIA_TYPE =
    // eslint-disable-next-line unicorn/prefer-includes
    SUPPORTED_PARSER_MEDIA_TYPES.indexOf(cfg.PARSER_MEDIA_TYPE) === -1 ? DEFAULT_PARSER_MEDIA_TYPE : cfg.PARSER_MEDIA_TYPE;
    // HTML tags and attributes are not case-sensitive, converting to lowercase. Keeping XHTML as is.
    transformCaseFunc = PARSER_MEDIA_TYPE === 'application/xhtml+xml' ? stringToString : stringToLowerCase;
    /* Set configuration parameters */
    ALLOWED_TAGS = objectHasOwnProperty(cfg, 'ALLOWED_TAGS') ? addToSet({}, cfg.ALLOWED_TAGS, transformCaseFunc) : DEFAULT_ALLOWED_TAGS;
    ALLOWED_ATTR = objectHasOwnProperty(cfg, 'ALLOWED_ATTR') ? addToSet({}, cfg.ALLOWED_ATTR, transformCaseFunc) : DEFAULT_ALLOWED_ATTR;
    ALLOWED_NAMESPACES = objectHasOwnProperty(cfg, 'ALLOWED_NAMESPACES') ? addToSet({}, cfg.ALLOWED_NAMESPACES, stringToString) : DEFAULT_ALLOWED_NAMESPACES;
    URI_SAFE_ATTRIBUTES = objectHasOwnProperty(cfg, 'ADD_URI_SAFE_ATTR') ? addToSet(clone(DEFAULT_URI_SAFE_ATTRIBUTES), cfg.ADD_URI_SAFE_ATTR, transformCaseFunc) : DEFAULT_URI_SAFE_ATTRIBUTES;
    DATA_URI_TAGS = objectHasOwnProperty(cfg, 'ADD_DATA_URI_TAGS') ? addToSet(clone(DEFAULT_DATA_URI_TAGS), cfg.ADD_DATA_URI_TAGS, transformCaseFunc) : DEFAULT_DATA_URI_TAGS;
    FORBID_CONTENTS = objectHasOwnProperty(cfg, 'FORBID_CONTENTS') ? addToSet({}, cfg.FORBID_CONTENTS, transformCaseFunc) : DEFAULT_FORBID_CONTENTS;
    FORBID_TAGS = objectHasOwnProperty(cfg, 'FORBID_TAGS') ? addToSet({}, cfg.FORBID_TAGS, transformCaseFunc) : clone({});
    FORBID_ATTR = objectHasOwnProperty(cfg, 'FORBID_ATTR') ? addToSet({}, cfg.FORBID_ATTR, transformCaseFunc) : clone({});
    USE_PROFILES = objectHasOwnProperty(cfg, 'USE_PROFILES') ? cfg.USE_PROFILES : false;
    ALLOW_ARIA_ATTR = cfg.ALLOW_ARIA_ATTR !== false; // Default true
    ALLOW_DATA_ATTR = cfg.ALLOW_DATA_ATTR !== false; // Default true
    ALLOW_UNKNOWN_PROTOCOLS = cfg.ALLOW_UNKNOWN_PROTOCOLS || false; // Default false
    ALLOW_SELF_CLOSE_IN_ATTR = cfg.ALLOW_SELF_CLOSE_IN_ATTR !== false; // Default true
    SAFE_FOR_TEMPLATES = cfg.SAFE_FOR_TEMPLATES || false; // Default false
    SAFE_FOR_XML = cfg.SAFE_FOR_XML !== false; // Default true
    WHOLE_DOCUMENT = cfg.WHOLE_DOCUMENT || false; // Default false
    RETURN_DOM = cfg.RETURN_DOM || false; // Default false
    RETURN_DOM_FRAGMENT = cfg.RETURN_DOM_FRAGMENT || false; // Default false
    RETURN_TRUSTED_TYPE = cfg.RETURN_TRUSTED_TYPE || false; // Default false
    FORCE_BODY = cfg.FORCE_BODY || false; // Default false
    SANITIZE_DOM = cfg.SANITIZE_DOM !== false; // Default true
    SANITIZE_NAMED_PROPS = cfg.SANITIZE_NAMED_PROPS || false; // Default false
    KEEP_CONTENT = cfg.KEEP_CONTENT !== false; // Default true
    IN_PLACE = cfg.IN_PLACE || false; // Default false
    IS_ALLOWED_URI$1 = cfg.ALLOWED_URI_REGEXP || IS_ALLOWED_URI;
    NAMESPACE = cfg.NAMESPACE || HTML_NAMESPACE;
    MATHML_TEXT_INTEGRATION_POINTS = cfg.MATHML_TEXT_INTEGRATION_POINTS || MATHML_TEXT_INTEGRATION_POINTS;
    HTML_INTEGRATION_POINTS = cfg.HTML_INTEGRATION_POINTS || HTML_INTEGRATION_POINTS;
    CUSTOM_ELEMENT_HANDLING = cfg.CUSTOM_ELEMENT_HANDLING || {};
    if (cfg.CUSTOM_ELEMENT_HANDLING && isRegexOrFunction(cfg.CUSTOM_ELEMENT_HANDLING.tagNameCheck)) {
      CUSTOM_ELEMENT_HANDLING.tagNameCheck = cfg.CUSTOM_ELEMENT_HANDLING.tagNameCheck;
    }
    if (cfg.CUSTOM_ELEMENT_HANDLING && isRegexOrFunction(cfg.CUSTOM_ELEMENT_HANDLING.attributeNameCheck)) {
      CUSTOM_ELEMENT_HANDLING.attributeNameCheck = cfg.CUSTOM_ELEMENT_HANDLING.attributeNameCheck;
    }
    if (cfg.CUSTOM_ELEMENT_HANDLING && typeof cfg.CUSTOM_ELEMENT_HANDLING.allowCustomizedBuiltInElements === 'boolean') {
      CUSTOM_ELEMENT_HANDLING.allowCustomizedBuiltInElements = cfg.CUSTOM_ELEMENT_HANDLING.allowCustomizedBuiltInElements;
    }
    if (SAFE_FOR_TEMPLATES) {
      ALLOW_DATA_ATTR = false;
    }
    if (RETURN_DOM_FRAGMENT) {
      RETURN_DOM = true;
    }
    /* Parse profile info */
    if (USE_PROFILES) {
      ALLOWED_TAGS = addToSet({}, text$1);
      ALLOWED_ATTR = [];
      if (USE_PROFILES.html === true) {
        addToSet(ALLOWED_TAGS, html$1);
        addToSet(ALLOWED_ATTR, html);
      }
      if (USE_PROFILES.svg === true) {
        addToSet(ALLOWED_TAGS, svg$1);
        addToSet(ALLOWED_ATTR, svg);
        addToSet(ALLOWED_ATTR, xml);
      }
      if (USE_PROFILES.svgFilters === true) {
        addToSet(ALLOWED_TAGS, svgFilters);
        addToSet(ALLOWED_ATTR, svg);
        addToSet(ALLOWED_ATTR, xml);
      }
      if (USE_PROFILES.mathMl === true) {
        addToSet(ALLOWED_TAGS, mathMl$1);
        addToSet(ALLOWED_ATTR, mathMl);
        addToSet(ALLOWED_ATTR, xml);
      }
    }
    /* Merge configuration parameters */
    if (cfg.ADD_TAGS) {
      if (ALLOWED_TAGS === DEFAULT_ALLOWED_TAGS) {
        ALLOWED_TAGS = clone(ALLOWED_TAGS);
      }
      addToSet(ALLOWED_TAGS, cfg.ADD_TAGS, transformCaseFunc);
    }
    if (cfg.ADD_ATTR) {
      if (ALLOWED_ATTR === DEFAULT_ALLOWED_ATTR) {
        ALLOWED_ATTR = clone(ALLOWED_ATTR);
      }
      addToSet(ALLOWED_ATTR, cfg.ADD_ATTR, transformCaseFunc);
    }
    if (cfg.ADD_URI_SAFE_ATTR) {
      addToSet(URI_SAFE_ATTRIBUTES, cfg.ADD_URI_SAFE_ATTR, transformCaseFunc);
    }
    if (cfg.FORBID_CONTENTS) {
      if (FORBID_CONTENTS === DEFAULT_FORBID_CONTENTS) {
        FORBID_CONTENTS = clone(FORBID_CONTENTS);
      }
      addToSet(FORBID_CONTENTS, cfg.FORBID_CONTENTS, transformCaseFunc);
    }
    /* Add #text in case KEEP_CONTENT is set to true */
    if (KEEP_CONTENT) {
      ALLOWED_TAGS['#text'] = true;
    }
    /* Add html, head and body to ALLOWED_TAGS in case WHOLE_DOCUMENT is true */
    if (WHOLE_DOCUMENT) {
      addToSet(ALLOWED_TAGS, ['html', 'head', 'body']);
    }
    /* Add tbody to ALLOWED_TAGS in case tables are permitted, see #286, #365 */
    if (ALLOWED_TAGS.table) {
      addToSet(ALLOWED_TAGS, ['tbody']);
      delete FORBID_TAGS.tbody;
    }
    if (cfg.TRUSTED_TYPES_POLICY) {
      if (typeof cfg.TRUSTED_TYPES_POLICY.createHTML !== 'function') {
        throw typeErrorCreate('TRUSTED_TYPES_POLICY configuration option must provide a "createHTML" hook.');
      }
      if (typeof cfg.TRUSTED_TYPES_POLICY.createScriptURL !== 'function') {
        throw typeErrorCreate('TRUSTED_TYPES_POLICY configuration option must provide a "createScriptURL" hook.');
      }
      // Overwrite existing TrustedTypes policy.
      trustedTypesPolicy = cfg.TRUSTED_TYPES_POLICY;
      // Sign local variables required by `sanitize`.
      emptyHTML = trustedTypesPolicy.createHTML('');
    } else {
      // Uninitialized policy, attempt to initialize the internal dompurify policy.
      if (trustedTypesPolicy === undefined) {
        trustedTypesPolicy = _createTrustedTypesPolicy(trustedTypes, currentScript);
      }
      // If creating the internal policy succeeded sign internal variables.
      if (trustedTypesPolicy !== null && typeof emptyHTML === 'string') {
        emptyHTML = trustedTypesPolicy.createHTML('');
      }
    }
    // Prevent further manipulation of configuration.
    // Not available in IE8, Safari 5, etc.
    if (freeze) {
      freeze(cfg);
    }
    CONFIG = cfg;
  };
  /* Keep track of all possible SVG and MathML tags
   * so that we can perform the namespace checks
   * correctly. */
  const ALL_SVG_TAGS = addToSet({}, [...svg$1, ...svgFilters, ...svgDisallowed]);
  const ALL_MATHML_TAGS = addToSet({}, [...mathMl$1, ...mathMlDisallowed]);
  /**
   * @param element a DOM element whose namespace is being checked
   * @returns Return false if the element has a
   *  namespace that a spec-compliant parser would never
   *  return. Return true otherwise.
   */
  const _checkValidNamespace = function _checkValidNamespace(element) {
    let parent = getParentNode(element);
    // In JSDOM, if we're inside shadow DOM, then parentNode
    // can be null. We just simulate parent in this case.
    if (!parent || !parent.tagName) {
      parent = {
        namespaceURI: NAMESPACE,
        tagName: 'template'
      };
    }
    const tagName = stringToLowerCase(element.tagName);
    const parentTagName = stringToLowerCase(parent.tagName);
    if (!ALLOWED_NAMESPACES[element.namespaceURI]) {
      return false;
    }
    if (element.namespaceURI === SVG_NAMESPACE) {
      // The only way to switch from HTML namespace to SVG
      // is via <svg>. If it happens via any other tag, then
      // it should be killed.
      if (parent.namespaceURI === HTML_NAMESPACE) {
        return tagName === 'svg';
      }
      // The only way to switch from MathML to SVG is via`
      // svg if parent is either <annotation-xml> or MathML
      // text integration points.
      if (parent.namespaceURI === MATHML_NAMESPACE) {
        return tagName === 'svg' && (parentTagName === 'annotation-xml' || MATHML_TEXT_INTEGRATION_POINTS[parentTagName]);
      }
      // We only allow elements that are defined in SVG
      // spec. All others are disallowed in SVG namespace.
      return Boolean(ALL_SVG_TAGS[tagName]);
    }
    if (element.namespaceURI === MATHML_NAMESPACE) {
      // The only way to switch from HTML namespace to MathML
      // is via <math>. If it happens via any other tag, then
      // it should be killed.
      if (parent.namespaceURI === HTML_NAMESPACE) {
        return tagName === 'math';
      }
      // The only way to switch from SVG to MathML is via
      // <math> and HTML integration points
      if (parent.namespaceURI === SVG_NAMESPACE) {
        return tagName === 'math' && HTML_INTEGRATION_POINTS[parentTagName];
      }
      // We only allow elements that are defined in MathML
      // spec. All others are disallowed in MathML namespace.
      return Boolean(ALL_MATHML_TAGS[tagName]);
    }
    if (element.namespaceURI === HTML_NAMESPACE) {
      // The only way to switch from SVG to HTML is via
      // HTML integration points, and from MathML to HTML
      // is via MathML text integration points
      if (parent.namespaceURI === SVG_NAMESPACE && !HTML_INTEGRATION_POINTS[parentTagName]) {
        return false;
      }
      if (parent.namespaceURI === MATHML_NAMESPACE && !MATHML_TEXT_INTEGRATION_POINTS[parentTagName]) {
        return false;
      }
      // We disallow tags that are specific for MathML
      // or SVG and should never appear in HTML namespace
      return !ALL_MATHML_TAGS[tagName] && (COMMON_SVG_AND_HTML_ELEMENTS[tagName] || !ALL_SVG_TAGS[tagName]);
    }
    // For XHTML and XML documents that support custom namespaces
    if (PARSER_MEDIA_TYPE === 'application/xhtml+xml' && ALLOWED_NAMESPACES[element.namespaceURI]) {
      return true;
    }
    // The code should never reach this place (this means
    // that the element somehow got namespace that is not
    // HTML, SVG, MathML or allowed via ALLOWED_NAMESPACES).
    // Return false just in case.
    return false;
  };
  /**
   * _forceRemove
   *
   * @param node a DOM node
   */
  const _forceRemove = function _forceRemove(node) {
    arrayPush(DOMPurify.removed, {
      element: node
    });
    try {
      // eslint-disable-next-line unicorn/prefer-dom-node-remove
      getParentNode(node).removeChild(node);
    } catch (_) {
      remove(node);
    }
  };
  /**
   * _removeAttribute
   *
   * @param name an Attribute name
   * @param element a DOM node
   */
  const _removeAttribute = function _removeAttribute(name, element) {
    try {
      arrayPush(DOMPurify.removed, {
        attribute: element.getAttributeNode(name),
        from: element
      });
    } catch (_) {
      arrayPush(DOMPurify.removed, {
        attribute: null,
        from: element
      });
    }
    element.removeAttribute(name);
    // We void attribute values for unremovable "is" attributes
    if (name === 'is') {
      if (RETURN_DOM || RETURN_DOM_FRAGMENT) {
        try {
          _forceRemove(element);
        } catch (_) {}
      } else {
        try {
          element.setAttribute(name, '');
        } catch (_) {}
      }
    }
  };
  /**
   * _initDocument
   *
   * @param dirty - a string of dirty markup
   * @return a DOM, filled with the dirty markup
   */
  const _initDocument = function _initDocument(dirty) {
    /* Create a HTML document */
    let doc = null;
    let leadingWhitespace = null;
    if (FORCE_BODY) {
      dirty = '<remove></remove>' + dirty;
    } else {
      /* If FORCE_BODY isn't used, leading whitespace needs to be preserved manually */
      const matches = stringMatch(dirty, /^[\r\n\t ]+/);
      leadingWhitespace = matches && matches[0];
    }
    if (PARSER_MEDIA_TYPE === 'application/xhtml+xml' && NAMESPACE === HTML_NAMESPACE) {
      // Root of XHTML doc must contain xmlns declaration (see https://www.w3.org/TR/xhtml1/normative.html#strict)
      dirty = '<html xmlns="http://www.w3.org/1999/xhtml"><head></head><body>' + dirty + '</body></html>';
    }
    const dirtyPayload = trustedTypesPolicy ? trustedTypesPolicy.createHTML(dirty) : dirty;
    /*
     * Use the DOMParser API by default, fallback later if needs be
     * DOMParser not work for svg when has multiple root element.
     */
    if (NAMESPACE === HTML_NAMESPACE) {
      try {
        doc = new DOMParser().parseFromString(dirtyPayload, PARSER_MEDIA_TYPE);
      } catch (_) {}
    }
    /* Use createHTMLDocument in case DOMParser is not available */
    if (!doc || !doc.documentElement) {
      doc = implementation.createDocument(NAMESPACE, 'template', null);
      try {
        doc.documentElement.innerHTML = IS_EMPTY_INPUT ? emptyHTML : dirtyPayload;
      } catch (_) {
        // Syntax error if dirtyPayload is invalid xml
      }
    }
    const body = doc.body || doc.documentElement;
    if (dirty && leadingWhitespace) {
      body.insertBefore(document.createTextNode(leadingWhitespace), body.childNodes[0] || null);
    }
    /* Work on whole document or just its body */
    if (NAMESPACE === HTML_NAMESPACE) {
      return getElementsByTagName.call(doc, WHOLE_DOCUMENT ? 'html' : 'body')[0];
    }
    return WHOLE_DOCUMENT ? doc.documentElement : body;
  };
  /**
   * Creates a NodeIterator object that you can use to traverse filtered lists of nodes or elements in a document.
   *
   * @param root The root element or node to start traversing on.
   * @return The created NodeIterator
   */
  const _createNodeIterator = function _createNodeIterator(root) {
    return createNodeIterator.call(root.ownerDocument || root, root,
    // eslint-disable-next-line no-bitwise
    NodeFilter.SHOW_ELEMENT | NodeFilter.SHOW_COMMENT | NodeFilter.SHOW_TEXT | NodeFilter.SHOW_PROCESSING_INSTRUCTION | NodeFilter.SHOW_CDATA_SECTION, null);
  };
  /**
   * _isClobbered
   *
   * @param element element to check for clobbering attacks
   * @return true if clobbered, false if safe
   */
  const _isClobbered = function _isClobbered(element) {
    return element instanceof HTMLFormElement && (typeof element.nodeName !== 'string' || typeof element.textContent !== 'string' || typeof element.removeChild !== 'function' || !(element.attributes instanceof NamedNodeMap) || typeof element.removeAttribute !== 'function' || typeof element.setAttribute !== 'function' || typeof element.namespaceURI !== 'string' || typeof element.insertBefore !== 'function' || typeof element.hasChildNodes !== 'function');
  };
  /**
   * Checks whether the given object is a DOM node.
   *
   * @param value object to check whether it's a DOM node
   * @return true is object is a DOM node
   */
  const _isNode = function _isNode(value) {
    return typeof Node === 'function' && value instanceof Node;
  };
  function _executeHooks(hooks, currentNode, data) {
    arrayForEach(hooks, hook => {
      hook.call(DOMPurify, currentNode, data, CONFIG);
    });
  }
  /**
   * _sanitizeElements
   *
   * @protect nodeName
   * @protect textContent
   * @protect removeChild
   * @param currentNode to check for permission to exist
   * @return true if node was killed, false if left alive
   */
  const _sanitizeElements = function _sanitizeElements(currentNode) {
    let content = null;
    /* Execute a hook if present */
    _executeHooks(hooks.beforeSanitizeElements, currentNode, null);
    /* Check if element is clobbered or can clobber */
    if (_isClobbered(currentNode)) {
      _forceRemove(currentNode);
      return true;
    }
    /* Now let's check the element's type and name */
    const tagName = transformCaseFunc(currentNode.nodeName);
    /* Execute a hook if present */
    _executeHooks(hooks.uponSanitizeElement, currentNode, {
      tagName,
      allowedTags: ALLOWED_TAGS
    });
    /* Detect mXSS attempts abusing namespace confusion */
    if (SAFE_FOR_XML && currentNode.hasChildNodes() && !_isNode(currentNode.firstElementChild) && regExpTest(/<[/\w!]/g, currentNode.innerHTML) && regExpTest(/<[/\w!]/g, currentNode.textContent)) {
      _forceRemove(currentNode);
      return true;
    }
    /* Remove any occurrence of processing instructions */
    if (currentNode.nodeType === NODE_TYPE.progressingInstruction) {
      _forceRemove(currentNode);
      return true;
    }
    /* Remove any kind of possibly harmful comments */
    if (SAFE_FOR_XML && currentNode.nodeType === NODE_TYPE.comment && regExpTest(/<[/\w]/g, currentNode.data)) {
      _forceRemove(currentNode);
      return true;
    }
    /* Remove element if anything forbids its presence */
    if (!ALLOWED_TAGS[tagName] || FORBID_TAGS[tagName]) {
      /* Check if we have a custom element to handle */
      if (!FORBID_TAGS[tagName] && _isBasicCustomElement(tagName)) {
        if (CUSTOM_ELEMENT_HANDLING.tagNameCheck instanceof RegExp && regExpTest(CUSTOM_ELEMENT_HANDLING.tagNameCheck, tagName)) {
          return false;
        }
        if (CUSTOM_ELEMENT_HANDLING.tagNameCheck instanceof Function && CUSTOM_ELEMENT_HANDLING.tagNameCheck(tagName)) {
          return false;
        }
      }
      /* Keep content except for bad-listed elements */
      if (KEEP_CONTENT && !FORBID_CONTENTS[tagName]) {
        const parentNode = getParentNode(currentNode) || currentNode.parentNode;
        const childNodes = getChildNodes(currentNode) || currentNode.childNodes;
        if (childNodes && parentNode) {
          const childCount = childNodes.length;
          for (let i = childCount - 1; i >= 0; --i) {
            const childClone = cloneNode(childNodes[i], true);
            childClone.__removalCount = (currentNode.__removalCount || 0) + 1;
            parentNode.insertBefore(childClone, getNextSibling(currentNode));
          }
        }
      }
      _forceRemove(currentNode);
      return true;
    }
    /* Check whether element has a valid namespace */
    if (currentNode instanceof Element && !_checkValidNamespace(currentNode)) {
      _forceRemove(currentNode);
      return true;
    }
    /* Make sure that older browsers don't get fallback-tag mXSS */
    if ((tagName === 'noscript' || tagName === 'noembed' || tagName === 'noframes') && regExpTest(/<\/no(script|embed|frames)/i, currentNode.innerHTML)) {
      _forceRemove(currentNode);
      return true;
    }
    /* Sanitize element content to be template-safe */
    if (SAFE_FOR_TEMPLATES && currentNode.nodeType === NODE_TYPE.text) {
      /* Get the element's text content */
      content = currentNode.textContent;
      arrayForEach([MUSTACHE_EXPR, ERB_EXPR, TMPLIT_EXPR], expr => {
        content = stringReplace(content, expr, ' ');
      });
      if (currentNode.textContent !== content) {
        arrayPush(DOMPurify.removed, {
          element: currentNode.cloneNode()
        });
        currentNode.textContent = content;
      }
    }
    /* Execute a hook if present */
    _executeHooks(hooks.afterSanitizeElements, currentNode, null);
    return false;
  };
  /**
   * _isValidAttribute
   *
   * @param lcTag Lowercase tag name of containing element.
   * @param lcName Lowercase attribute name.
   * @param value Attribute value.
   * @return Returns true if `value` is valid, otherwise false.
   */
  // eslint-disable-next-line complexity
  const _isValidAttribute = function _isValidAttribute(lcTag, lcName, value) {
    /* Make sure attribute cannot clobber */
    if (SANITIZE_DOM && (lcName === 'id' || lcName === 'name') && (value in document || value in formElement)) {
      return false;
    }
    /* Allow valid data-* attributes: At least one character after "-"
        (https://html.spec.whatwg.org/multipage/dom.html#embedding-custom-non-visible-data-with-the-data-*-attributes)
        XML-compatible (https://html.spec.whatwg.org/multipage/infrastructure.html#xml-compatible and http://www.w3.org/TR/xml/#d0e804)
        We don't need to check the value; it's always URI safe. */
    if (ALLOW_DATA_ATTR && !FORBID_ATTR[lcName] && regExpTest(DATA_ATTR, lcName)) ; else if (ALLOW_ARIA_ATTR && regExpTest(ARIA_ATTR, lcName)) ; else if (!ALLOWED_ATTR[lcName] || FORBID_ATTR[lcName]) {
      if (
      // First condition does a very basic check if a) it's basically a valid custom element tagname AND
      // b) if the tagName passes whatever the user has configured for CUSTOM_ELEMENT_HANDLING.tagNameCheck
      // and c) if the attribute name passes whatever the user has configured for CUSTOM_ELEMENT_HANDLING.attributeNameCheck
      _isBasicCustomElement(lcTag) && (CUSTOM_ELEMENT_HANDLING.tagNameCheck instanceof RegExp && regExpTest(CUSTOM_ELEMENT_HANDLING.tagNameCheck, lcTag) || CUSTOM_ELEMENT_HANDLING.tagNameCheck instanceof Function && CUSTOM_ELEMENT_HANDLING.tagNameCheck(lcTag)) && (CUSTOM_ELEMENT_HANDLING.attributeNameCheck instanceof RegExp && regExpTest(CUSTOM_ELEMENT_HANDLING.attributeNameCheck, lcName) || CUSTOM_ELEMENT_HANDLING.attributeNameCheck instanceof Function && CUSTOM_ELEMENT_HANDLING.attributeNameCheck(lcName)) ||
      // Alternative, second condition checks if it's an `is`-attribute, AND
      // the value passes whatever the user has configured for CUSTOM_ELEMENT_HANDLING.tagNameCheck
      lcName === 'is' && CUSTOM_ELEMENT_HANDLING.allowCustomizedBuiltInElements && (CUSTOM_ELEMENT_HANDLING.tagNameCheck instanceof RegExp && regExpTest(CUSTOM_ELEMENT_HANDLING.tagNameCheck, value) || CUSTOM_ELEMENT_HANDLING.tagNameCheck instanceof Function && CUSTOM_ELEMENT_HANDLING.tagNameCheck(value))) ; else {
        return false;
      }
      /* Check value is safe. First, is attr inert? If so, is safe */
    } else if (URI_SAFE_ATTRIBUTES[lcName]) ; else if (regExpTest(IS_ALLOWED_URI$1, stringReplace(value, ATTR_WHITESPACE, ''))) ; else if ((lcName === 'src' || lcName === 'xlink:href' || lcName === 'href') && lcTag !== 'script' && stringIndexOf(value, 'data:') === 0 && DATA_URI_TAGS[lcTag]) ; else if (ALLOW_UNKNOWN_PROTOCOLS && !regExpTest(IS_SCRIPT_OR_DATA, stringReplace(value, ATTR_WHITESPACE, ''))) ; else if (value) {
      return false;
    } else ;
    return true;
  };
  /**
   * _isBasicCustomElement
   * checks if at least one dash is included in tagName, and it's not the first char
   * for more sophisticated checking see https://github.com/sindresorhus/validate-element-name
   *
   * @param tagName name of the tag of the node to sanitize
   * @returns Returns true if the tag name meets the basic criteria for a custom element, otherwise false.
   */
  const _isBasicCustomElement = function _isBasicCustomElement(tagName) {
    return tagName !== 'annotation-xml' && stringMatch(tagName, CUSTOM_ELEMENT);
  };
  /**
   * _sanitizeAttributes
   *
   * @protect attributes
   * @protect nodeName
   * @protect removeAttribute
   * @protect setAttribute
   *
   * @param currentNode to sanitize
   */
  const _sanitizeAttributes = function _sanitizeAttributes(currentNode) {
    /* Execute a hook if present */
    _executeHooks(hooks.beforeSanitizeAttributes, currentNode, null);
    const {
      attributes
    } = currentNode;
    /* Check if we have attributes; if not we might have a text node */
    if (!attributes || _isClobbered(currentNode)) {
      return;
    }
    const hookEvent = {
      attrName: '',
      attrValue: '',
      keepAttr: true,
      allowedAttributes: ALLOWED_ATTR,
      forceKeepAttr: undefined
    };
    let l = attributes.length;
    /* Go backwards over all attributes; safely remove bad ones */
    while (l--) {
      const attr = attributes[l];
      const {
        name,
        namespaceURI,
        value: attrValue
      } = attr;
      const lcName = transformCaseFunc(name);
      const initValue = attrValue;
      let value = name === 'value' ? initValue : stringTrim(initValue);
      /* Execute a hook if present */
      hookEvent.attrName = lcName;
      hookEvent.attrValue = value;
      hookEvent.keepAttr = true;
      hookEvent.forceKeepAttr = undefined; // Allows developers to see this is a property they can set
      _executeHooks(hooks.uponSanitizeAttribute, currentNode, hookEvent);
      value = hookEvent.attrValue;
      /* Full DOM Clobbering protection via namespace isolation,
       * Prefix id and name attributes with `user-content-`
       */
      if (SANITIZE_NAMED_PROPS && (lcName === 'id' || lcName === 'name')) {
        // Remove the attribute with this value
        _removeAttribute(name, currentNode);
        // Prefix the value and later re-create the attribute with the sanitized value
        value = SANITIZE_NAMED_PROPS_PREFIX + value;
      }
      /* Work around a security issue with comments inside attributes */
      if (SAFE_FOR_XML && regExpTest(/((--!?|])>)|<\/(style|title)/i, value)) {
        _removeAttribute(name, currentNode);
        continue;
      }
      /* Did the hooks approve of the attribute? */
      if (hookEvent.forceKeepAttr) {
        continue;
      }
      /* Did the hooks approve of the attribute? */
      if (!hookEvent.keepAttr) {
        _removeAttribute(name, currentNode);
        continue;
      }
      /* Work around a security issue in jQuery 3.0 */
      if (!ALLOW_SELF_CLOSE_IN_ATTR && regExpTest(/\/>/i, value)) {
        _removeAttribute(name, currentNode);
        continue;
      }
      /* Sanitize attribute content to be template-safe */
      if (SAFE_FOR_TEMPLATES) {
        arrayForEach([MUSTACHE_EXPR, ERB_EXPR, TMPLIT_EXPR], expr => {
          value = stringReplace(value, expr, ' ');
        });
      }
      /* Is `value` valid for this attribute? */
      const lcTag = transformCaseFunc(currentNode.nodeName);
      if (!_isValidAttribute(lcTag, lcName, value)) {
        _removeAttribute(name, currentNode);
        continue;
      }
      /* Handle attributes that require Trusted Types */
      if (trustedTypesPolicy && typeof trustedTypes === 'object' && typeof trustedTypes.getAttributeType === 'function') {
        if (namespaceURI) ; else {
          switch (trustedTypes.getAttributeType(lcTag, lcName)) {
            case 'TrustedHTML':
              {
                value = trustedTypesPolicy.createHTML(value);
                break;
              }
            case 'TrustedScriptURL':
              {
                value = trustedTypesPolicy.createScriptURL(value);
                break;
              }
          }
        }
      }
      /* Handle invalid data-* attribute set by try-catching it */
      if (value !== initValue) {
        try {
          if (namespaceURI) {
            currentNode.setAttributeNS(namespaceURI, name, value);
          } else {
            /* Fallback to setAttribute() for browser-unrecognized namespaces e.g. "x-schema". */
            currentNode.setAttribute(name, value);
          }
          if (_isClobbered(currentNode)) {
            _forceRemove(currentNode);
          } else {
            arrayPop(DOMPurify.removed);
          }
        } catch (_) {
          _removeAttribute(name, currentNode);
        }
      }
    }
    /* Execute a hook if present */
    _executeHooks(hooks.afterSanitizeAttributes, currentNode, null);
  };
  /**
   * _sanitizeShadowDOM
   *
   * @param fragment to iterate over recursively
   */
  const _sanitizeShadowDOM = function _sanitizeShadowDOM(fragment) {
    let shadowNode = null;
    const shadowIterator = _createNodeIterator(fragment);
    /* Execute a hook if present */
    _executeHooks(hooks.beforeSanitizeShadowDOM, fragment, null);
    while (shadowNode = shadowIterator.nextNode()) {
      /* Execute a hook if present */
      _executeHooks(hooks.uponSanitizeShadowNode, shadowNode, null);
      /* Sanitize tags and elements */
      _sanitizeElements(shadowNode);
      /* Check attributes next */
      _sanitizeAttributes(shadowNode);
      /* Deep shadow DOM detected */
      if (shadowNode.content instanceof DocumentFragment) {
        _sanitizeShadowDOM(shadowNode.content);
      }
    }
    /* Execute a hook if present */
    _executeHooks(hooks.afterSanitizeShadowDOM, fragment, null);
  };
  // eslint-disable-next-line complexity
  DOMPurify.sanitize = function (dirty) {
    let cfg = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : {};
    let body = null;
    let importedNode = null;
    let currentNode = null;
    let returnNode = null;
    /* Make sure we have a string to sanitize.
      DO NOT return early, as this will return the wrong type if
      the user has requested a DOM object rather than a string */
    IS_EMPTY_INPUT = !dirty;
    if (IS_EMPTY_INPUT) {
      dirty = '<!-->';
    }
    /* Stringify, in case dirty is an object */
    if (typeof dirty !== 'string' && !_isNode(dirty)) {
      if (typeof dirty.toString === 'function') {
        dirty = dirty.toString();
        if (typeof dirty !== 'string') {
          throw typeErrorCreate('dirty is not a string, aborting');
        }
      } else {
        throw typeErrorCreate('toString is not a function');
      }
    }
    /* Return dirty HTML if DOMPurify cannot run */
    if (!DOMPurify.isSupported) {
      return dirty;
    }
    /* Assign config vars */
    if (!SET_CONFIG) {
      _parseConfig(cfg);
    }
    /* Clean up removed elements */
    DOMPurify.removed = [];
    /* Check if dirty is correctly typed for IN_PLACE */
    if (typeof dirty === 'string') {
      IN_PLACE = false;
    }
    if (IN_PLACE) {
      /* Do some early pre-sanitization to avoid unsafe root nodes */
      if (dirty.nodeName) {
        const tagName = transformCaseFunc(dirty.nodeName);
        if (!ALLOWED_TAGS[tagName] || FORBID_TAGS[tagName]) {
          throw typeErrorCreate('root node is forbidden and cannot be sanitized in-place');
        }
      }
    } else if (dirty instanceof Node) {
      /* If dirty is a DOM element, append to an empty document to avoid
         elements being stripped by the parser */
      body = _initDocument('<!---->');
      importedNode = body.ownerDocument.importNode(dirty, true);
      if (importedNode.nodeType === NODE_TYPE.element && importedNode.nodeName === 'BODY') {
        /* Node is already a body, use as is */
        body = importedNode;
      } else if (importedNode.nodeName === 'HTML') {
        body = importedNode;
      } else {
        // eslint-disable-next-line unicorn/prefer-dom-node-append
        body.appendChild(importedNode);
      }
    } else {
      /* Exit directly if we have nothing to do */
      if (!RETURN_DOM && !SAFE_FOR_TEMPLATES && !WHOLE_DOCUMENT &&
      // eslint-disable-next-line unicorn/prefer-includes
      dirty.indexOf('<') === -1) {
        return trustedTypesPolicy && RETURN_TRUSTED_TYPE ? trustedTypesPolicy.createHTML(dirty) : dirty;
      }
      /* Initialize the document to work on */
      body = _initDocument(dirty);
      /* Check we have a DOM node from the data */
      if (!body) {
        return RETURN_DOM ? null : RETURN_TRUSTED_TYPE ? emptyHTML : '';
      }
    }
    /* Remove first element node (ours) if FORCE_BODY is set */
    if (body && FORCE_BODY) {
      _forceRemove(body.firstChild);
    }
    /* Get node iterator */
    const nodeIterator = _createNodeIterator(IN_PLACE ? dirty : body);
    /* Now start iterating over the created document */
    while (currentNode = nodeIterator.nextNode()) {
      /* Sanitize tags and elements */
      _sanitizeElements(currentNode);
      /* Check attributes next */
      _sanitizeAttributes(currentNode);
      /* Shadow DOM detected, sanitize it */
      if (currentNode.content instanceof DocumentFragment) {
        _sanitizeShadowDOM(currentNode.content);
      }
    }
    /* If we sanitized `dirty` in-place, return it. */
    if (IN_PLACE) {
      return dirty;
    }
    /* Return sanitized string or DOM */
    if (RETURN_DOM) {
      if (RETURN_DOM_FRAGMENT) {
        returnNode = createDocumentFragment.call(body.ownerDocument);
        while (body.firstChild) {
          // eslint-disable-next-line unicorn/prefer-dom-node-append
          returnNode.appendChild(body.firstChild);
        }
      } else {
        returnNode = body;
      }
      if (ALLOWED_ATTR.shadowroot || ALLOWED_ATTR.shadowrootmode) {
        /*
          AdoptNode() is not used because internal state is not reset
          (e.g. the past names map of a HTMLFormElement), this is safe
          in theory but we would rather not risk another attack vector.
          The state that is cloned by importNode() is explicitly defined
          by the specs.
        */
        returnNode = importNode.call(originalDocument, returnNode, true);
      }
      return returnNode;
    }
    let serializedHTML = WHOLE_DOCUMENT ? body.outerHTML : body.innerHTML;
    /* Serialize doctype if allowed */
    if (WHOLE_DOCUMENT && ALLOWED_TAGS['!doctype'] && body.ownerDocument && body.ownerDocument.doctype && body.ownerDocument.doctype.name && regExpTest(DOCTYPE_NAME, body.ownerDocument.doctype.name)) {
      serializedHTML = '<!DOCTYPE ' + body.ownerDocument.doctype.name + '>\n' + serializedHTML;
    }
    /* Sanitize final string template-safe */
    if (SAFE_FOR_TEMPLATES) {
      arrayForEach([MUSTACHE_EXPR, ERB_EXPR, TMPLIT_EXPR], expr => {
        serializedHTML = stringReplace(serializedHTML, expr, ' ');
      });
    }
    return trustedTypesPolicy && RETURN_TRUSTED_TYPE ? trustedTypesPolicy.createHTML(serializedHTML) : serializedHTML;
  };
  DOMPurify.setConfig = function () {
    let cfg = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : {};
    _parseConfig(cfg);
    SET_CONFIG = true;
  };
  DOMPurify.clearConfig = function () {
    CONFIG = null;
    SET_CONFIG = false;
  };
  DOMPurify.isValidAttribute = function (tag, attr, value) {
    /* Initialize shared config vars if necessary. */
    if (!CONFIG) {
      _parseConfig({});
    }
    const lcTag = transformCaseFunc(tag);
    const lcName = transformCaseFunc(attr);
    return _isValidAttribute(lcTag, lcName, value);
  };
  DOMPurify.addHook = function (entryPoint, hookFunction) {
    if (typeof hookFunction !== 'function') {
      return;
    }
    arrayPush(hooks[entryPoint], hookFunction);
  };
  DOMPurify.removeHook = function (entryPoint, hookFunction) {
    if (hookFunction !== undefined) {
      const index = arrayLastIndexOf(hooks[entryPoint], hookFunction);
      return index === -1 ? undefined : arraySplice(hooks[entryPoint], index, 1)[0];
    }
    return arrayPop(hooks[entryPoint]);
  };
  DOMPurify.removeHooks = function (entryPoint) {
    hooks[entryPoint] = [];
  };
  DOMPurify.removeAllHooks = function () {
    hooks = _createHooksMap();
  };
  return DOMPurify;
}
var purify = createDOMPurify();

var __defProp = Object.defineProperty;
var __name = (target, value) => __defProp(target, "name", { value, configurable: true });
var __export = (target, all) => {
  for (var name in all)
    __defProp(target, name, { get: all[name], enumerable: true });
};
var LEVELS = {
  trace: 0,
  debug: 1,
  info: 2,
  warn: 3,
  error: 4,
  fatal: 5
};
var log = {
  trace: /* @__PURE__ */ __name((..._args) => {
  }, "trace"),
  debug: /* @__PURE__ */ __name((..._args) => {
  }, "debug"),
  info: /* @__PURE__ */ __name((..._args) => {
  }, "info"),
  warn: /* @__PURE__ */ __name((..._args) => {
  }, "warn"),
  error: /* @__PURE__ */ __name((..._args) => {
  }, "error"),
  fatal: /* @__PURE__ */ __name((..._args) => {
  }, "fatal")
};
var setLogLevel = /* @__PURE__ */ __name(function(level = "fatal") {
  let numericLevel = LEVELS.fatal;
  if (typeof level === "string") {
    if (level.toLowerCase() in LEVELS) {
      numericLevel = LEVELS[level];
    }
  } else if (typeof level === "number") {
    numericLevel = level;
  }
  log.trace = () => {
  };
  log.debug = () => {
  };
  log.info = () => {
  };
  log.warn = () => {
  };
  log.error = () => {
  };
  log.fatal = () => {
  };
  if (numericLevel <= LEVELS.fatal) {
    log.fatal = console.error ? console.error.bind(console, format("FATAL"), "color: orange") : console.log.bind(console, "\x1B[35m", format("FATAL"));
  }
  if (numericLevel <= LEVELS.error) {
    log.error = console.error ? console.error.bind(console, format("ERROR"), "color: orange") : console.log.bind(console, "\x1B[31m", format("ERROR"));
  }
  if (numericLevel <= LEVELS.warn) {
    log.warn = console.warn ? console.warn.bind(console, format("WARN"), "color: orange") : console.log.bind(console, `\x1B[33m`, format("WARN"));
  }
  if (numericLevel <= LEVELS.info) {
    log.info = console.info ? console.info.bind(console, format("INFO"), "color: lightblue") : console.log.bind(console, "\x1B[34m", format("INFO"));
  }
  if (numericLevel <= LEVELS.debug) {
    log.debug = console.debug ? console.debug.bind(console, format("DEBUG"), "color: lightgreen") : console.log.bind(console, "\x1B[32m", format("DEBUG"));
  }
  if (numericLevel <= LEVELS.trace) {
    log.trace = console.debug ? console.debug.bind(console, format("TRACE"), "color: lightgreen") : console.log.bind(console, "\x1B[32m", format("TRACE"));
  }
}, "setLogLevel");
var format = /* @__PURE__ */ __name((level) => {
  const time = dayjs2().format("ss.SSS");
  return `%c${time} : ${level} : `;
}, "format");

// src/diagram-api/regexes.ts
var frontMatterRegex = /^-{3}\s*[\n\r](.*?)[\n\r]-{3}\s*[\n\r]+/s;
var directiveRegex = /%{2}{\s*(?:(\w+)\s*:|(\w+))\s*(?:(\w+)|((?:(?!}%{2}).|\r?\n)*))?\s*(?:}%{2})?/gi;
var anyCommentRegex = /\s*%%.*\n/gm;

// src/errors.ts
var UnknownDiagramError = class extends Error {
  static {
    __name(this, "UnknownDiagramError");
  }
  constructor(message) {
    super(message);
    this.name = "UnknownDiagramError";
  }
};

// src/diagram-api/detectType.ts
var detectors = {};
var detectType$1 = /* @__PURE__ */ __name(function(text, config2) {
  text = text.replace(frontMatterRegex, "").replace(directiveRegex, "").replace(anyCommentRegex, "\n");
  for (const [key, { detector }] of Object.entries(detectors)) {
    const diagram = detector(text, config2);
    if (diagram) {
      return key;
    }
  }
  throw new UnknownDiagramError(
    `No diagram type detected matching given configuration for text: ${text}`
  );
}, "detectType");
var registerLazyLoadedDiagrams = /* @__PURE__ */ __name((...diagrams2) => {
  for (const { id, detector, loader } of diagrams2) {
    addDetector(id, detector, loader);
  }
}, "registerLazyLoadedDiagrams");
var addDetector = /* @__PURE__ */ __name((key, detector, loader) => {
  if (detectors[key]) {
    log.warn(`Detector with key ${key} already exists. Overwriting.`);
  }
  detectors[key] = { detector, loader };
  log.debug(`Detector with key ${key} added${loader ? " with loader" : ""}`);
}, "addDetector");
var getDiagramLoader = /* @__PURE__ */ __name((key) => {
  return detectors[key].loader;
}, "getDiagramLoader");

// src/assignWithDepth.ts
var assignWithDepth = /* @__PURE__ */ __name((dst, src, { depth = 2, clobber = false } = {}) => {
  const config2 = { depth, clobber };
  if (Array.isArray(src) && !Array.isArray(dst)) {
    src.forEach((s) => assignWithDepth(dst, s, config2));
    return dst;
  } else if (Array.isArray(src) && Array.isArray(dst)) {
    src.forEach((s) => {
      if (!dst.includes(s)) {
        dst.push(s);
      }
    });
    return dst;
  }
  if (dst === void 0 || depth <= 0) {
    if (dst !== void 0 && dst !== null && typeof dst === "object" && typeof src === "object") {
      return Object.assign(dst, src);
    } else {
      return src;
    }
  }
  if (src !== void 0 && typeof dst === "object" && typeof src === "object") {
    Object.keys(src).forEach((key) => {
      if (typeof src[key] === "object" && (dst[key] === void 0 || typeof dst[key] === "object")) {
        if (dst[key] === void 0) {
          dst[key] = Array.isArray(src[key]) ? [] : {};
        }
        dst[key] = assignWithDepth(dst[key], src[key], { depth: depth - 1, clobber });
      } else if (clobber || typeof dst[key] !== "object" && typeof src[key] !== "object") {
        dst[key] = src[key];
      }
    });
  }
  return dst;
}, "assignWithDepth");
var assignWithDepth_default = assignWithDepth;

// src/themes/erDiagram-oldHardcodedValues.ts
var oldAttributeBackgroundColorOdd = "#ffffff";
var oldAttributeBackgroundColorEven = "#f2f2f2";
var mkBorder = /* @__PURE__ */ __name((col, darkMode) => darkMode ? adjust(col, { s: -40, l: 10 }) : adjust(col, { s: -40, l: -10 }), "mkBorder");

// src/themes/theme-base.js
var Theme = class {
  static {
    __name(this, "Theme");
  }
  constructor() {
    this.background = "#f4f4f4";
    this.primaryColor = "#fff4dd";
    this.noteBkgColor = "#fff5ad";
    this.noteTextColor = "#333";
    this.THEME_COLOR_LIMIT = 12;
    this.fontFamily = '"trebuchet ms", verdana, arial, sans-serif';
    this.fontSize = "16px";
  }
  updateColors() {
    this.primaryTextColor = this.primaryTextColor || (this.darkMode ? "#eee" : "#333");
    this.secondaryColor = this.secondaryColor || adjust(this.primaryColor, { h: -120 });
    this.tertiaryColor = this.tertiaryColor || adjust(this.primaryColor, { h: 180, l: 5 });
    this.primaryBorderColor = this.primaryBorderColor || mkBorder(this.primaryColor, this.darkMode);
    this.secondaryBorderColor = this.secondaryBorderColor || mkBorder(this.secondaryColor, this.darkMode);
    this.tertiaryBorderColor = this.tertiaryBorderColor || mkBorder(this.tertiaryColor, this.darkMode);
    this.noteBorderColor = this.noteBorderColor || mkBorder(this.noteBkgColor, this.darkMode);
    this.noteBkgColor = this.noteBkgColor || "#fff5ad";
    this.noteTextColor = this.noteTextColor || "#333";
    this.secondaryTextColor = this.secondaryTextColor || invert(this.secondaryColor);
    this.tertiaryTextColor = this.tertiaryTextColor || invert(this.tertiaryColor);
    this.lineColor = this.lineColor || invert(this.background);
    this.arrowheadColor = this.arrowheadColor || invert(this.background);
    this.textColor = this.textColor || this.primaryTextColor;
    this.border2 = this.border2 || this.tertiaryBorderColor;
    this.nodeBkg = this.nodeBkg || this.primaryColor;
    this.mainBkg = this.mainBkg || this.primaryColor;
    this.nodeBorder = this.nodeBorder || this.primaryBorderColor;
    this.clusterBkg = this.clusterBkg || this.tertiaryColor;
    this.clusterBorder = this.clusterBorder || this.tertiaryBorderColor;
    this.defaultLinkColor = this.defaultLinkColor || this.lineColor;
    this.titleColor = this.titleColor || this.tertiaryTextColor;
    this.edgeLabelBackground = this.edgeLabelBackground || (this.darkMode ? darken(this.secondaryColor, 30) : this.secondaryColor);
    this.nodeTextColor = this.nodeTextColor || this.primaryTextColor;
    this.actorBorder = this.actorBorder || this.primaryBorderColor;
    this.actorBkg = this.actorBkg || this.mainBkg;
    this.actorTextColor = this.actorTextColor || this.primaryTextColor;
    this.actorLineColor = this.actorLineColor || this.actorBorder;
    this.labelBoxBkgColor = this.labelBoxBkgColor || this.actorBkg;
    this.signalColor = this.signalColor || this.textColor;
    this.signalTextColor = this.signalTextColor || this.textColor;
    this.labelBoxBorderColor = this.labelBoxBorderColor || this.actorBorder;
    this.labelTextColor = this.labelTextColor || this.actorTextColor;
    this.loopTextColor = this.loopTextColor || this.actorTextColor;
    this.activationBorderColor = this.activationBorderColor || darken(this.secondaryColor, 10);
    this.activationBkgColor = this.activationBkgColor || this.secondaryColor;
    this.sequenceNumberColor = this.sequenceNumberColor || invert(this.lineColor);
    this.sectionBkgColor = this.sectionBkgColor || this.tertiaryColor;
    this.altSectionBkgColor = this.altSectionBkgColor || "white";
    this.sectionBkgColor = this.sectionBkgColor || this.secondaryColor;
    this.sectionBkgColor2 = this.sectionBkgColor2 || this.primaryColor;
    this.excludeBkgColor = this.excludeBkgColor || "#eeeeee";
    this.taskBorderColor = this.taskBorderColor || this.primaryBorderColor;
    this.taskBkgColor = this.taskBkgColor || this.primaryColor;
    this.activeTaskBorderColor = this.activeTaskBorderColor || this.primaryColor;
    this.activeTaskBkgColor = this.activeTaskBkgColor || lighten(this.primaryColor, 23);
    this.gridColor = this.gridColor || "lightgrey";
    this.doneTaskBkgColor = this.doneTaskBkgColor || "lightgrey";
    this.doneTaskBorderColor = this.doneTaskBorderColor || "grey";
    this.critBorderColor = this.critBorderColor || "#ff8888";
    this.critBkgColor = this.critBkgColor || "red";
    this.todayLineColor = this.todayLineColor || "red";
    this.vertLineColor = this.vertLineColor || "navy";
    this.taskTextColor = this.taskTextColor || this.textColor;
    this.taskTextOutsideColor = this.taskTextOutsideColor || this.textColor;
    this.taskTextLightColor = this.taskTextLightColor || this.textColor;
    this.taskTextColor = this.taskTextColor || this.primaryTextColor;
    this.taskTextDarkColor = this.taskTextDarkColor || this.textColor;
    this.taskTextClickableColor = this.taskTextClickableColor || "#003163";
    this.personBorder = this.personBorder || this.primaryBorderColor;
    this.personBkg = this.personBkg || this.mainBkg;
    if (this.darkMode) {
      this.rowOdd = this.rowOdd || darken(this.mainBkg, 5) || "#ffffff";
      this.rowEven = this.rowEven || darken(this.mainBkg, 10);
    } else {
      this.rowOdd = this.rowOdd || lighten(this.mainBkg, 75) || "#ffffff";
      this.rowEven = this.rowEven || lighten(this.mainBkg, 5);
    }
    this.transitionColor = this.transitionColor || this.lineColor;
    this.transitionLabelColor = this.transitionLabelColor || this.textColor;
    this.stateLabelColor = this.stateLabelColor || this.stateBkg || this.primaryTextColor;
    this.stateBkg = this.stateBkg || this.mainBkg;
    this.labelBackgroundColor = this.labelBackgroundColor || this.stateBkg;
    this.compositeBackground = this.compositeBackground || this.background || this.tertiaryColor;
    this.altBackground = this.altBackground || this.tertiaryColor;
    this.compositeTitleBackground = this.compositeTitleBackground || this.mainBkg;
    this.compositeBorder = this.compositeBorder || this.nodeBorder;
    this.innerEndBackground = this.nodeBorder;
    this.errorBkgColor = this.errorBkgColor || this.tertiaryColor;
    this.errorTextColor = this.errorTextColor || this.tertiaryTextColor;
    this.transitionColor = this.transitionColor || this.lineColor;
    this.specialStateColor = this.lineColor;
    this.cScale0 = this.cScale0 || this.primaryColor;
    this.cScale1 = this.cScale1 || this.secondaryColor;
    this.cScale2 = this.cScale2 || this.tertiaryColor;
    this.cScale3 = this.cScale3 || adjust(this.primaryColor, { h: 30 });
    this.cScale4 = this.cScale4 || adjust(this.primaryColor, { h: 60 });
    this.cScale5 = this.cScale5 || adjust(this.primaryColor, { h: 90 });
    this.cScale6 = this.cScale6 || adjust(this.primaryColor, { h: 120 });
    this.cScale7 = this.cScale7 || adjust(this.primaryColor, { h: 150 });
    this.cScale8 = this.cScale8 || adjust(this.primaryColor, { h: 210, l: 150 });
    this.cScale9 = this.cScale9 || adjust(this.primaryColor, { h: 270 });
    this.cScale10 = this.cScale10 || adjust(this.primaryColor, { h: 300 });
    this.cScale11 = this.cScale11 || adjust(this.primaryColor, { h: 330 });
    if (this.darkMode) {
      for (let i = 0; i < this.THEME_COLOR_LIMIT; i++) {
        this["cScale" + i] = darken(this["cScale" + i], 75);
      }
    } else {
      for (let i = 0; i < this.THEME_COLOR_LIMIT; i++) {
        this["cScale" + i] = darken(this["cScale" + i], 25);
      }
    }
    for (let i = 0; i < this.THEME_COLOR_LIMIT; i++) {
      this["cScaleInv" + i] = this["cScaleInv" + i] || invert(this["cScale" + i]);
    }
    for (let i = 0; i < this.THEME_COLOR_LIMIT; i++) {
      if (this.darkMode) {
        this["cScalePeer" + i] = this["cScalePeer" + i] || lighten(this["cScale" + i], 10);
      } else {
        this["cScalePeer" + i] = this["cScalePeer" + i] || darken(this["cScale" + i], 10);
      }
    }
    this.scaleLabelColor = this.scaleLabelColor || this.labelTextColor;
    for (let i = 0; i < this.THEME_COLOR_LIMIT; i++) {
      this["cScaleLabel" + i] = this["cScaleLabel" + i] || this.scaleLabelColor;
    }
    const multiplier = this.darkMode ? -4 : -1;
    for (let i = 0; i < 5; i++) {
      this["surface" + i] = this["surface" + i] || adjust(this.mainBkg, { h: 180, s: -15, l: multiplier * (5 + i * 3) });
      this["surfacePeer" + i] = this["surfacePeer" + i] || adjust(this.mainBkg, { h: 180, s: -15, l: multiplier * (8 + i * 3) });
    }
    this.classText = this.classText || this.textColor;
    this.fillType0 = this.fillType0 || this.primaryColor;
    this.fillType1 = this.fillType1 || this.secondaryColor;
    this.fillType2 = this.fillType2 || adjust(this.primaryColor, { h: 64 });
    this.fillType3 = this.fillType3 || adjust(this.secondaryColor, { h: 64 });
    this.fillType4 = this.fillType4 || adjust(this.primaryColor, { h: -64 });
    this.fillType5 = this.fillType5 || adjust(this.secondaryColor, { h: -64 });
    this.fillType6 = this.fillType6 || adjust(this.primaryColor, { h: 128 });
    this.fillType7 = this.fillType7 || adjust(this.secondaryColor, { h: 128 });
    this.pie1 = this.pie1 || this.primaryColor;
    this.pie2 = this.pie2 || this.secondaryColor;
    this.pie3 = this.pie3 || this.tertiaryColor;
    this.pie4 = this.pie4 || adjust(this.primaryColor, { l: -10 });
    this.pie5 = this.pie5 || adjust(this.secondaryColor, { l: -10 });
    this.pie6 = this.pie6 || adjust(this.tertiaryColor, { l: -10 });
    this.pie7 = this.pie7 || adjust(this.primaryColor, { h: 60, l: -10 });
    this.pie8 = this.pie8 || adjust(this.primaryColor, { h: -60, l: -10 });
    this.pie9 = this.pie9 || adjust(this.primaryColor, { h: 120, l: 0 });
    this.pie10 = this.pie10 || adjust(this.primaryColor, { h: 60, l: -20 });
    this.pie11 = this.pie11 || adjust(this.primaryColor, { h: -60, l: -20 });
    this.pie12 = this.pie12 || adjust(this.primaryColor, { h: 120, l: -10 });
    this.pieTitleTextSize = this.pieTitleTextSize || "25px";
    this.pieTitleTextColor = this.pieTitleTextColor || this.taskTextDarkColor;
    this.pieSectionTextSize = this.pieSectionTextSize || "17px";
    this.pieSectionTextColor = this.pieSectionTextColor || this.textColor;
    this.pieLegendTextSize = this.pieLegendTextSize || "17px";
    this.pieLegendTextColor = this.pieLegendTextColor || this.taskTextDarkColor;
    this.pieStrokeColor = this.pieStrokeColor || "black";
    this.pieStrokeWidth = this.pieStrokeWidth || "2px";
    this.pieOuterStrokeWidth = this.pieOuterStrokeWidth || "2px";
    this.pieOuterStrokeColor = this.pieOuterStrokeColor || "black";
    this.pieOpacity = this.pieOpacity || "0.7";
    this.radar = {
      axisColor: this.radar?.axisColor || this.lineColor,
      axisStrokeWidth: this.radar?.axisStrokeWidth || 2,
      axisLabelFontSize: this.radar?.axisLabelFontSize || 12,
      curveOpacity: this.radar?.curveOpacity || 0.5,
      curveStrokeWidth: this.radar?.curveStrokeWidth || 2,
      graticuleColor: this.radar?.graticuleColor || "#DEDEDE",
      graticuleStrokeWidth: this.radar?.graticuleStrokeWidth || 1,
      graticuleOpacity: this.radar?.graticuleOpacity || 0.3,
      legendBoxSize: this.radar?.legendBoxSize || 12,
      legendFontSize: this.radar?.legendFontSize || 12
    };
    this.archEdgeColor = this.archEdgeColor || "#777";
    this.archEdgeArrowColor = this.archEdgeArrowColor || "#777";
    this.archEdgeWidth = this.archEdgeWidth || "3";
    this.archGroupBorderColor = this.archGroupBorderColor || "#000";
    this.archGroupBorderWidth = this.archGroupBorderWidth || "2px";
    this.quadrant1Fill = this.quadrant1Fill || this.primaryColor;
    this.quadrant2Fill = this.quadrant2Fill || adjust(this.primaryColor, { r: 5, g: 5, b: 5 });
    this.quadrant3Fill = this.quadrant3Fill || adjust(this.primaryColor, { r: 10, g: 10, b: 10 });
    this.quadrant4Fill = this.quadrant4Fill || adjust(this.primaryColor, { r: 15, g: 15, b: 15 });
    this.quadrant1TextFill = this.quadrant1TextFill || this.primaryTextColor;
    this.quadrant2TextFill = this.quadrant2TextFill || adjust(this.primaryTextColor, { r: -5, g: -5, b: -5 });
    this.quadrant3TextFill = this.quadrant3TextFill || adjust(this.primaryTextColor, { r: -10, g: -10, b: -10 });
    this.quadrant4TextFill = this.quadrant4TextFill || adjust(this.primaryTextColor, { r: -15, g: -15, b: -15 });
    this.quadrantPointFill = this.quadrantPointFill || isDark(this.quadrant1Fill) ? lighten(this.quadrant1Fill) : darken(this.quadrant1Fill);
    this.quadrantPointTextFill = this.quadrantPointTextFill || this.primaryTextColor;
    this.quadrantXAxisTextFill = this.quadrantXAxisTextFill || this.primaryTextColor;
    this.quadrantYAxisTextFill = this.quadrantYAxisTextFill || this.primaryTextColor;
    this.quadrantInternalBorderStrokeFill = this.quadrantInternalBorderStrokeFill || this.primaryBorderColor;
    this.quadrantExternalBorderStrokeFill = this.quadrantExternalBorderStrokeFill || this.primaryBorderColor;
    this.quadrantTitleFill = this.quadrantTitleFill || this.primaryTextColor;
    this.xyChart = {
      backgroundColor: this.xyChart?.backgroundColor || this.background,
      titleColor: this.xyChart?.titleColor || this.primaryTextColor,
      xAxisTitleColor: this.xyChart?.xAxisTitleColor || this.primaryTextColor,
      xAxisLabelColor: this.xyChart?.xAxisLabelColor || this.primaryTextColor,
      xAxisTickColor: this.xyChart?.xAxisTickColor || this.primaryTextColor,
      xAxisLineColor: this.xyChart?.xAxisLineColor || this.primaryTextColor,
      yAxisTitleColor: this.xyChart?.yAxisTitleColor || this.primaryTextColor,
      yAxisLabelColor: this.xyChart?.yAxisLabelColor || this.primaryTextColor,
      yAxisTickColor: this.xyChart?.yAxisTickColor || this.primaryTextColor,
      yAxisLineColor: this.xyChart?.yAxisLineColor || this.primaryTextColor,
      plotColorPalette: this.xyChart?.plotColorPalette || "#FFF4DD,#FFD8B1,#FFA07A,#ECEFF1,#D6DBDF,#C3E0A8,#FFB6A4,#FFD74D,#738FA7,#FFFFF0"
    };
    this.requirementBackground = this.requirementBackground || this.primaryColor;
    this.requirementBorderColor = this.requirementBorderColor || this.primaryBorderColor;
    this.requirementBorderSize = this.requirementBorderSize || "1";
    this.requirementTextColor = this.requirementTextColor || this.primaryTextColor;
    this.relationColor = this.relationColor || this.lineColor;
    this.relationLabelBackground = this.relationLabelBackground || (this.darkMode ? darken(this.secondaryColor, 30) : this.secondaryColor);
    this.relationLabelColor = this.relationLabelColor || this.actorTextColor;
    this.git0 = this.git0 || this.primaryColor;
    this.git1 = this.git1 || this.secondaryColor;
    this.git2 = this.git2 || this.tertiaryColor;
    this.git3 = this.git3 || adjust(this.primaryColor, { h: -30 });
    this.git4 = this.git4 || adjust(this.primaryColor, { h: -60 });
    this.git5 = this.git5 || adjust(this.primaryColor, { h: -90 });
    this.git6 = this.git6 || adjust(this.primaryColor, { h: 60 });
    this.git7 = this.git7 || adjust(this.primaryColor, { h: 120 });
    if (this.darkMode) {
      this.git0 = lighten(this.git0, 25);
      this.git1 = lighten(this.git1, 25);
      this.git2 = lighten(this.git2, 25);
      this.git3 = lighten(this.git3, 25);
      this.git4 = lighten(this.git4, 25);
      this.git5 = lighten(this.git5, 25);
      this.git6 = lighten(this.git6, 25);
      this.git7 = lighten(this.git7, 25);
    } else {
      this.git0 = darken(this.git0, 25);
      this.git1 = darken(this.git1, 25);
      this.git2 = darken(this.git2, 25);
      this.git3 = darken(this.git3, 25);
      this.git4 = darken(this.git4, 25);
      this.git5 = darken(this.git5, 25);
      this.git6 = darken(this.git6, 25);
      this.git7 = darken(this.git7, 25);
    }
    this.gitInv0 = this.gitInv0 || invert(this.git0);
    this.gitInv1 = this.gitInv1 || invert(this.git1);
    this.gitInv2 = this.gitInv2 || invert(this.git2);
    this.gitInv3 = this.gitInv3 || invert(this.git3);
    this.gitInv4 = this.gitInv4 || invert(this.git4);
    this.gitInv5 = this.gitInv5 || invert(this.git5);
    this.gitInv6 = this.gitInv6 || invert(this.git6);
    this.gitInv7 = this.gitInv7 || invert(this.git7);
    this.branchLabelColor = this.branchLabelColor || (this.darkMode ? "black" : this.labelTextColor);
    this.gitBranchLabel0 = this.gitBranchLabel0 || this.branchLabelColor;
    this.gitBranchLabel1 = this.gitBranchLabel1 || this.branchLabelColor;
    this.gitBranchLabel2 = this.gitBranchLabel2 || this.branchLabelColor;
    this.gitBranchLabel3 = this.gitBranchLabel3 || this.branchLabelColor;
    this.gitBranchLabel4 = this.gitBranchLabel4 || this.branchLabelColor;
    this.gitBranchLabel5 = this.gitBranchLabel5 || this.branchLabelColor;
    this.gitBranchLabel6 = this.gitBranchLabel6 || this.branchLabelColor;
    this.gitBranchLabel7 = this.gitBranchLabel7 || this.branchLabelColor;
    this.tagLabelColor = this.tagLabelColor || this.primaryTextColor;
    this.tagLabelBackground = this.tagLabelBackground || this.primaryColor;
    this.tagLabelBorder = this.tagBorder || this.primaryBorderColor;
    this.tagLabelFontSize = this.tagLabelFontSize || "10px";
    this.commitLabelColor = this.commitLabelColor || this.secondaryTextColor;
    this.commitLabelBackground = this.commitLabelBackground || this.secondaryColor;
    this.commitLabelFontSize = this.commitLabelFontSize || "10px";
    this.attributeBackgroundColorOdd = this.attributeBackgroundColorOdd || oldAttributeBackgroundColorOdd;
    this.attributeBackgroundColorEven = this.attributeBackgroundColorEven || oldAttributeBackgroundColorEven;
  }
  calculate(overrides) {
    if (typeof overrides !== "object") {
      this.updateColors();
      return;
    }
    const keys = Object.keys(overrides);
    keys.forEach((k) => {
      this[k] = overrides[k];
    });
    this.updateColors();
    keys.forEach((k) => {
      this[k] = overrides[k];
    });
  }
};
var getThemeVariables = /* @__PURE__ */ __name((userOverrides) => {
  const theme = new Theme();
  theme.calculate(userOverrides);
  return theme;
}, "getThemeVariables");
var Theme2 = class {
  static {
    __name(this, "Theme");
  }
  constructor() {
    this.background = "#333";
    this.primaryColor = "#1f2020";
    this.secondaryColor = lighten(this.primaryColor, 16);
    this.tertiaryColor = adjust(this.primaryColor, { h: -160 });
    this.primaryBorderColor = invert(this.background);
    this.secondaryBorderColor = mkBorder(this.secondaryColor, this.darkMode);
    this.tertiaryBorderColor = mkBorder(this.tertiaryColor, this.darkMode);
    this.primaryTextColor = invert(this.primaryColor);
    this.secondaryTextColor = invert(this.secondaryColor);
    this.tertiaryTextColor = invert(this.tertiaryColor);
    this.lineColor = invert(this.background);
    this.textColor = invert(this.background);
    this.mainBkg = "#1f2020";
    this.secondBkg = "calculated";
    this.mainContrastColor = "lightgrey";
    this.darkTextColor = lighten(invert("#323D47"), 10);
    this.lineColor = "calculated";
    this.border1 = "#ccc";
    this.border2 = rgba$1(255, 255, 255, 0.25);
    this.arrowheadColor = "calculated";
    this.fontFamily = '"trebuchet ms", verdana, arial, sans-serif';
    this.fontSize = "16px";
    this.labelBackground = "#181818";
    this.textColor = "#ccc";
    this.THEME_COLOR_LIMIT = 12;
    this.nodeBkg = "calculated";
    this.nodeBorder = "calculated";
    this.clusterBkg = "calculated";
    this.clusterBorder = "calculated";
    this.defaultLinkColor = "calculated";
    this.titleColor = "#F9FFFE";
    this.edgeLabelBackground = "calculated";
    this.actorBorder = "calculated";
    this.actorBkg = "calculated";
    this.actorTextColor = "calculated";
    this.actorLineColor = "calculated";
    this.signalColor = "calculated";
    this.signalTextColor = "calculated";
    this.labelBoxBkgColor = "calculated";
    this.labelBoxBorderColor = "calculated";
    this.labelTextColor = "calculated";
    this.loopTextColor = "calculated";
    this.noteBorderColor = "calculated";
    this.noteBkgColor = "#fff5ad";
    this.noteTextColor = "calculated";
    this.activationBorderColor = "calculated";
    this.activationBkgColor = "calculated";
    this.sequenceNumberColor = "black";
    this.sectionBkgColor = darken("#EAE8D9", 30);
    this.altSectionBkgColor = "calculated";
    this.sectionBkgColor2 = "#EAE8D9";
    this.excludeBkgColor = darken(this.sectionBkgColor, 10);
    this.taskBorderColor = rgba$1(255, 255, 255, 70);
    this.taskBkgColor = "calculated";
    this.taskTextColor = "calculated";
    this.taskTextLightColor = "calculated";
    this.taskTextOutsideColor = "calculated";
    this.taskTextClickableColor = "#003163";
    this.activeTaskBorderColor = rgba$1(255, 255, 255, 50);
    this.activeTaskBkgColor = "#81B1DB";
    this.gridColor = "calculated";
    this.doneTaskBkgColor = "calculated";
    this.doneTaskBorderColor = "grey";
    this.critBorderColor = "#E83737";
    this.critBkgColor = "#E83737";
    this.taskTextDarkColor = "calculated";
    this.todayLineColor = "#DB5757";
    this.vertLineColor = "#00BFFF";
    this.personBorder = this.primaryBorderColor;
    this.personBkg = this.mainBkg;
    this.archEdgeColor = "calculated";
    this.archEdgeArrowColor = "calculated";
    this.archEdgeWidth = "3";
    this.archGroupBorderColor = this.primaryBorderColor;
    this.archGroupBorderWidth = "2px";
    this.rowOdd = this.rowOdd || lighten(this.mainBkg, 5) || "#ffffff";
    this.rowEven = this.rowEven || darken(this.mainBkg, 10);
    this.labelColor = "calculated";
    this.errorBkgColor = "#a44141";
    this.errorTextColor = "#ddd";
  }
  updateColors() {
    this.secondBkg = lighten(this.mainBkg, 16);
    this.lineColor = this.mainContrastColor;
    this.arrowheadColor = this.mainContrastColor;
    this.nodeBkg = this.mainBkg;
    this.nodeBorder = this.border1;
    this.clusterBkg = this.secondBkg;
    this.clusterBorder = this.border2;
    this.defaultLinkColor = this.lineColor;
    this.edgeLabelBackground = lighten(this.labelBackground, 25);
    this.actorBorder = this.border1;
    this.actorBkg = this.mainBkg;
    this.actorTextColor = this.mainContrastColor;
    this.actorLineColor = this.actorBorder;
    this.signalColor = this.mainContrastColor;
    this.signalTextColor = this.mainContrastColor;
    this.labelBoxBkgColor = this.actorBkg;
    this.labelBoxBorderColor = this.actorBorder;
    this.labelTextColor = this.mainContrastColor;
    this.loopTextColor = this.mainContrastColor;
    this.noteBorderColor = this.secondaryBorderColor;
    this.noteBkgColor = this.secondBkg;
    this.noteTextColor = this.secondaryTextColor;
    this.activationBorderColor = this.border1;
    this.activationBkgColor = this.secondBkg;
    this.altSectionBkgColor = this.background;
    this.taskBkgColor = lighten(this.mainBkg, 23);
    this.taskTextColor = this.darkTextColor;
    this.taskTextLightColor = this.mainContrastColor;
    this.taskTextOutsideColor = this.taskTextLightColor;
    this.gridColor = this.mainContrastColor;
    this.doneTaskBkgColor = this.mainContrastColor;
    this.taskTextDarkColor = this.darkTextColor;
    this.archEdgeColor = this.lineColor;
    this.archEdgeArrowColor = this.lineColor;
    this.transitionColor = this.transitionColor || this.lineColor;
    this.transitionLabelColor = this.transitionLabelColor || this.textColor;
    this.stateLabelColor = this.stateLabelColor || this.stateBkg || this.primaryTextColor;
    this.stateBkg = this.stateBkg || this.mainBkg;
    this.labelBackgroundColor = this.labelBackgroundColor || this.stateBkg;
    this.compositeBackground = this.compositeBackground || this.background || this.tertiaryColor;
    this.altBackground = this.altBackground || "#555";
    this.compositeTitleBackground = this.compositeTitleBackground || this.mainBkg;
    this.compositeBorder = this.compositeBorder || this.nodeBorder;
    this.innerEndBackground = this.primaryBorderColor;
    this.specialStateColor = "#f4f4f4";
    this.errorBkgColor = this.errorBkgColor || this.tertiaryColor;
    this.errorTextColor = this.errorTextColor || this.tertiaryTextColor;
    this.fillType0 = this.primaryColor;
    this.fillType1 = this.secondaryColor;
    this.fillType2 = adjust(this.primaryColor, { h: 64 });
    this.fillType3 = adjust(this.secondaryColor, { h: 64 });
    this.fillType4 = adjust(this.primaryColor, { h: -64 });
    this.fillType5 = adjust(this.secondaryColor, { h: -64 });
    this.fillType6 = adjust(this.primaryColor, { h: 128 });
    this.fillType7 = adjust(this.secondaryColor, { h: 128 });
    this.cScale1 = this.cScale1 || "#0b0000";
    this.cScale2 = this.cScale2 || "#4d1037";
    this.cScale3 = this.cScale3 || "#3f5258";
    this.cScale4 = this.cScale4 || "#4f2f1b";
    this.cScale5 = this.cScale5 || "#6e0a0a";
    this.cScale6 = this.cScale6 || "#3b0048";
    this.cScale7 = this.cScale7 || "#995a01";
    this.cScale8 = this.cScale8 || "#154706";
    this.cScale9 = this.cScale9 || "#161722";
    this.cScale10 = this.cScale10 || "#00296f";
    this.cScale11 = this.cScale11 || "#01629c";
    this.cScale12 = this.cScale12 || "#010029";
    this.cScale0 = this.cScale0 || this.primaryColor;
    this.cScale1 = this.cScale1 || this.secondaryColor;
    this.cScale2 = this.cScale2 || this.tertiaryColor;
    this.cScale3 = this.cScale3 || adjust(this.primaryColor, { h: 30 });
    this.cScale4 = this.cScale4 || adjust(this.primaryColor, { h: 60 });
    this.cScale5 = this.cScale5 || adjust(this.primaryColor, { h: 90 });
    this.cScale6 = this.cScale6 || adjust(this.primaryColor, { h: 120 });
    this.cScale7 = this.cScale7 || adjust(this.primaryColor, { h: 150 });
    this.cScale8 = this.cScale8 || adjust(this.primaryColor, { h: 210 });
    this.cScale9 = this.cScale9 || adjust(this.primaryColor, { h: 270 });
    this.cScale10 = this.cScale10 || adjust(this.primaryColor, { h: 300 });
    this.cScale11 = this.cScale11 || adjust(this.primaryColor, { h: 330 });
    for (let i = 0; i < this.THEME_COLOR_LIMIT; i++) {
      this["cScaleInv" + i] = this["cScaleInv" + i] || invert(this["cScale" + i]);
    }
    for (let i = 0; i < this.THEME_COLOR_LIMIT; i++) {
      this["cScalePeer" + i] = this["cScalePeer" + i] || lighten(this["cScale" + i], 10);
    }
    for (let i = 0; i < 5; i++) {
      this["surface" + i] = this["surface" + i] || adjust(this.mainBkg, { h: 30, s: -30, l: -(-10 + i * 4) });
      this["surfacePeer" + i] = this["surfacePeer" + i] || adjust(this.mainBkg, { h: 30, s: -30, l: -(-7 + i * 4) });
    }
    this.scaleLabelColor = this.scaleLabelColor || (this.darkMode ? "black" : this.labelTextColor);
    for (let i = 0; i < this.THEME_COLOR_LIMIT; i++) {
      this["cScaleLabel" + i] = this["cScaleLabel" + i] || this.scaleLabelColor;
    }
    for (let i = 0; i < this.THEME_COLOR_LIMIT; i++) {
      this["pie" + i] = this["cScale" + i];
    }
    this.pieTitleTextSize = this.pieTitleTextSize || "25px";
    this.pieTitleTextColor = this.pieTitleTextColor || this.taskTextDarkColor;
    this.pieSectionTextSize = this.pieSectionTextSize || "17px";
    this.pieSectionTextColor = this.pieSectionTextColor || this.textColor;
    this.pieLegendTextSize = this.pieLegendTextSize || "17px";
    this.pieLegendTextColor = this.pieLegendTextColor || this.taskTextDarkColor;
    this.pieStrokeColor = this.pieStrokeColor || "black";
    this.pieStrokeWidth = this.pieStrokeWidth || "2px";
    this.pieOuterStrokeWidth = this.pieOuterStrokeWidth || "2px";
    this.pieOuterStrokeColor = this.pieOuterStrokeColor || "black";
    this.pieOpacity = this.pieOpacity || "0.7";
    this.quadrant1Fill = this.quadrant1Fill || this.primaryColor;
    this.quadrant2Fill = this.quadrant2Fill || adjust(this.primaryColor, { r: 5, g: 5, b: 5 });
    this.quadrant3Fill = this.quadrant3Fill || adjust(this.primaryColor, { r: 10, g: 10, b: 10 });
    this.quadrant4Fill = this.quadrant4Fill || adjust(this.primaryColor, { r: 15, g: 15, b: 15 });
    this.quadrant1TextFill = this.quadrant1TextFill || this.primaryTextColor;
    this.quadrant2TextFill = this.quadrant2TextFill || adjust(this.primaryTextColor, { r: -5, g: -5, b: -5 });
    this.quadrant3TextFill = this.quadrant3TextFill || adjust(this.primaryTextColor, { r: -10, g: -10, b: -10 });
    this.quadrant4TextFill = this.quadrant4TextFill || adjust(this.primaryTextColor, { r: -15, g: -15, b: -15 });
    this.quadrantPointFill = this.quadrantPointFill || isDark(this.quadrant1Fill) ? lighten(this.quadrant1Fill) : darken(this.quadrant1Fill);
    this.quadrantPointTextFill = this.quadrantPointTextFill || this.primaryTextColor;
    this.quadrantXAxisTextFill = this.quadrantXAxisTextFill || this.primaryTextColor;
    this.quadrantYAxisTextFill = this.quadrantYAxisTextFill || this.primaryTextColor;
    this.quadrantInternalBorderStrokeFill = this.quadrantInternalBorderStrokeFill || this.primaryBorderColor;
    this.quadrantExternalBorderStrokeFill = this.quadrantExternalBorderStrokeFill || this.primaryBorderColor;
    this.quadrantTitleFill = this.quadrantTitleFill || this.primaryTextColor;
    this.xyChart = {
      backgroundColor: this.xyChart?.backgroundColor || this.background,
      titleColor: this.xyChart?.titleColor || this.primaryTextColor,
      xAxisTitleColor: this.xyChart?.xAxisTitleColor || this.primaryTextColor,
      xAxisLabelColor: this.xyChart?.xAxisLabelColor || this.primaryTextColor,
      xAxisTickColor: this.xyChart?.xAxisTickColor || this.primaryTextColor,
      xAxisLineColor: this.xyChart?.xAxisLineColor || this.primaryTextColor,
      yAxisTitleColor: this.xyChart?.yAxisTitleColor || this.primaryTextColor,
      yAxisLabelColor: this.xyChart?.yAxisLabelColor || this.primaryTextColor,
      yAxisTickColor: this.xyChart?.yAxisTickColor || this.primaryTextColor,
      yAxisLineColor: this.xyChart?.yAxisLineColor || this.primaryTextColor,
      plotColorPalette: this.xyChart?.plotColorPalette || "#3498db,#2ecc71,#e74c3c,#f1c40f,#bdc3c7,#ffffff,#34495e,#9b59b6,#1abc9c,#e67e22"
    };
    this.packet = {
      startByteColor: this.primaryTextColor,
      endByteColor: this.primaryTextColor,
      labelColor: this.primaryTextColor,
      titleColor: this.primaryTextColor,
      blockStrokeColor: this.primaryTextColor,
      blockFillColor: this.background
    };
    this.radar = {
      axisColor: this.radar?.axisColor || this.lineColor,
      axisStrokeWidth: this.radar?.axisStrokeWidth || 2,
      axisLabelFontSize: this.radar?.axisLabelFontSize || 12,
      curveOpacity: this.radar?.curveOpacity || 0.5,
      curveStrokeWidth: this.radar?.curveStrokeWidth || 2,
      graticuleColor: this.radar?.graticuleColor || "#DEDEDE",
      graticuleStrokeWidth: this.radar?.graticuleStrokeWidth || 1,
      graticuleOpacity: this.radar?.graticuleOpacity || 0.3,
      legendBoxSize: this.radar?.legendBoxSize || 12,
      legendFontSize: this.radar?.legendFontSize || 12
    };
    this.classText = this.primaryTextColor;
    this.requirementBackground = this.requirementBackground || this.primaryColor;
    this.requirementBorderColor = this.requirementBorderColor || this.primaryBorderColor;
    this.requirementBorderSize = this.requirementBorderSize || "1";
    this.requirementTextColor = this.requirementTextColor || this.primaryTextColor;
    this.relationColor = this.relationColor || this.lineColor;
    this.relationLabelBackground = this.relationLabelBackground || (this.darkMode ? darken(this.secondaryColor, 30) : this.secondaryColor);
    this.relationLabelColor = this.relationLabelColor || this.actorTextColor;
    this.git0 = lighten(this.secondaryColor, 20);
    this.git1 = lighten(this.pie2 || this.secondaryColor, 20);
    this.git2 = lighten(this.pie3 || this.tertiaryColor, 20);
    this.git3 = lighten(this.pie4 || adjust(this.primaryColor, { h: -30 }), 20);
    this.git4 = lighten(this.pie5 || adjust(this.primaryColor, { h: -60 }), 20);
    this.git5 = lighten(this.pie6 || adjust(this.primaryColor, { h: -90 }), 10);
    this.git6 = lighten(this.pie7 || adjust(this.primaryColor, { h: 60 }), 10);
    this.git7 = lighten(this.pie8 || adjust(this.primaryColor, { h: 120 }), 20);
    this.gitInv0 = this.gitInv0 || invert(this.git0);
    this.gitInv1 = this.gitInv1 || invert(this.git1);
    this.gitInv2 = this.gitInv2 || invert(this.git2);
    this.gitInv3 = this.gitInv3 || invert(this.git3);
    this.gitInv4 = this.gitInv4 || invert(this.git4);
    this.gitInv5 = this.gitInv5 || invert(this.git5);
    this.gitInv6 = this.gitInv6 || invert(this.git6);
    this.gitInv7 = this.gitInv7 || invert(this.git7);
    this.gitBranchLabel0 = this.gitBranchLabel0 || invert(this.labelTextColor);
    this.gitBranchLabel1 = this.gitBranchLabel1 || this.labelTextColor;
    this.gitBranchLabel2 = this.gitBranchLabel2 || this.labelTextColor;
    this.gitBranchLabel3 = this.gitBranchLabel3 || invert(this.labelTextColor);
    this.gitBranchLabel4 = this.gitBranchLabel4 || this.labelTextColor;
    this.gitBranchLabel5 = this.gitBranchLabel5 || this.labelTextColor;
    this.gitBranchLabel6 = this.gitBranchLabel6 || this.labelTextColor;
    this.gitBranchLabel7 = this.gitBranchLabel7 || this.labelTextColor;
    this.tagLabelColor = this.tagLabelColor || this.primaryTextColor;
    this.tagLabelBackground = this.tagLabelBackground || this.primaryColor;
    this.tagLabelBorder = this.tagBorder || this.primaryBorderColor;
    this.tagLabelFontSize = this.tagLabelFontSize || "10px";
    this.commitLabelColor = this.commitLabelColor || this.secondaryTextColor;
    this.commitLabelBackground = this.commitLabelBackground || this.secondaryColor;
    this.commitLabelFontSize = this.commitLabelFontSize || "10px";
    this.attributeBackgroundColorOdd = this.attributeBackgroundColorOdd || lighten(this.background, 12);
    this.attributeBackgroundColorEven = this.attributeBackgroundColorEven || lighten(this.background, 2);
    this.nodeBorder = this.nodeBorder || "#999";
  }
  calculate(overrides) {
    if (typeof overrides !== "object") {
      this.updateColors();
      return;
    }
    const keys = Object.keys(overrides);
    keys.forEach((k) => {
      this[k] = overrides[k];
    });
    this.updateColors();
    keys.forEach((k) => {
      this[k] = overrides[k];
    });
  }
};
var getThemeVariables2 = /* @__PURE__ */ __name((userOverrides) => {
  const theme = new Theme2();
  theme.calculate(userOverrides);
  return theme;
}, "getThemeVariables");
var Theme3 = class {
  static {
    __name(this, "Theme");
  }
  constructor() {
    this.background = "#f4f4f4";
    this.primaryColor = "#ECECFF";
    this.secondaryColor = adjust(this.primaryColor, { h: 120 });
    this.secondaryColor = "#ffffde";
    this.tertiaryColor = adjust(this.primaryColor, { h: -160 });
    this.primaryBorderColor = mkBorder(this.primaryColor, this.darkMode);
    this.secondaryBorderColor = mkBorder(this.secondaryColor, this.darkMode);
    this.tertiaryBorderColor = mkBorder(this.tertiaryColor, this.darkMode);
    this.primaryTextColor = invert(this.primaryColor);
    this.secondaryTextColor = invert(this.secondaryColor);
    this.tertiaryTextColor = invert(this.tertiaryColor);
    this.lineColor = invert(this.background);
    this.textColor = invert(this.background);
    this.background = "white";
    this.mainBkg = "#ECECFF";
    this.secondBkg = "#ffffde";
    this.lineColor = "#333333";
    this.border1 = "#9370DB";
    this.border2 = "#aaaa33";
    this.arrowheadColor = "#333333";
    this.fontFamily = '"trebuchet ms", verdana, arial, sans-serif';
    this.fontSize = "16px";
    this.labelBackground = "rgba(232,232,232, 0.8)";
    this.textColor = "#333";
    this.THEME_COLOR_LIMIT = 12;
    this.nodeBkg = "calculated";
    this.nodeBorder = "calculated";
    this.clusterBkg = "calculated";
    this.clusterBorder = "calculated";
    this.defaultLinkColor = "calculated";
    this.titleColor = "calculated";
    this.edgeLabelBackground = "calculated";
    this.actorBorder = "calculated";
    this.actorBkg = "calculated";
    this.actorTextColor = "black";
    this.actorLineColor = "calculated";
    this.signalColor = "calculated";
    this.signalTextColor = "calculated";
    this.labelBoxBkgColor = "calculated";
    this.labelBoxBorderColor = "calculated";
    this.labelTextColor = "calculated";
    this.loopTextColor = "calculated";
    this.noteBorderColor = "calculated";
    this.noteBkgColor = "#fff5ad";
    this.noteTextColor = "calculated";
    this.activationBorderColor = "#666";
    this.activationBkgColor = "#f4f4f4";
    this.sequenceNumberColor = "white";
    this.sectionBkgColor = "calculated";
    this.altSectionBkgColor = "calculated";
    this.sectionBkgColor2 = "calculated";
    this.excludeBkgColor = "#eeeeee";
    this.taskBorderColor = "calculated";
    this.taskBkgColor = "calculated";
    this.taskTextLightColor = "calculated";
    this.taskTextColor = this.taskTextLightColor;
    this.taskTextDarkColor = "calculated";
    this.taskTextOutsideColor = this.taskTextDarkColor;
    this.taskTextClickableColor = "calculated";
    this.activeTaskBorderColor = "calculated";
    this.activeTaskBkgColor = "calculated";
    this.gridColor = "calculated";
    this.doneTaskBkgColor = "calculated";
    this.doneTaskBorderColor = "calculated";
    this.critBorderColor = "calculated";
    this.critBkgColor = "calculated";
    this.todayLineColor = "calculated";
    this.vertLineColor = "calculated";
    this.sectionBkgColor = rgba$1(102, 102, 255, 0.49);
    this.altSectionBkgColor = "white";
    this.sectionBkgColor2 = "#fff400";
    this.taskBorderColor = "#534fbc";
    this.taskBkgColor = "#8a90dd";
    this.taskTextLightColor = "white";
    this.taskTextColor = "calculated";
    this.taskTextDarkColor = "black";
    this.taskTextOutsideColor = "calculated";
    this.taskTextClickableColor = "#003163";
    this.activeTaskBorderColor = "#534fbc";
    this.activeTaskBkgColor = "#bfc7ff";
    this.gridColor = "lightgrey";
    this.doneTaskBkgColor = "lightgrey";
    this.doneTaskBorderColor = "grey";
    this.critBorderColor = "#ff8888";
    this.critBkgColor = "red";
    this.todayLineColor = "red";
    this.vertLineColor = "navy";
    this.personBorder = this.primaryBorderColor;
    this.personBkg = this.mainBkg;
    this.archEdgeColor = "calculated";
    this.archEdgeArrowColor = "calculated";
    this.archEdgeWidth = "3";
    this.archGroupBorderColor = this.primaryBorderColor;
    this.archGroupBorderWidth = "2px";
    this.rowOdd = "calculated";
    this.rowEven = "calculated";
    this.labelColor = "black";
    this.errorBkgColor = "#552222";
    this.errorTextColor = "#552222";
    this.updateColors();
  }
  updateColors() {
    this.cScale0 = this.cScale0 || this.primaryColor;
    this.cScale1 = this.cScale1 || this.secondaryColor;
    this.cScale2 = this.cScale2 || this.tertiaryColor;
    this.cScale3 = this.cScale3 || adjust(this.primaryColor, { h: 30 });
    this.cScale4 = this.cScale4 || adjust(this.primaryColor, { h: 60 });
    this.cScale5 = this.cScale5 || adjust(this.primaryColor, { h: 90 });
    this.cScale6 = this.cScale6 || adjust(this.primaryColor, { h: 120 });
    this.cScale7 = this.cScale7 || adjust(this.primaryColor, { h: 150 });
    this.cScale8 = this.cScale8 || adjust(this.primaryColor, { h: 210 });
    this.cScale9 = this.cScale9 || adjust(this.primaryColor, { h: 270 });
    this.cScale10 = this.cScale10 || adjust(this.primaryColor, { h: 300 });
    this.cScale11 = this.cScale11 || adjust(this.primaryColor, { h: 330 });
    this["cScalePeer1"] = this["cScalePeer1"] || darken(this.secondaryColor, 45);
    this["cScalePeer2"] = this["cScalePeer2"] || darken(this.tertiaryColor, 40);
    for (let i = 0; i < this.THEME_COLOR_LIMIT; i++) {
      this["cScale" + i] = darken(this["cScale" + i], 10);
      this["cScalePeer" + i] = this["cScalePeer" + i] || darken(this["cScale" + i], 25);
    }
    for (let i = 0; i < this.THEME_COLOR_LIMIT; i++) {
      this["cScaleInv" + i] = this["cScaleInv" + i] || adjust(this["cScale" + i], { h: 180 });
    }
    for (let i = 0; i < 5; i++) {
      this["surface" + i] = this["surface" + i] || adjust(this.mainBkg, { h: 30, l: -(5 + i * 5) });
      this["surfacePeer" + i] = this["surfacePeer" + i] || adjust(this.mainBkg, { h: 30, l: -(7 + i * 5) });
    }
    this.scaleLabelColor = this.scaleLabelColor !== "calculated" && this.scaleLabelColor ? this.scaleLabelColor : this.labelTextColor;
    if (this.labelTextColor !== "calculated") {
      this.cScaleLabel0 = this.cScaleLabel0 || invert(this.labelTextColor);
      this.cScaleLabel3 = this.cScaleLabel3 || invert(this.labelTextColor);
      for (let i = 0; i < this.THEME_COLOR_LIMIT; i++) {
        this["cScaleLabel" + i] = this["cScaleLabel" + i] || this.labelTextColor;
      }
    }
    this.nodeBkg = this.mainBkg;
    this.nodeBorder = this.border1;
    this.clusterBkg = this.secondBkg;
    this.clusterBorder = this.border2;
    this.defaultLinkColor = this.lineColor;
    this.titleColor = this.textColor;
    this.edgeLabelBackground = this.labelBackground;
    this.actorBorder = lighten(this.border1, 23);
    this.actorBkg = this.mainBkg;
    this.labelBoxBkgColor = this.actorBkg;
    this.signalColor = this.textColor;
    this.signalTextColor = this.textColor;
    this.labelBoxBorderColor = this.actorBorder;
    this.labelTextColor = this.actorTextColor;
    this.loopTextColor = this.actorTextColor;
    this.noteBorderColor = this.border2;
    this.noteTextColor = this.actorTextColor;
    this.actorLineColor = this.actorBorder;
    this.taskTextColor = this.taskTextLightColor;
    this.taskTextOutsideColor = this.taskTextDarkColor;
    this.archEdgeColor = this.lineColor;
    this.archEdgeArrowColor = this.lineColor;
    this.rowOdd = this.rowOdd || lighten(this.primaryColor, 75) || "#ffffff";
    this.rowEven = this.rowEven || lighten(this.primaryColor, 1);
    this.transitionColor = this.transitionColor || this.lineColor;
    this.transitionLabelColor = this.transitionLabelColor || this.textColor;
    this.stateLabelColor = this.stateLabelColor || this.stateBkg || this.primaryTextColor;
    this.stateBkg = this.stateBkg || this.mainBkg;
    this.labelBackgroundColor = this.labelBackgroundColor || this.stateBkg;
    this.compositeBackground = this.compositeBackground || this.background || this.tertiaryColor;
    this.altBackground = this.altBackground || "#f0f0f0";
    this.compositeTitleBackground = this.compositeTitleBackground || this.mainBkg;
    this.compositeBorder = this.compositeBorder || this.nodeBorder;
    this.innerEndBackground = this.nodeBorder;
    this.specialStateColor = this.lineColor;
    this.errorBkgColor = this.errorBkgColor || this.tertiaryColor;
    this.errorTextColor = this.errorTextColor || this.tertiaryTextColor;
    this.transitionColor = this.transitionColor || this.lineColor;
    this.classText = this.primaryTextColor;
    this.fillType0 = this.primaryColor;
    this.fillType1 = this.secondaryColor;
    this.fillType2 = adjust(this.primaryColor, { h: 64 });
    this.fillType3 = adjust(this.secondaryColor, { h: 64 });
    this.fillType4 = adjust(this.primaryColor, { h: -64 });
    this.fillType5 = adjust(this.secondaryColor, { h: -64 });
    this.fillType6 = adjust(this.primaryColor, { h: 128 });
    this.fillType7 = adjust(this.secondaryColor, { h: 128 });
    this.pie1 = this.pie1 || this.primaryColor;
    this.pie2 = this.pie2 || this.secondaryColor;
    this.pie3 = this.pie3 || adjust(this.tertiaryColor, { l: -40 });
    this.pie4 = this.pie4 || adjust(this.primaryColor, { l: -10 });
    this.pie5 = this.pie5 || adjust(this.secondaryColor, { l: -30 });
    this.pie6 = this.pie6 || adjust(this.tertiaryColor, { l: -20 });
    this.pie7 = this.pie7 || adjust(this.primaryColor, { h: 60, l: -20 });
    this.pie8 = this.pie8 || adjust(this.primaryColor, { h: -60, l: -40 });
    this.pie9 = this.pie9 || adjust(this.primaryColor, { h: 120, l: -40 });
    this.pie10 = this.pie10 || adjust(this.primaryColor, { h: 60, l: -40 });
    this.pie11 = this.pie11 || adjust(this.primaryColor, { h: -90, l: -40 });
    this.pie12 = this.pie12 || adjust(this.primaryColor, { h: 120, l: -30 });
    this.pieTitleTextSize = this.pieTitleTextSize || "25px";
    this.pieTitleTextColor = this.pieTitleTextColor || this.taskTextDarkColor;
    this.pieSectionTextSize = this.pieSectionTextSize || "17px";
    this.pieSectionTextColor = this.pieSectionTextColor || this.textColor;
    this.pieLegendTextSize = this.pieLegendTextSize || "17px";
    this.pieLegendTextColor = this.pieLegendTextColor || this.taskTextDarkColor;
    this.pieStrokeColor = this.pieStrokeColor || "black";
    this.pieStrokeWidth = this.pieStrokeWidth || "2px";
    this.pieOuterStrokeWidth = this.pieOuterStrokeWidth || "2px";
    this.pieOuterStrokeColor = this.pieOuterStrokeColor || "black";
    this.pieOpacity = this.pieOpacity || "0.7";
    this.quadrant1Fill = this.quadrant1Fill || this.primaryColor;
    this.quadrant2Fill = this.quadrant2Fill || adjust(this.primaryColor, { r: 5, g: 5, b: 5 });
    this.quadrant3Fill = this.quadrant3Fill || adjust(this.primaryColor, { r: 10, g: 10, b: 10 });
    this.quadrant4Fill = this.quadrant4Fill || adjust(this.primaryColor, { r: 15, g: 15, b: 15 });
    this.quadrant1TextFill = this.quadrant1TextFill || this.primaryTextColor;
    this.quadrant2TextFill = this.quadrant2TextFill || adjust(this.primaryTextColor, { r: -5, g: -5, b: -5 });
    this.quadrant3TextFill = this.quadrant3TextFill || adjust(this.primaryTextColor, { r: -10, g: -10, b: -10 });
    this.quadrant4TextFill = this.quadrant4TextFill || adjust(this.primaryTextColor, { r: -15, g: -15, b: -15 });
    this.quadrantPointFill = this.quadrantPointFill || isDark(this.quadrant1Fill) ? lighten(this.quadrant1Fill) : darken(this.quadrant1Fill);
    this.quadrantPointTextFill = this.quadrantPointTextFill || this.primaryTextColor;
    this.quadrantXAxisTextFill = this.quadrantXAxisTextFill || this.primaryTextColor;
    this.quadrantYAxisTextFill = this.quadrantYAxisTextFill || this.primaryTextColor;
    this.quadrantInternalBorderStrokeFill = this.quadrantInternalBorderStrokeFill || this.primaryBorderColor;
    this.quadrantExternalBorderStrokeFill = this.quadrantExternalBorderStrokeFill || this.primaryBorderColor;
    this.quadrantTitleFill = this.quadrantTitleFill || this.primaryTextColor;
    this.radar = {
      axisColor: this.radar?.axisColor || this.lineColor,
      axisStrokeWidth: this.radar?.axisStrokeWidth || 2,
      axisLabelFontSize: this.radar?.axisLabelFontSize || 12,
      curveOpacity: this.radar?.curveOpacity || 0.5,
      curveStrokeWidth: this.radar?.curveStrokeWidth || 2,
      graticuleColor: this.radar?.graticuleColor || "#DEDEDE",
      graticuleStrokeWidth: this.radar?.graticuleStrokeWidth || 1,
      graticuleOpacity: this.radar?.graticuleOpacity || 0.3,
      legendBoxSize: this.radar?.legendBoxSize || 12,
      legendFontSize: this.radar?.legendFontSize || 12
    };
    this.xyChart = {
      backgroundColor: this.xyChart?.backgroundColor || this.background,
      titleColor: this.xyChart?.titleColor || this.primaryTextColor,
      xAxisTitleColor: this.xyChart?.xAxisTitleColor || this.primaryTextColor,
      xAxisLabelColor: this.xyChart?.xAxisLabelColor || this.primaryTextColor,
      xAxisTickColor: this.xyChart?.xAxisTickColor || this.primaryTextColor,
      xAxisLineColor: this.xyChart?.xAxisLineColor || this.primaryTextColor,
      yAxisTitleColor: this.xyChart?.yAxisTitleColor || this.primaryTextColor,
      yAxisLabelColor: this.xyChart?.yAxisLabelColor || this.primaryTextColor,
      yAxisTickColor: this.xyChart?.yAxisTickColor || this.primaryTextColor,
      yAxisLineColor: this.xyChart?.yAxisLineColor || this.primaryTextColor,
      plotColorPalette: this.xyChart?.plotColorPalette || "#ECECFF,#8493A6,#FFC3A0,#DCDDE1,#B8E994,#D1A36F,#C3CDE6,#FFB6C1,#496078,#F8F3E3"
    };
    this.requirementBackground = this.requirementBackground || this.primaryColor;
    this.requirementBorderColor = this.requirementBorderColor || this.primaryBorderColor;
    this.requirementBorderSize = this.requirementBorderSize || "1";
    this.requirementTextColor = this.requirementTextColor || this.primaryTextColor;
    this.relationColor = this.relationColor || this.lineColor;
    this.relationLabelBackground = this.relationLabelBackground || this.labelBackground;
    this.relationLabelColor = this.relationLabelColor || this.actorTextColor;
    this.git0 = this.git0 || this.primaryColor;
    this.git1 = this.git1 || this.secondaryColor;
    this.git2 = this.git2 || this.tertiaryColor;
    this.git3 = this.git3 || adjust(this.primaryColor, { h: -30 });
    this.git4 = this.git4 || adjust(this.primaryColor, { h: -60 });
    this.git5 = this.git5 || adjust(this.primaryColor, { h: -90 });
    this.git6 = this.git6 || adjust(this.primaryColor, { h: 60 });
    this.git7 = this.git7 || adjust(this.primaryColor, { h: 120 });
    if (this.darkMode) {
      this.git0 = lighten(this.git0, 25);
      this.git1 = lighten(this.git1, 25);
      this.git2 = lighten(this.git2, 25);
      this.git3 = lighten(this.git3, 25);
      this.git4 = lighten(this.git4, 25);
      this.git5 = lighten(this.git5, 25);
      this.git6 = lighten(this.git6, 25);
      this.git7 = lighten(this.git7, 25);
    } else {
      this.git0 = darken(this.git0, 25);
      this.git1 = darken(this.git1, 25);
      this.git2 = darken(this.git2, 25);
      this.git3 = darken(this.git3, 25);
      this.git4 = darken(this.git4, 25);
      this.git5 = darken(this.git5, 25);
      this.git6 = darken(this.git6, 25);
      this.git7 = darken(this.git7, 25);
    }
    this.gitInv0 = this.gitInv0 || darken(invert(this.git0), 25);
    this.gitInv1 = this.gitInv1 || invert(this.git1);
    this.gitInv2 = this.gitInv2 || invert(this.git2);
    this.gitInv3 = this.gitInv3 || invert(this.git3);
    this.gitInv4 = this.gitInv4 || invert(this.git4);
    this.gitInv5 = this.gitInv5 || invert(this.git5);
    this.gitInv6 = this.gitInv6 || invert(this.git6);
    this.gitInv7 = this.gitInv7 || invert(this.git7);
    this.gitBranchLabel0 = this.gitBranchLabel0 || invert(this.labelTextColor);
    this.gitBranchLabel1 = this.gitBranchLabel1 || this.labelTextColor;
    this.gitBranchLabel2 = this.gitBranchLabel2 || this.labelTextColor;
    this.gitBranchLabel3 = this.gitBranchLabel3 || invert(this.labelTextColor);
    this.gitBranchLabel4 = this.gitBranchLabel4 || this.labelTextColor;
    this.gitBranchLabel5 = this.gitBranchLabel5 || this.labelTextColor;
    this.gitBranchLabel6 = this.gitBranchLabel6 || this.labelTextColor;
    this.gitBranchLabel7 = this.gitBranchLabel7 || this.labelTextColor;
    this.tagLabelColor = this.tagLabelColor || this.primaryTextColor;
    this.tagLabelBackground = this.tagLabelBackground || this.primaryColor;
    this.tagLabelBorder = this.tagBorder || this.primaryBorderColor;
    this.tagLabelFontSize = this.tagLabelFontSize || "10px";
    this.commitLabelColor = this.commitLabelColor || this.secondaryTextColor;
    this.commitLabelBackground = this.commitLabelBackground || this.secondaryColor;
    this.commitLabelFontSize = this.commitLabelFontSize || "10px";
    this.attributeBackgroundColorOdd = this.attributeBackgroundColorOdd || oldAttributeBackgroundColorOdd;
    this.attributeBackgroundColorEven = this.attributeBackgroundColorEven || oldAttributeBackgroundColorEven;
  }
  calculate(overrides) {
    Object.keys(this).forEach((k) => {
      if (this[k] === "calculated") {
        this[k] = void 0;
      }
    });
    if (typeof overrides !== "object") {
      this.updateColors();
      return;
    }
    const keys = Object.keys(overrides);
    keys.forEach((k) => {
      this[k] = overrides[k];
    });
    this.updateColors();
    keys.forEach((k) => {
      this[k] = overrides[k];
    });
  }
};
var getThemeVariables3 = /* @__PURE__ */ __name((userOverrides) => {
  const theme = new Theme3();
  theme.calculate(userOverrides);
  return theme;
}, "getThemeVariables");
var Theme4 = class {
  static {
    __name(this, "Theme");
  }
  constructor() {
    this.background = "#f4f4f4";
    this.primaryColor = "#cde498";
    this.secondaryColor = "#cdffb2";
    this.background = "white";
    this.mainBkg = "#cde498";
    this.secondBkg = "#cdffb2";
    this.lineColor = "green";
    this.border1 = "#13540c";
    this.border2 = "#6eaa49";
    this.arrowheadColor = "green";
    this.fontFamily = '"trebuchet ms", verdana, arial, sans-serif';
    this.fontSize = "16px";
    this.tertiaryColor = lighten("#cde498", 10);
    this.primaryBorderColor = mkBorder(this.primaryColor, this.darkMode);
    this.secondaryBorderColor = mkBorder(this.secondaryColor, this.darkMode);
    this.tertiaryBorderColor = mkBorder(this.tertiaryColor, this.darkMode);
    this.primaryTextColor = invert(this.primaryColor);
    this.secondaryTextColor = invert(this.secondaryColor);
    this.tertiaryTextColor = invert(this.primaryColor);
    this.lineColor = invert(this.background);
    this.textColor = invert(this.background);
    this.THEME_COLOR_LIMIT = 12;
    this.nodeBkg = "calculated";
    this.nodeBorder = "calculated";
    this.clusterBkg = "calculated";
    this.clusterBorder = "calculated";
    this.defaultLinkColor = "calculated";
    this.titleColor = "#333";
    this.edgeLabelBackground = "#e8e8e8";
    this.actorBorder = "calculated";
    this.actorBkg = "calculated";
    this.actorTextColor = "black";
    this.actorLineColor = "calculated";
    this.signalColor = "#333";
    this.signalTextColor = "#333";
    this.labelBoxBkgColor = "calculated";
    this.labelBoxBorderColor = "#326932";
    this.labelTextColor = "calculated";
    this.loopTextColor = "calculated";
    this.noteBorderColor = "calculated";
    this.noteBkgColor = "#fff5ad";
    this.noteTextColor = "calculated";
    this.activationBorderColor = "#666";
    this.activationBkgColor = "#f4f4f4";
    this.sequenceNumberColor = "white";
    this.sectionBkgColor = "#6eaa49";
    this.altSectionBkgColor = "white";
    this.sectionBkgColor2 = "#6eaa49";
    this.excludeBkgColor = "#eeeeee";
    this.taskBorderColor = "calculated";
    this.taskBkgColor = "#487e3a";
    this.taskTextLightColor = "white";
    this.taskTextColor = "calculated";
    this.taskTextDarkColor = "black";
    this.taskTextOutsideColor = "calculated";
    this.taskTextClickableColor = "#003163";
    this.activeTaskBorderColor = "calculated";
    this.activeTaskBkgColor = "calculated";
    this.gridColor = "lightgrey";
    this.doneTaskBkgColor = "lightgrey";
    this.doneTaskBorderColor = "grey";
    this.critBorderColor = "#ff8888";
    this.critBkgColor = "red";
    this.todayLineColor = "red";
    this.vertLineColor = "#00BFFF";
    this.personBorder = this.primaryBorderColor;
    this.personBkg = this.mainBkg;
    this.archEdgeColor = "calculated";
    this.archEdgeArrowColor = "calculated";
    this.archEdgeWidth = "3";
    this.archGroupBorderColor = this.primaryBorderColor;
    this.archGroupBorderWidth = "2px";
    this.labelColor = "black";
    this.errorBkgColor = "#552222";
    this.errorTextColor = "#552222";
  }
  updateColors() {
    this.actorBorder = darken(this.mainBkg, 20);
    this.actorBkg = this.mainBkg;
    this.labelBoxBkgColor = this.actorBkg;
    this.labelTextColor = this.actorTextColor;
    this.loopTextColor = this.actorTextColor;
    this.noteBorderColor = this.border2;
    this.noteTextColor = this.actorTextColor;
    this.actorLineColor = this.actorBorder;
    this.cScale0 = this.cScale0 || this.primaryColor;
    this.cScale1 = this.cScale1 || this.secondaryColor;
    this.cScale2 = this.cScale2 || this.tertiaryColor;
    this.cScale3 = this.cScale3 || adjust(this.primaryColor, { h: 30 });
    this.cScale4 = this.cScale4 || adjust(this.primaryColor, { h: 60 });
    this.cScale5 = this.cScale5 || adjust(this.primaryColor, { h: 90 });
    this.cScale6 = this.cScale6 || adjust(this.primaryColor, { h: 120 });
    this.cScale7 = this.cScale7 || adjust(this.primaryColor, { h: 150 });
    this.cScale8 = this.cScale8 || adjust(this.primaryColor, { h: 210 });
    this.cScale9 = this.cScale9 || adjust(this.primaryColor, { h: 270 });
    this.cScale10 = this.cScale10 || adjust(this.primaryColor, { h: 300 });
    this.cScale11 = this.cScale11 || adjust(this.primaryColor, { h: 330 });
    this["cScalePeer1"] = this["cScalePeer1"] || darken(this.secondaryColor, 45);
    this["cScalePeer2"] = this["cScalePeer2"] || darken(this.tertiaryColor, 40);
    for (let i = 0; i < this.THEME_COLOR_LIMIT; i++) {
      this["cScale" + i] = darken(this["cScale" + i], 10);
      this["cScalePeer" + i] = this["cScalePeer" + i] || darken(this["cScale" + i], 25);
    }
    for (let i = 0; i < this.THEME_COLOR_LIMIT; i++) {
      this["cScaleInv" + i] = this["cScaleInv" + i] || adjust(this["cScale" + i], { h: 180 });
    }
    this.scaleLabelColor = this.scaleLabelColor !== "calculated" && this.scaleLabelColor ? this.scaleLabelColor : this.labelTextColor;
    for (let i = 0; i < this.THEME_COLOR_LIMIT; i++) {
      this["cScaleLabel" + i] = this["cScaleLabel" + i] || this.scaleLabelColor;
    }
    for (let i = 0; i < 5; i++) {
      this["surface" + i] = this["surface" + i] || adjust(this.mainBkg, { h: 30, s: -30, l: -(5 + i * 5) });
      this["surfacePeer" + i] = this["surfacePeer" + i] || adjust(this.mainBkg, { h: 30, s: -30, l: -(8 + i * 5) });
    }
    this.nodeBkg = this.mainBkg;
    this.nodeBorder = this.border1;
    this.clusterBkg = this.secondBkg;
    this.clusterBorder = this.border2;
    this.defaultLinkColor = this.lineColor;
    this.taskBorderColor = this.border1;
    this.taskTextColor = this.taskTextLightColor;
    this.taskTextOutsideColor = this.taskTextDarkColor;
    this.activeTaskBorderColor = this.taskBorderColor;
    this.activeTaskBkgColor = this.mainBkg;
    this.archEdgeColor = this.lineColor;
    this.archEdgeArrowColor = this.lineColor;
    this.rowOdd = this.rowOdd || lighten(this.mainBkg, 75) || "#ffffff";
    this.rowEven = this.rowEven || lighten(this.mainBkg, 20);
    this.transitionColor = this.transitionColor || this.lineColor;
    this.transitionLabelColor = this.transitionLabelColor || this.textColor;
    this.stateLabelColor = this.stateLabelColor || this.stateBkg || this.primaryTextColor;
    this.stateBkg = this.stateBkg || this.mainBkg;
    this.labelBackgroundColor = this.labelBackgroundColor || this.stateBkg;
    this.compositeBackground = this.compositeBackground || this.background || this.tertiaryColor;
    this.altBackground = this.altBackground || "#f0f0f0";
    this.compositeTitleBackground = this.compositeTitleBackground || this.mainBkg;
    this.compositeBorder = this.compositeBorder || this.nodeBorder;
    this.innerEndBackground = this.primaryBorderColor;
    this.specialStateColor = this.lineColor;
    this.errorBkgColor = this.errorBkgColor || this.tertiaryColor;
    this.errorTextColor = this.errorTextColor || this.tertiaryTextColor;
    this.transitionColor = this.transitionColor || this.lineColor;
    this.classText = this.primaryTextColor;
    this.fillType0 = this.primaryColor;
    this.fillType1 = this.secondaryColor;
    this.fillType2 = adjust(this.primaryColor, { h: 64 });
    this.fillType3 = adjust(this.secondaryColor, { h: 64 });
    this.fillType4 = adjust(this.primaryColor, { h: -64 });
    this.fillType5 = adjust(this.secondaryColor, { h: -64 });
    this.fillType6 = adjust(this.primaryColor, { h: 128 });
    this.fillType7 = adjust(this.secondaryColor, { h: 128 });
    this.pie1 = this.pie1 || this.primaryColor;
    this.pie2 = this.pie2 || this.secondaryColor;
    this.pie3 = this.pie3 || this.tertiaryColor;
    this.pie4 = this.pie4 || adjust(this.primaryColor, { l: -30 });
    this.pie5 = this.pie5 || adjust(this.secondaryColor, { l: -30 });
    this.pie6 = this.pie6 || adjust(this.tertiaryColor, { h: 40, l: -40 });
    this.pie7 = this.pie7 || adjust(this.primaryColor, { h: 60, l: -10 });
    this.pie8 = this.pie8 || adjust(this.primaryColor, { h: -60, l: -10 });
    this.pie9 = this.pie9 || adjust(this.primaryColor, { h: 120, l: 0 });
    this.pie10 = this.pie10 || adjust(this.primaryColor, { h: 60, l: -50 });
    this.pie11 = this.pie11 || adjust(this.primaryColor, { h: -60, l: -50 });
    this.pie12 = this.pie12 || adjust(this.primaryColor, { h: 120, l: -50 });
    this.pieTitleTextSize = this.pieTitleTextSize || "25px";
    this.pieTitleTextColor = this.pieTitleTextColor || this.taskTextDarkColor;
    this.pieSectionTextSize = this.pieSectionTextSize || "17px";
    this.pieSectionTextColor = this.pieSectionTextColor || this.textColor;
    this.pieLegendTextSize = this.pieLegendTextSize || "17px";
    this.pieLegendTextColor = this.pieLegendTextColor || this.taskTextDarkColor;
    this.pieStrokeColor = this.pieStrokeColor || "black";
    this.pieStrokeWidth = this.pieStrokeWidth || "2px";
    this.pieOuterStrokeWidth = this.pieOuterStrokeWidth || "2px";
    this.pieOuterStrokeColor = this.pieOuterStrokeColor || "black";
    this.pieOpacity = this.pieOpacity || "0.7";
    this.quadrant1Fill = this.quadrant1Fill || this.primaryColor;
    this.quadrant2Fill = this.quadrant2Fill || adjust(this.primaryColor, { r: 5, g: 5, b: 5 });
    this.quadrant3Fill = this.quadrant3Fill || adjust(this.primaryColor, { r: 10, g: 10, b: 10 });
    this.quadrant4Fill = this.quadrant4Fill || adjust(this.primaryColor, { r: 15, g: 15, b: 15 });
    this.quadrant1TextFill = this.quadrant1TextFill || this.primaryTextColor;
    this.quadrant2TextFill = this.quadrant2TextFill || adjust(this.primaryTextColor, { r: -5, g: -5, b: -5 });
    this.quadrant3TextFill = this.quadrant3TextFill || adjust(this.primaryTextColor, { r: -10, g: -10, b: -10 });
    this.quadrant4TextFill = this.quadrant4TextFill || adjust(this.primaryTextColor, { r: -15, g: -15, b: -15 });
    this.quadrantPointFill = this.quadrantPointFill || isDark(this.quadrant1Fill) ? lighten(this.quadrant1Fill) : darken(this.quadrant1Fill);
    this.quadrantPointTextFill = this.quadrantPointTextFill || this.primaryTextColor;
    this.quadrantXAxisTextFill = this.quadrantXAxisTextFill || this.primaryTextColor;
    this.quadrantYAxisTextFill = this.quadrantYAxisTextFill || this.primaryTextColor;
    this.quadrantInternalBorderStrokeFill = this.quadrantInternalBorderStrokeFill || this.primaryBorderColor;
    this.quadrantExternalBorderStrokeFill = this.quadrantExternalBorderStrokeFill || this.primaryBorderColor;
    this.quadrantTitleFill = this.quadrantTitleFill || this.primaryTextColor;
    this.packet = {
      startByteColor: this.primaryTextColor,
      endByteColor: this.primaryTextColor,
      labelColor: this.primaryTextColor,
      titleColor: this.primaryTextColor,
      blockStrokeColor: this.primaryTextColor,
      blockFillColor: this.mainBkg
    };
    this.radar = {
      axisColor: this.radar?.axisColor || this.lineColor,
      axisStrokeWidth: this.radar?.axisStrokeWidth || 2,
      axisLabelFontSize: this.radar?.axisLabelFontSize || 12,
      curveOpacity: this.radar?.curveOpacity || 0.5,
      curveStrokeWidth: this.radar?.curveStrokeWidth || 2,
      graticuleColor: this.radar?.graticuleColor || "#DEDEDE",
      graticuleStrokeWidth: this.radar?.graticuleStrokeWidth || 1,
      graticuleOpacity: this.radar?.graticuleOpacity || 0.3,
      legendBoxSize: this.radar?.legendBoxSize || 12,
      legendFontSize: this.radar?.legendFontSize || 12
    };
    this.xyChart = {
      backgroundColor: this.xyChart?.backgroundColor || this.background,
      titleColor: this.xyChart?.titleColor || this.primaryTextColor,
      xAxisTitleColor: this.xyChart?.xAxisTitleColor || this.primaryTextColor,
      xAxisLabelColor: this.xyChart?.xAxisLabelColor || this.primaryTextColor,
      xAxisTickColor: this.xyChart?.xAxisTickColor || this.primaryTextColor,
      xAxisLineColor: this.xyChart?.xAxisLineColor || this.primaryTextColor,
      yAxisTitleColor: this.xyChart?.yAxisTitleColor || this.primaryTextColor,
      yAxisLabelColor: this.xyChart?.yAxisLabelColor || this.primaryTextColor,
      yAxisTickColor: this.xyChart?.yAxisTickColor || this.primaryTextColor,
      yAxisLineColor: this.xyChart?.yAxisLineColor || this.primaryTextColor,
      plotColorPalette: this.xyChart?.plotColorPalette || "#CDE498,#FF6B6B,#A0D2DB,#D7BDE2,#F0F0F0,#FFC3A0,#7FD8BE,#FF9A8B,#FAF3E0,#FFF176"
    };
    this.requirementBackground = this.requirementBackground || this.primaryColor;
    this.requirementBorderColor = this.requirementBorderColor || this.primaryBorderColor;
    this.requirementBorderSize = this.requirementBorderSize || "1";
    this.requirementTextColor = this.requirementTextColor || this.primaryTextColor;
    this.relationColor = this.relationColor || this.lineColor;
    this.relationLabelBackground = this.relationLabelBackground || this.edgeLabelBackground;
    this.relationLabelColor = this.relationLabelColor || this.actorTextColor;
    this.git0 = this.git0 || this.primaryColor;
    this.git1 = this.git1 || this.secondaryColor;
    this.git2 = this.git2 || this.tertiaryColor;
    this.git3 = this.git3 || adjust(this.primaryColor, { h: -30 });
    this.git4 = this.git4 || adjust(this.primaryColor, { h: -60 });
    this.git5 = this.git5 || adjust(this.primaryColor, { h: -90 });
    this.git6 = this.git6 || adjust(this.primaryColor, { h: 60 });
    this.git7 = this.git7 || adjust(this.primaryColor, { h: 120 });
    if (this.darkMode) {
      this.git0 = lighten(this.git0, 25);
      this.git1 = lighten(this.git1, 25);
      this.git2 = lighten(this.git2, 25);
      this.git3 = lighten(this.git3, 25);
      this.git4 = lighten(this.git4, 25);
      this.git5 = lighten(this.git5, 25);
      this.git6 = lighten(this.git6, 25);
      this.git7 = lighten(this.git7, 25);
    } else {
      this.git0 = darken(this.git0, 25);
      this.git1 = darken(this.git1, 25);
      this.git2 = darken(this.git2, 25);
      this.git3 = darken(this.git3, 25);
      this.git4 = darken(this.git4, 25);
      this.git5 = darken(this.git5, 25);
      this.git6 = darken(this.git6, 25);
      this.git7 = darken(this.git7, 25);
    }
    this.gitInv0 = this.gitInv0 || invert(this.git0);
    this.gitInv1 = this.gitInv1 || invert(this.git1);
    this.gitInv2 = this.gitInv2 || invert(this.git2);
    this.gitInv3 = this.gitInv3 || invert(this.git3);
    this.gitInv4 = this.gitInv4 || invert(this.git4);
    this.gitInv5 = this.gitInv5 || invert(this.git5);
    this.gitInv6 = this.gitInv6 || invert(this.git6);
    this.gitInv7 = this.gitInv7 || invert(this.git7);
    this.gitBranchLabel0 = this.gitBranchLabel0 || invert(this.labelTextColor);
    this.gitBranchLabel1 = this.gitBranchLabel1 || this.labelTextColor;
    this.gitBranchLabel2 = this.gitBranchLabel2 || this.labelTextColor;
    this.gitBranchLabel3 = this.gitBranchLabel3 || invert(this.labelTextColor);
    this.gitBranchLabel4 = this.gitBranchLabel4 || this.labelTextColor;
    this.gitBranchLabel5 = this.gitBranchLabel5 || this.labelTextColor;
    this.gitBranchLabel6 = this.gitBranchLabel6 || this.labelTextColor;
    this.gitBranchLabel7 = this.gitBranchLabel7 || this.labelTextColor;
    this.tagLabelColor = this.tagLabelColor || this.primaryTextColor;
    this.tagLabelBackground = this.tagLabelBackground || this.primaryColor;
    this.tagLabelBorder = this.tagBorder || this.primaryBorderColor;
    this.tagLabelFontSize = this.tagLabelFontSize || "10px";
    this.commitLabelColor = this.commitLabelColor || this.secondaryTextColor;
    this.commitLabelBackground = this.commitLabelBackground || this.secondaryColor;
    this.commitLabelFontSize = this.commitLabelFontSize || "10px";
    this.attributeBackgroundColorOdd = this.attributeBackgroundColorOdd || oldAttributeBackgroundColorOdd;
    this.attributeBackgroundColorEven = this.attributeBackgroundColorEven || oldAttributeBackgroundColorEven;
  }
  calculate(overrides) {
    if (typeof overrides !== "object") {
      this.updateColors();
      return;
    }
    const keys = Object.keys(overrides);
    keys.forEach((k) => {
      this[k] = overrides[k];
    });
    this.updateColors();
    keys.forEach((k) => {
      this[k] = overrides[k];
    });
  }
};
var getThemeVariables4 = /* @__PURE__ */ __name((userOverrides) => {
  const theme = new Theme4();
  theme.calculate(userOverrides);
  return theme;
}, "getThemeVariables");
var Theme5 = class {
  static {
    __name(this, "Theme");
  }
  constructor() {
    this.primaryColor = "#eee";
    this.contrast = "#707070";
    this.secondaryColor = lighten(this.contrast, 55);
    this.background = "#ffffff";
    this.tertiaryColor = adjust(this.primaryColor, { h: -160 });
    this.primaryBorderColor = mkBorder(this.primaryColor, this.darkMode);
    this.secondaryBorderColor = mkBorder(this.secondaryColor, this.darkMode);
    this.tertiaryBorderColor = mkBorder(this.tertiaryColor, this.darkMode);
    this.primaryTextColor = invert(this.primaryColor);
    this.secondaryTextColor = invert(this.secondaryColor);
    this.tertiaryTextColor = invert(this.tertiaryColor);
    this.lineColor = invert(this.background);
    this.textColor = invert(this.background);
    this.mainBkg = "#eee";
    this.secondBkg = "calculated";
    this.lineColor = "#666";
    this.border1 = "#999";
    this.border2 = "calculated";
    this.note = "#ffa";
    this.text = "#333";
    this.critical = "#d42";
    this.done = "#bbb";
    this.arrowheadColor = "#333333";
    this.fontFamily = '"trebuchet ms", verdana, arial, sans-serif';
    this.fontSize = "16px";
    this.THEME_COLOR_LIMIT = 12;
    this.nodeBkg = "calculated";
    this.nodeBorder = "calculated";
    this.clusterBkg = "calculated";
    this.clusterBorder = "calculated";
    this.defaultLinkColor = "calculated";
    this.titleColor = "calculated";
    this.edgeLabelBackground = "white";
    this.actorBorder = "calculated";
    this.actorBkg = "calculated";
    this.actorTextColor = "calculated";
    this.actorLineColor = this.actorBorder;
    this.signalColor = "calculated";
    this.signalTextColor = "calculated";
    this.labelBoxBkgColor = "calculated";
    this.labelBoxBorderColor = "calculated";
    this.labelTextColor = "calculated";
    this.loopTextColor = "calculated";
    this.noteBorderColor = "calculated";
    this.noteBkgColor = "calculated";
    this.noteTextColor = "calculated";
    this.activationBorderColor = "#666";
    this.activationBkgColor = "#f4f4f4";
    this.sequenceNumberColor = "white";
    this.sectionBkgColor = "calculated";
    this.altSectionBkgColor = "white";
    this.sectionBkgColor2 = "calculated";
    this.excludeBkgColor = "#eeeeee";
    this.taskBorderColor = "calculated";
    this.taskBkgColor = "calculated";
    this.taskTextLightColor = "white";
    this.taskTextColor = "calculated";
    this.taskTextDarkColor = "calculated";
    this.taskTextOutsideColor = "calculated";
    this.taskTextClickableColor = "#003163";
    this.activeTaskBorderColor = "calculated";
    this.activeTaskBkgColor = "calculated";
    this.gridColor = "calculated";
    this.doneTaskBkgColor = "calculated";
    this.doneTaskBorderColor = "calculated";
    this.critBkgColor = "calculated";
    this.critBorderColor = "calculated";
    this.todayLineColor = "calculated";
    this.vertLineColor = "calculated";
    this.personBorder = this.primaryBorderColor;
    this.personBkg = this.mainBkg;
    this.archEdgeColor = "calculated";
    this.archEdgeArrowColor = "calculated";
    this.archEdgeWidth = "3";
    this.archGroupBorderColor = this.primaryBorderColor;
    this.archGroupBorderWidth = "2px";
    this.rowOdd = this.rowOdd || lighten(this.mainBkg, 75) || "#ffffff";
    this.rowEven = this.rowEven || "#f4f4f4";
    this.labelColor = "black";
    this.errorBkgColor = "#552222";
    this.errorTextColor = "#552222";
  }
  updateColors() {
    this.secondBkg = lighten(this.contrast, 55);
    this.border2 = this.contrast;
    this.actorBorder = lighten(this.border1, 23);
    this.actorBkg = this.mainBkg;
    this.actorTextColor = this.text;
    this.actorLineColor = this.actorBorder;
    this.signalColor = this.text;
    this.signalTextColor = this.text;
    this.labelBoxBkgColor = this.actorBkg;
    this.labelBoxBorderColor = this.actorBorder;
    this.labelTextColor = this.text;
    this.loopTextColor = this.text;
    this.noteBorderColor = "#999";
    this.noteBkgColor = "#666";
    this.noteTextColor = "#fff";
    this.cScale0 = this.cScale0 || "#555";
    this.cScale1 = this.cScale1 || "#F4F4F4";
    this.cScale2 = this.cScale2 || "#555";
    this.cScale3 = this.cScale3 || "#BBB";
    this.cScale4 = this.cScale4 || "#777";
    this.cScale5 = this.cScale5 || "#999";
    this.cScale6 = this.cScale6 || "#DDD";
    this.cScale7 = this.cScale7 || "#FFF";
    this.cScale8 = this.cScale8 || "#DDD";
    this.cScale9 = this.cScale9 || "#BBB";
    this.cScale10 = this.cScale10 || "#999";
    this.cScale11 = this.cScale11 || "#777";
    for (let i = 0; i < this.THEME_COLOR_LIMIT; i++) {
      this["cScaleInv" + i] = this["cScaleInv" + i] || invert(this["cScale" + i]);
    }
    for (let i = 0; i < this.THEME_COLOR_LIMIT; i++) {
      if (this.darkMode) {
        this["cScalePeer" + i] = this["cScalePeer" + i] || lighten(this["cScale" + i], 10);
      } else {
        this["cScalePeer" + i] = this["cScalePeer" + i] || darken(this["cScale" + i], 10);
      }
    }
    this.scaleLabelColor = this.scaleLabelColor || (this.darkMode ? "black" : this.labelTextColor);
    this.cScaleLabel0 = this.cScaleLabel0 || this.cScale1;
    this.cScaleLabel2 = this.cScaleLabel2 || this.cScale1;
    for (let i = 0; i < this.THEME_COLOR_LIMIT; i++) {
      this["cScaleLabel" + i] = this["cScaleLabel" + i] || this.scaleLabelColor;
    }
    for (let i = 0; i < 5; i++) {
      this["surface" + i] = this["surface" + i] || adjust(this.mainBkg, { l: -(5 + i * 5) });
      this["surfacePeer" + i] = this["surfacePeer" + i] || adjust(this.mainBkg, { l: -(8 + i * 5) });
    }
    this.nodeBkg = this.mainBkg;
    this.nodeBorder = this.border1;
    this.clusterBkg = this.secondBkg;
    this.clusterBorder = this.border2;
    this.defaultLinkColor = this.lineColor;
    this.titleColor = this.text;
    this.sectionBkgColor = lighten(this.contrast, 30);
    this.sectionBkgColor2 = lighten(this.contrast, 30);
    this.taskBorderColor = darken(this.contrast, 10);
    this.taskBkgColor = this.contrast;
    this.taskTextColor = this.taskTextLightColor;
    this.taskTextDarkColor = this.text;
    this.taskTextOutsideColor = this.taskTextDarkColor;
    this.activeTaskBorderColor = this.taskBorderColor;
    this.activeTaskBkgColor = this.mainBkg;
    this.gridColor = lighten(this.border1, 30);
    this.doneTaskBkgColor = this.done;
    this.doneTaskBorderColor = this.lineColor;
    this.critBkgColor = this.critical;
    this.critBorderColor = darken(this.critBkgColor, 10);
    this.todayLineColor = this.critBkgColor;
    this.vertLineColor = this.critBkgColor;
    this.archEdgeColor = this.lineColor;
    this.archEdgeArrowColor = this.lineColor;
    this.transitionColor = this.transitionColor || "#000";
    this.transitionLabelColor = this.transitionLabelColor || this.textColor;
    this.stateLabelColor = this.stateLabelColor || this.stateBkg || this.primaryTextColor;
    this.stateBkg = this.stateBkg || this.mainBkg;
    this.labelBackgroundColor = this.labelBackgroundColor || this.stateBkg;
    this.compositeBackground = this.compositeBackground || this.background || this.tertiaryColor;
    this.altBackground = this.altBackground || "#f4f4f4";
    this.compositeTitleBackground = this.compositeTitleBackground || this.mainBkg;
    this.stateBorder = this.stateBorder || "#000";
    this.innerEndBackground = this.primaryBorderColor;
    this.specialStateColor = "#222";
    this.errorBkgColor = this.errorBkgColor || this.tertiaryColor;
    this.errorTextColor = this.errorTextColor || this.tertiaryTextColor;
    this.classText = this.primaryTextColor;
    this.fillType0 = this.primaryColor;
    this.fillType1 = this.secondaryColor;
    this.fillType2 = adjust(this.primaryColor, { h: 64 });
    this.fillType3 = adjust(this.secondaryColor, { h: 64 });
    this.fillType4 = adjust(this.primaryColor, { h: -64 });
    this.fillType5 = adjust(this.secondaryColor, { h: -64 });
    this.fillType6 = adjust(this.primaryColor, { h: 128 });
    this.fillType7 = adjust(this.secondaryColor, { h: 128 });
    for (let i = 0; i < this.THEME_COLOR_LIMIT; i++) {
      this["pie" + i] = this["cScale" + i];
    }
    this.pie12 = this.pie0;
    this.pieTitleTextSize = this.pieTitleTextSize || "25px";
    this.pieTitleTextColor = this.pieTitleTextColor || this.taskTextDarkColor;
    this.pieSectionTextSize = this.pieSectionTextSize || "17px";
    this.pieSectionTextColor = this.pieSectionTextColor || this.textColor;
    this.pieLegendTextSize = this.pieLegendTextSize || "17px";
    this.pieLegendTextColor = this.pieLegendTextColor || this.taskTextDarkColor;
    this.pieStrokeColor = this.pieStrokeColor || "black";
    this.pieStrokeWidth = this.pieStrokeWidth || "2px";
    this.pieOuterStrokeWidth = this.pieOuterStrokeWidth || "2px";
    this.pieOuterStrokeColor = this.pieOuterStrokeColor || "black";
    this.pieOpacity = this.pieOpacity || "0.7";
    this.quadrant1Fill = this.quadrant1Fill || this.primaryColor;
    this.quadrant2Fill = this.quadrant2Fill || adjust(this.primaryColor, { r: 5, g: 5, b: 5 });
    this.quadrant3Fill = this.quadrant3Fill || adjust(this.primaryColor, { r: 10, g: 10, b: 10 });
    this.quadrant4Fill = this.quadrant4Fill || adjust(this.primaryColor, { r: 15, g: 15, b: 15 });
    this.quadrant1TextFill = this.quadrant1TextFill || this.primaryTextColor;
    this.quadrant2TextFill = this.quadrant2TextFill || adjust(this.primaryTextColor, { r: -5, g: -5, b: -5 });
    this.quadrant3TextFill = this.quadrant3TextFill || adjust(this.primaryTextColor, { r: -10, g: -10, b: -10 });
    this.quadrant4TextFill = this.quadrant4TextFill || adjust(this.primaryTextColor, { r: -15, g: -15, b: -15 });
    this.quadrantPointFill = this.quadrantPointFill || isDark(this.quadrant1Fill) ? lighten(this.quadrant1Fill) : darken(this.quadrant1Fill);
    this.quadrantPointTextFill = this.quadrantPointTextFill || this.primaryTextColor;
    this.quadrantXAxisTextFill = this.quadrantXAxisTextFill || this.primaryTextColor;
    this.quadrantYAxisTextFill = this.quadrantYAxisTextFill || this.primaryTextColor;
    this.quadrantInternalBorderStrokeFill = this.quadrantInternalBorderStrokeFill || this.primaryBorderColor;
    this.quadrantExternalBorderStrokeFill = this.quadrantExternalBorderStrokeFill || this.primaryBorderColor;
    this.quadrantTitleFill = this.quadrantTitleFill || this.primaryTextColor;
    this.xyChart = {
      backgroundColor: this.xyChart?.backgroundColor || this.background,
      titleColor: this.xyChart?.titleColor || this.primaryTextColor,
      xAxisTitleColor: this.xyChart?.xAxisTitleColor || this.primaryTextColor,
      xAxisLabelColor: this.xyChart?.xAxisLabelColor || this.primaryTextColor,
      xAxisTickColor: this.xyChart?.xAxisTickColor || this.primaryTextColor,
      xAxisLineColor: this.xyChart?.xAxisLineColor || this.primaryTextColor,
      yAxisTitleColor: this.xyChart?.yAxisTitleColor || this.primaryTextColor,
      yAxisLabelColor: this.xyChart?.yAxisLabelColor || this.primaryTextColor,
      yAxisTickColor: this.xyChart?.yAxisTickColor || this.primaryTextColor,
      yAxisLineColor: this.xyChart?.yAxisLineColor || this.primaryTextColor,
      plotColorPalette: this.xyChart?.plotColorPalette || "#EEE,#6BB8E4,#8ACB88,#C7ACD6,#E8DCC2,#FFB2A8,#FFF380,#7E8D91,#FFD8B1,#FAF3E0"
    };
    this.radar = {
      axisColor: this.radar?.axisColor || this.lineColor,
      axisStrokeWidth: this.radar?.axisStrokeWidth || 2,
      axisLabelFontSize: this.radar?.axisLabelFontSize || 12,
      curveOpacity: this.radar?.curveOpacity || 0.5,
      curveStrokeWidth: this.radar?.curveStrokeWidth || 2,
      graticuleColor: this.radar?.graticuleColor || "#DEDEDE",
      graticuleStrokeWidth: this.radar?.graticuleStrokeWidth || 1,
      graticuleOpacity: this.radar?.graticuleOpacity || 0.3,
      legendBoxSize: this.radar?.legendBoxSize || 12,
      legendFontSize: this.radar?.legendFontSize || 12
    };
    this.requirementBackground = this.requirementBackground || this.primaryColor;
    this.requirementBorderColor = this.requirementBorderColor || this.primaryBorderColor;
    this.requirementBorderSize = this.requirementBorderSize || "1";
    this.requirementTextColor = this.requirementTextColor || this.primaryTextColor;
    this.relationColor = this.relationColor || this.lineColor;
    this.relationLabelBackground = this.relationLabelBackground || this.edgeLabelBackground;
    this.relationLabelColor = this.relationLabelColor || this.actorTextColor;
    this.git0 = darken(this.pie1, 25) || this.primaryColor;
    this.git1 = this.pie2 || this.secondaryColor;
    this.git2 = this.pie3 || this.tertiaryColor;
    this.git3 = this.pie4 || adjust(this.primaryColor, { h: -30 });
    this.git4 = this.pie5 || adjust(this.primaryColor, { h: -60 });
    this.git5 = this.pie6 || adjust(this.primaryColor, { h: -90 });
    this.git6 = this.pie7 || adjust(this.primaryColor, { h: 60 });
    this.git7 = this.pie8 || adjust(this.primaryColor, { h: 120 });
    this.gitInv0 = this.gitInv0 || invert(this.git0);
    this.gitInv1 = this.gitInv1 || invert(this.git1);
    this.gitInv2 = this.gitInv2 || invert(this.git2);
    this.gitInv3 = this.gitInv3 || invert(this.git3);
    this.gitInv4 = this.gitInv4 || invert(this.git4);
    this.gitInv5 = this.gitInv5 || invert(this.git5);
    this.gitInv6 = this.gitInv6 || invert(this.git6);
    this.gitInv7 = this.gitInv7 || invert(this.git7);
    this.branchLabelColor = this.branchLabelColor || this.labelTextColor;
    this.gitBranchLabel0 = this.branchLabelColor;
    this.gitBranchLabel1 = "white";
    this.gitBranchLabel2 = this.branchLabelColor;
    this.gitBranchLabel3 = "white";
    this.gitBranchLabel4 = this.branchLabelColor;
    this.gitBranchLabel5 = this.branchLabelColor;
    this.gitBranchLabel6 = this.branchLabelColor;
    this.gitBranchLabel7 = this.branchLabelColor;
    this.tagLabelColor = this.tagLabelColor || this.primaryTextColor;
    this.tagLabelBackground = this.tagLabelBackground || this.primaryColor;
    this.tagLabelBorder = this.tagBorder || this.primaryBorderColor;
    this.tagLabelFontSize = this.tagLabelFontSize || "10px";
    this.commitLabelColor = this.commitLabelColor || this.secondaryTextColor;
    this.commitLabelBackground = this.commitLabelBackground || this.secondaryColor;
    this.commitLabelFontSize = this.commitLabelFontSize || "10px";
    this.attributeBackgroundColorOdd = this.attributeBackgroundColorOdd || oldAttributeBackgroundColorOdd;
    this.attributeBackgroundColorEven = this.attributeBackgroundColorEven || oldAttributeBackgroundColorEven;
  }
  calculate(overrides) {
    if (typeof overrides !== "object") {
      this.updateColors();
      return;
    }
    const keys = Object.keys(overrides);
    keys.forEach((k) => {
      this[k] = overrides[k];
    });
    this.updateColors();
    keys.forEach((k) => {
      this[k] = overrides[k];
    });
  }
};
var getThemeVariables5 = /* @__PURE__ */ __name((userOverrides) => {
  const theme = new Theme5();
  theme.calculate(userOverrides);
  return theme;
}, "getThemeVariables");

// src/themes/index.js
var themes_default = {
  base: {
    getThemeVariables
  },
  dark: {
    getThemeVariables: getThemeVariables2
  },
  default: {
    getThemeVariables: getThemeVariables3
  },
  forest: {
    getThemeVariables: getThemeVariables4
  },
  neutral: {
    getThemeVariables: getThemeVariables5
  }
};

// src/schemas/config.schema.yaml?only-defaults=true
var config_schema_default = {
  "flowchart": {
    "useMaxWidth": true,
    "titleTopMargin": 25,
    "subGraphTitleMargin": {
      "top": 0,
      "bottom": 0
    },
    "diagramPadding": 8,
    "htmlLabels": true,
    "nodeSpacing": 50,
    "rankSpacing": 50,
    "curve": "basis",
    "padding": 15,
    "defaultRenderer": "dagre-wrapper",
    "wrappingWidth": 200,
    "inheritDir": false
  },
  "sequence": {
    "useMaxWidth": true,
    "hideUnusedParticipants": false,
    "activationWidth": 10,
    "diagramMarginX": 50,
    "diagramMarginY": 10,
    "actorMargin": 50,
    "width": 150,
    "height": 65,
    "boxMargin": 10,
    "boxTextMargin": 5,
    "noteMargin": 10,
    "messageMargin": 35,
    "messageAlign": "center",
    "mirrorActors": true,
    "forceMenus": false,
    "bottomMarginAdj": 1,
    "rightAngles": false,
    "showSequenceNumbers": false,
    "actorFontSize": 14,
    "actorFontFamily": '"Open Sans", sans-serif',
    "actorFontWeight": 400,
    "noteFontSize": 14,
    "noteFontFamily": '"trebuchet ms", verdana, arial, sans-serif',
    "noteFontWeight": 400,
    "noteAlign": "center",
    "messageFontSize": 16,
    "messageFontFamily": '"trebuchet ms", verdana, arial, sans-serif',
    "messageFontWeight": 400,
    "wrap": false,
    "wrapPadding": 10,
    "labelBoxWidth": 50,
    "labelBoxHeight": 20
  },
  "gantt": {
    "useMaxWidth": true,
    "titleTopMargin": 25,
    "barHeight": 20,
    "barGap": 4,
    "topPadding": 50,
    "rightPadding": 75,
    "leftPadding": 75,
    "gridLineStartPadding": 35,
    "fontSize": 11,
    "sectionFontSize": 11,
    "numberSectionStyles": 4,
    "axisFormat": "%Y-%m-%d",
    "topAxis": false,
    "displayMode": "",
    "weekday": "sunday"
  },
  "journey": {
    "useMaxWidth": true,
    "diagramMarginX": 50,
    "diagramMarginY": 10,
    "leftMargin": 150,
    "maxLabelWidth": 360,
    "width": 150,
    "height": 50,
    "boxMargin": 10,
    "boxTextMargin": 5,
    "noteMargin": 10,
    "messageMargin": 35,
    "messageAlign": "center",
    "bottomMarginAdj": 1,
    "rightAngles": false,
    "taskFontSize": 14,
    "taskFontFamily": '"Open Sans", sans-serif',
    "taskMargin": 50,
    "activationWidth": 10,
    "textPlacement": "fo",
    "actorColours": [
      "#8FBC8F",
      "#7CFC00",
      "#00FFFF",
      "#20B2AA",
      "#B0E0E6",
      "#FFFFE0"
    ],
    "sectionFills": [
      "#191970",
      "#8B008B",
      "#4B0082",
      "#2F4F4F",
      "#800000",
      "#8B4513",
      "#00008B"
    ],
    "sectionColours": [
      "#fff"
    ],
    "titleColor": "",
    "titleFontFamily": '"trebuchet ms", verdana, arial, sans-serif',
    "titleFontSize": "4ex"
  },
  "class": {
    "useMaxWidth": true,
    "titleTopMargin": 25,
    "arrowMarkerAbsolute": false,
    "dividerMargin": 10,
    "padding": 5,
    "textHeight": 10,
    "defaultRenderer": "dagre-wrapper",
    "htmlLabels": false,
    "hideEmptyMembersBox": false
  },
  "state": {
    "useMaxWidth": true,
    "titleTopMargin": 25,
    "dividerMargin": 10,
    "sizeUnit": 5,
    "padding": 8,
    "textHeight": 10,
    "titleShift": -15,
    "noteMargin": 10,
    "forkWidth": 70,
    "forkHeight": 7,
    "miniPadding": 2,
    "fontSizeFactor": 5.02,
    "fontSize": 24,
    "labelHeight": 16,
    "edgeLengthFactor": "20",
    "compositTitleSize": 35,
    "radius": 5,
    "defaultRenderer": "dagre-wrapper"
  },
  "er": {
    "useMaxWidth": true,
    "titleTopMargin": 25,
    "diagramPadding": 20,
    "layoutDirection": "TB",
    "minEntityWidth": 100,
    "minEntityHeight": 75,
    "entityPadding": 15,
    "nodeSpacing": 140,
    "rankSpacing": 80,
    "stroke": "gray",
    "fill": "honeydew",
    "fontSize": 12
  },
  "pie": {
    "useMaxWidth": true,
    "textPosition": 0.75
  },
  "quadrantChart": {
    "useMaxWidth": true,
    "chartWidth": 500,
    "chartHeight": 500,
    "titleFontSize": 20,
    "titlePadding": 10,
    "quadrantPadding": 5,
    "xAxisLabelPadding": 5,
    "yAxisLabelPadding": 5,
    "xAxisLabelFontSize": 16,
    "yAxisLabelFontSize": 16,
    "quadrantLabelFontSize": 16,
    "quadrantTextTopPadding": 5,
    "pointTextPadding": 5,
    "pointLabelFontSize": 12,
    "pointRadius": 5,
    "xAxisPosition": "top",
    "yAxisPosition": "left",
    "quadrantInternalBorderStrokeWidth": 1,
    "quadrantExternalBorderStrokeWidth": 2
  },
  "xyChart": {
    "useMaxWidth": true,
    "width": 700,
    "height": 500,
    "titleFontSize": 20,
    "titlePadding": 10,
    "showDataLabel": false,
    "showTitle": true,
    "xAxis": {
      "$ref": "#/$defs/XYChartAxisConfig",
      "showLabel": true,
      "labelFontSize": 14,
      "labelPadding": 5,
      "showTitle": true,
      "titleFontSize": 16,
      "titlePadding": 5,
      "showTick": true,
      "tickLength": 5,
      "tickWidth": 2,
      "showAxisLine": true,
      "axisLineWidth": 2
    },
    "yAxis": {
      "$ref": "#/$defs/XYChartAxisConfig",
      "showLabel": true,
      "labelFontSize": 14,
      "labelPadding": 5,
      "showTitle": true,
      "titleFontSize": 16,
      "titlePadding": 5,
      "showTick": true,
      "tickLength": 5,
      "tickWidth": 2,
      "showAxisLine": true,
      "axisLineWidth": 2
    },
    "chartOrientation": "vertical",
    "plotReservedSpacePercent": 50
  },
  "requirement": {
    "useMaxWidth": true,
    "rect_fill": "#f9f9f9",
    "text_color": "#333",
    "rect_border_size": "0.5px",
    "rect_border_color": "#bbb",
    "rect_min_width": 200,
    "rect_min_height": 200,
    "fontSize": 14,
    "rect_padding": 10,
    "line_height": 20
  },
  "mindmap": {
    "useMaxWidth": true,
    "padding": 10,
    "maxNodeWidth": 200
  },
  "kanban": {
    "useMaxWidth": true,
    "padding": 8,
    "sectionWidth": 200,
    "ticketBaseUrl": ""
  },
  "timeline": {
    "useMaxWidth": true,
    "diagramMarginX": 50,
    "diagramMarginY": 10,
    "leftMargin": 150,
    "width": 150,
    "height": 50,
    "boxMargin": 10,
    "boxTextMargin": 5,
    "noteMargin": 10,
    "messageMargin": 35,
    "messageAlign": "center",
    "bottomMarginAdj": 1,
    "rightAngles": false,
    "taskFontSize": 14,
    "taskFontFamily": '"Open Sans", sans-serif',
    "taskMargin": 50,
    "activationWidth": 10,
    "textPlacement": "fo",
    "actorColours": [
      "#8FBC8F",
      "#7CFC00",
      "#00FFFF",
      "#20B2AA",
      "#B0E0E6",
      "#FFFFE0"
    ],
    "sectionFills": [
      "#191970",
      "#8B008B",
      "#4B0082",
      "#2F4F4F",
      "#800000",
      "#8B4513",
      "#00008B"
    ],
    "sectionColours": [
      "#fff"
    ],
    "disableMulticolor": false
  },
  "gitGraph": {
    "useMaxWidth": true,
    "titleTopMargin": 25,
    "diagramPadding": 8,
    "nodeLabel": {
      "width": 75,
      "height": 100,
      "x": -25,
      "y": 0
    },
    "mainBranchName": "main",
    "mainBranchOrder": 0,
    "showCommitLabel": true,
    "showBranches": true,
    "rotateCommitLabel": true,
    "parallelCommits": false,
    "arrowMarkerAbsolute": false
  },
  "c4": {
    "useMaxWidth": true,
    "diagramMarginX": 50,
    "diagramMarginY": 10,
    "c4ShapeMargin": 50,
    "c4ShapePadding": 20,
    "width": 216,
    "height": 60,
    "boxMargin": 10,
    "c4ShapeInRow": 4,
    "nextLinePaddingX": 0,
    "c4BoundaryInRow": 2,
    "personFontSize": 14,
    "personFontFamily": '"Open Sans", sans-serif',
    "personFontWeight": "normal",
    "external_personFontSize": 14,
    "external_personFontFamily": '"Open Sans", sans-serif',
    "external_personFontWeight": "normal",
    "systemFontSize": 14,
    "systemFontFamily": '"Open Sans", sans-serif',
    "systemFontWeight": "normal",
    "external_systemFontSize": 14,
    "external_systemFontFamily": '"Open Sans", sans-serif',
    "external_systemFontWeight": "normal",
    "system_dbFontSize": 14,
    "system_dbFontFamily": '"Open Sans", sans-serif',
    "system_dbFontWeight": "normal",
    "external_system_dbFontSize": 14,
    "external_system_dbFontFamily": '"Open Sans", sans-serif',
    "external_system_dbFontWeight": "normal",
    "system_queueFontSize": 14,
    "system_queueFontFamily": '"Open Sans", sans-serif',
    "system_queueFontWeight": "normal",
    "external_system_queueFontSize": 14,
    "external_system_queueFontFamily": '"Open Sans", sans-serif',
    "external_system_queueFontWeight": "normal",
    "boundaryFontSize": 14,
    "boundaryFontFamily": '"Open Sans", sans-serif',
    "boundaryFontWeight": "normal",
    "messageFontSize": 12,
    "messageFontFamily": '"Open Sans", sans-serif',
    "messageFontWeight": "normal",
    "containerFontSize": 14,
    "containerFontFamily": '"Open Sans", sans-serif',
    "containerFontWeight": "normal",
    "external_containerFontSize": 14,
    "external_containerFontFamily": '"Open Sans", sans-serif',
    "external_containerFontWeight": "normal",
    "container_dbFontSize": 14,
    "container_dbFontFamily": '"Open Sans", sans-serif',
    "container_dbFontWeight": "normal",
    "external_container_dbFontSize": 14,
    "external_container_dbFontFamily": '"Open Sans", sans-serif',
    "external_container_dbFontWeight": "normal",
    "container_queueFontSize": 14,
    "container_queueFontFamily": '"Open Sans", sans-serif',
    "container_queueFontWeight": "normal",
    "external_container_queueFontSize": 14,
    "external_container_queueFontFamily": '"Open Sans", sans-serif',
    "external_container_queueFontWeight": "normal",
    "componentFontSize": 14,
    "componentFontFamily": '"Open Sans", sans-serif',
    "componentFontWeight": "normal",
    "external_componentFontSize": 14,
    "external_componentFontFamily": '"Open Sans", sans-serif',
    "external_componentFontWeight": "normal",
    "component_dbFontSize": 14,
    "component_dbFontFamily": '"Open Sans", sans-serif',
    "component_dbFontWeight": "normal",
    "external_component_dbFontSize": 14,
    "external_component_dbFontFamily": '"Open Sans", sans-serif',
    "external_component_dbFontWeight": "normal",
    "component_queueFontSize": 14,
    "component_queueFontFamily": '"Open Sans", sans-serif',
    "component_queueFontWeight": "normal",
    "external_component_queueFontSize": 14,
    "external_component_queueFontFamily": '"Open Sans", sans-serif',
    "external_component_queueFontWeight": "normal",
    "wrap": true,
    "wrapPadding": 10,
    "person_bg_color": "#08427B",
    "person_border_color": "#073B6F",
    "external_person_bg_color": "#686868",
    "external_person_border_color": "#8A8A8A",
    "system_bg_color": "#1168BD",
    "system_border_color": "#3C7FC0",
    "system_db_bg_color": "#1168BD",
    "system_db_border_color": "#3C7FC0",
    "system_queue_bg_color": "#1168BD",
    "system_queue_border_color": "#3C7FC0",
    "external_system_bg_color": "#999999",
    "external_system_border_color": "#8A8A8A",
    "external_system_db_bg_color": "#999999",
    "external_system_db_border_color": "#8A8A8A",
    "external_system_queue_bg_color": "#999999",
    "external_system_queue_border_color": "#8A8A8A",
    "container_bg_color": "#438DD5",
    "container_border_color": "#3C7FC0",
    "container_db_bg_color": "#438DD5",
    "container_db_border_color": "#3C7FC0",
    "container_queue_bg_color": "#438DD5",
    "container_queue_border_color": "#3C7FC0",
    "external_container_bg_color": "#B3B3B3",
    "external_container_border_color": "#A6A6A6",
    "external_container_db_bg_color": "#B3B3B3",
    "external_container_db_border_color": "#A6A6A6",
    "external_container_queue_bg_color": "#B3B3B3",
    "external_container_queue_border_color": "#A6A6A6",
    "component_bg_color": "#85BBF0",
    "component_border_color": "#78A8D8",
    "component_db_bg_color": "#85BBF0",
    "component_db_border_color": "#78A8D8",
    "component_queue_bg_color": "#85BBF0",
    "component_queue_border_color": "#78A8D8",
    "external_component_bg_color": "#CCCCCC",
    "external_component_border_color": "#BFBFBF",
    "external_component_db_bg_color": "#CCCCCC",
    "external_component_db_border_color": "#BFBFBF",
    "external_component_queue_bg_color": "#CCCCCC",
    "external_component_queue_border_color": "#BFBFBF"
  },
  "sankey": {
    "useMaxWidth": true,
    "width": 600,
    "height": 400,
    "linkColor": "gradient",
    "nodeAlignment": "justify",
    "showValues": true,
    "prefix": "",
    "suffix": ""
  },
  "block": {
    "useMaxWidth": true,
    "padding": 8
  },
  "packet": {
    "useMaxWidth": true,
    "rowHeight": 32,
    "bitWidth": 32,
    "bitsPerRow": 32,
    "showBits": true,
    "paddingX": 5,
    "paddingY": 5
  },
  "architecture": {
    "useMaxWidth": true,
    "padding": 40,
    "iconSize": 80,
    "fontSize": 16
  },
  "radar": {
    "useMaxWidth": true,
    "width": 600,
    "height": 600,
    "marginTop": 50,
    "marginRight": 50,
    "marginBottom": 50,
    "marginLeft": 50,
    "axisScaleFactor": 1,
    "axisLabelFactor": 1.05,
    "curveTension": 0.17
  },
  "theme": "default",
  "look": "classic",
  "handDrawnSeed": 0,
  "layout": "dagre",
  "maxTextSize": 5e4,
  "maxEdges": 500,
  "darkMode": false,
  "fontFamily": '"trebuchet ms", verdana, arial, sans-serif;',
  "logLevel": 5,
  "securityLevel": "strict",
  "startOnLoad": true,
  "arrowMarkerAbsolute": false,
  "secure": [
    "secure",
    "securityLevel",
    "startOnLoad",
    "maxTextSize",
    "suppressErrorRendering",
    "maxEdges"
  ],
  "legacyMathML": false,
  "forceLegacyMathML": false,
  "deterministicIds": false,
  "fontSize": 16,
  "markdownAutoWrap": true,
  "suppressErrorRendering": false
};

// src/defaultConfig.ts
var config = {
  ...config_schema_default,
  // Set, even though they're `undefined` so that `configKeys` finds these keys
  // TODO: Should we replace these with `null` so that they can go in the JSON Schema?
  deterministicIDSeed: void 0,
  elk: {
    // mergeEdges is needed here to be considered
    mergeEdges: false,
    nodePlacementStrategy: "BRANDES_KOEPF",
    forceNodeModelOrder: false,
    considerModelOrder: "NODES_AND_EDGES"
  },
  themeCSS: void 0,
  // add non-JSON default config values
  themeVariables: themes_default.default.getThemeVariables(),
  sequence: {
    ...config_schema_default.sequence,
    messageFont: /* @__PURE__ */ __name(function() {
      return {
        fontFamily: this.messageFontFamily,
        fontSize: this.messageFontSize,
        fontWeight: this.messageFontWeight
      };
    }, "messageFont"),
    noteFont: /* @__PURE__ */ __name(function() {
      return {
        fontFamily: this.noteFontFamily,
        fontSize: this.noteFontSize,
        fontWeight: this.noteFontWeight
      };
    }, "noteFont"),
    actorFont: /* @__PURE__ */ __name(function() {
      return {
        fontFamily: this.actorFontFamily,
        fontSize: this.actorFontSize,
        fontWeight: this.actorFontWeight
      };
    }, "actorFont")
  },
  class: {
    hideEmptyMembersBox: false
  },
  gantt: {
    ...config_schema_default.gantt,
    tickInterval: void 0,
    useWidth: void 0
    // can probably be removed since `configKeys` already includes this
  },
  c4: {
    ...config_schema_default.c4,
    useWidth: void 0,
    personFont: /* @__PURE__ */ __name(function() {
      return {
        fontFamily: this.personFontFamily,
        fontSize: this.personFontSize,
        fontWeight: this.personFontWeight
      };
    }, "personFont"),
    flowchart: {
      ...config_schema_default.flowchart,
      inheritDir: false
      // default to legacy behavior
    },
    external_personFont: /* @__PURE__ */ __name(function() {
      return {
        fontFamily: this.external_personFontFamily,
        fontSize: this.external_personFontSize,
        fontWeight: this.external_personFontWeight
      };
    }, "external_personFont"),
    systemFont: /* @__PURE__ */ __name(function() {
      return {
        fontFamily: this.systemFontFamily,
        fontSize: this.systemFontSize,
        fontWeight: this.systemFontWeight
      };
    }, "systemFont"),
    external_systemFont: /* @__PURE__ */ __name(function() {
      return {
        fontFamily: this.external_systemFontFamily,
        fontSize: this.external_systemFontSize,
        fontWeight: this.external_systemFontWeight
      };
    }, "external_systemFont"),
    system_dbFont: /* @__PURE__ */ __name(function() {
      return {
        fontFamily: this.system_dbFontFamily,
        fontSize: this.system_dbFontSize,
        fontWeight: this.system_dbFontWeight
      };
    }, "system_dbFont"),
    external_system_dbFont: /* @__PURE__ */ __name(function() {
      return {
        fontFamily: this.external_system_dbFontFamily,
        fontSize: this.external_system_dbFontSize,
        fontWeight: this.external_system_dbFontWeight
      };
    }, "external_system_dbFont"),
    system_queueFont: /* @__PURE__ */ __name(function() {
      return {
        fontFamily: this.system_queueFontFamily,
        fontSize: this.system_queueFontSize,
        fontWeight: this.system_queueFontWeight
      };
    }, "system_queueFont"),
    external_system_queueFont: /* @__PURE__ */ __name(function() {
      return {
        fontFamily: this.external_system_queueFontFamily,
        fontSize: this.external_system_queueFontSize,
        fontWeight: this.external_system_queueFontWeight
      };
    }, "external_system_queueFont"),
    containerFont: /* @__PURE__ */ __name(function() {
      return {
        fontFamily: this.containerFontFamily,
        fontSize: this.containerFontSize,
        fontWeight: this.containerFontWeight
      };
    }, "containerFont"),
    external_containerFont: /* @__PURE__ */ __name(function() {
      return {
        fontFamily: this.external_containerFontFamily,
        fontSize: this.external_containerFontSize,
        fontWeight: this.external_containerFontWeight
      };
    }, "external_containerFont"),
    container_dbFont: /* @__PURE__ */ __name(function() {
      return {
        fontFamily: this.container_dbFontFamily,
        fontSize: this.container_dbFontSize,
        fontWeight: this.container_dbFontWeight
      };
    }, "container_dbFont"),
    external_container_dbFont: /* @__PURE__ */ __name(function() {
      return {
        fontFamily: this.external_container_dbFontFamily,
        fontSize: this.external_container_dbFontSize,
        fontWeight: this.external_container_dbFontWeight
      };
    }, "external_container_dbFont"),
    container_queueFont: /* @__PURE__ */ __name(function() {
      return {
        fontFamily: this.container_queueFontFamily,
        fontSize: this.container_queueFontSize,
        fontWeight: this.container_queueFontWeight
      };
    }, "container_queueFont"),
    external_container_queueFont: /* @__PURE__ */ __name(function() {
      return {
        fontFamily: this.external_container_queueFontFamily,
        fontSize: this.external_container_queueFontSize,
        fontWeight: this.external_container_queueFontWeight
      };
    }, "external_container_queueFont"),
    componentFont: /* @__PURE__ */ __name(function() {
      return {
        fontFamily: this.componentFontFamily,
        fontSize: this.componentFontSize,
        fontWeight: this.componentFontWeight
      };
    }, "componentFont"),
    external_componentFont: /* @__PURE__ */ __name(function() {
      return {
        fontFamily: this.external_componentFontFamily,
        fontSize: this.external_componentFontSize,
        fontWeight: this.external_componentFontWeight
      };
    }, "external_componentFont"),
    component_dbFont: /* @__PURE__ */ __name(function() {
      return {
        fontFamily: this.component_dbFontFamily,
        fontSize: this.component_dbFontSize,
        fontWeight: this.component_dbFontWeight
      };
    }, "component_dbFont"),
    external_component_dbFont: /* @__PURE__ */ __name(function() {
      return {
        fontFamily: this.external_component_dbFontFamily,
        fontSize: this.external_component_dbFontSize,
        fontWeight: this.external_component_dbFontWeight
      };
    }, "external_component_dbFont"),
    component_queueFont: /* @__PURE__ */ __name(function() {
      return {
        fontFamily: this.component_queueFontFamily,
        fontSize: this.component_queueFontSize,
        fontWeight: this.component_queueFontWeight
      };
    }, "component_queueFont"),
    external_component_queueFont: /* @__PURE__ */ __name(function() {
      return {
        fontFamily: this.external_component_queueFontFamily,
        fontSize: this.external_component_queueFontSize,
        fontWeight: this.external_component_queueFontWeight
      };
    }, "external_component_queueFont"),
    boundaryFont: /* @__PURE__ */ __name(function() {
      return {
        fontFamily: this.boundaryFontFamily,
        fontSize: this.boundaryFontSize,
        fontWeight: this.boundaryFontWeight
      };
    }, "boundaryFont"),
    messageFont: /* @__PURE__ */ __name(function() {
      return {
        fontFamily: this.messageFontFamily,
        fontSize: this.messageFontSize,
        fontWeight: this.messageFontWeight
      };
    }, "messageFont")
  },
  pie: {
    ...config_schema_default.pie,
    useWidth: 984
  },
  xyChart: {
    ...config_schema_default.xyChart,
    useWidth: void 0
  },
  requirement: {
    ...config_schema_default.requirement,
    useWidth: void 0
  },
  packet: {
    ...config_schema_default.packet
  },
  radar: {
    ...config_schema_default.radar
  },
  treemap: {
    useMaxWidth: true,
    padding: 10,
    diagramPadding: 8,
    showValues: true,
    nodeWidth: 100,
    nodeHeight: 40,
    borderWidth: 1,
    valueFontSize: 12,
    labelFontSize: 14,
    valueFormat: ","
  }
};
var keyify = /* @__PURE__ */ __name((obj, prefix = "") => Object.keys(obj).reduce((res, el) => {
  if (Array.isArray(obj[el])) {
    return res;
  } else if (typeof obj[el] === "object" && obj[el] !== null) {
    return [...res, prefix + el, ...keyify(obj[el], "")];
  }
  return [...res, prefix + el];
}, []), "keyify");
var configKeys = new Set(keyify(config, ""));
var defaultConfig_default = config;

// src/utils/sanitizeDirective.ts
var sanitizeDirective = /* @__PURE__ */ __name((args) => {
  log.debug("sanitizeDirective called with", args);
  if (typeof args !== "object" || args == null) {
    return;
  }
  if (Array.isArray(args)) {
    args.forEach((arg) => sanitizeDirective(arg));
    return;
  }
  for (const key of Object.keys(args)) {
    log.debug("Checking key", key);
    if (key.startsWith("__") || key.includes("proto") || key.includes("constr") || !configKeys.has(key) || args[key] == null) {
      log.debug("sanitize deleting key: ", key);
      delete args[key];
      continue;
    }
    if (typeof args[key] === "object") {
      log.debug("sanitizing object", key);
      sanitizeDirective(args[key]);
      continue;
    }
    const cssMatchers = ["themeCSS", "fontFamily", "altFontFamily"];
    for (const cssKey of cssMatchers) {
      if (key.includes(cssKey)) {
        log.debug("sanitizing css option", key);
        args[key] = sanitizeCss(args[key]);
      }
    }
  }
  if (args.themeVariables) {
    for (const k of Object.keys(args.themeVariables)) {
      const val = args.themeVariables[k];
      if (val?.match && !val.match(/^[\d "#%(),.;A-Za-z]+$/)) {
        args.themeVariables[k] = "";
      }
    }
  }
  log.debug("After sanitization", args);
}, "sanitizeDirective");
var sanitizeCss = /* @__PURE__ */ __name((str) => {
  let startCnt = 0;
  let endCnt = 0;
  for (const element of str) {
    if (startCnt < endCnt) {
      return "{ /* ERROR: Unbalanced CSS */ }";
    }
    if (element === "{") {
      startCnt++;
    } else if (element === "}") {
      endCnt++;
    }
  }
  if (startCnt !== endCnt) {
    return "{ /* ERROR: Unbalanced CSS */ }";
  }
  return str;
}, "sanitizeCss");

// src/config.ts
var defaultConfig = Object.freeze(defaultConfig_default);
var siteConfig = assignWithDepth_default({}, defaultConfig);
var configFromInitialize;
var directives = [];
var currentConfig = assignWithDepth_default({}, defaultConfig);
var updateCurrentConfig = /* @__PURE__ */ __name((siteCfg, _directives) => {
  let cfg = assignWithDepth_default({}, siteCfg);
  let sumOfDirectives = {};
  for (const d of _directives) {
    sanitize(d);
    sumOfDirectives = assignWithDepth_default(sumOfDirectives, d);
  }
  cfg = assignWithDepth_default(cfg, sumOfDirectives);
  if (sumOfDirectives.theme && sumOfDirectives.theme in themes_default) {
    const tmpConfigFromInitialize = assignWithDepth_default({}, configFromInitialize);
    const themeVariables = assignWithDepth_default(
      tmpConfigFromInitialize.themeVariables || {},
      sumOfDirectives.themeVariables
    );
    if (cfg.theme && cfg.theme in themes_default) {
      cfg.themeVariables = themes_default[cfg.theme].getThemeVariables(themeVariables);
    }
  }
  currentConfig = cfg;
  checkConfig(currentConfig);
  return currentConfig;
}, "updateCurrentConfig");
var setSiteConfig = /* @__PURE__ */ __name((conf) => {
  siteConfig = assignWithDepth_default({}, defaultConfig);
  siteConfig = assignWithDepth_default(siteConfig, conf);
  if (conf.theme && themes_default[conf.theme]) {
    siteConfig.themeVariables = themes_default[conf.theme].getThemeVariables(conf.themeVariables);
  }
  updateCurrentConfig(siteConfig, directives);
  return siteConfig;
}, "setSiteConfig");
var saveConfigFromInitialize = /* @__PURE__ */ __name((conf) => {
  configFromInitialize = assignWithDepth_default({}, conf);
}, "saveConfigFromInitialize");
var updateSiteConfig = /* @__PURE__ */ __name((conf) => {
  siteConfig = assignWithDepth_default(siteConfig, conf);
  updateCurrentConfig(siteConfig, directives);
  return siteConfig;
}, "updateSiteConfig");
var getSiteConfig = /* @__PURE__ */ __name(() => {
  return assignWithDepth_default({}, siteConfig);
}, "getSiteConfig");
var setConfig = /* @__PURE__ */ __name((conf) => {
  checkConfig(conf);
  assignWithDepth_default(currentConfig, conf);
  return getConfig();
}, "setConfig");
var getConfig = /* @__PURE__ */ __name(() => {
  return assignWithDepth_default({}, currentConfig);
}, "getConfig");
var sanitize = /* @__PURE__ */ __name((options) => {
  if (!options) {
    return;
  }
  ["secure", ...siteConfig.secure ?? []].forEach((key) => {
    if (Object.hasOwn(options, key)) {
      log.debug(`Denied attempt to modify a secure key ${key}`, options[key]);
      delete options[key];
    }
  });
  Object.keys(options).forEach((key) => {
    if (key.startsWith("__")) {
      delete options[key];
    }
  });
  Object.keys(options).forEach((key) => {
    if (typeof options[key] === "string" && (options[key].includes("<") || options[key].includes(">") || options[key].includes("url(data:"))) {
      delete options[key];
    }
    if (typeof options[key] === "object") {
      sanitize(options[key]);
    }
  });
}, "sanitize");
var addDirective = /* @__PURE__ */ __name((directive) => {
  sanitizeDirective(directive);
  if (directive.fontFamily && !directive.themeVariables?.fontFamily) {
    directive.themeVariables = {
      ...directive.themeVariables,
      fontFamily: directive.fontFamily
    };
  }
  directives.push(directive);
  updateCurrentConfig(siteConfig, directives);
}, "addDirective");
var reset = /* @__PURE__ */ __name((config2 = siteConfig) => {
  directives = [];
  updateCurrentConfig(config2, directives);
}, "reset");
var ConfigWarning = {
  LAZY_LOAD_DEPRECATED: "The configuration options lazyLoadedDiagrams and loadExternalDiagramsAtStartup are deprecated. Please use registerExternalDiagrams instead."
};
var issuedWarnings = {};
var issueWarning = /* @__PURE__ */ __name((warning) => {
  if (issuedWarnings[warning]) {
    return;
  }
  log.warn(ConfigWarning[warning]);
  issuedWarnings[warning] = true;
}, "issueWarning");
var checkConfig = /* @__PURE__ */ __name((config2) => {
  if (!config2) {
    return;
  }
  if (config2.lazyLoadedDiagrams || config2.loadExternalDiagramsAtStartup) {
    issueWarning("LAZY_LOAD_DEPRECATED");
  }
}, "checkConfig");
var lineBreakRegex = /<br\s*\/?>/gi;
var getRows = /* @__PURE__ */ __name((s) => {
  if (!s) {
    return [""];
  }
  const str = breakToPlaceholder(s).replace(/\\n/g, "#br#");
  return str.split("#br#");
}, "getRows");
var setupDompurifyHooksIfNotSetup = /* @__PURE__ */ (() => {
  let setup = false;
  return () => {
    if (!setup) {
      setupDompurifyHooks();
      setup = true;
    }
  };
})();
function setupDompurifyHooks() {
  const TEMPORARY_ATTRIBUTE = "data-temp-href-target";
  purify.addHook("beforeSanitizeAttributes", (node) => {
    if (node.tagName === "A" && node.hasAttribute("target")) {
      node.setAttribute(TEMPORARY_ATTRIBUTE, node.getAttribute("target") ?? "");
    }
  });
  purify.addHook("afterSanitizeAttributes", (node) => {
    if (node.tagName === "A" && node.hasAttribute(TEMPORARY_ATTRIBUTE)) {
      node.setAttribute("target", node.getAttribute(TEMPORARY_ATTRIBUTE) ?? "");
      node.removeAttribute(TEMPORARY_ATTRIBUTE);
      if (node.getAttribute("target") === "_blank") {
        node.setAttribute("rel", "noopener");
      }
    }
  });
}
__name(setupDompurifyHooks, "setupDompurifyHooks");
var removeScript = /* @__PURE__ */ __name((txt) => {
  setupDompurifyHooksIfNotSetup();
  const sanitizedText = purify.sanitize(txt);
  return sanitizedText;
}, "removeScript");
var sanitizeMore = /* @__PURE__ */ __name((text, config2) => {
  if (config2.flowchart?.htmlLabels !== false) {
    const level = config2.securityLevel;
    if (level === "antiscript" || level === "strict") {
      text = removeScript(text);
    } else if (level !== "loose") {
      text = breakToPlaceholder(text);
      text = text.replace(/</g, "&lt;").replace(/>/g, "&gt;");
      text = text.replace(/=/g, "&equals;");
      text = placeholderToBreak(text);
    }
  }
  return text;
}, "sanitizeMore");
var sanitizeText = /* @__PURE__ */ __name((text, config2) => {
  if (!text) {
    return text;
  }
  if (config2.dompurifyConfig) {
    text = purify.sanitize(sanitizeMore(text, config2), config2.dompurifyConfig).toString();
  } else {
    text = purify.sanitize(sanitizeMore(text, config2), {
      FORBID_TAGS: ["style"]
    }).toString();
  }
  return text;
}, "sanitizeText");
var sanitizeTextOrArray = /* @__PURE__ */ __name((a, config2) => {
  if (typeof a === "string") {
    return sanitizeText(a, config2);
  }
  return a.flat().map((x) => sanitizeText(x, config2));
}, "sanitizeTextOrArray");
var hasBreaks = /* @__PURE__ */ __name((text) => {
  return lineBreakRegex.test(text);
}, "hasBreaks");
var splitBreaks = /* @__PURE__ */ __name((text) => {
  return text.split(lineBreakRegex);
}, "splitBreaks");
var placeholderToBreak = /* @__PURE__ */ __name((s) => {
  return s.replace(/#br#/g, "<br/>");
}, "placeholderToBreak");
var breakToPlaceholder = /* @__PURE__ */ __name((s) => {
  return s.replace(lineBreakRegex, "#br#");
}, "breakToPlaceholder");
var getUrl = /* @__PURE__ */ __name((useAbsolute) => {
  let url = "";
  if (useAbsolute) {
    url = window.location.protocol + "//" + window.location.host + window.location.pathname + window.location.search;
    url = CSS.escape(url);
  }
  return url;
}, "getUrl");
var evaluate = /* @__PURE__ */ __name((val) => val === false || ["false", "null", "0"].includes(String(val).trim().toLowerCase()) ? false : true, "evaluate");
var getMax = /* @__PURE__ */ __name(function(...values) {
  const newValues = values.filter((value) => {
    return !isNaN(value);
  });
  return Math.max(...newValues);
}, "getMax");
var getMin = /* @__PURE__ */ __name(function(...values) {
  const newValues = values.filter((value) => {
    return !isNaN(value);
  });
  return Math.min(...newValues);
}, "getMin");
var parseGenericTypes = /* @__PURE__ */ __name(function(input) {
  const inputSets = input.split(/(,)/);
  const output = [];
  for (let i = 0; i < inputSets.length; i++) {
    let thisSet = inputSets[i];
    if (thisSet === "," && i > 0 && i + 1 < inputSets.length) {
      const previousSet = inputSets[i - 1];
      const nextSet = inputSets[i + 1];
      if (shouldCombineSets(previousSet, nextSet)) {
        thisSet = previousSet + "," + nextSet;
        i++;
        output.pop();
      }
    }
    output.push(processSet(thisSet));
  }
  return output.join("");
}, "parseGenericTypes");
var countOccurrence = /* @__PURE__ */ __name((string, substring) => {
  return Math.max(0, string.split(substring).length - 1);
}, "countOccurrence");
var shouldCombineSets = /* @__PURE__ */ __name((previousSet, nextSet) => {
  const prevCount = countOccurrence(previousSet, "~");
  const nextCount = countOccurrence(nextSet, "~");
  return prevCount === 1 && nextCount === 1;
}, "shouldCombineSets");
var processSet = /* @__PURE__ */ __name((input) => {
  const tildeCount = countOccurrence(input, "~");
  let hasStartingTilde = false;
  if (tildeCount <= 1) {
    return input;
  }
  if (tildeCount % 2 !== 0 && input.startsWith("~")) {
    input = input.substring(1);
    hasStartingTilde = true;
  }
  const chars = [...input];
  let first = chars.indexOf("~");
  let last = chars.lastIndexOf("~");
  while (first !== -1 && last !== -1 && first !== last) {
    chars[first] = "<";
    chars[last] = ">";
    first = chars.indexOf("~");
    last = chars.lastIndexOf("~");
  }
  if (hasStartingTilde) {
    chars.unshift("~");
  }
  return chars.join("");
}, "processSet");
var isMathMLSupported = /* @__PURE__ */ __name(() => window.MathMLElement !== void 0, "isMathMLSupported");
var katexRegex = /\$\$(.*)\$\$/g;
var hasKatex = /* @__PURE__ */ __name((text) => (text.match(katexRegex)?.length ?? 0) > 0, "hasKatex");
var calculateMathMLDimensions = /* @__PURE__ */ __name(async (text, config2) => {
  const divElem = document.createElement("div");
  divElem.innerHTML = await renderKatexSanitized(text, config2);
  divElem.id = "katex-temp";
  divElem.style.visibility = "hidden";
  divElem.style.position = "absolute";
  divElem.style.top = "0";
  const body = document.querySelector("body");
  body?.insertAdjacentElement("beforeend", divElem);
  const dim = { width: divElem.clientWidth, height: divElem.clientHeight };
  divElem.remove();
  return dim;
}, "calculateMathMLDimensions");
var renderKatexUnsanitized = /* @__PURE__ */ __name(async (text, config2) => {
  if (!hasKatex(text)) {
    return text;
  }
  if (!(isMathMLSupported() || config2.legacyMathML || config2.forceLegacyMathML)) {
    return text.replace(katexRegex, "MathML is unsupported in this environment.");
  }
  {
    const { default: katex } = await __vitePreload(async () => { const { default: katex } = await import('./katex-C_izPJdu.js');return { default: katex }},true              ?[]:void 0);
    const outputMode = config2.forceLegacyMathML || !isMathMLSupported() && config2.legacyMathML ? "htmlAndMathml" : "mathml";
    return text.split(lineBreakRegex).map(
      (line) => hasKatex(line) ? `<div style="display: flex; align-items: center; justify-content: center; white-space: nowrap;">${line}</div>` : `<div>${line}</div>`
    ).join("").replace(
      katexRegex,
      (_, c) => katex.renderToString(c, {
        throwOnError: true,
        displayMode: true,
        output: outputMode
      }).replace(/\n/g, " ").replace(/<annotation.*<\/annotation>/g, "")
    );
  }
}, "renderKatexUnsanitized");
var renderKatexSanitized = /* @__PURE__ */ __name(async (text, config2) => {
  return sanitizeText(await renderKatexUnsanitized(text, config2), config2);
}, "renderKatexSanitized");
var common_default = {
  getRows,
  sanitizeText,
  sanitizeTextOrArray,
  hasBreaks,
  splitBreaks,
  lineBreakRegex,
  removeScript,
  getUrl,
  evaluate,
  getMax,
  getMin
};

// src/setupGraphViewbox.js
var d3Attrs = /* @__PURE__ */ __name(function(d3Elem, attrs) {
  for (let attr of attrs) {
    d3Elem.attr(attr[0], attr[1]);
  }
}, "d3Attrs");
var calculateSvgSizeAttrs = /* @__PURE__ */ __name(function(height, width, useMaxWidth) {
  let attrs = /* @__PURE__ */ new Map();
  if (useMaxWidth) {
    attrs.set("width", "100%");
    attrs.set("style", `max-width: ${width}px;`);
  } else {
    attrs.set("height", height);
    attrs.set("width", width);
  }
  return attrs;
}, "calculateSvgSizeAttrs");
var configureSvgSize = /* @__PURE__ */ __name(function(svgElem, height, width, useMaxWidth) {
  const attrs = calculateSvgSizeAttrs(height, width, useMaxWidth);
  d3Attrs(svgElem, attrs);
}, "configureSvgSize");
var setupGraphViewbox = /* @__PURE__ */ __name(function(graph, svgElem, padding, useMaxWidth) {
  const svgBounds = svgElem.node().getBBox();
  const sWidth = svgBounds.width;
  const sHeight = svgBounds.height;
  log.info(`SVG bounds: ${sWidth}x${sHeight}`, svgBounds);
  let width = 0;
  let height = 0;
  log.info(`Graph bounds: ${width}x${height}`, graph);
  width = sWidth + padding * 2;
  height = sHeight + padding * 2;
  log.info(`Calculated bounds: ${width}x${height}`);
  configureSvgSize(svgElem, height, width, useMaxWidth);
  const vBox = `${svgBounds.x - padding} ${svgBounds.y - padding} ${svgBounds.width + 2 * padding} ${svgBounds.height + 2 * padding}`;
  svgElem.attr("viewBox", vBox);
}, "setupGraphViewbox");

// src/styles.ts
var themes = {};
var getStyles = /* @__PURE__ */ __name((type, userStyles, options) => {
  let diagramStyles = "";
  if (type in themes && themes[type]) {
    diagramStyles = themes[type](options);
  } else {
    log.warn(`No theme found for ${type}`);
  }
  return ` & {
    font-family: ${options.fontFamily};
    font-size: ${options.fontSize};
    fill: ${options.textColor}
  }
  @keyframes edge-animation-frame {
    from {
      stroke-dashoffset: 0;
    }
  }
  @keyframes dash {
    to {
      stroke-dashoffset: 0;
    }
  }
  & .edge-animation-slow {
    stroke-dasharray: 9,5 !important;
    stroke-dashoffset: 900;
    animation: dash 50s linear infinite;
    stroke-linecap: round;
  }
  & .edge-animation-fast {
    stroke-dasharray: 9,5 !important;
    stroke-dashoffset: 900;
    animation: dash 20s linear infinite;
    stroke-linecap: round;
  }
  /* Classes common for multiple diagrams */

  & .error-icon {
    fill: ${options.errorBkgColor};
  }
  & .error-text {
    fill: ${options.errorTextColor};
    stroke: ${options.errorTextColor};
  }

  & .edge-thickness-normal {
    stroke-width: 1px;
  }
  & .edge-thickness-thick {
    stroke-width: 3.5px
  }
  & .edge-pattern-solid {
    stroke-dasharray: 0;
  }
  & .edge-thickness-invisible {
    stroke-width: 0;
    fill: none;
  }
  & .edge-pattern-dashed{
    stroke-dasharray: 3;
  }
  .edge-pattern-dotted {
    stroke-dasharray: 2;
  }

  & .marker {
    fill: ${options.lineColor};
    stroke: ${options.lineColor};
  }
  & .marker.cross {
    stroke: ${options.lineColor};
  }

  & svg {
    font-family: ${options.fontFamily};
    font-size: ${options.fontSize};
  }
   & p {
    margin: 0
   }

  ${diagramStyles}

  ${userStyles}
`;
}, "getStyles");
var addStylesForDiagram = /* @__PURE__ */ __name((type, diagramTheme) => {
  if (diagramTheme !== void 0) {
    themes[type] = diagramTheme;
  }
}, "addStylesForDiagram");
var styles_default = getStyles;

// src/diagrams/common/commonDb.ts
var commonDb_exports = {};
__export(commonDb_exports, {
  clear: () => clear$2,
  getAccDescription: () => getAccDescription,
  getAccTitle: () => getAccTitle,
  getDiagramTitle: () => getDiagramTitle,
  setAccDescription: () => setAccDescription,
  setAccTitle: () => setAccTitle,
  setDiagramTitle: () => setDiagramTitle
});
var accTitle = "";
var diagramTitle = "";
var accDescription = "";
var sanitizeText2 = /* @__PURE__ */ __name((txt) => sanitizeText(txt, getConfig()), "sanitizeText");
var clear$2 = /* @__PURE__ */ __name(() => {
  accTitle = "";
  accDescription = "";
  diagramTitle = "";
}, "clear");
var setAccTitle = /* @__PURE__ */ __name((txt) => {
  accTitle = sanitizeText2(txt).replace(/^\s+/g, "");
}, "setAccTitle");
var getAccTitle = /* @__PURE__ */ __name(() => accTitle, "getAccTitle");
var setAccDescription = /* @__PURE__ */ __name((txt) => {
  accDescription = sanitizeText2(txt).replace(/\n\s+/g, "\n");
}, "setAccDescription");
var getAccDescription = /* @__PURE__ */ __name(() => accDescription, "getAccDescription");
var setDiagramTitle = /* @__PURE__ */ __name((txt) => {
  diagramTitle = sanitizeText2(txt);
}, "setDiagramTitle");
var getDiagramTitle = /* @__PURE__ */ __name(() => diagramTitle, "getDiagramTitle");

// src/diagram-api/diagramAPI.ts
var log2 = log;
var setLogLevel2 = setLogLevel;
var getConfig2 = getConfig;
var setConfig2 = setConfig;
var defaultConfig2 = defaultConfig;
var sanitizeText3 = /* @__PURE__ */ __name((text) => sanitizeText(text, getConfig2()), "sanitizeText");
var setupGraphViewbox2 = setupGraphViewbox;
var getCommonDb = /* @__PURE__ */ __name(() => {
  return commonDb_exports;
}, "getCommonDb");
var diagrams = {};
var registerDiagram = /* @__PURE__ */ __name((id, diagram, detector) => {
  if (diagrams[id]) {
    log2.warn(`Diagram with id ${id} already registered. Overwriting.`);
  }
  diagrams[id] = diagram;
  if (detector) {
    addDetector(id, detector);
  }
  addStylesForDiagram(id, diagram.styles);
  diagram.injectUtils?.(
    log2,
    setLogLevel2,
    getConfig2,
    sanitizeText3,
    setupGraphViewbox2,
    getCommonDb(),
    () => {
    }
  );
}, "registerDiagram");
var getDiagram = /* @__PURE__ */ __name((name) => {
  if (name in diagrams) {
    return diagrams[name];
  }
  throw new DiagramNotFoundError(name);
}, "getDiagram");
var DiagramNotFoundError = class extends Error {
  static {
    __name(this, "DiagramNotFoundError");
  }
  constructor(name) {
    super(`Diagram ${name} not found.`);
  }
};

// ../../node_modules/.pnpm/js-yaml@4.1.0/node_modules/js-yaml/dist/js-yaml.mjs
function isNothing(subject) {
  return typeof subject === "undefined" || subject === null;
}
__name(isNothing, "isNothing");
function isObject$1(subject) {
  return typeof subject === "object" && subject !== null;
}
__name(isObject$1, "isObject");
function toArray(sequence) {
  if (Array.isArray(sequence)) return sequence;
  else if (isNothing(sequence)) return [];
  return [sequence];
}
__name(toArray, "toArray");
function extend$1(target, source) {
  var index, length, key, sourceKeys;
  if (source) {
    sourceKeys = Object.keys(source);
    for (index = 0, length = sourceKeys.length; index < length; index += 1) {
      key = sourceKeys[index];
      target[key] = source[key];
    }
  }
  return target;
}
__name(extend$1, "extend");
function repeat(string, count) {
  var result = "", cycle;
  for (cycle = 0; cycle < count; cycle += 1) {
    result += string;
  }
  return result;
}
__name(repeat, "repeat");
function isNegativeZero(number) {
  return number === 0 && Number.NEGATIVE_INFINITY === 1 / number;
}
__name(isNegativeZero, "isNegativeZero");
var isNothing_1 = isNothing;
var isObject_1 = isObject$1;
var toArray_1 = toArray;
var repeat_1 = repeat;
var isNegativeZero_1 = isNegativeZero;
var extend_1 = extend$1;
var common = {
  isNothing: isNothing_1,
  isObject: isObject_1,
  toArray: toArray_1,
  repeat: repeat_1,
  isNegativeZero: isNegativeZero_1,
  extend: extend_1
};
function formatError(exception2, compact) {
  var where = "", message = exception2.reason || "(unknown reason)";
  if (!exception2.mark) return message;
  if (exception2.mark.name) {
    where += 'in "' + exception2.mark.name + '" ';
  }
  where += "(" + (exception2.mark.line + 1) + ":" + (exception2.mark.column + 1) + ")";
  if (!compact && exception2.mark.snippet) {
    where += "\n\n" + exception2.mark.snippet;
  }
  return message + " " + where;
}
__name(formatError, "formatError");
function YAMLException$1(reason, mark) {
  Error.call(this);
  this.name = "YAMLException";
  this.reason = reason;
  this.mark = mark;
  this.message = formatError(this, false);
  if (Error.captureStackTrace) {
    Error.captureStackTrace(this, this.constructor);
  } else {
    this.stack = new Error().stack || "";
  }
}
__name(YAMLException$1, "YAMLException$1");
YAMLException$1.prototype = Object.create(Error.prototype);
YAMLException$1.prototype.constructor = YAMLException$1;
YAMLException$1.prototype.toString = /* @__PURE__ */ __name(function toString(compact) {
  return this.name + ": " + formatError(this, compact);
}, "toString");
var exception = YAMLException$1;
function getLine(buffer, lineStart, lineEnd, position, maxLineLength) {
  var head = "";
  var tail = "";
  var maxHalfLength = Math.floor(maxLineLength / 2) - 1;
  if (position - lineStart > maxHalfLength) {
    head = " ... ";
    lineStart = position - maxHalfLength + head.length;
  }
  if (lineEnd - position > maxHalfLength) {
    tail = " ...";
    lineEnd = position + maxHalfLength - tail.length;
  }
  return {
    str: head + buffer.slice(lineStart, lineEnd).replace(/\t/g, "\u2192") + tail,
    pos: position - lineStart + head.length
    // relative position
  };
}
__name(getLine, "getLine");
function padStart(string, max) {
  return common.repeat(" ", max - string.length) + string;
}
__name(padStart, "padStart");
function makeSnippet(mark, options) {
  options = Object.create(options || null);
  if (!mark.buffer) return null;
  if (!options.maxLength) options.maxLength = 79;
  if (typeof options.indent !== "number") options.indent = 1;
  if (typeof options.linesBefore !== "number") options.linesBefore = 3;
  if (typeof options.linesAfter !== "number") options.linesAfter = 2;
  var re = /\r?\n|\r|\0/g;
  var lineStarts = [0];
  var lineEnds = [];
  var match;
  var foundLineNo = -1;
  while (match = re.exec(mark.buffer)) {
    lineEnds.push(match.index);
    lineStarts.push(match.index + match[0].length);
    if (mark.position <= match.index && foundLineNo < 0) {
      foundLineNo = lineStarts.length - 2;
    }
  }
  if (foundLineNo < 0) foundLineNo = lineStarts.length - 1;
  var result = "", i, line;
  var lineNoLength = Math.min(mark.line + options.linesAfter, lineEnds.length).toString().length;
  var maxLineLength = options.maxLength - (options.indent + lineNoLength + 3);
  for (i = 1; i <= options.linesBefore; i++) {
    if (foundLineNo - i < 0) break;
    line = getLine(
      mark.buffer,
      lineStarts[foundLineNo - i],
      lineEnds[foundLineNo - i],
      mark.position - (lineStarts[foundLineNo] - lineStarts[foundLineNo - i]),
      maxLineLength
    );
    result = common.repeat(" ", options.indent) + padStart((mark.line - i + 1).toString(), lineNoLength) + " | " + line.str + "\n" + result;
  }
  line = getLine(mark.buffer, lineStarts[foundLineNo], lineEnds[foundLineNo], mark.position, maxLineLength);
  result += common.repeat(" ", options.indent) + padStart((mark.line + 1).toString(), lineNoLength) + " | " + line.str + "\n";
  result += common.repeat("-", options.indent + lineNoLength + 3 + line.pos) + "^\n";
  for (i = 1; i <= options.linesAfter; i++) {
    if (foundLineNo + i >= lineEnds.length) break;
    line = getLine(
      mark.buffer,
      lineStarts[foundLineNo + i],
      lineEnds[foundLineNo + i],
      mark.position - (lineStarts[foundLineNo] - lineStarts[foundLineNo + i]),
      maxLineLength
    );
    result += common.repeat(" ", options.indent) + padStart((mark.line + i + 1).toString(), lineNoLength) + " | " + line.str + "\n";
  }
  return result.replace(/\n$/, "");
}
__name(makeSnippet, "makeSnippet");
var snippet = makeSnippet;
var TYPE_CONSTRUCTOR_OPTIONS = [
  "kind",
  "multi",
  "resolve",
  "construct",
  "instanceOf",
  "predicate",
  "represent",
  "representName",
  "defaultStyle",
  "styleAliases"
];
var YAML_NODE_KINDS = [
  "scalar",
  "sequence",
  "mapping"
];
function compileStyleAliases(map2) {
  var result = {};
  if (map2 !== null) {
    Object.keys(map2).forEach(function(style) {
      map2[style].forEach(function(alias) {
        result[String(alias)] = style;
      });
    });
  }
  return result;
}
__name(compileStyleAliases, "compileStyleAliases");
function Type$1(tag, options) {
  options = options || {};
  Object.keys(options).forEach(function(name) {
    if (TYPE_CONSTRUCTOR_OPTIONS.indexOf(name) === -1) {
      throw new exception('Unknown option "' + name + '" is met in definition of "' + tag + '" YAML type.');
    }
  });
  this.options = options;
  this.tag = tag;
  this.kind = options["kind"] || null;
  this.resolve = options["resolve"] || function() {
    return true;
  };
  this.construct = options["construct"] || function(data) {
    return data;
  };
  this.instanceOf = options["instanceOf"] || null;
  this.predicate = options["predicate"] || null;
  this.represent = options["represent"] || null;
  this.representName = options["representName"] || null;
  this.defaultStyle = options["defaultStyle"] || null;
  this.multi = options["multi"] || false;
  this.styleAliases = compileStyleAliases(options["styleAliases"] || null);
  if (YAML_NODE_KINDS.indexOf(this.kind) === -1) {
    throw new exception('Unknown kind "' + this.kind + '" is specified for "' + tag + '" YAML type.');
  }
}
__name(Type$1, "Type$1");
var type = Type$1;
function compileList(schema2, name) {
  var result = [];
  schema2[name].forEach(function(currentType) {
    var newIndex = result.length;
    result.forEach(function(previousType, previousIndex) {
      if (previousType.tag === currentType.tag && previousType.kind === currentType.kind && previousType.multi === currentType.multi) {
        newIndex = previousIndex;
      }
    });
    result[newIndex] = currentType;
  });
  return result;
}
__name(compileList, "compileList");
function compileMap() {
  var result = {
    scalar: {},
    sequence: {},
    mapping: {},
    fallback: {},
    multi: {
      scalar: [],
      sequence: [],
      mapping: [],
      fallback: []
    }
  }, index, length;
  function collectType(type2) {
    if (type2.multi) {
      result.multi[type2.kind].push(type2);
      result.multi["fallback"].push(type2);
    } else {
      result[type2.kind][type2.tag] = result["fallback"][type2.tag] = type2;
    }
  }
  __name(collectType, "collectType");
  for (index = 0, length = arguments.length; index < length; index += 1) {
    arguments[index].forEach(collectType);
  }
  return result;
}
__name(compileMap, "compileMap");
function Schema$1(definition) {
  return this.extend(definition);
}
__name(Schema$1, "Schema$1");
Schema$1.prototype.extend = /* @__PURE__ */ __name(function extend2(definition) {
  var implicit = [];
  var explicit = [];
  if (definition instanceof type) {
    explicit.push(definition);
  } else if (Array.isArray(definition)) {
    explicit = explicit.concat(definition);
  } else if (definition && (Array.isArray(definition.implicit) || Array.isArray(definition.explicit))) {
    if (definition.implicit) implicit = implicit.concat(definition.implicit);
    if (definition.explicit) explicit = explicit.concat(definition.explicit);
  } else {
    throw new exception("Schema.extend argument should be a Type, [ Type ], or a schema definition ({ implicit: [...], explicit: [...] })");
  }
  implicit.forEach(function(type$1) {
    if (!(type$1 instanceof type)) {
      throw new exception("Specified list of YAML types (or a single Type object) contains a non-Type object.");
    }
    if (type$1.loadKind && type$1.loadKind !== "scalar") {
      throw new exception("There is a non-scalar type in the implicit list of a schema. Implicit resolving of such types is not supported.");
    }
    if (type$1.multi) {
      throw new exception("There is a multi type in the implicit list of a schema. Multi tags can only be listed as explicit.");
    }
  });
  explicit.forEach(function(type$1) {
    if (!(type$1 instanceof type)) {
      throw new exception("Specified list of YAML types (or a single Type object) contains a non-Type object.");
    }
  });
  var result = Object.create(Schema$1.prototype);
  result.implicit = (this.implicit || []).concat(implicit);
  result.explicit = (this.explicit || []).concat(explicit);
  result.compiledImplicit = compileList(result, "implicit");
  result.compiledExplicit = compileList(result, "explicit");
  result.compiledTypeMap = compileMap(result.compiledImplicit, result.compiledExplicit);
  return result;
}, "extend");
var schema = Schema$1;
var str = new type("tag:yaml.org,2002:str", {
  kind: "scalar",
  construct: /* @__PURE__ */ __name(function(data) {
    return data !== null ? data : "";
  }, "construct")
});
var seq = new type("tag:yaml.org,2002:seq", {
  kind: "sequence",
  construct: /* @__PURE__ */ __name(function(data) {
    return data !== null ? data : [];
  }, "construct")
});
var map = new type("tag:yaml.org,2002:map", {
  kind: "mapping",
  construct: /* @__PURE__ */ __name(function(data) {
    return data !== null ? data : {};
  }, "construct")
});
var failsafe = new schema({
  explicit: [
    str,
    seq,
    map
  ]
});
function resolveYamlNull(data) {
  if (data === null) return true;
  var max = data.length;
  return max === 1 && data === "~" || max === 4 && (data === "null" || data === "Null" || data === "NULL");
}
__name(resolveYamlNull, "resolveYamlNull");
function constructYamlNull() {
  return null;
}
__name(constructYamlNull, "constructYamlNull");
function isNull(object) {
  return object === null;
}
__name(isNull, "isNull");
var _null = new type("tag:yaml.org,2002:null", {
  kind: "scalar",
  resolve: resolveYamlNull,
  construct: constructYamlNull,
  predicate: isNull,
  represent: {
    canonical: /* @__PURE__ */ __name(function() {
      return "~";
    }, "canonical"),
    lowercase: /* @__PURE__ */ __name(function() {
      return "null";
    }, "lowercase"),
    uppercase: /* @__PURE__ */ __name(function() {
      return "NULL";
    }, "uppercase"),
    camelcase: /* @__PURE__ */ __name(function() {
      return "Null";
    }, "camelcase"),
    empty: /* @__PURE__ */ __name(function() {
      return "";
    }, "empty")
  },
  defaultStyle: "lowercase"
});
function resolveYamlBoolean(data) {
  if (data === null) return false;
  var max = data.length;
  return max === 4 && (data === "true" || data === "True" || data === "TRUE") || max === 5 && (data === "false" || data === "False" || data === "FALSE");
}
__name(resolveYamlBoolean, "resolveYamlBoolean");
function constructYamlBoolean(data) {
  return data === "true" || data === "True" || data === "TRUE";
}
__name(constructYamlBoolean, "constructYamlBoolean");
function isBoolean(object) {
  return Object.prototype.toString.call(object) === "[object Boolean]";
}
__name(isBoolean, "isBoolean");
var bool = new type("tag:yaml.org,2002:bool", {
  kind: "scalar",
  resolve: resolveYamlBoolean,
  construct: constructYamlBoolean,
  predicate: isBoolean,
  represent: {
    lowercase: /* @__PURE__ */ __name(function(object) {
      return object ? "true" : "false";
    }, "lowercase"),
    uppercase: /* @__PURE__ */ __name(function(object) {
      return object ? "TRUE" : "FALSE";
    }, "uppercase"),
    camelcase: /* @__PURE__ */ __name(function(object) {
      return object ? "True" : "False";
    }, "camelcase")
  },
  defaultStyle: "lowercase"
});
function isHexCode(c) {
  return 48 <= c && c <= 57 || 65 <= c && c <= 70 || 97 <= c && c <= 102;
}
__name(isHexCode, "isHexCode");
function isOctCode(c) {
  return 48 <= c && c <= 55;
}
__name(isOctCode, "isOctCode");
function isDecCode(c) {
  return 48 <= c && c <= 57;
}
__name(isDecCode, "isDecCode");
function resolveYamlInteger(data) {
  if (data === null) return false;
  var max = data.length, index = 0, hasDigits = false, ch;
  if (!max) return false;
  ch = data[index];
  if (ch === "-" || ch === "+") {
    ch = data[++index];
  }
  if (ch === "0") {
    if (index + 1 === max) return true;
    ch = data[++index];
    if (ch === "b") {
      index++;
      for (; index < max; index++) {
        ch = data[index];
        if (ch === "_") continue;
        if (ch !== "0" && ch !== "1") return false;
        hasDigits = true;
      }
      return hasDigits && ch !== "_";
    }
    if (ch === "x") {
      index++;
      for (; index < max; index++) {
        ch = data[index];
        if (ch === "_") continue;
        if (!isHexCode(data.charCodeAt(index))) return false;
        hasDigits = true;
      }
      return hasDigits && ch !== "_";
    }
    if (ch === "o") {
      index++;
      for (; index < max; index++) {
        ch = data[index];
        if (ch === "_") continue;
        if (!isOctCode(data.charCodeAt(index))) return false;
        hasDigits = true;
      }
      return hasDigits && ch !== "_";
    }
  }
  if (ch === "_") return false;
  for (; index < max; index++) {
    ch = data[index];
    if (ch === "_") continue;
    if (!isDecCode(data.charCodeAt(index))) {
      return false;
    }
    hasDigits = true;
  }
  if (!hasDigits || ch === "_") return false;
  return true;
}
__name(resolveYamlInteger, "resolveYamlInteger");
function constructYamlInteger(data) {
  var value = data, sign = 1, ch;
  if (value.indexOf("_") !== -1) {
    value = value.replace(/_/g, "");
  }
  ch = value[0];
  if (ch === "-" || ch === "+") {
    if (ch === "-") sign = -1;
    value = value.slice(1);
    ch = value[0];
  }
  if (value === "0") return 0;
  if (ch === "0") {
    if (value[1] === "b") return sign * parseInt(value.slice(2), 2);
    if (value[1] === "x") return sign * parseInt(value.slice(2), 16);
    if (value[1] === "o") return sign * parseInt(value.slice(2), 8);
  }
  return sign * parseInt(value, 10);
}
__name(constructYamlInteger, "constructYamlInteger");
function isInteger(object) {
  return Object.prototype.toString.call(object) === "[object Number]" && (object % 1 === 0 && !common.isNegativeZero(object));
}
__name(isInteger, "isInteger");
var int = new type("tag:yaml.org,2002:int", {
  kind: "scalar",
  resolve: resolveYamlInteger,
  construct: constructYamlInteger,
  predicate: isInteger,
  represent: {
    binary: /* @__PURE__ */ __name(function(obj) {
      return obj >= 0 ? "0b" + obj.toString(2) : "-0b" + obj.toString(2).slice(1);
    }, "binary"),
    octal: /* @__PURE__ */ __name(function(obj) {
      return obj >= 0 ? "0o" + obj.toString(8) : "-0o" + obj.toString(8).slice(1);
    }, "octal"),
    decimal: /* @__PURE__ */ __name(function(obj) {
      return obj.toString(10);
    }, "decimal"),
    /* eslint-disable max-len */
    hexadecimal: /* @__PURE__ */ __name(function(obj) {
      return obj >= 0 ? "0x" + obj.toString(16).toUpperCase() : "-0x" + obj.toString(16).toUpperCase().slice(1);
    }, "hexadecimal")
  },
  defaultStyle: "decimal",
  styleAliases: {
    binary: [2, "bin"],
    octal: [8, "oct"],
    decimal: [10, "dec"],
    hexadecimal: [16, "hex"]
  }
});
var YAML_FLOAT_PATTERN = new RegExp(
  // 2.5e4, 2.5 and integers
  "^(?:[-+]?(?:[0-9][0-9_]*)(?:\\.[0-9_]*)?(?:[eE][-+]?[0-9]+)?|\\.[0-9_]+(?:[eE][-+]?[0-9]+)?|[-+]?\\.(?:inf|Inf|INF)|\\.(?:nan|NaN|NAN))$"
);
function resolveYamlFloat(data) {
  if (data === null) return false;
  if (!YAML_FLOAT_PATTERN.test(data) || // Quick hack to not allow integers end with `_`
  // Probably should update regexp & check speed
  data[data.length - 1] === "_") {
    return false;
  }
  return true;
}
__name(resolveYamlFloat, "resolveYamlFloat");
function constructYamlFloat(data) {
  var value, sign;
  value = data.replace(/_/g, "").toLowerCase();
  sign = value[0] === "-" ? -1 : 1;
  if ("+-".indexOf(value[0]) >= 0) {
    value = value.slice(1);
  }
  if (value === ".inf") {
    return sign === 1 ? Number.POSITIVE_INFINITY : Number.NEGATIVE_INFINITY;
  } else if (value === ".nan") {
    return NaN;
  }
  return sign * parseFloat(value, 10);
}
__name(constructYamlFloat, "constructYamlFloat");
var SCIENTIFIC_WITHOUT_DOT = /^[-+]?[0-9]+e/;
function representYamlFloat(object, style) {
  var res;
  if (isNaN(object)) {
    switch (style) {
      case "lowercase":
        return ".nan";
      case "uppercase":
        return ".NAN";
      case "camelcase":
        return ".NaN";
    }
  } else if (Number.POSITIVE_INFINITY === object) {
    switch (style) {
      case "lowercase":
        return ".inf";
      case "uppercase":
        return ".INF";
      case "camelcase":
        return ".Inf";
    }
  } else if (Number.NEGATIVE_INFINITY === object) {
    switch (style) {
      case "lowercase":
        return "-.inf";
      case "uppercase":
        return "-.INF";
      case "camelcase":
        return "-.Inf";
    }
  } else if (common.isNegativeZero(object)) {
    return "-0.0";
  }
  res = object.toString(10);
  return SCIENTIFIC_WITHOUT_DOT.test(res) ? res.replace("e", ".e") : res;
}
__name(representYamlFloat, "representYamlFloat");
function isFloat(object) {
  return Object.prototype.toString.call(object) === "[object Number]" && (object % 1 !== 0 || common.isNegativeZero(object));
}
__name(isFloat, "isFloat");
var float = new type("tag:yaml.org,2002:float", {
  kind: "scalar",
  resolve: resolveYamlFloat,
  construct: constructYamlFloat,
  predicate: isFloat,
  represent: representYamlFloat,
  defaultStyle: "lowercase"
});
var json = failsafe.extend({
  implicit: [
    _null,
    bool,
    int,
    float
  ]
});
var core = json;
var YAML_DATE_REGEXP = new RegExp(
  "^([0-9][0-9][0-9][0-9])-([0-9][0-9])-([0-9][0-9])$"
);
var YAML_TIMESTAMP_REGEXP = new RegExp(
  "^([0-9][0-9][0-9][0-9])-([0-9][0-9]?)-([0-9][0-9]?)(?:[Tt]|[ \\t]+)([0-9][0-9]?):([0-9][0-9]):([0-9][0-9])(?:\\.([0-9]*))?(?:[ \\t]*(Z|([-+])([0-9][0-9]?)(?::([0-9][0-9]))?))?$"
);
function resolveYamlTimestamp(data) {
  if (data === null) return false;
  if (YAML_DATE_REGEXP.exec(data) !== null) return true;
  if (YAML_TIMESTAMP_REGEXP.exec(data) !== null) return true;
  return false;
}
__name(resolveYamlTimestamp, "resolveYamlTimestamp");
function constructYamlTimestamp(data) {
  var match, year, month, day, hour, minute, second, fraction = 0, delta = null, tz_hour, tz_minute, date;
  match = YAML_DATE_REGEXP.exec(data);
  if (match === null) match = YAML_TIMESTAMP_REGEXP.exec(data);
  if (match === null) throw new Error("Date resolve error");
  year = +match[1];
  month = +match[2] - 1;
  day = +match[3];
  if (!match[4]) {
    return new Date(Date.UTC(year, month, day));
  }
  hour = +match[4];
  minute = +match[5];
  second = +match[6];
  if (match[7]) {
    fraction = match[7].slice(0, 3);
    while (fraction.length < 3) {
      fraction += "0";
    }
    fraction = +fraction;
  }
  if (match[9]) {
    tz_hour = +match[10];
    tz_minute = +(match[11] || 0);
    delta = (tz_hour * 60 + tz_minute) * 6e4;
    if (match[9] === "-") delta = -delta;
  }
  date = new Date(Date.UTC(year, month, day, hour, minute, second, fraction));
  if (delta) date.setTime(date.getTime() - delta);
  return date;
}
__name(constructYamlTimestamp, "constructYamlTimestamp");
function representYamlTimestamp(object) {
  return object.toISOString();
}
__name(representYamlTimestamp, "representYamlTimestamp");
var timestamp = new type("tag:yaml.org,2002:timestamp", {
  kind: "scalar",
  resolve: resolveYamlTimestamp,
  construct: constructYamlTimestamp,
  instanceOf: Date,
  represent: representYamlTimestamp
});
function resolveYamlMerge(data) {
  return data === "<<" || data === null;
}
__name(resolveYamlMerge, "resolveYamlMerge");
var merge$1 = new type("tag:yaml.org,2002:merge", {
  kind: "scalar",
  resolve: resolveYamlMerge
});
var BASE64_MAP = "ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789+/=\n\r";
function resolveYamlBinary(data) {
  if (data === null) return false;
  var code, idx, bitlen = 0, max = data.length, map2 = BASE64_MAP;
  for (idx = 0; idx < max; idx++) {
    code = map2.indexOf(data.charAt(idx));
    if (code > 64) continue;
    if (code < 0) return false;
    bitlen += 6;
  }
  return bitlen % 8 === 0;
}
__name(resolveYamlBinary, "resolveYamlBinary");
function constructYamlBinary(data) {
  var idx, tailbits, input = data.replace(/[\r\n=]/g, ""), max = input.length, map2 = BASE64_MAP, bits = 0, result = [];
  for (idx = 0; idx < max; idx++) {
    if (idx % 4 === 0 && idx) {
      result.push(bits >> 16 & 255);
      result.push(bits >> 8 & 255);
      result.push(bits & 255);
    }
    bits = bits << 6 | map2.indexOf(input.charAt(idx));
  }
  tailbits = max % 4 * 6;
  if (tailbits === 0) {
    result.push(bits >> 16 & 255);
    result.push(bits >> 8 & 255);
    result.push(bits & 255);
  } else if (tailbits === 18) {
    result.push(bits >> 10 & 255);
    result.push(bits >> 2 & 255);
  } else if (tailbits === 12) {
    result.push(bits >> 4 & 255);
  }
  return new Uint8Array(result);
}
__name(constructYamlBinary, "constructYamlBinary");
function representYamlBinary(object) {
  var result = "", bits = 0, idx, tail, max = object.length, map2 = BASE64_MAP;
  for (idx = 0; idx < max; idx++) {
    if (idx % 3 === 0 && idx) {
      result += map2[bits >> 18 & 63];
      result += map2[bits >> 12 & 63];
      result += map2[bits >> 6 & 63];
      result += map2[bits & 63];
    }
    bits = (bits << 8) + object[idx];
  }
  tail = max % 3;
  if (tail === 0) {
    result += map2[bits >> 18 & 63];
    result += map2[bits >> 12 & 63];
    result += map2[bits >> 6 & 63];
    result += map2[bits & 63];
  } else if (tail === 2) {
    result += map2[bits >> 10 & 63];
    result += map2[bits >> 4 & 63];
    result += map2[bits << 2 & 63];
    result += map2[64];
  } else if (tail === 1) {
    result += map2[bits >> 2 & 63];
    result += map2[bits << 4 & 63];
    result += map2[64];
    result += map2[64];
  }
  return result;
}
__name(representYamlBinary, "representYamlBinary");
function isBinary(obj) {
  return Object.prototype.toString.call(obj) === "[object Uint8Array]";
}
__name(isBinary, "isBinary");
var binary = new type("tag:yaml.org,2002:binary", {
  kind: "scalar",
  resolve: resolveYamlBinary,
  construct: constructYamlBinary,
  predicate: isBinary,
  represent: representYamlBinary
});
var _hasOwnProperty$3 = Object.prototype.hasOwnProperty;
var _toString$2 = Object.prototype.toString;
function resolveYamlOmap(data) {
  if (data === null) return true;
  var objectKeys = [], index, length, pair, pairKey, pairHasKey, object = data;
  for (index = 0, length = object.length; index < length; index += 1) {
    pair = object[index];
    pairHasKey = false;
    if (_toString$2.call(pair) !== "[object Object]") return false;
    for (pairKey in pair) {
      if (_hasOwnProperty$3.call(pair, pairKey)) {
        if (!pairHasKey) pairHasKey = true;
        else return false;
      }
    }
    if (!pairHasKey) return false;
    if (objectKeys.indexOf(pairKey) === -1) objectKeys.push(pairKey);
    else return false;
  }
  return true;
}
__name(resolveYamlOmap, "resolveYamlOmap");
function constructYamlOmap(data) {
  return data !== null ? data : [];
}
__name(constructYamlOmap, "constructYamlOmap");
var omap = new type("tag:yaml.org,2002:omap", {
  kind: "sequence",
  resolve: resolveYamlOmap,
  construct: constructYamlOmap
});
var _toString$1 = Object.prototype.toString;
function resolveYamlPairs(data) {
  if (data === null) return true;
  var index, length, pair, keys, result, object = data;
  result = new Array(object.length);
  for (index = 0, length = object.length; index < length; index += 1) {
    pair = object[index];
    if (_toString$1.call(pair) !== "[object Object]") return false;
    keys = Object.keys(pair);
    if (keys.length !== 1) return false;
    result[index] = [keys[0], pair[keys[0]]];
  }
  return true;
}
__name(resolveYamlPairs, "resolveYamlPairs");
function constructYamlPairs(data) {
  if (data === null) return [];
  var index, length, pair, keys, result, object = data;
  result = new Array(object.length);
  for (index = 0, length = object.length; index < length; index += 1) {
    pair = object[index];
    keys = Object.keys(pair);
    result[index] = [keys[0], pair[keys[0]]];
  }
  return result;
}
__name(constructYamlPairs, "constructYamlPairs");
var pairs = new type("tag:yaml.org,2002:pairs", {
  kind: "sequence",
  resolve: resolveYamlPairs,
  construct: constructYamlPairs
});
var _hasOwnProperty$2 = Object.prototype.hasOwnProperty;
function resolveYamlSet(data) {
  if (data === null) return true;
  var key, object = data;
  for (key in object) {
    if (_hasOwnProperty$2.call(object, key)) {
      if (object[key] !== null) return false;
    }
  }
  return true;
}
__name(resolveYamlSet, "resolveYamlSet");
function constructYamlSet(data) {
  return data !== null ? data : {};
}
__name(constructYamlSet, "constructYamlSet");
var set$2 = new type("tag:yaml.org,2002:set", {
  kind: "mapping",
  resolve: resolveYamlSet,
  construct: constructYamlSet
});
var _default = core.extend({
  implicit: [
    timestamp,
    merge$1
  ],
  explicit: [
    binary,
    omap,
    pairs,
    set$2
  ]
});
var _hasOwnProperty$1 = Object.prototype.hasOwnProperty;
var CONTEXT_FLOW_IN = 1;
var CONTEXT_FLOW_OUT = 2;
var CONTEXT_BLOCK_IN = 3;
var CONTEXT_BLOCK_OUT = 4;
var CHOMPING_CLIP = 1;
var CHOMPING_STRIP = 2;
var CHOMPING_KEEP = 3;
var PATTERN_NON_PRINTABLE = /[\x00-\x08\x0B\x0C\x0E-\x1F\x7F-\x84\x86-\x9F\uFFFE\uFFFF]|[\uD800-\uDBFF](?![\uDC00-\uDFFF])|(?:[^\uD800-\uDBFF]|^)[\uDC00-\uDFFF]/;
var PATTERN_NON_ASCII_LINE_BREAKS = /[\x85\u2028\u2029]/;
var PATTERN_FLOW_INDICATORS = /[,\[\]\{\}]/;
var PATTERN_TAG_HANDLE = /^(?:!|!!|![a-z\-]+!)$/i;
var PATTERN_TAG_URI = /^(?:!|[^,\[\]\{\}])(?:%[0-9a-f]{2}|[0-9a-z\-#;\/\?:@&=\+\$,_\.!~\*'\(\)\[\]])*$/i;
function _class(obj) {
  return Object.prototype.toString.call(obj);
}
__name(_class, "_class");
function is_EOL(c) {
  return c === 10 || c === 13;
}
__name(is_EOL, "is_EOL");
function is_WHITE_SPACE(c) {
  return c === 9 || c === 32;
}
__name(is_WHITE_SPACE, "is_WHITE_SPACE");
function is_WS_OR_EOL(c) {
  return c === 9 || c === 32 || c === 10 || c === 13;
}
__name(is_WS_OR_EOL, "is_WS_OR_EOL");
function is_FLOW_INDICATOR(c) {
  return c === 44 || c === 91 || c === 93 || c === 123 || c === 125;
}
__name(is_FLOW_INDICATOR, "is_FLOW_INDICATOR");
function fromHexCode(c) {
  var lc;
  if (48 <= c && c <= 57) {
    return c - 48;
  }
  lc = c | 32;
  if (97 <= lc && lc <= 102) {
    return lc - 97 + 10;
  }
  return -1;
}
__name(fromHexCode, "fromHexCode");
function escapedHexLen(c) {
  if (c === 120) {
    return 2;
  }
  if (c === 117) {
    return 4;
  }
  if (c === 85) {
    return 8;
  }
  return 0;
}
__name(escapedHexLen, "escapedHexLen");
function fromDecimalCode(c) {
  if (48 <= c && c <= 57) {
    return c - 48;
  }
  return -1;
}
__name(fromDecimalCode, "fromDecimalCode");
function simpleEscapeSequence(c) {
  return c === 48 ? "\0" : c === 97 ? "\x07" : c === 98 ? "\b" : c === 116 ? "	" : c === 9 ? "	" : c === 110 ? "\n" : c === 118 ? "\v" : c === 102 ? "\f" : c === 114 ? "\r" : c === 101 ? "\x1B" : c === 32 ? " " : c === 34 ? '"' : c === 47 ? "/" : c === 92 ? "\\" : c === 78 ? "\x85" : c === 95 ? "\xA0" : c === 76 ? "\u2028" : c === 80 ? "\u2029" : "";
}
__name(simpleEscapeSequence, "simpleEscapeSequence");
function charFromCodepoint(c) {
  if (c <= 65535) {
    return String.fromCharCode(c);
  }
  return String.fromCharCode(
    (c - 65536 >> 10) + 55296,
    (c - 65536 & 1023) + 56320
  );
}
__name(charFromCodepoint, "charFromCodepoint");
var simpleEscapeCheck = new Array(256);
var simpleEscapeMap = new Array(256);
for (i$1 = 0; i$1 < 256; i$1++) {
  simpleEscapeCheck[i$1] = simpleEscapeSequence(i$1) ? 1 : 0;
  simpleEscapeMap[i$1] = simpleEscapeSequence(i$1);
}
var i$1;
function State$1(input, options) {
  this.input = input;
  this.filename = options["filename"] || null;
  this.schema = options["schema"] || _default;
  this.onWarning = options["onWarning"] || null;
  this.legacy = options["legacy"] || false;
  this.json = options["json"] || false;
  this.listener = options["listener"] || null;
  this.implicitTypes = this.schema.compiledImplicit;
  this.typeMap = this.schema.compiledTypeMap;
  this.length = input.length;
  this.position = 0;
  this.line = 0;
  this.lineStart = 0;
  this.lineIndent = 0;
  this.firstTabInLine = -1;
  this.documents = [];
}
__name(State$1, "State$1");
function generateError(state, message) {
  var mark = {
    name: state.filename,
    buffer: state.input.slice(0, -1),
    // omit trailing \0
    position: state.position,
    line: state.line,
    column: state.position - state.lineStart
  };
  mark.snippet = snippet(mark);
  return new exception(message, mark);
}
__name(generateError, "generateError");
function throwError(state, message) {
  throw generateError(state, message);
}
__name(throwError, "throwError");
function throwWarning(state, message) {
  if (state.onWarning) {
    state.onWarning.call(null, generateError(state, message));
  }
}
__name(throwWarning, "throwWarning");
var directiveHandlers = {
  YAML: /* @__PURE__ */ __name(function handleYamlDirective(state, name, args) {
    var match, major, minor;
    if (state.version !== null) {
      throwError(state, "duplication of %YAML directive");
    }
    if (args.length !== 1) {
      throwError(state, "YAML directive accepts exactly one argument");
    }
    match = /^([0-9]+)\.([0-9]+)$/.exec(args[0]);
    if (match === null) {
      throwError(state, "ill-formed argument of the YAML directive");
    }
    major = parseInt(match[1], 10);
    minor = parseInt(match[2], 10);
    if (major !== 1) {
      throwError(state, "unacceptable YAML version of the document");
    }
    state.version = args[0];
    state.checkLineBreaks = minor < 2;
    if (minor !== 1 && minor !== 2) {
      throwWarning(state, "unsupported YAML version of the document");
    }
  }, "handleYamlDirective"),
  TAG: /* @__PURE__ */ __name(function handleTagDirective(state, name, args) {
    var handle, prefix;
    if (args.length !== 2) {
      throwError(state, "TAG directive accepts exactly two arguments");
    }
    handle = args[0];
    prefix = args[1];
    if (!PATTERN_TAG_HANDLE.test(handle)) {
      throwError(state, "ill-formed tag handle (first argument) of the TAG directive");
    }
    if (_hasOwnProperty$1.call(state.tagMap, handle)) {
      throwError(state, 'there is a previously declared suffix for "' + handle + '" tag handle');
    }
    if (!PATTERN_TAG_URI.test(prefix)) {
      throwError(state, "ill-formed tag prefix (second argument) of the TAG directive");
    }
    try {
      prefix = decodeURIComponent(prefix);
    } catch (err) {
      throwError(state, "tag prefix is malformed: " + prefix);
    }
    state.tagMap[handle] = prefix;
  }, "handleTagDirective")
};
function captureSegment(state, start, end, checkJson) {
  var _position, _length, _character, _result;
  if (start < end) {
    _result = state.input.slice(start, end);
    if (checkJson) {
      for (_position = 0, _length = _result.length; _position < _length; _position += 1) {
        _character = _result.charCodeAt(_position);
        if (!(_character === 9 || 32 <= _character && _character <= 1114111)) {
          throwError(state, "expected valid JSON character");
        }
      }
    } else if (PATTERN_NON_PRINTABLE.test(_result)) {
      throwError(state, "the stream contains non-printable characters");
    }
    state.result += _result;
  }
}
__name(captureSegment, "captureSegment");
function mergeMappings(state, destination, source, overridableKeys) {
  var sourceKeys, key, index, quantity;
  if (!common.isObject(source)) {
    throwError(state, "cannot merge mappings; the provided source object is unacceptable");
  }
  sourceKeys = Object.keys(source);
  for (index = 0, quantity = sourceKeys.length; index < quantity; index += 1) {
    key = sourceKeys[index];
    if (!_hasOwnProperty$1.call(destination, key)) {
      destination[key] = source[key];
      overridableKeys[key] = true;
    }
  }
}
__name(mergeMappings, "mergeMappings");
function storeMappingPair(state, _result, overridableKeys, keyTag, keyNode, valueNode, startLine, startLineStart, startPos) {
  var index, quantity;
  if (Array.isArray(keyNode)) {
    keyNode = Array.prototype.slice.call(keyNode);
    for (index = 0, quantity = keyNode.length; index < quantity; index += 1) {
      if (Array.isArray(keyNode[index])) {
        throwError(state, "nested arrays are not supported inside keys");
      }
      if (typeof keyNode === "object" && _class(keyNode[index]) === "[object Object]") {
        keyNode[index] = "[object Object]";
      }
    }
  }
  if (typeof keyNode === "object" && _class(keyNode) === "[object Object]") {
    keyNode = "[object Object]";
  }
  keyNode = String(keyNode);
  if (_result === null) {
    _result = {};
  }
  if (keyTag === "tag:yaml.org,2002:merge") {
    if (Array.isArray(valueNode)) {
      for (index = 0, quantity = valueNode.length; index < quantity; index += 1) {
        mergeMappings(state, _result, valueNode[index], overridableKeys);
      }
    } else {
      mergeMappings(state, _result, valueNode, overridableKeys);
    }
  } else {
    if (!state.json && !_hasOwnProperty$1.call(overridableKeys, keyNode) && _hasOwnProperty$1.call(_result, keyNode)) {
      state.line = startLine || state.line;
      state.lineStart = startLineStart || state.lineStart;
      state.position = startPos || state.position;
      throwError(state, "duplicated mapping key");
    }
    if (keyNode === "__proto__") {
      Object.defineProperty(_result, keyNode, {
        configurable: true,
        enumerable: true,
        writable: true,
        value: valueNode
      });
    } else {
      _result[keyNode] = valueNode;
    }
    delete overridableKeys[keyNode];
  }
  return _result;
}
__name(storeMappingPair, "storeMappingPair");
function readLineBreak(state) {
  var ch;
  ch = state.input.charCodeAt(state.position);
  if (ch === 10) {
    state.position++;
  } else if (ch === 13) {
    state.position++;
    if (state.input.charCodeAt(state.position) === 10) {
      state.position++;
    }
  } else {
    throwError(state, "a line break is expected");
  }
  state.line += 1;
  state.lineStart = state.position;
  state.firstTabInLine = -1;
}
__name(readLineBreak, "readLineBreak");
function skipSeparationSpace(state, allowComments, checkIndent) {
  var lineBreaks = 0, ch = state.input.charCodeAt(state.position);
  while (ch !== 0) {
    while (is_WHITE_SPACE(ch)) {
      if (ch === 9 && state.firstTabInLine === -1) {
        state.firstTabInLine = state.position;
      }
      ch = state.input.charCodeAt(++state.position);
    }
    if (allowComments && ch === 35) {
      do {
        ch = state.input.charCodeAt(++state.position);
      } while (ch !== 10 && ch !== 13 && ch !== 0);
    }
    if (is_EOL(ch)) {
      readLineBreak(state);
      ch = state.input.charCodeAt(state.position);
      lineBreaks++;
      state.lineIndent = 0;
      while (ch === 32) {
        state.lineIndent++;
        ch = state.input.charCodeAt(++state.position);
      }
    } else {
      break;
    }
  }
  if (checkIndent !== -1 && lineBreaks !== 0 && state.lineIndent < checkIndent) {
    throwWarning(state, "deficient indentation");
  }
  return lineBreaks;
}
__name(skipSeparationSpace, "skipSeparationSpace");
function testDocumentSeparator(state) {
  var _position = state.position, ch;
  ch = state.input.charCodeAt(_position);
  if ((ch === 45 || ch === 46) && ch === state.input.charCodeAt(_position + 1) && ch === state.input.charCodeAt(_position + 2)) {
    _position += 3;
    ch = state.input.charCodeAt(_position);
    if (ch === 0 || is_WS_OR_EOL(ch)) {
      return true;
    }
  }
  return false;
}
__name(testDocumentSeparator, "testDocumentSeparator");
function writeFoldedLines(state, count) {
  if (count === 1) {
    state.result += " ";
  } else if (count > 1) {
    state.result += common.repeat("\n", count - 1);
  }
}
__name(writeFoldedLines, "writeFoldedLines");
function readPlainScalar(state, nodeIndent, withinFlowCollection) {
  var preceding, following, captureStart, captureEnd, hasPendingContent, _line, _lineStart, _lineIndent, _kind = state.kind, _result = state.result, ch;
  ch = state.input.charCodeAt(state.position);
  if (is_WS_OR_EOL(ch) || is_FLOW_INDICATOR(ch) || ch === 35 || ch === 38 || ch === 42 || ch === 33 || ch === 124 || ch === 62 || ch === 39 || ch === 34 || ch === 37 || ch === 64 || ch === 96) {
    return false;
  }
  if (ch === 63 || ch === 45) {
    following = state.input.charCodeAt(state.position + 1);
    if (is_WS_OR_EOL(following) || withinFlowCollection && is_FLOW_INDICATOR(following)) {
      return false;
    }
  }
  state.kind = "scalar";
  state.result = "";
  captureStart = captureEnd = state.position;
  hasPendingContent = false;
  while (ch !== 0) {
    if (ch === 58) {
      following = state.input.charCodeAt(state.position + 1);
      if (is_WS_OR_EOL(following) || withinFlowCollection && is_FLOW_INDICATOR(following)) {
        break;
      }
    } else if (ch === 35) {
      preceding = state.input.charCodeAt(state.position - 1);
      if (is_WS_OR_EOL(preceding)) {
        break;
      }
    } else if (state.position === state.lineStart && testDocumentSeparator(state) || withinFlowCollection && is_FLOW_INDICATOR(ch)) {
      break;
    } else if (is_EOL(ch)) {
      _line = state.line;
      _lineStart = state.lineStart;
      _lineIndent = state.lineIndent;
      skipSeparationSpace(state, false, -1);
      if (state.lineIndent >= nodeIndent) {
        hasPendingContent = true;
        ch = state.input.charCodeAt(state.position);
        continue;
      } else {
        state.position = captureEnd;
        state.line = _line;
        state.lineStart = _lineStart;
        state.lineIndent = _lineIndent;
        break;
      }
    }
    if (hasPendingContent) {
      captureSegment(state, captureStart, captureEnd, false);
      writeFoldedLines(state, state.line - _line);
      captureStart = captureEnd = state.position;
      hasPendingContent = false;
    }
    if (!is_WHITE_SPACE(ch)) {
      captureEnd = state.position + 1;
    }
    ch = state.input.charCodeAt(++state.position);
  }
  captureSegment(state, captureStart, captureEnd, false);
  if (state.result) {
    return true;
  }
  state.kind = _kind;
  state.result = _result;
  return false;
}
__name(readPlainScalar, "readPlainScalar");
function readSingleQuotedScalar(state, nodeIndent) {
  var ch, captureStart, captureEnd;
  ch = state.input.charCodeAt(state.position);
  if (ch !== 39) {
    return false;
  }
  state.kind = "scalar";
  state.result = "";
  state.position++;
  captureStart = captureEnd = state.position;
  while ((ch = state.input.charCodeAt(state.position)) !== 0) {
    if (ch === 39) {
      captureSegment(state, captureStart, state.position, true);
      ch = state.input.charCodeAt(++state.position);
      if (ch === 39) {
        captureStart = state.position;
        state.position++;
        captureEnd = state.position;
      } else {
        return true;
      }
    } else if (is_EOL(ch)) {
      captureSegment(state, captureStart, captureEnd, true);
      writeFoldedLines(state, skipSeparationSpace(state, false, nodeIndent));
      captureStart = captureEnd = state.position;
    } else if (state.position === state.lineStart && testDocumentSeparator(state)) {
      throwError(state, "unexpected end of the document within a single quoted scalar");
    } else {
      state.position++;
      captureEnd = state.position;
    }
  }
  throwError(state, "unexpected end of the stream within a single quoted scalar");
}
__name(readSingleQuotedScalar, "readSingleQuotedScalar");
function readDoubleQuotedScalar(state, nodeIndent) {
  var captureStart, captureEnd, hexLength, hexResult, tmp, ch;
  ch = state.input.charCodeAt(state.position);
  if (ch !== 34) {
    return false;
  }
  state.kind = "scalar";
  state.result = "";
  state.position++;
  captureStart = captureEnd = state.position;
  while ((ch = state.input.charCodeAt(state.position)) !== 0) {
    if (ch === 34) {
      captureSegment(state, captureStart, state.position, true);
      state.position++;
      return true;
    } else if (ch === 92) {
      captureSegment(state, captureStart, state.position, true);
      ch = state.input.charCodeAt(++state.position);
      if (is_EOL(ch)) {
        skipSeparationSpace(state, false, nodeIndent);
      } else if (ch < 256 && simpleEscapeCheck[ch]) {
        state.result += simpleEscapeMap[ch];
        state.position++;
      } else if ((tmp = escapedHexLen(ch)) > 0) {
        hexLength = tmp;
        hexResult = 0;
        for (; hexLength > 0; hexLength--) {
          ch = state.input.charCodeAt(++state.position);
          if ((tmp = fromHexCode(ch)) >= 0) {
            hexResult = (hexResult << 4) + tmp;
          } else {
            throwError(state, "expected hexadecimal character");
          }
        }
        state.result += charFromCodepoint(hexResult);
        state.position++;
      } else {
        throwError(state, "unknown escape sequence");
      }
      captureStart = captureEnd = state.position;
    } else if (is_EOL(ch)) {
      captureSegment(state, captureStart, captureEnd, true);
      writeFoldedLines(state, skipSeparationSpace(state, false, nodeIndent));
      captureStart = captureEnd = state.position;
    } else if (state.position === state.lineStart && testDocumentSeparator(state)) {
      throwError(state, "unexpected end of the document within a double quoted scalar");
    } else {
      state.position++;
      captureEnd = state.position;
    }
  }
  throwError(state, "unexpected end of the stream within a double quoted scalar");
}
__name(readDoubleQuotedScalar, "readDoubleQuotedScalar");
function readFlowCollection(state, nodeIndent) {
  var readNext = true, _line, _lineStart, _pos, _tag = state.tag, _result, _anchor = state.anchor, following, terminator, isPair, isExplicitPair, isMapping, overridableKeys = /* @__PURE__ */ Object.create(null), keyNode, keyTag, valueNode, ch;
  ch = state.input.charCodeAt(state.position);
  if (ch === 91) {
    terminator = 93;
    isMapping = false;
    _result = [];
  } else if (ch === 123) {
    terminator = 125;
    isMapping = true;
    _result = {};
  } else {
    return false;
  }
  if (state.anchor !== null) {
    state.anchorMap[state.anchor] = _result;
  }
  ch = state.input.charCodeAt(++state.position);
  while (ch !== 0) {
    skipSeparationSpace(state, true, nodeIndent);
    ch = state.input.charCodeAt(state.position);
    if (ch === terminator) {
      state.position++;
      state.tag = _tag;
      state.anchor = _anchor;
      state.kind = isMapping ? "mapping" : "sequence";
      state.result = _result;
      return true;
    } else if (!readNext) {
      throwError(state, "missed comma between flow collection entries");
    } else if (ch === 44) {
      throwError(state, "expected the node content, but found ','");
    }
    keyTag = keyNode = valueNode = null;
    isPair = isExplicitPair = false;
    if (ch === 63) {
      following = state.input.charCodeAt(state.position + 1);
      if (is_WS_OR_EOL(following)) {
        isPair = isExplicitPair = true;
        state.position++;
        skipSeparationSpace(state, true, nodeIndent);
      }
    }
    _line = state.line;
    _lineStart = state.lineStart;
    _pos = state.position;
    composeNode(state, nodeIndent, CONTEXT_FLOW_IN, false, true);
    keyTag = state.tag;
    keyNode = state.result;
    skipSeparationSpace(state, true, nodeIndent);
    ch = state.input.charCodeAt(state.position);
    if ((isExplicitPair || state.line === _line) && ch === 58) {
      isPair = true;
      ch = state.input.charCodeAt(++state.position);
      skipSeparationSpace(state, true, nodeIndent);
      composeNode(state, nodeIndent, CONTEXT_FLOW_IN, false, true);
      valueNode = state.result;
    }
    if (isMapping) {
      storeMappingPair(state, _result, overridableKeys, keyTag, keyNode, valueNode, _line, _lineStart, _pos);
    } else if (isPair) {
      _result.push(storeMappingPair(state, null, overridableKeys, keyTag, keyNode, valueNode, _line, _lineStart, _pos));
    } else {
      _result.push(keyNode);
    }
    skipSeparationSpace(state, true, nodeIndent);
    ch = state.input.charCodeAt(state.position);
    if (ch === 44) {
      readNext = true;
      ch = state.input.charCodeAt(++state.position);
    } else {
      readNext = false;
    }
  }
  throwError(state, "unexpected end of the stream within a flow collection");
}
__name(readFlowCollection, "readFlowCollection");
function readBlockScalar(state, nodeIndent) {
  var captureStart, folding, chomping = CHOMPING_CLIP, didReadContent = false, detectedIndent = false, textIndent = nodeIndent, emptyLines = 0, atMoreIndented = false, tmp, ch;
  ch = state.input.charCodeAt(state.position);
  if (ch === 124) {
    folding = false;
  } else if (ch === 62) {
    folding = true;
  } else {
    return false;
  }
  state.kind = "scalar";
  state.result = "";
  while (ch !== 0) {
    ch = state.input.charCodeAt(++state.position);
    if (ch === 43 || ch === 45) {
      if (CHOMPING_CLIP === chomping) {
        chomping = ch === 43 ? CHOMPING_KEEP : CHOMPING_STRIP;
      } else {
        throwError(state, "repeat of a chomping mode identifier");
      }
    } else if ((tmp = fromDecimalCode(ch)) >= 0) {
      if (tmp === 0) {
        throwError(state, "bad explicit indentation width of a block scalar; it cannot be less than one");
      } else if (!detectedIndent) {
        textIndent = nodeIndent + tmp - 1;
        detectedIndent = true;
      } else {
        throwError(state, "repeat of an indentation width identifier");
      }
    } else {
      break;
    }
  }
  if (is_WHITE_SPACE(ch)) {
    do {
      ch = state.input.charCodeAt(++state.position);
    } while (is_WHITE_SPACE(ch));
    if (ch === 35) {
      do {
        ch = state.input.charCodeAt(++state.position);
      } while (!is_EOL(ch) && ch !== 0);
    }
  }
  while (ch !== 0) {
    readLineBreak(state);
    state.lineIndent = 0;
    ch = state.input.charCodeAt(state.position);
    while ((!detectedIndent || state.lineIndent < textIndent) && ch === 32) {
      state.lineIndent++;
      ch = state.input.charCodeAt(++state.position);
    }
    if (!detectedIndent && state.lineIndent > textIndent) {
      textIndent = state.lineIndent;
    }
    if (is_EOL(ch)) {
      emptyLines++;
      continue;
    }
    if (state.lineIndent < textIndent) {
      if (chomping === CHOMPING_KEEP) {
        state.result += common.repeat("\n", didReadContent ? 1 + emptyLines : emptyLines);
      } else if (chomping === CHOMPING_CLIP) {
        if (didReadContent) {
          state.result += "\n";
        }
      }
      break;
    }
    if (folding) {
      if (is_WHITE_SPACE(ch)) {
        atMoreIndented = true;
        state.result += common.repeat("\n", didReadContent ? 1 + emptyLines : emptyLines);
      } else if (atMoreIndented) {
        atMoreIndented = false;
        state.result += common.repeat("\n", emptyLines + 1);
      } else if (emptyLines === 0) {
        if (didReadContent) {
          state.result += " ";
        }
      } else {
        state.result += common.repeat("\n", emptyLines);
      }
    } else {
      state.result += common.repeat("\n", didReadContent ? 1 + emptyLines : emptyLines);
    }
    didReadContent = true;
    detectedIndent = true;
    emptyLines = 0;
    captureStart = state.position;
    while (!is_EOL(ch) && ch !== 0) {
      ch = state.input.charCodeAt(++state.position);
    }
    captureSegment(state, captureStart, state.position, false);
  }
  return true;
}
__name(readBlockScalar, "readBlockScalar");
function readBlockSequence(state, nodeIndent) {
  var _line, _tag = state.tag, _anchor = state.anchor, _result = [], following, detected = false, ch;
  if (state.firstTabInLine !== -1) return false;
  if (state.anchor !== null) {
    state.anchorMap[state.anchor] = _result;
  }
  ch = state.input.charCodeAt(state.position);
  while (ch !== 0) {
    if (state.firstTabInLine !== -1) {
      state.position = state.firstTabInLine;
      throwError(state, "tab characters must not be used in indentation");
    }
    if (ch !== 45) {
      break;
    }
    following = state.input.charCodeAt(state.position + 1);
    if (!is_WS_OR_EOL(following)) {
      break;
    }
    detected = true;
    state.position++;
    if (skipSeparationSpace(state, true, -1)) {
      if (state.lineIndent <= nodeIndent) {
        _result.push(null);
        ch = state.input.charCodeAt(state.position);
        continue;
      }
    }
    _line = state.line;
    composeNode(state, nodeIndent, CONTEXT_BLOCK_IN, false, true);
    _result.push(state.result);
    skipSeparationSpace(state, true, -1);
    ch = state.input.charCodeAt(state.position);
    if ((state.line === _line || state.lineIndent > nodeIndent) && ch !== 0) {
      throwError(state, "bad indentation of a sequence entry");
    } else if (state.lineIndent < nodeIndent) {
      break;
    }
  }
  if (detected) {
    state.tag = _tag;
    state.anchor = _anchor;
    state.kind = "sequence";
    state.result = _result;
    return true;
  }
  return false;
}
__name(readBlockSequence, "readBlockSequence");
function readBlockMapping(state, nodeIndent, flowIndent) {
  var following, allowCompact, _line, _keyLine, _keyLineStart, _keyPos, _tag = state.tag, _anchor = state.anchor, _result = {}, overridableKeys = /* @__PURE__ */ Object.create(null), keyTag = null, keyNode = null, valueNode = null, atExplicitKey = false, detected = false, ch;
  if (state.firstTabInLine !== -1) return false;
  if (state.anchor !== null) {
    state.anchorMap[state.anchor] = _result;
  }
  ch = state.input.charCodeAt(state.position);
  while (ch !== 0) {
    if (!atExplicitKey && state.firstTabInLine !== -1) {
      state.position = state.firstTabInLine;
      throwError(state, "tab characters must not be used in indentation");
    }
    following = state.input.charCodeAt(state.position + 1);
    _line = state.line;
    if ((ch === 63 || ch === 58) && is_WS_OR_EOL(following)) {
      if (ch === 63) {
        if (atExplicitKey) {
          storeMappingPair(state, _result, overridableKeys, keyTag, keyNode, null, _keyLine, _keyLineStart, _keyPos);
          keyTag = keyNode = valueNode = null;
        }
        detected = true;
        atExplicitKey = true;
        allowCompact = true;
      } else if (atExplicitKey) {
        atExplicitKey = false;
        allowCompact = true;
      } else {
        throwError(state, "incomplete explicit mapping pair; a key node is missed; or followed by a non-tabulated empty line");
      }
      state.position += 1;
      ch = following;
    } else {
      _keyLine = state.line;
      _keyLineStart = state.lineStart;
      _keyPos = state.position;
      if (!composeNode(state, flowIndent, CONTEXT_FLOW_OUT, false, true)) {
        break;
      }
      if (state.line === _line) {
        ch = state.input.charCodeAt(state.position);
        while (is_WHITE_SPACE(ch)) {
          ch = state.input.charCodeAt(++state.position);
        }
        if (ch === 58) {
          ch = state.input.charCodeAt(++state.position);
          if (!is_WS_OR_EOL(ch)) {
            throwError(state, "a whitespace character is expected after the key-value separator within a block mapping");
          }
          if (atExplicitKey) {
            storeMappingPair(state, _result, overridableKeys, keyTag, keyNode, null, _keyLine, _keyLineStart, _keyPos);
            keyTag = keyNode = valueNode = null;
          }
          detected = true;
          atExplicitKey = false;
          allowCompact = false;
          keyTag = state.tag;
          keyNode = state.result;
        } else if (detected) {
          throwError(state, "can not read an implicit mapping pair; a colon is missed");
        } else {
          state.tag = _tag;
          state.anchor = _anchor;
          return true;
        }
      } else if (detected) {
        throwError(state, "can not read a block mapping entry; a multiline key may not be an implicit key");
      } else {
        state.tag = _tag;
        state.anchor = _anchor;
        return true;
      }
    }
    if (state.line === _line || state.lineIndent > nodeIndent) {
      if (atExplicitKey) {
        _keyLine = state.line;
        _keyLineStart = state.lineStart;
        _keyPos = state.position;
      }
      if (composeNode(state, nodeIndent, CONTEXT_BLOCK_OUT, true, allowCompact)) {
        if (atExplicitKey) {
          keyNode = state.result;
        } else {
          valueNode = state.result;
        }
      }
      if (!atExplicitKey) {
        storeMappingPair(state, _result, overridableKeys, keyTag, keyNode, valueNode, _keyLine, _keyLineStart, _keyPos);
        keyTag = keyNode = valueNode = null;
      }
      skipSeparationSpace(state, true, -1);
      ch = state.input.charCodeAt(state.position);
    }
    if ((state.line === _line || state.lineIndent > nodeIndent) && ch !== 0) {
      throwError(state, "bad indentation of a mapping entry");
    } else if (state.lineIndent < nodeIndent) {
      break;
    }
  }
  if (atExplicitKey) {
    storeMappingPair(state, _result, overridableKeys, keyTag, keyNode, null, _keyLine, _keyLineStart, _keyPos);
  }
  if (detected) {
    state.tag = _tag;
    state.anchor = _anchor;
    state.kind = "mapping";
    state.result = _result;
  }
  return detected;
}
__name(readBlockMapping, "readBlockMapping");
function readTagProperty(state) {
  var _position, isVerbatim = false, isNamed = false, tagHandle, tagName, ch;
  ch = state.input.charCodeAt(state.position);
  if (ch !== 33) return false;
  if (state.tag !== null) {
    throwError(state, "duplication of a tag property");
  }
  ch = state.input.charCodeAt(++state.position);
  if (ch === 60) {
    isVerbatim = true;
    ch = state.input.charCodeAt(++state.position);
  } else if (ch === 33) {
    isNamed = true;
    tagHandle = "!!";
    ch = state.input.charCodeAt(++state.position);
  } else {
    tagHandle = "!";
  }
  _position = state.position;
  if (isVerbatim) {
    do {
      ch = state.input.charCodeAt(++state.position);
    } while (ch !== 0 && ch !== 62);
    if (state.position < state.length) {
      tagName = state.input.slice(_position, state.position);
      ch = state.input.charCodeAt(++state.position);
    } else {
      throwError(state, "unexpected end of the stream within a verbatim tag");
    }
  } else {
    while (ch !== 0 && !is_WS_OR_EOL(ch)) {
      if (ch === 33) {
        if (!isNamed) {
          tagHandle = state.input.slice(_position - 1, state.position + 1);
          if (!PATTERN_TAG_HANDLE.test(tagHandle)) {
            throwError(state, "named tag handle cannot contain such characters");
          }
          isNamed = true;
          _position = state.position + 1;
        } else {
          throwError(state, "tag suffix cannot contain exclamation marks");
        }
      }
      ch = state.input.charCodeAt(++state.position);
    }
    tagName = state.input.slice(_position, state.position);
    if (PATTERN_FLOW_INDICATORS.test(tagName)) {
      throwError(state, "tag suffix cannot contain flow indicator characters");
    }
  }
  if (tagName && !PATTERN_TAG_URI.test(tagName)) {
    throwError(state, "tag name cannot contain such characters: " + tagName);
  }
  try {
    tagName = decodeURIComponent(tagName);
  } catch (err) {
    throwError(state, "tag name is malformed: " + tagName);
  }
  if (isVerbatim) {
    state.tag = tagName;
  } else if (_hasOwnProperty$1.call(state.tagMap, tagHandle)) {
    state.tag = state.tagMap[tagHandle] + tagName;
  } else if (tagHandle === "!") {
    state.tag = "!" + tagName;
  } else if (tagHandle === "!!") {
    state.tag = "tag:yaml.org,2002:" + tagName;
  } else {
    throwError(state, 'undeclared tag handle "' + tagHandle + '"');
  }
  return true;
}
__name(readTagProperty, "readTagProperty");
function readAnchorProperty(state) {
  var _position, ch;
  ch = state.input.charCodeAt(state.position);
  if (ch !== 38) return false;
  if (state.anchor !== null) {
    throwError(state, "duplication of an anchor property");
  }
  ch = state.input.charCodeAt(++state.position);
  _position = state.position;
  while (ch !== 0 && !is_WS_OR_EOL(ch) && !is_FLOW_INDICATOR(ch)) {
    ch = state.input.charCodeAt(++state.position);
  }
  if (state.position === _position) {
    throwError(state, "name of an anchor node must contain at least one character");
  }
  state.anchor = state.input.slice(_position, state.position);
  return true;
}
__name(readAnchorProperty, "readAnchorProperty");
function readAlias(state) {
  var _position, alias, ch;
  ch = state.input.charCodeAt(state.position);
  if (ch !== 42) return false;
  ch = state.input.charCodeAt(++state.position);
  _position = state.position;
  while (ch !== 0 && !is_WS_OR_EOL(ch) && !is_FLOW_INDICATOR(ch)) {
    ch = state.input.charCodeAt(++state.position);
  }
  if (state.position === _position) {
    throwError(state, "name of an alias node must contain at least one character");
  }
  alias = state.input.slice(_position, state.position);
  if (!_hasOwnProperty$1.call(state.anchorMap, alias)) {
    throwError(state, 'unidentified alias "' + alias + '"');
  }
  state.result = state.anchorMap[alias];
  skipSeparationSpace(state, true, -1);
  return true;
}
__name(readAlias, "readAlias");
function composeNode(state, parentIndent, nodeContext, allowToSeek, allowCompact) {
  var allowBlockStyles, allowBlockScalars, allowBlockCollections, indentStatus = 1, atNewLine = false, hasContent = false, typeIndex, typeQuantity, typeList, type2, flowIndent, blockIndent;
  if (state.listener !== null) {
    state.listener("open", state);
  }
  state.tag = null;
  state.anchor = null;
  state.kind = null;
  state.result = null;
  allowBlockStyles = allowBlockScalars = allowBlockCollections = CONTEXT_BLOCK_OUT === nodeContext || CONTEXT_BLOCK_IN === nodeContext;
  if (allowToSeek) {
    if (skipSeparationSpace(state, true, -1)) {
      atNewLine = true;
      if (state.lineIndent > parentIndent) {
        indentStatus = 1;
      } else if (state.lineIndent === parentIndent) {
        indentStatus = 0;
      } else if (state.lineIndent < parentIndent) {
        indentStatus = -1;
      }
    }
  }
  if (indentStatus === 1) {
    while (readTagProperty(state) || readAnchorProperty(state)) {
      if (skipSeparationSpace(state, true, -1)) {
        atNewLine = true;
        allowBlockCollections = allowBlockStyles;
        if (state.lineIndent > parentIndent) {
          indentStatus = 1;
        } else if (state.lineIndent === parentIndent) {
          indentStatus = 0;
        } else if (state.lineIndent < parentIndent) {
          indentStatus = -1;
        }
      } else {
        allowBlockCollections = false;
      }
    }
  }
  if (allowBlockCollections) {
    allowBlockCollections = atNewLine || allowCompact;
  }
  if (indentStatus === 1 || CONTEXT_BLOCK_OUT === nodeContext) {
    if (CONTEXT_FLOW_IN === nodeContext || CONTEXT_FLOW_OUT === nodeContext) {
      flowIndent = parentIndent;
    } else {
      flowIndent = parentIndent + 1;
    }
    blockIndent = state.position - state.lineStart;
    if (indentStatus === 1) {
      if (allowBlockCollections && (readBlockSequence(state, blockIndent) || readBlockMapping(state, blockIndent, flowIndent)) || readFlowCollection(state, flowIndent)) {
        hasContent = true;
      } else {
        if (allowBlockScalars && readBlockScalar(state, flowIndent) || readSingleQuotedScalar(state, flowIndent) || readDoubleQuotedScalar(state, flowIndent)) {
          hasContent = true;
        } else if (readAlias(state)) {
          hasContent = true;
          if (state.tag !== null || state.anchor !== null) {
            throwError(state, "alias node should not have any properties");
          }
        } else if (readPlainScalar(state, flowIndent, CONTEXT_FLOW_IN === nodeContext)) {
          hasContent = true;
          if (state.tag === null) {
            state.tag = "?";
          }
        }
        if (state.anchor !== null) {
          state.anchorMap[state.anchor] = state.result;
        }
      }
    } else if (indentStatus === 0) {
      hasContent = allowBlockCollections && readBlockSequence(state, blockIndent);
    }
  }
  if (state.tag === null) {
    if (state.anchor !== null) {
      state.anchorMap[state.anchor] = state.result;
    }
  } else if (state.tag === "?") {
    if (state.result !== null && state.kind !== "scalar") {
      throwError(state, 'unacceptable node kind for !<?> tag; it should be "scalar", not "' + state.kind + '"');
    }
    for (typeIndex = 0, typeQuantity = state.implicitTypes.length; typeIndex < typeQuantity; typeIndex += 1) {
      type2 = state.implicitTypes[typeIndex];
      if (type2.resolve(state.result)) {
        state.result = type2.construct(state.result);
        state.tag = type2.tag;
        if (state.anchor !== null) {
          state.anchorMap[state.anchor] = state.result;
        }
        break;
      }
    }
  } else if (state.tag !== "!") {
    if (_hasOwnProperty$1.call(state.typeMap[state.kind || "fallback"], state.tag)) {
      type2 = state.typeMap[state.kind || "fallback"][state.tag];
    } else {
      type2 = null;
      typeList = state.typeMap.multi[state.kind || "fallback"];
      for (typeIndex = 0, typeQuantity = typeList.length; typeIndex < typeQuantity; typeIndex += 1) {
        if (state.tag.slice(0, typeList[typeIndex].tag.length) === typeList[typeIndex].tag) {
          type2 = typeList[typeIndex];
          break;
        }
      }
    }
    if (!type2) {
      throwError(state, "unknown tag !<" + state.tag + ">");
    }
    if (state.result !== null && type2.kind !== state.kind) {
      throwError(state, "unacceptable node kind for !<" + state.tag + '> tag; it should be "' + type2.kind + '", not "' + state.kind + '"');
    }
    if (!type2.resolve(state.result, state.tag)) {
      throwError(state, "cannot resolve a node with !<" + state.tag + "> explicit tag");
    } else {
      state.result = type2.construct(state.result, state.tag);
      if (state.anchor !== null) {
        state.anchorMap[state.anchor] = state.result;
      }
    }
  }
  if (state.listener !== null) {
    state.listener("close", state);
  }
  return state.tag !== null || state.anchor !== null || hasContent;
}
__name(composeNode, "composeNode");
function readDocument(state) {
  var documentStart = state.position, _position, directiveName, directiveArgs, hasDirectives = false, ch;
  state.version = null;
  state.checkLineBreaks = state.legacy;
  state.tagMap = /* @__PURE__ */ Object.create(null);
  state.anchorMap = /* @__PURE__ */ Object.create(null);
  while ((ch = state.input.charCodeAt(state.position)) !== 0) {
    skipSeparationSpace(state, true, -1);
    ch = state.input.charCodeAt(state.position);
    if (state.lineIndent > 0 || ch !== 37) {
      break;
    }
    hasDirectives = true;
    ch = state.input.charCodeAt(++state.position);
    _position = state.position;
    while (ch !== 0 && !is_WS_OR_EOL(ch)) {
      ch = state.input.charCodeAt(++state.position);
    }
    directiveName = state.input.slice(_position, state.position);
    directiveArgs = [];
    if (directiveName.length < 1) {
      throwError(state, "directive name must not be less than one character in length");
    }
    while (ch !== 0) {
      while (is_WHITE_SPACE(ch)) {
        ch = state.input.charCodeAt(++state.position);
      }
      if (ch === 35) {
        do {
          ch = state.input.charCodeAt(++state.position);
        } while (ch !== 0 && !is_EOL(ch));
        break;
      }
      if (is_EOL(ch)) break;
      _position = state.position;
      while (ch !== 0 && !is_WS_OR_EOL(ch)) {
        ch = state.input.charCodeAt(++state.position);
      }
      directiveArgs.push(state.input.slice(_position, state.position));
    }
    if (ch !== 0) readLineBreak(state);
    if (_hasOwnProperty$1.call(directiveHandlers, directiveName)) {
      directiveHandlers[directiveName](state, directiveName, directiveArgs);
    } else {
      throwWarning(state, 'unknown document directive "' + directiveName + '"');
    }
  }
  skipSeparationSpace(state, true, -1);
  if (state.lineIndent === 0 && state.input.charCodeAt(state.position) === 45 && state.input.charCodeAt(state.position + 1) === 45 && state.input.charCodeAt(state.position + 2) === 45) {
    state.position += 3;
    skipSeparationSpace(state, true, -1);
  } else if (hasDirectives) {
    throwError(state, "directives end mark is expected");
  }
  composeNode(state, state.lineIndent - 1, CONTEXT_BLOCK_OUT, false, true);
  skipSeparationSpace(state, true, -1);
  if (state.checkLineBreaks && PATTERN_NON_ASCII_LINE_BREAKS.test(state.input.slice(documentStart, state.position))) {
    throwWarning(state, "non-ASCII line breaks are interpreted as content");
  }
  state.documents.push(state.result);
  if (state.position === state.lineStart && testDocumentSeparator(state)) {
    if (state.input.charCodeAt(state.position) === 46) {
      state.position += 3;
      skipSeparationSpace(state, true, -1);
    }
    return;
  }
  if (state.position < state.length - 1) {
    throwError(state, "end of the stream or a document separator is expected");
  } else {
    return;
  }
}
__name(readDocument, "readDocument");
function loadDocuments(input, options) {
  input = String(input);
  options = options || {};
  if (input.length !== 0) {
    if (input.charCodeAt(input.length - 1) !== 10 && input.charCodeAt(input.length - 1) !== 13) {
      input += "\n";
    }
    if (input.charCodeAt(0) === 65279) {
      input = input.slice(1);
    }
  }
  var state = new State$1(input, options);
  var nullpos = input.indexOf("\0");
  if (nullpos !== -1) {
    state.position = nullpos;
    throwError(state, "null byte is not allowed in input");
  }
  state.input += "\0";
  while (state.input.charCodeAt(state.position) === 32) {
    state.lineIndent += 1;
    state.position += 1;
  }
  while (state.position < state.length - 1) {
    readDocument(state);
  }
  return state.documents;
}
__name(loadDocuments, "loadDocuments");
function loadAll$1(input, iterator, options) {
  if (iterator !== null && typeof iterator === "object" && typeof options === "undefined") {
    options = iterator;
    iterator = null;
  }
  var documents = loadDocuments(input, options);
  if (typeof iterator !== "function") {
    return documents;
  }
  for (var index = 0, length = documents.length; index < length; index += 1) {
    iterator(documents[index]);
  }
}
__name(loadAll$1, "loadAll$1");
function load$1(input, options) {
  var documents = loadDocuments(input, options);
  if (documents.length === 0) {
    return void 0;
  } else if (documents.length === 1) {
    return documents[0];
  }
  throw new exception("expected a single document in the stream, but found more");
}
__name(load$1, "load$1");
var load_1 = load$1;
var loader$1 = {
  load: load_1
};
var _toString = Object.prototype.toString;
var _hasOwnProperty = Object.prototype.hasOwnProperty;
var CHAR_BOM = 65279;
var CHAR_TAB = 9;
var CHAR_LINE_FEED = 10;
var CHAR_CARRIAGE_RETURN = 13;
var CHAR_SPACE = 32;
var CHAR_EXCLAMATION = 33;
var CHAR_DOUBLE_QUOTE = 34;
var CHAR_SHARP = 35;
var CHAR_PERCENT = 37;
var CHAR_AMPERSAND = 38;
var CHAR_SINGLE_QUOTE = 39;
var CHAR_ASTERISK = 42;
var CHAR_COMMA = 44;
var CHAR_MINUS = 45;
var CHAR_COLON = 58;
var CHAR_EQUALS = 61;
var CHAR_GREATER_THAN = 62;
var CHAR_QUESTION = 63;
var CHAR_COMMERCIAL_AT = 64;
var CHAR_LEFT_SQUARE_BRACKET = 91;
var CHAR_RIGHT_SQUARE_BRACKET = 93;
var CHAR_GRAVE_ACCENT = 96;
var CHAR_LEFT_CURLY_BRACKET = 123;
var CHAR_VERTICAL_LINE = 124;
var CHAR_RIGHT_CURLY_BRACKET = 125;
var ESCAPE_SEQUENCES = {};
ESCAPE_SEQUENCES[0] = "\\0";
ESCAPE_SEQUENCES[7] = "\\a";
ESCAPE_SEQUENCES[8] = "\\b";
ESCAPE_SEQUENCES[9] = "\\t";
ESCAPE_SEQUENCES[10] = "\\n";
ESCAPE_SEQUENCES[11] = "\\v";
ESCAPE_SEQUENCES[12] = "\\f";
ESCAPE_SEQUENCES[13] = "\\r";
ESCAPE_SEQUENCES[27] = "\\e";
ESCAPE_SEQUENCES[34] = '\\"';
ESCAPE_SEQUENCES[92] = "\\\\";
ESCAPE_SEQUENCES[133] = "\\N";
ESCAPE_SEQUENCES[160] = "\\_";
ESCAPE_SEQUENCES[8232] = "\\L";
ESCAPE_SEQUENCES[8233] = "\\P";
var DEPRECATED_BOOLEANS_SYNTAX = [
  "y",
  "Y",
  "yes",
  "Yes",
  "YES",
  "on",
  "On",
  "ON",
  "n",
  "N",
  "no",
  "No",
  "NO",
  "off",
  "Off",
  "OFF"
];
var DEPRECATED_BASE60_SYNTAX = /^[-+]?[0-9_]+(?::[0-9_]+)+(?:\.[0-9_]*)?$/;
function compileStyleMap(schema2, map2) {
  var result, keys, index, length, tag, style, type2;
  if (map2 === null) return {};
  result = {};
  keys = Object.keys(map2);
  for (index = 0, length = keys.length; index < length; index += 1) {
    tag = keys[index];
    style = String(map2[tag]);
    if (tag.slice(0, 2) === "!!") {
      tag = "tag:yaml.org,2002:" + tag.slice(2);
    }
    type2 = schema2.compiledTypeMap["fallback"][tag];
    if (type2 && _hasOwnProperty.call(type2.styleAliases, style)) {
      style = type2.styleAliases[style];
    }
    result[tag] = style;
  }
  return result;
}
__name(compileStyleMap, "compileStyleMap");
function encodeHex(character) {
  var string, handle, length;
  string = character.toString(16).toUpperCase();
  if (character <= 255) {
    handle = "x";
    length = 2;
  } else if (character <= 65535) {
    handle = "u";
    length = 4;
  } else if (character <= 4294967295) {
    handle = "U";
    length = 8;
  } else {
    throw new exception("code point within a string may not be greater than 0xFFFFFFFF");
  }
  return "\\" + handle + common.repeat("0", length - string.length) + string;
}
__name(encodeHex, "encodeHex");
var QUOTING_TYPE_SINGLE = 1;
var QUOTING_TYPE_DOUBLE = 2;
function State(options) {
  this.schema = options["schema"] || _default;
  this.indent = Math.max(1, options["indent"] || 2);
  this.noArrayIndent = options["noArrayIndent"] || false;
  this.skipInvalid = options["skipInvalid"] || false;
  this.flowLevel = common.isNothing(options["flowLevel"]) ? -1 : options["flowLevel"];
  this.styleMap = compileStyleMap(this.schema, options["styles"] || null);
  this.sortKeys = options["sortKeys"] || false;
  this.lineWidth = options["lineWidth"] || 80;
  this.noRefs = options["noRefs"] || false;
  this.noCompatMode = options["noCompatMode"] || false;
  this.condenseFlow = options["condenseFlow"] || false;
  this.quotingType = options["quotingType"] === '"' ? QUOTING_TYPE_DOUBLE : QUOTING_TYPE_SINGLE;
  this.forceQuotes = options["forceQuotes"] || false;
  this.replacer = typeof options["replacer"] === "function" ? options["replacer"] : null;
  this.implicitTypes = this.schema.compiledImplicit;
  this.explicitTypes = this.schema.compiledExplicit;
  this.tag = null;
  this.result = "";
  this.duplicates = [];
  this.usedDuplicates = null;
}
__name(State, "State");
function indentString(string, spaces) {
  var ind = common.repeat(" ", spaces), position = 0, next = -1, result = "", line, length = string.length;
  while (position < length) {
    next = string.indexOf("\n", position);
    if (next === -1) {
      line = string.slice(position);
      position = length;
    } else {
      line = string.slice(position, next + 1);
      position = next + 1;
    }
    if (line.length && line !== "\n") result += ind;
    result += line;
  }
  return result;
}
__name(indentString, "indentString");
function generateNextLine(state, level) {
  return "\n" + common.repeat(" ", state.indent * level);
}
__name(generateNextLine, "generateNextLine");
function testImplicitResolving(state, str2) {
  var index, length, type2;
  for (index = 0, length = state.implicitTypes.length; index < length; index += 1) {
    type2 = state.implicitTypes[index];
    if (type2.resolve(str2)) {
      return true;
    }
  }
  return false;
}
__name(testImplicitResolving, "testImplicitResolving");
function isWhitespace(c) {
  return c === CHAR_SPACE || c === CHAR_TAB;
}
__name(isWhitespace, "isWhitespace");
function isPrintable(c) {
  return 32 <= c && c <= 126 || 161 <= c && c <= 55295 && c !== 8232 && c !== 8233 || 57344 <= c && c <= 65533 && c !== CHAR_BOM || 65536 <= c && c <= 1114111;
}
__name(isPrintable, "isPrintable");
function isNsCharOrWhitespace(c) {
  return isPrintable(c) && c !== CHAR_BOM && c !== CHAR_CARRIAGE_RETURN && c !== CHAR_LINE_FEED;
}
__name(isNsCharOrWhitespace, "isNsCharOrWhitespace");
function isPlainSafe(c, prev, inblock) {
  var cIsNsCharOrWhitespace = isNsCharOrWhitespace(c);
  var cIsNsChar = cIsNsCharOrWhitespace && !isWhitespace(c);
  return (
    // ns-plain-safe
    (inblock ? (
      // c = flow-in
      cIsNsCharOrWhitespace
    ) : cIsNsCharOrWhitespace && c !== CHAR_COMMA && c !== CHAR_LEFT_SQUARE_BRACKET && c !== CHAR_RIGHT_SQUARE_BRACKET && c !== CHAR_LEFT_CURLY_BRACKET && c !== CHAR_RIGHT_CURLY_BRACKET) && c !== CHAR_SHARP && !(prev === CHAR_COLON && !cIsNsChar) || isNsCharOrWhitespace(prev) && !isWhitespace(prev) && c === CHAR_SHARP || prev === CHAR_COLON && cIsNsChar
  );
}
__name(isPlainSafe, "isPlainSafe");
function isPlainSafeFirst(c) {
  return isPrintable(c) && c !== CHAR_BOM && !isWhitespace(c) && c !== CHAR_MINUS && c !== CHAR_QUESTION && c !== CHAR_COLON && c !== CHAR_COMMA && c !== CHAR_LEFT_SQUARE_BRACKET && c !== CHAR_RIGHT_SQUARE_BRACKET && c !== CHAR_LEFT_CURLY_BRACKET && c !== CHAR_RIGHT_CURLY_BRACKET && c !== CHAR_SHARP && c !== CHAR_AMPERSAND && c !== CHAR_ASTERISK && c !== CHAR_EXCLAMATION && c !== CHAR_VERTICAL_LINE && c !== CHAR_EQUALS && c !== CHAR_GREATER_THAN && c !== CHAR_SINGLE_QUOTE && c !== CHAR_DOUBLE_QUOTE && c !== CHAR_PERCENT && c !== CHAR_COMMERCIAL_AT && c !== CHAR_GRAVE_ACCENT;
}
__name(isPlainSafeFirst, "isPlainSafeFirst");
function isPlainSafeLast(c) {
  return !isWhitespace(c) && c !== CHAR_COLON;
}
__name(isPlainSafeLast, "isPlainSafeLast");
function codePointAt(string, pos) {
  var first = string.charCodeAt(pos), second;
  if (first >= 55296 && first <= 56319 && pos + 1 < string.length) {
    second = string.charCodeAt(pos + 1);
    if (second >= 56320 && second <= 57343) {
      return (first - 55296) * 1024 + second - 56320 + 65536;
    }
  }
  return first;
}
__name(codePointAt, "codePointAt");
function needIndentIndicator(string) {
  var leadingSpaceRe = /^\n* /;
  return leadingSpaceRe.test(string);
}
__name(needIndentIndicator, "needIndentIndicator");
var STYLE_PLAIN = 1;
var STYLE_SINGLE = 2;
var STYLE_LITERAL = 3;
var STYLE_FOLDED = 4;
var STYLE_DOUBLE = 5;
function chooseScalarStyle(string, singleLineOnly, indentPerLevel, lineWidth, testAmbiguousType, quotingType, forceQuotes, inblock) {
  var i;
  var char = 0;
  var prevChar = null;
  var hasLineBreak = false;
  var hasFoldableLine = false;
  var shouldTrackWidth = lineWidth !== -1;
  var previousLineBreak = -1;
  var plain = isPlainSafeFirst(codePointAt(string, 0)) && isPlainSafeLast(codePointAt(string, string.length - 1));
  if (singleLineOnly || forceQuotes) {
    for (i = 0; i < string.length; char >= 65536 ? i += 2 : i++) {
      char = codePointAt(string, i);
      if (!isPrintable(char)) {
        return STYLE_DOUBLE;
      }
      plain = plain && isPlainSafe(char, prevChar, inblock);
      prevChar = char;
    }
  } else {
    for (i = 0; i < string.length; char >= 65536 ? i += 2 : i++) {
      char = codePointAt(string, i);
      if (char === CHAR_LINE_FEED) {
        hasLineBreak = true;
        if (shouldTrackWidth) {
          hasFoldableLine = hasFoldableLine || // Foldable line = too long, and not more-indented.
          i - previousLineBreak - 1 > lineWidth && string[previousLineBreak + 1] !== " ";
          previousLineBreak = i;
        }
      } else if (!isPrintable(char)) {
        return STYLE_DOUBLE;
      }
      plain = plain && isPlainSafe(char, prevChar, inblock);
      prevChar = char;
    }
    hasFoldableLine = hasFoldableLine || shouldTrackWidth && (i - previousLineBreak - 1 > lineWidth && string[previousLineBreak + 1] !== " ");
  }
  if (!hasLineBreak && !hasFoldableLine) {
    if (plain && !forceQuotes && !testAmbiguousType(string)) {
      return STYLE_PLAIN;
    }
    return quotingType === QUOTING_TYPE_DOUBLE ? STYLE_DOUBLE : STYLE_SINGLE;
  }
  if (indentPerLevel > 9 && needIndentIndicator(string)) {
    return STYLE_DOUBLE;
  }
  if (!forceQuotes) {
    return hasFoldableLine ? STYLE_FOLDED : STYLE_LITERAL;
  }
  return quotingType === QUOTING_TYPE_DOUBLE ? STYLE_DOUBLE : STYLE_SINGLE;
}
__name(chooseScalarStyle, "chooseScalarStyle");
function writeScalar(state, string, level, iskey, inblock) {
  state.dump = function() {
    if (string.length === 0) {
      return state.quotingType === QUOTING_TYPE_DOUBLE ? '""' : "''";
    }
    if (!state.noCompatMode) {
      if (DEPRECATED_BOOLEANS_SYNTAX.indexOf(string) !== -1 || DEPRECATED_BASE60_SYNTAX.test(string)) {
        return state.quotingType === QUOTING_TYPE_DOUBLE ? '"' + string + '"' : "'" + string + "'";
      }
    }
    var indent = state.indent * Math.max(1, level);
    var lineWidth = state.lineWidth === -1 ? -1 : Math.max(Math.min(state.lineWidth, 40), state.lineWidth - indent);
    var singleLineOnly = iskey || state.flowLevel > -1 && level >= state.flowLevel;
    function testAmbiguity(string2) {
      return testImplicitResolving(state, string2);
    }
    __name(testAmbiguity, "testAmbiguity");
    switch (chooseScalarStyle(
      string,
      singleLineOnly,
      state.indent,
      lineWidth,
      testAmbiguity,
      state.quotingType,
      state.forceQuotes && !iskey,
      inblock
    )) {
      case STYLE_PLAIN:
        return string;
      case STYLE_SINGLE:
        return "'" + string.replace(/'/g, "''") + "'";
      case STYLE_LITERAL:
        return "|" + blockHeader(string, state.indent) + dropEndingNewline(indentString(string, indent));
      case STYLE_FOLDED:
        return ">" + blockHeader(string, state.indent) + dropEndingNewline(indentString(foldString(string, lineWidth), indent));
      case STYLE_DOUBLE:
        return '"' + escapeString(string) + '"';
      default:
        throw new exception("impossible error: invalid scalar style");
    }
  }();
}
__name(writeScalar, "writeScalar");
function blockHeader(string, indentPerLevel) {
  var indentIndicator = needIndentIndicator(string) ? String(indentPerLevel) : "";
  var clip = string[string.length - 1] === "\n";
  var keep = clip && (string[string.length - 2] === "\n" || string === "\n");
  var chomp = keep ? "+" : clip ? "" : "-";
  return indentIndicator + chomp + "\n";
}
__name(blockHeader, "blockHeader");
function dropEndingNewline(string) {
  return string[string.length - 1] === "\n" ? string.slice(0, -1) : string;
}
__name(dropEndingNewline, "dropEndingNewline");
function foldString(string, width) {
  var lineRe = /(\n+)([^\n]*)/g;
  var result = function() {
    var nextLF = string.indexOf("\n");
    nextLF = nextLF !== -1 ? nextLF : string.length;
    lineRe.lastIndex = nextLF;
    return foldLine(string.slice(0, nextLF), width);
  }();
  var prevMoreIndented = string[0] === "\n" || string[0] === " ";
  var moreIndented;
  var match;
  while (match = lineRe.exec(string)) {
    var prefix = match[1], line = match[2];
    moreIndented = line[0] === " ";
    result += prefix + (!prevMoreIndented && !moreIndented && line !== "" ? "\n" : "") + foldLine(line, width);
    prevMoreIndented = moreIndented;
  }
  return result;
}
__name(foldString, "foldString");
function foldLine(line, width) {
  if (line === "" || line[0] === " ") return line;
  var breakRe = / [^ ]/g;
  var match;
  var start = 0, end, curr = 0, next = 0;
  var result = "";
  while (match = breakRe.exec(line)) {
    next = match.index;
    if (next - start > width) {
      end = curr > start ? curr : next;
      result += "\n" + line.slice(start, end);
      start = end + 1;
    }
    curr = next;
  }
  result += "\n";
  if (line.length - start > width && curr > start) {
    result += line.slice(start, curr) + "\n" + line.slice(curr + 1);
  } else {
    result += line.slice(start);
  }
  return result.slice(1);
}
__name(foldLine, "foldLine");
function escapeString(string) {
  var result = "";
  var char = 0;
  var escapeSeq;
  for (var i = 0; i < string.length; char >= 65536 ? i += 2 : i++) {
    char = codePointAt(string, i);
    escapeSeq = ESCAPE_SEQUENCES[char];
    if (!escapeSeq && isPrintable(char)) {
      result += string[i];
      if (char >= 65536) result += string[i + 1];
    } else {
      result += escapeSeq || encodeHex(char);
    }
  }
  return result;
}
__name(escapeString, "escapeString");
function writeFlowSequence(state, level, object) {
  var _result = "", _tag = state.tag, index, length, value;
  for (index = 0, length = object.length; index < length; index += 1) {
    value = object[index];
    if (state.replacer) {
      value = state.replacer.call(object, String(index), value);
    }
    if (writeNode(state, level, value, false, false) || typeof value === "undefined" && writeNode(state, level, null, false, false)) {
      if (_result !== "") _result += "," + (!state.condenseFlow ? " " : "");
      _result += state.dump;
    }
  }
  state.tag = _tag;
  state.dump = "[" + _result + "]";
}
__name(writeFlowSequence, "writeFlowSequence");
function writeBlockSequence(state, level, object, compact) {
  var _result = "", _tag = state.tag, index, length, value;
  for (index = 0, length = object.length; index < length; index += 1) {
    value = object[index];
    if (state.replacer) {
      value = state.replacer.call(object, String(index), value);
    }
    if (writeNode(state, level + 1, value, true, true, false, true) || typeof value === "undefined" && writeNode(state, level + 1, null, true, true, false, true)) {
      if (!compact || _result !== "") {
        _result += generateNextLine(state, level);
      }
      if (state.dump && CHAR_LINE_FEED === state.dump.charCodeAt(0)) {
        _result += "-";
      } else {
        _result += "- ";
      }
      _result += state.dump;
    }
  }
  state.tag = _tag;
  state.dump = _result || "[]";
}
__name(writeBlockSequence, "writeBlockSequence");
function writeFlowMapping(state, level, object) {
  var _result = "", _tag = state.tag, objectKeyList = Object.keys(object), index, length, objectKey, objectValue, pairBuffer;
  for (index = 0, length = objectKeyList.length; index < length; index += 1) {
    pairBuffer = "";
    if (_result !== "") pairBuffer += ", ";
    if (state.condenseFlow) pairBuffer += '"';
    objectKey = objectKeyList[index];
    objectValue = object[objectKey];
    if (state.replacer) {
      objectValue = state.replacer.call(object, objectKey, objectValue);
    }
    if (!writeNode(state, level, objectKey, false, false)) {
      continue;
    }
    if (state.dump.length > 1024) pairBuffer += "? ";
    pairBuffer += state.dump + (state.condenseFlow ? '"' : "") + ":" + (state.condenseFlow ? "" : " ");
    if (!writeNode(state, level, objectValue, false, false)) {
      continue;
    }
    pairBuffer += state.dump;
    _result += pairBuffer;
  }
  state.tag = _tag;
  state.dump = "{" + _result + "}";
}
__name(writeFlowMapping, "writeFlowMapping");
function writeBlockMapping(state, level, object, compact) {
  var _result = "", _tag = state.tag, objectKeyList = Object.keys(object), index, length, objectKey, objectValue, explicitPair, pairBuffer;
  if (state.sortKeys === true) {
    objectKeyList.sort();
  } else if (typeof state.sortKeys === "function") {
    objectKeyList.sort(state.sortKeys);
  } else if (state.sortKeys) {
    throw new exception("sortKeys must be a boolean or a function");
  }
  for (index = 0, length = objectKeyList.length; index < length; index += 1) {
    pairBuffer = "";
    if (!compact || _result !== "") {
      pairBuffer += generateNextLine(state, level);
    }
    objectKey = objectKeyList[index];
    objectValue = object[objectKey];
    if (state.replacer) {
      objectValue = state.replacer.call(object, objectKey, objectValue);
    }
    if (!writeNode(state, level + 1, objectKey, true, true, true)) {
      continue;
    }
    explicitPair = state.tag !== null && state.tag !== "?" || state.dump && state.dump.length > 1024;
    if (explicitPair) {
      if (state.dump && CHAR_LINE_FEED === state.dump.charCodeAt(0)) {
        pairBuffer += "?";
      } else {
        pairBuffer += "? ";
      }
    }
    pairBuffer += state.dump;
    if (explicitPair) {
      pairBuffer += generateNextLine(state, level);
    }
    if (!writeNode(state, level + 1, objectValue, true, explicitPair)) {
      continue;
    }
    if (state.dump && CHAR_LINE_FEED === state.dump.charCodeAt(0)) {
      pairBuffer += ":";
    } else {
      pairBuffer += ": ";
    }
    pairBuffer += state.dump;
    _result += pairBuffer;
  }
  state.tag = _tag;
  state.dump = _result || "{}";
}
__name(writeBlockMapping, "writeBlockMapping");
function detectType(state, object, explicit) {
  var _result, typeList, index, length, type2, style;
  typeList = explicit ? state.explicitTypes : state.implicitTypes;
  for (index = 0, length = typeList.length; index < length; index += 1) {
    type2 = typeList[index];
    if ((type2.instanceOf || type2.predicate) && (!type2.instanceOf || typeof object === "object" && object instanceof type2.instanceOf) && (!type2.predicate || type2.predicate(object))) {
      if (explicit) {
        if (type2.multi && type2.representName) {
          state.tag = type2.representName(object);
        } else {
          state.tag = type2.tag;
        }
      } else {
        state.tag = "?";
      }
      if (type2.represent) {
        style = state.styleMap[type2.tag] || type2.defaultStyle;
        if (_toString.call(type2.represent) === "[object Function]") {
          _result = type2.represent(object, style);
        } else if (_hasOwnProperty.call(type2.represent, style)) {
          _result = type2.represent[style](object, style);
        } else {
          throw new exception("!<" + type2.tag + '> tag resolver accepts not "' + style + '" style');
        }
        state.dump = _result;
      }
      return true;
    }
  }
  return false;
}
__name(detectType, "detectType");
function writeNode(state, level, object, block, compact, iskey, isblockseq) {
  state.tag = null;
  state.dump = object;
  if (!detectType(state, object, false)) {
    detectType(state, object, true);
  }
  var type2 = _toString.call(state.dump);
  var inblock = block;
  var tagStr;
  if (block) {
    block = state.flowLevel < 0 || state.flowLevel > level;
  }
  var objectOrArray = type2 === "[object Object]" || type2 === "[object Array]", duplicateIndex, duplicate;
  if (objectOrArray) {
    duplicateIndex = state.duplicates.indexOf(object);
    duplicate = duplicateIndex !== -1;
  }
  if (state.tag !== null && state.tag !== "?" || duplicate || state.indent !== 2 && level > 0) {
    compact = false;
  }
  if (duplicate && state.usedDuplicates[duplicateIndex]) {
    state.dump = "*ref_" + duplicateIndex;
  } else {
    if (objectOrArray && duplicate && !state.usedDuplicates[duplicateIndex]) {
      state.usedDuplicates[duplicateIndex] = true;
    }
    if (type2 === "[object Object]") {
      if (block && Object.keys(state.dump).length !== 0) {
        writeBlockMapping(state, level, state.dump, compact);
        if (duplicate) {
          state.dump = "&ref_" + duplicateIndex + state.dump;
        }
      } else {
        writeFlowMapping(state, level, state.dump);
        if (duplicate) {
          state.dump = "&ref_" + duplicateIndex + " " + state.dump;
        }
      }
    } else if (type2 === "[object Array]") {
      if (block && state.dump.length !== 0) {
        if (state.noArrayIndent && !isblockseq && level > 0) {
          writeBlockSequence(state, level - 1, state.dump, compact);
        } else {
          writeBlockSequence(state, level, state.dump, compact);
        }
        if (duplicate) {
          state.dump = "&ref_" + duplicateIndex + state.dump;
        }
      } else {
        writeFlowSequence(state, level, state.dump);
        if (duplicate) {
          state.dump = "&ref_" + duplicateIndex + " " + state.dump;
        }
      }
    } else if (type2 === "[object String]") {
      if (state.tag !== "?") {
        writeScalar(state, state.dump, level, iskey, inblock);
      }
    } else if (type2 === "[object Undefined]") {
      return false;
    } else {
      if (state.skipInvalid) return false;
      throw new exception("unacceptable kind of an object to dump " + type2);
    }
    if (state.tag !== null && state.tag !== "?") {
      tagStr = encodeURI(
        state.tag[0] === "!" ? state.tag.slice(1) : state.tag
      ).replace(/!/g, "%21");
      if (state.tag[0] === "!") {
        tagStr = "!" + tagStr;
      } else if (tagStr.slice(0, 18) === "tag:yaml.org,2002:") {
        tagStr = "!!" + tagStr.slice(18);
      } else {
        tagStr = "!<" + tagStr + ">";
      }
      state.dump = tagStr + " " + state.dump;
    }
  }
  return true;
}
__name(writeNode, "writeNode");
function getDuplicateReferences(object, state) {
  var objects = [], duplicatesIndexes = [], index, length;
  inspectNode(object, objects, duplicatesIndexes);
  for (index = 0, length = duplicatesIndexes.length; index < length; index += 1) {
    state.duplicates.push(objects[duplicatesIndexes[index]]);
  }
  state.usedDuplicates = new Array(length);
}
__name(getDuplicateReferences, "getDuplicateReferences");
function inspectNode(object, objects, duplicatesIndexes) {
  var objectKeyList, index, length;
  if (object !== null && typeof object === "object") {
    index = objects.indexOf(object);
    if (index !== -1) {
      if (duplicatesIndexes.indexOf(index) === -1) {
        duplicatesIndexes.push(index);
      }
    } else {
      objects.push(object);
      if (Array.isArray(object)) {
        for (index = 0, length = object.length; index < length; index += 1) {
          inspectNode(object[index], objects, duplicatesIndexes);
        }
      } else {
        objectKeyList = Object.keys(object);
        for (index = 0, length = objectKeyList.length; index < length; index += 1) {
          inspectNode(object[objectKeyList[index]], objects, duplicatesIndexes);
        }
      }
    }
  }
}
__name(inspectNode, "inspectNode");
function dump$1(input, options) {
  options = options || {};
  var state = new State(options);
  if (!state.noRefs) getDuplicateReferences(input, state);
  var value = input;
  if (state.replacer) {
    value = state.replacer.call({ "": value }, "", value);
  }
  if (writeNode(state, 0, value, true, true)) return state.dump + "\n";
  return "";
}
__name(dump$1, "dump$1");
function renamed(from, to) {
  return function() {
    throw new Error("Function yaml." + from + " is removed in js-yaml 4. Use yaml." + to + " instead, which is now safe by default.");
  };
}
__name(renamed, "renamed");
var JSON_SCHEMA = json;
var load = loader$1.load;
/*! Bundled license information:

js-yaml/dist/js-yaml.mjs:
  (*! js-yaml 4.1.0 https://github.com/nodeca/js-yaml @license MIT *)
*/

// src/utils/lineWithOffset.ts
var markerOffsets = {
  aggregation: 18,
  extension: 18,
  composition: 18,
  dependency: 6,
  lollipop: 13.5,
  arrow_point: 4
};
function calculateDeltaAndAngle(point1, point2) {
  if (point1 === void 0 || point2 === void 0) {
    return { angle: 0, deltaX: 0, deltaY: 0 };
  }
  point1 = pointTransformer(point1);
  point2 = pointTransformer(point2);
  const [x1, y1] = [point1.x, point1.y];
  const [x2, y2] = [point2.x, point2.y];
  const deltaX = x2 - x1;
  const deltaY = y2 - y1;
  return { angle: Math.atan(deltaY / deltaX), deltaX, deltaY };
}
__name(calculateDeltaAndAngle, "calculateDeltaAndAngle");
var pointTransformer = /* @__PURE__ */ __name((data) => {
  if (Array.isArray(data)) {
    return { x: data[0], y: data[1] };
  }
  return data;
}, "pointTransformer");
var getLineFunctionsWithOffset = /* @__PURE__ */ __name((edge) => {
  return {
    x: /* @__PURE__ */ __name(function(d, i, data) {
      let offset = 0;
      const DIRECTION = pointTransformer(data[0]).x < pointTransformer(data[data.length - 1]).x ? "left" : "right";
      if (i === 0 && Object.hasOwn(markerOffsets, edge.arrowTypeStart)) {
        const { angle, deltaX } = calculateDeltaAndAngle(data[0], data[1]);
        offset = markerOffsets[edge.arrowTypeStart] * Math.cos(angle) * (deltaX >= 0 ? 1 : -1);
      } else if (i === data.length - 1 && Object.hasOwn(markerOffsets, edge.arrowTypeEnd)) {
        const { angle, deltaX } = calculateDeltaAndAngle(
          data[data.length - 1],
          data[data.length - 2]
        );
        offset = markerOffsets[edge.arrowTypeEnd] * Math.cos(angle) * (deltaX >= 0 ? 1 : -1);
      }
      const differenceToEnd = Math.abs(
        pointTransformer(d).x - pointTransformer(data[data.length - 1]).x
      );
      const differenceInYEnd = Math.abs(
        pointTransformer(d).y - pointTransformer(data[data.length - 1]).y
      );
      const differenceToStart = Math.abs(pointTransformer(d).x - pointTransformer(data[0]).x);
      const differenceInYStart = Math.abs(pointTransformer(d).y - pointTransformer(data[0]).y);
      const startMarkerHeight = markerOffsets[edge.arrowTypeStart];
      const endMarkerHeight = markerOffsets[edge.arrowTypeEnd];
      const extraRoom = 1;
      if (differenceToEnd < endMarkerHeight && differenceToEnd > 0 && differenceInYEnd < endMarkerHeight) {
        let adjustment = endMarkerHeight + extraRoom - differenceToEnd;
        adjustment *= DIRECTION === "right" ? -1 : 1;
        offset -= adjustment;
      }
      if (differenceToStart < startMarkerHeight && differenceToStart > 0 && differenceInYStart < startMarkerHeight) {
        let adjustment = startMarkerHeight + extraRoom - differenceToStart;
        adjustment *= DIRECTION === "right" ? -1 : 1;
        offset += adjustment;
      }
      return pointTransformer(d).x + offset;
    }, "x"),
    y: /* @__PURE__ */ __name(function(d, i, data) {
      let offset = 0;
      const DIRECTION = pointTransformer(data[0]).y < pointTransformer(data[data.length - 1]).y ? "down" : "up";
      if (i === 0 && Object.hasOwn(markerOffsets, edge.arrowTypeStart)) {
        const { angle, deltaY } = calculateDeltaAndAngle(data[0], data[1]);
        offset = markerOffsets[edge.arrowTypeStart] * Math.abs(Math.sin(angle)) * (deltaY >= 0 ? 1 : -1);
      } else if (i === data.length - 1 && Object.hasOwn(markerOffsets, edge.arrowTypeEnd)) {
        const { angle, deltaY } = calculateDeltaAndAngle(
          data[data.length - 1],
          data[data.length - 2]
        );
        offset = markerOffsets[edge.arrowTypeEnd] * Math.abs(Math.sin(angle)) * (deltaY >= 0 ? 1 : -1);
      }
      const differenceToEnd = Math.abs(
        pointTransformer(d).y - pointTransformer(data[data.length - 1]).y
      );
      const differenceInXEnd = Math.abs(
        pointTransformer(d).x - pointTransformer(data[data.length - 1]).x
      );
      const differenceToStart = Math.abs(pointTransformer(d).y - pointTransformer(data[0]).y);
      const differenceInXStart = Math.abs(pointTransformer(d).x - pointTransformer(data[0]).x);
      const startMarkerHeight = markerOffsets[edge.arrowTypeStart];
      const endMarkerHeight = markerOffsets[edge.arrowTypeEnd];
      const extraRoom = 1;
      if (differenceToEnd < endMarkerHeight && differenceToEnd > 0 && differenceInXEnd < endMarkerHeight) {
        let adjustment = endMarkerHeight + extraRoom - differenceToEnd;
        adjustment *= DIRECTION === "up" ? -1 : 1;
        offset -= adjustment;
      }
      if (differenceToStart < startMarkerHeight && differenceToStart > 0 && differenceInXStart < startMarkerHeight) {
        let adjustment = startMarkerHeight + extraRoom - differenceToStart;
        adjustment *= DIRECTION === "up" ? -1 : 1;
        offset += adjustment;
      }
      return pointTransformer(d).y + offset;
    }, "y")
  };
}, "getLineFunctionsWithOffset");

// src/utils/subGraphTitleMargins.ts
var getSubGraphTitleMargins = /* @__PURE__ */ __name(({
  flowchart
}) => {
  const subGraphTitleTopMargin = flowchart?.subGraphTitleMargin?.top ?? 0;
  const subGraphTitleBottomMargin = flowchart?.subGraphTitleMargin?.bottom ?? 0;
  const subGraphTitleTotalMargin = subGraphTitleTopMargin + subGraphTitleBottomMargin;
  return {
    subGraphTitleTopMargin,
    subGraphTitleBottomMargin,
    subGraphTitleTotalMargin
  };
}, "getSubGraphTitleMargins");

// src/rendering-util/rendering-elements/shapes/handDrawnShapeStyles.ts
var solidStateFill = /* @__PURE__ */ __name((color) => {
  const { handDrawnSeed } = getConfig2();
  return {
    fill: color,
    hachureAngle: 120,
    // angle of hachure,
    hachureGap: 4,
    fillWeight: 2,
    roughness: 0.7,
    stroke: color,
    seed: handDrawnSeed
  };
}, "solidStateFill");
var compileStyles = /* @__PURE__ */ __name((node) => {
  const stylesMap = styles2Map([...node.cssCompiledStyles || [], ...node.cssStyles || []]);
  return { stylesMap, stylesArray: [...stylesMap] };
}, "compileStyles");
var styles2Map = /* @__PURE__ */ __name((styles) => {
  const styleMap = /* @__PURE__ */ new Map();
  styles.forEach((style) => {
    const [key, value] = style.split(":");
    styleMap.set(key.trim(), value?.trim());
  });
  return styleMap;
}, "styles2Map");
var isLabelStyle = /* @__PURE__ */ __name((key) => {
  return key === "color" || key === "font-size" || key === "font-family" || key === "font-weight" || key === "font-style" || key === "text-decoration" || key === "text-align" || key === "text-transform" || key === "line-height" || key === "letter-spacing" || key === "word-spacing" || key === "text-shadow" || key === "text-overflow" || key === "white-space" || key === "word-wrap" || key === "word-break" || key === "overflow-wrap" || key === "hyphens";
}, "isLabelStyle");
var styles2String = /* @__PURE__ */ __name((node) => {
  const { stylesArray } = compileStyles(node);
  const labelStyles = [];
  const nodeStyles = [];
  const borderStyles = [];
  const backgroundStyles = [];
  stylesArray.forEach((style) => {
    const key = style[0];
    if (isLabelStyle(key)) {
      labelStyles.push(style.join(":") + " !important");
    } else {
      nodeStyles.push(style.join(":") + " !important");
      if (key.includes("stroke")) {
        borderStyles.push(style.join(":") + " !important");
      }
      if (key === "fill") {
        backgroundStyles.push(style.join(":") + " !important");
      }
    }
  });
  return {
    labelStyles: labelStyles.join(";"),
    nodeStyles: nodeStyles.join(";"),
    stylesArray,
    borderStyles,
    backgroundStyles
  };
}, "styles2String");
var userNodeOverrides = /* @__PURE__ */ __name((node, options) => {
  const { themeVariables, handDrawnSeed } = getConfig2();
  const { nodeBorder, mainBkg } = themeVariables;
  const { stylesMap } = compileStyles(node);
  const result = Object.assign(
    {
      roughness: 0.7,
      fill: stylesMap.get("fill") || mainBkg,
      fillStyle: "hachure",
      // solid fill
      fillWeight: 4,
      hachureGap: 5.2,
      stroke: stylesMap.get("stroke") || nodeBorder,
      seed: handDrawnSeed,
      strokeWidth: stylesMap.get("stroke-width")?.replace("px", "") || 1.3,
      fillLineDash: [0, 0],
      strokeLineDash: getStrokeDashArray(stylesMap.get("stroke-dasharray"))
    },
    options
  );
  return result;
}, "userNodeOverrides");
var getStrokeDashArray = /* @__PURE__ */ __name((strokeDasharrayStyle) => {
  if (!strokeDasharrayStyle) {
    return [0, 0];
  }
  const dashArray = strokeDasharrayStyle.trim().split(/\s+/).map(Number);
  if (dashArray.length === 1) {
    const val = isNaN(dashArray[0]) ? 0 : dashArray[0];
    return [val, val];
  }
  const first = isNaN(dashArray[0]) ? 0 : dashArray[0];
  const second = isNaN(dashArray[1]) ? 0 : dashArray[1];
  return [first, second];
}, "getStrokeDashArray");

var dist = {};

var constants = {};

var hasRequiredConstants;

function requireConstants () {
	if (hasRequiredConstants) return constants;
	hasRequiredConstants = 1;
	Object.defineProperty(constants, "__esModule", { value: true });
	constants.BLANK_URL = constants.relativeFirstCharacters = constants.whitespaceEscapeCharsRegex = constants.urlSchemeRegex = constants.ctrlCharactersRegex = constants.htmlCtrlEntityRegex = constants.htmlEntitiesRegex = constants.invalidProtocolRegex = void 0;
	constants.invalidProtocolRegex = /^([^\w]*)(javascript|data|vbscript)/im;
	constants.htmlEntitiesRegex = /&#(\w+)(^\w|;)?/g;
	constants.htmlCtrlEntityRegex = /&(newline|tab);/gi;
	constants.ctrlCharactersRegex = /[\u0000-\u001F\u007F-\u009F\u2000-\u200D\uFEFF]/gim;
	constants.urlSchemeRegex = /^.+(:|&colon;)/gim;
	constants.whitespaceEscapeCharsRegex = /(\\|%5[cC])((%(6[eE]|72|74))|[nrt])/g;
	constants.relativeFirstCharacters = [".", "/"];
	constants.BLANK_URL = "about:blank";
	return constants;
}

var hasRequiredDist;

function requireDist () {
	if (hasRequiredDist) return dist;
	hasRequiredDist = 1;
	Object.defineProperty(dist, "__esModule", { value: true });
	dist.sanitizeUrl = void 0;
	var constants_1 = requireConstants();
	function isRelativeUrlWithoutProtocol(url) {
	    return constants_1.relativeFirstCharacters.indexOf(url[0]) > -1;
	}
	function decodeHtmlCharacters(str) {
	    var removedNullByte = str.replace(constants_1.ctrlCharactersRegex, "");
	    return removedNullByte.replace(constants_1.htmlEntitiesRegex, function (match, dec) {
	        return String.fromCharCode(dec);
	    });
	}
	function isValidUrl(url) {
	    return URL.canParse(url);
	}
	function decodeURI(uri) {
	    try {
	        return decodeURIComponent(uri);
	    }
	    catch (e) {
	        // Ignoring error
	        // It is possible that the URI contains a `%` not associated
	        // with URI/URL-encoding.
	        return uri;
	    }
	}
	function sanitizeUrl(url) {
	    if (!url) {
	        return constants_1.BLANK_URL;
	    }
	    var charsToDecode;
	    var decodedUrl = decodeURI(url.trim());
	    do {
	        decodedUrl = decodeHtmlCharacters(decodedUrl)
	            .replace(constants_1.htmlCtrlEntityRegex, "")
	            .replace(constants_1.ctrlCharactersRegex, "")
	            .replace(constants_1.whitespaceEscapeCharsRegex, "")
	            .trim();
	        decodedUrl = decodeURI(decodedUrl);
	        charsToDecode =
	            decodedUrl.match(constants_1.ctrlCharactersRegex) ||
	                decodedUrl.match(constants_1.htmlEntitiesRegex) ||
	                decodedUrl.match(constants_1.htmlCtrlEntityRegex) ||
	                decodedUrl.match(constants_1.whitespaceEscapeCharsRegex);
	    } while (charsToDecode && charsToDecode.length > 0);
	    var sanitizedUrl = decodedUrl;
	    if (!sanitizedUrl) {
	        return constants_1.BLANK_URL;
	    }
	    if (isRelativeUrlWithoutProtocol(sanitizedUrl)) {
	        return sanitizedUrl;
	    }
	    // Remove any leading whitespace before checking the URL scheme
	    var trimmedUrl = sanitizedUrl.trimStart();
	    var urlSchemeParseResults = trimmedUrl.match(constants_1.urlSchemeRegex);
	    if (!urlSchemeParseResults) {
	        return sanitizedUrl;
	    }
	    var urlScheme = urlSchemeParseResults[0].toLowerCase().trim();
	    if (constants_1.invalidProtocolRegex.test(urlScheme)) {
	        return constants_1.BLANK_URL;
	    }
	    var backSanitized = trimmedUrl.replace(/\\/g, "/");
	    // Handle special cases for mailto: and custom deep-link protocols
	    if (urlScheme === "mailto:" || urlScheme.includes("://")) {
	        return backSanitized;
	    }
	    // For http and https URLs, perform additional validation
	    if (urlScheme === "http:" || urlScheme === "https:") {
	        if (!isValidUrl(backSanitized)) {
	            return constants_1.BLANK_URL;
	        }
	        var url_1 = new URL(backSanitized);
	        url_1.protocol = url_1.protocol.toLowerCase();
	        url_1.hostname = url_1.hostname.toLowerCase();
	        return url_1.toString();
	    }
	    return backSanitized;
	}
	dist.sanitizeUrl = sanitizeUrl;
	return dist;
}

var distExports = requireDist();

var noop$1 = {value: () => {}};

function dispatch() {
  for (var i = 0, n = arguments.length, _ = {}, t; i < n; ++i) {
    if (!(t = arguments[i] + "") || (t in _) || /[\s.]/.test(t)) throw new Error("illegal type: " + t);
    _[t] = [];
  }
  return new Dispatch(_);
}

function Dispatch(_) {
  this._ = _;
}

function parseTypenames$1(typenames, types) {
  return typenames.trim().split(/^|\s+/).map(function(t) {
    var name = "", i = t.indexOf(".");
    if (i >= 0) name = t.slice(i + 1), t = t.slice(0, i);
    if (t && !types.hasOwnProperty(t)) throw new Error("unknown type: " + t);
    return {type: t, name: name};
  });
}

Dispatch.prototype = dispatch.prototype = {
  constructor: Dispatch,
  on: function(typename, callback) {
    var _ = this._,
        T = parseTypenames$1(typename + "", _),
        t,
        i = -1,
        n = T.length;

    // If no callback was specified, return the callback of the given type and name.
    if (arguments.length < 2) {
      while (++i < n) if ((t = (typename = T[i]).type) && (t = get$1(_[t], typename.name))) return t;
      return;
    }

    // If a type was specified, set the callback for the given type and name.
    // Otherwise, if a null callback was specified, remove callbacks of the given name.
    if (callback != null && typeof callback !== "function") throw new Error("invalid callback: " + callback);
    while (++i < n) {
      if (t = (typename = T[i]).type) _[t] = set$1(_[t], typename.name, callback);
      else if (callback == null) for (t in _) _[t] = set$1(_[t], typename.name, null);
    }

    return this;
  },
  copy: function() {
    var copy = {}, _ = this._;
    for (var t in _) copy[t] = _[t].slice();
    return new Dispatch(copy);
  },
  call: function(type, that) {
    if ((n = arguments.length - 2) > 0) for (var args = new Array(n), i = 0, n, t; i < n; ++i) args[i] = arguments[i + 2];
    if (!this._.hasOwnProperty(type)) throw new Error("unknown type: " + type);
    for (t = this._[type], i = 0, n = t.length; i < n; ++i) t[i].value.apply(that, args);
  },
  apply: function(type, that, args) {
    if (!this._.hasOwnProperty(type)) throw new Error("unknown type: " + type);
    for (var t = this._[type], i = 0, n = t.length; i < n; ++i) t[i].value.apply(that, args);
  }
};

function get$1(type, name) {
  for (var i = 0, n = type.length, c; i < n; ++i) {
    if ((c = type[i]).name === name) {
      return c.value;
    }
  }
}

function set$1(type, name, callback) {
  for (var i = 0, n = type.length; i < n; ++i) {
    if (type[i].name === name) {
      type[i] = noop$1, type = type.slice(0, i).concat(type.slice(i + 1));
      break;
    }
  }
  if (callback != null) type.push({name: name, value: callback});
  return type;
}

var xhtml = "http://www.w3.org/1999/xhtml";

const namespaces = {
  svg: "http://www.w3.org/2000/svg",
  xhtml: xhtml,
  xlink: "http://www.w3.org/1999/xlink",
  xml: "http://www.w3.org/XML/1998/namespace",
  xmlns: "http://www.w3.org/2000/xmlns/"
};

function namespace(name) {
  var prefix = name += "", i = prefix.indexOf(":");
  if (i >= 0 && (prefix = name.slice(0, i)) !== "xmlns") name = name.slice(i + 1);
  return namespaces.hasOwnProperty(prefix) ? {space: namespaces[prefix], local: name} : name; // eslint-disable-line no-prototype-builtins
}

function creatorInherit(name) {
  return function() {
    var document = this.ownerDocument,
        uri = this.namespaceURI;
    return uri === xhtml && document.documentElement.namespaceURI === xhtml
        ? document.createElement(name)
        : document.createElementNS(uri, name);
  };
}

function creatorFixed(fullname) {
  return function() {
    return this.ownerDocument.createElementNS(fullname.space, fullname.local);
  };
}

function creator(name) {
  var fullname = namespace(name);
  return (fullname.local
      ? creatorFixed
      : creatorInherit)(fullname);
}

function none() {}

function selector(selector) {
  return selector == null ? none : function() {
    return this.querySelector(selector);
  };
}

function selection_select(select) {
  if (typeof select !== "function") select = selector(select);

  for (var groups = this._groups, m = groups.length, subgroups = new Array(m), j = 0; j < m; ++j) {
    for (var group = groups[j], n = group.length, subgroup = subgroups[j] = new Array(n), node, subnode, i = 0; i < n; ++i) {
      if ((node = group[i]) && (subnode = select.call(node, node.__data__, i, group))) {
        if ("__data__" in node) subnode.__data__ = node.__data__;
        subgroup[i] = subnode;
      }
    }
  }

  return new Selection$1(subgroups, this._parents);
}

// Given something array like (or null), returns something that is strictly an
// array. This is used to ensure that array-like objects passed to d3.selectAll
// or selection.selectAll are converted into proper arrays when creating a
// selection; we don’t ever want to create a selection backed by a live
// HTMLCollection or NodeList. However, note that selection.selectAll will use a
// static NodeList as a group, since it safely derived from querySelectorAll.
function array$1(x) {
  return x == null ? [] : Array.isArray(x) ? x : Array.from(x);
}

function empty() {
  return [];
}

function selectorAll(selector) {
  return selector == null ? empty : function() {
    return this.querySelectorAll(selector);
  };
}

function arrayAll(select) {
  return function() {
    return array$1(select.apply(this, arguments));
  };
}

function selection_selectAll(select) {
  if (typeof select === "function") select = arrayAll(select);
  else select = selectorAll(select);

  for (var groups = this._groups, m = groups.length, subgroups = [], parents = [], j = 0; j < m; ++j) {
    for (var group = groups[j], n = group.length, node, i = 0; i < n; ++i) {
      if (node = group[i]) {
        subgroups.push(select.call(node, node.__data__, i, group));
        parents.push(node);
      }
    }
  }

  return new Selection$1(subgroups, parents);
}

function matcher(selector) {
  return function() {
    return this.matches(selector);
  };
}

function childMatcher(selector) {
  return function(node) {
    return node.matches(selector);
  };
}

var find = Array.prototype.find;

function childFind(match) {
  return function() {
    return find.call(this.children, match);
  };
}

function childFirst() {
  return this.firstElementChild;
}

function selection_selectChild(match) {
  return this.select(match == null ? childFirst
      : childFind(typeof match === "function" ? match : childMatcher(match)));
}

var filter = Array.prototype.filter;

function children() {
  return Array.from(this.children);
}

function childrenFilter(match) {
  return function() {
    return filter.call(this.children, match);
  };
}

function selection_selectChildren(match) {
  return this.selectAll(match == null ? children
      : childrenFilter(typeof match === "function" ? match : childMatcher(match)));
}

function selection_filter(match) {
  if (typeof match !== "function") match = matcher(match);

  for (var groups = this._groups, m = groups.length, subgroups = new Array(m), j = 0; j < m; ++j) {
    for (var group = groups[j], n = group.length, subgroup = subgroups[j] = [], node, i = 0; i < n; ++i) {
      if ((node = group[i]) && match.call(node, node.__data__, i, group)) {
        subgroup.push(node);
      }
    }
  }

  return new Selection$1(subgroups, this._parents);
}

function sparse(update) {
  return new Array(update.length);
}

function selection_enter() {
  return new Selection$1(this._enter || this._groups.map(sparse), this._parents);
}

function EnterNode(parent, datum) {
  this.ownerDocument = parent.ownerDocument;
  this.namespaceURI = parent.namespaceURI;
  this._next = null;
  this._parent = parent;
  this.__data__ = datum;
}

EnterNode.prototype = {
  constructor: EnterNode,
  appendChild: function(child) { return this._parent.insertBefore(child, this._next); },
  insertBefore: function(child, next) { return this._parent.insertBefore(child, next); },
  querySelector: function(selector) { return this._parent.querySelector(selector); },
  querySelectorAll: function(selector) { return this._parent.querySelectorAll(selector); }
};

function constant$3(x) {
  return function() {
    return x;
  };
}

function bindIndex(parent, group, enter, update, exit, data) {
  var i = 0,
      node,
      groupLength = group.length,
      dataLength = data.length;

  // Put any non-null nodes that fit into update.
  // Put any null nodes into enter.
  // Put any remaining data into enter.
  for (; i < dataLength; ++i) {
    if (node = group[i]) {
      node.__data__ = data[i];
      update[i] = node;
    } else {
      enter[i] = new EnterNode(parent, data[i]);
    }
  }

  // Put any non-null nodes that don’t fit into exit.
  for (; i < groupLength; ++i) {
    if (node = group[i]) {
      exit[i] = node;
    }
  }
}

function bindKey(parent, group, enter, update, exit, data, key) {
  var i,
      node,
      nodeByKeyValue = new Map,
      groupLength = group.length,
      dataLength = data.length,
      keyValues = new Array(groupLength),
      keyValue;

  // Compute the key for each node.
  // If multiple nodes have the same key, the duplicates are added to exit.
  for (i = 0; i < groupLength; ++i) {
    if (node = group[i]) {
      keyValues[i] = keyValue = key.call(node, node.__data__, i, group) + "";
      if (nodeByKeyValue.has(keyValue)) {
        exit[i] = node;
      } else {
        nodeByKeyValue.set(keyValue, node);
      }
    }
  }

  // Compute the key for each datum.
  // If there a node associated with this key, join and add it to update.
  // If there is not (or the key is a duplicate), add it to enter.
  for (i = 0; i < dataLength; ++i) {
    keyValue = key.call(parent, data[i], i, data) + "";
    if (node = nodeByKeyValue.get(keyValue)) {
      update[i] = node;
      node.__data__ = data[i];
      nodeByKeyValue.delete(keyValue);
    } else {
      enter[i] = new EnterNode(parent, data[i]);
    }
  }

  // Add any remaining nodes that were not bound to data to exit.
  for (i = 0; i < groupLength; ++i) {
    if ((node = group[i]) && (nodeByKeyValue.get(keyValues[i]) === node)) {
      exit[i] = node;
    }
  }
}

function datum(node) {
  return node.__data__;
}

function selection_data(value, key) {
  if (!arguments.length) return Array.from(this, datum);

  var bind = key ? bindKey : bindIndex,
      parents = this._parents,
      groups = this._groups;

  if (typeof value !== "function") value = constant$3(value);

  for (var m = groups.length, update = new Array(m), enter = new Array(m), exit = new Array(m), j = 0; j < m; ++j) {
    var parent = parents[j],
        group = groups[j],
        groupLength = group.length,
        data = arraylike(value.call(parent, parent && parent.__data__, j, parents)),
        dataLength = data.length,
        enterGroup = enter[j] = new Array(dataLength),
        updateGroup = update[j] = new Array(dataLength),
        exitGroup = exit[j] = new Array(groupLength);

    bind(parent, group, enterGroup, updateGroup, exitGroup, data, key);

    // Now connect the enter nodes to their following update node, such that
    // appendChild can insert the materialized enter node before this node,
    // rather than at the end of the parent node.
    for (var i0 = 0, i1 = 0, previous, next; i0 < dataLength; ++i0) {
      if (previous = enterGroup[i0]) {
        if (i0 >= i1) i1 = i0 + 1;
        while (!(next = updateGroup[i1]) && ++i1 < dataLength);
        previous._next = next || null;
      }
    }
  }

  update = new Selection$1(update, parents);
  update._enter = enter;
  update._exit = exit;
  return update;
}

// Given some data, this returns an array-like view of it: an object that
// exposes a length property and allows numeric indexing. Note that unlike
// selectAll, this isn’t worried about “live” collections because the resulting
// array will only be used briefly while data is being bound. (It is possible to
// cause the data to change while iterating by using a key function, but please
// don’t; we’d rather avoid a gratuitous copy.)
function arraylike(data) {
  return typeof data === "object" && "length" in data
    ? data // Array, TypedArray, NodeList, array-like
    : Array.from(data); // Map, Set, iterable, string, or anything else
}

function selection_exit() {
  return new Selection$1(this._exit || this._groups.map(sparse), this._parents);
}

function selection_join(onenter, onupdate, onexit) {
  var enter = this.enter(), update = this, exit = this.exit();
  if (typeof onenter === "function") {
    enter = onenter(enter);
    if (enter) enter = enter.selection();
  } else {
    enter = enter.append(onenter + "");
  }
  if (onupdate != null) {
    update = onupdate(update);
    if (update) update = update.selection();
  }
  if (onexit == null) exit.remove(); else onexit(exit);
  return enter && update ? enter.merge(update).order() : update;
}

function selection_merge(context) {
  var selection = context.selection ? context.selection() : context;

  for (var groups0 = this._groups, groups1 = selection._groups, m0 = groups0.length, m1 = groups1.length, m = Math.min(m0, m1), merges = new Array(m0), j = 0; j < m; ++j) {
    for (var group0 = groups0[j], group1 = groups1[j], n = group0.length, merge = merges[j] = new Array(n), node, i = 0; i < n; ++i) {
      if (node = group0[i] || group1[i]) {
        merge[i] = node;
      }
    }
  }

  for (; j < m0; ++j) {
    merges[j] = groups0[j];
  }

  return new Selection$1(merges, this._parents);
}

function selection_order() {

  for (var groups = this._groups, j = -1, m = groups.length; ++j < m;) {
    for (var group = groups[j], i = group.length - 1, next = group[i], node; --i >= 0;) {
      if (node = group[i]) {
        if (next && node.compareDocumentPosition(next) ^ 4) next.parentNode.insertBefore(node, next);
        next = node;
      }
    }
  }

  return this;
}

function selection_sort(compare) {
  if (!compare) compare = ascending;

  function compareNode(a, b) {
    return a && b ? compare(a.__data__, b.__data__) : !a - !b;
  }

  for (var groups = this._groups, m = groups.length, sortgroups = new Array(m), j = 0; j < m; ++j) {
    for (var group = groups[j], n = group.length, sortgroup = sortgroups[j] = new Array(n), node, i = 0; i < n; ++i) {
      if (node = group[i]) {
        sortgroup[i] = node;
      }
    }
    sortgroup.sort(compareNode);
  }

  return new Selection$1(sortgroups, this._parents).order();
}

function ascending(a, b) {
  return a < b ? -1 : a > b ? 1 : a >= b ? 0 : NaN;
}

function selection_call() {
  var callback = arguments[0];
  arguments[0] = this;
  callback.apply(null, arguments);
  return this;
}

function selection_nodes() {
  return Array.from(this);
}

function selection_node() {

  for (var groups = this._groups, j = 0, m = groups.length; j < m; ++j) {
    for (var group = groups[j], i = 0, n = group.length; i < n; ++i) {
      var node = group[i];
      if (node) return node;
    }
  }

  return null;
}

function selection_size() {
  let size = 0;
  for (const node of this) ++size; // eslint-disable-line no-unused-vars
  return size;
}

function selection_empty() {
  return !this.node();
}

function selection_each(callback) {

  for (var groups = this._groups, j = 0, m = groups.length; j < m; ++j) {
    for (var group = groups[j], i = 0, n = group.length, node; i < n; ++i) {
      if (node = group[i]) callback.call(node, node.__data__, i, group);
    }
  }

  return this;
}

function attrRemove$1(name) {
  return function() {
    this.removeAttribute(name);
  };
}

function attrRemoveNS$1(fullname) {
  return function() {
    this.removeAttributeNS(fullname.space, fullname.local);
  };
}

function attrConstant$1(name, value) {
  return function() {
    this.setAttribute(name, value);
  };
}

function attrConstantNS$1(fullname, value) {
  return function() {
    this.setAttributeNS(fullname.space, fullname.local, value);
  };
}

function attrFunction$1(name, value) {
  return function() {
    var v = value.apply(this, arguments);
    if (v == null) this.removeAttribute(name);
    else this.setAttribute(name, v);
  };
}

function attrFunctionNS$1(fullname, value) {
  return function() {
    var v = value.apply(this, arguments);
    if (v == null) this.removeAttributeNS(fullname.space, fullname.local);
    else this.setAttributeNS(fullname.space, fullname.local, v);
  };
}

function selection_attr(name, value) {
  var fullname = namespace(name);

  if (arguments.length < 2) {
    var node = this.node();
    return fullname.local
        ? node.getAttributeNS(fullname.space, fullname.local)
        : node.getAttribute(fullname);
  }

  return this.each((value == null
      ? (fullname.local ? attrRemoveNS$1 : attrRemove$1) : (typeof value === "function"
      ? (fullname.local ? attrFunctionNS$1 : attrFunction$1)
      : (fullname.local ? attrConstantNS$1 : attrConstant$1)))(fullname, value));
}

function defaultView(node) {
  return (node.ownerDocument && node.ownerDocument.defaultView) // node is a Node
      || (node.document && node) // node is a Window
      || node.defaultView; // node is a Document
}

function styleRemove$1(name) {
  return function() {
    this.style.removeProperty(name);
  };
}

function styleConstant$1(name, value, priority) {
  return function() {
    this.style.setProperty(name, value, priority);
  };
}

function styleFunction$1(name, value, priority) {
  return function() {
    var v = value.apply(this, arguments);
    if (v == null) this.style.removeProperty(name);
    else this.style.setProperty(name, v, priority);
  };
}

function selection_style(name, value, priority) {
  return arguments.length > 1
      ? this.each((value == null
            ? styleRemove$1 : typeof value === "function"
            ? styleFunction$1
            : styleConstant$1)(name, value, priority == null ? "" : priority))
      : styleValue(this.node(), name);
}

function styleValue(node, name) {
  return node.style.getPropertyValue(name)
      || defaultView(node).getComputedStyle(node, null).getPropertyValue(name);
}

function propertyRemove(name) {
  return function() {
    delete this[name];
  };
}

function propertyConstant(name, value) {
  return function() {
    this[name] = value;
  };
}

function propertyFunction(name, value) {
  return function() {
    var v = value.apply(this, arguments);
    if (v == null) delete this[name];
    else this[name] = v;
  };
}

function selection_property(name, value) {
  return arguments.length > 1
      ? this.each((value == null
          ? propertyRemove : typeof value === "function"
          ? propertyFunction
          : propertyConstant)(name, value))
      : this.node()[name];
}

function classArray(string) {
  return string.trim().split(/^|\s+/);
}

function classList(node) {
  return node.classList || new ClassList(node);
}

function ClassList(node) {
  this._node = node;
  this._names = classArray(node.getAttribute("class") || "");
}

ClassList.prototype = {
  add: function(name) {
    var i = this._names.indexOf(name);
    if (i < 0) {
      this._names.push(name);
      this._node.setAttribute("class", this._names.join(" "));
    }
  },
  remove: function(name) {
    var i = this._names.indexOf(name);
    if (i >= 0) {
      this._names.splice(i, 1);
      this._node.setAttribute("class", this._names.join(" "));
    }
  },
  contains: function(name) {
    return this._names.indexOf(name) >= 0;
  }
};

function classedAdd(node, names) {
  var list = classList(node), i = -1, n = names.length;
  while (++i < n) list.add(names[i]);
}

function classedRemove(node, names) {
  var list = classList(node), i = -1, n = names.length;
  while (++i < n) list.remove(names[i]);
}

function classedTrue(names) {
  return function() {
    classedAdd(this, names);
  };
}

function classedFalse(names) {
  return function() {
    classedRemove(this, names);
  };
}

function classedFunction(names, value) {
  return function() {
    (value.apply(this, arguments) ? classedAdd : classedRemove)(this, names);
  };
}

function selection_classed(name, value) {
  var names = classArray(name + "");

  if (arguments.length < 2) {
    var list = classList(this.node()), i = -1, n = names.length;
    while (++i < n) if (!list.contains(names[i])) return false;
    return true;
  }

  return this.each((typeof value === "function"
      ? classedFunction : value
      ? classedTrue
      : classedFalse)(names, value));
}

function textRemove() {
  this.textContent = "";
}

function textConstant$1(value) {
  return function() {
    this.textContent = value;
  };
}

function textFunction$1(value) {
  return function() {
    var v = value.apply(this, arguments);
    this.textContent = v == null ? "" : v;
  };
}

function selection_text(value) {
  return arguments.length
      ? this.each(value == null
          ? textRemove : (typeof value === "function"
          ? textFunction$1
          : textConstant$1)(value))
      : this.node().textContent;
}

function htmlRemove() {
  this.innerHTML = "";
}

function htmlConstant(value) {
  return function() {
    this.innerHTML = value;
  };
}

function htmlFunction(value) {
  return function() {
    var v = value.apply(this, arguments);
    this.innerHTML = v == null ? "" : v;
  };
}

function selection_html(value) {
  return arguments.length
      ? this.each(value == null
          ? htmlRemove : (typeof value === "function"
          ? htmlFunction
          : htmlConstant)(value))
      : this.node().innerHTML;
}

function raise() {
  if (this.nextSibling) this.parentNode.appendChild(this);
}

function selection_raise() {
  return this.each(raise);
}

function lower() {
  if (this.previousSibling) this.parentNode.insertBefore(this, this.parentNode.firstChild);
}

function selection_lower() {
  return this.each(lower);
}

function selection_append(name) {
  var create = typeof name === "function" ? name : creator(name);
  return this.select(function() {
    return this.appendChild(create.apply(this, arguments));
  });
}

function constantNull() {
  return null;
}

function selection_insert(name, before) {
  var create = typeof name === "function" ? name : creator(name),
      select = before == null ? constantNull : typeof before === "function" ? before : selector(before);
  return this.select(function() {
    return this.insertBefore(create.apply(this, arguments), select.apply(this, arguments) || null);
  });
}

function remove() {
  var parent = this.parentNode;
  if (parent) parent.removeChild(this);
}

function selection_remove() {
  return this.each(remove);
}

function selection_cloneShallow() {
  var clone = this.cloneNode(false), parent = this.parentNode;
  return parent ? parent.insertBefore(clone, this.nextSibling) : clone;
}

function selection_cloneDeep() {
  var clone = this.cloneNode(true), parent = this.parentNode;
  return parent ? parent.insertBefore(clone, this.nextSibling) : clone;
}

function selection_clone(deep) {
  return this.select(deep ? selection_cloneDeep : selection_cloneShallow);
}

function selection_datum(value) {
  return arguments.length
      ? this.property("__data__", value)
      : this.node().__data__;
}

function contextListener(listener) {
  return function(event) {
    listener.call(this, event, this.__data__);
  };
}

function parseTypenames(typenames) {
  return typenames.trim().split(/^|\s+/).map(function(t) {
    var name = "", i = t.indexOf(".");
    if (i >= 0) name = t.slice(i + 1), t = t.slice(0, i);
    return {type: t, name: name};
  });
}

function onRemove(typename) {
  return function() {
    var on = this.__on;
    if (!on) return;
    for (var j = 0, i = -1, m = on.length, o; j < m; ++j) {
      if (o = on[j], (!typename.type || o.type === typename.type) && o.name === typename.name) {
        this.removeEventListener(o.type, o.listener, o.options);
      } else {
        on[++i] = o;
      }
    }
    if (++i) on.length = i;
    else delete this.__on;
  };
}

function onAdd(typename, value, options) {
  return function() {
    var on = this.__on, o, listener = contextListener(value);
    if (on) for (var j = 0, m = on.length; j < m; ++j) {
      if ((o = on[j]).type === typename.type && o.name === typename.name) {
        this.removeEventListener(o.type, o.listener, o.options);
        this.addEventListener(o.type, o.listener = listener, o.options = options);
        o.value = value;
        return;
      }
    }
    this.addEventListener(typename.type, listener, options);
    o = {type: typename.type, name: typename.name, value: value, listener: listener, options: options};
    if (!on) this.__on = [o];
    else on.push(o);
  };
}

function selection_on(typename, value, options) {
  var typenames = parseTypenames(typename + ""), i, n = typenames.length, t;

  if (arguments.length < 2) {
    var on = this.node().__on;
    if (on) for (var j = 0, m = on.length, o; j < m; ++j) {
      for (i = 0, o = on[j]; i < n; ++i) {
        if ((t = typenames[i]).type === o.type && t.name === o.name) {
          return o.value;
        }
      }
    }
    return;
  }

  on = value ? onAdd : onRemove;
  for (i = 0; i < n; ++i) this.each(on(typenames[i], value, options));
  return this;
}

function dispatchEvent(node, type, params) {
  var window = defaultView(node),
      event = window.CustomEvent;

  if (typeof event === "function") {
    event = new event(type, params);
  } else {
    event = window.document.createEvent("Event");
    if (params) event.initEvent(type, params.bubbles, params.cancelable), event.detail = params.detail;
    else event.initEvent(type, false, false);
  }

  node.dispatchEvent(event);
}

function dispatchConstant(type, params) {
  return function() {
    return dispatchEvent(this, type, params);
  };
}

function dispatchFunction(type, params) {
  return function() {
    return dispatchEvent(this, type, params.apply(this, arguments));
  };
}

function selection_dispatch(type, params) {
  return this.each((typeof params === "function"
      ? dispatchFunction
      : dispatchConstant)(type, params));
}

function* selection_iterator() {
  for (var groups = this._groups, j = 0, m = groups.length; j < m; ++j) {
    for (var group = groups[j], i = 0, n = group.length, node; i < n; ++i) {
      if (node = group[i]) yield node;
    }
  }
}

var root$1 = [null];

function Selection$1(groups, parents) {
  this._groups = groups;
  this._parents = parents;
}

function selection() {
  return new Selection$1([[document.documentElement]], root$1);
}

function selection_selection() {
  return this;
}

Selection$1.prototype = selection.prototype = {
  constructor: Selection$1,
  select: selection_select,
  selectAll: selection_selectAll,
  selectChild: selection_selectChild,
  selectChildren: selection_selectChildren,
  filter: selection_filter,
  data: selection_data,
  enter: selection_enter,
  exit: selection_exit,
  join: selection_join,
  merge: selection_merge,
  selection: selection_selection,
  order: selection_order,
  sort: selection_sort,
  call: selection_call,
  nodes: selection_nodes,
  node: selection_node,
  size: selection_size,
  empty: selection_empty,
  each: selection_each,
  attr: selection_attr,
  style: selection_style,
  property: selection_property,
  classed: selection_classed,
  text: selection_text,
  html: selection_html,
  raise: selection_raise,
  lower: selection_lower,
  append: selection_append,
  insert: selection_insert,
  remove: selection_remove,
  clone: selection_clone,
  datum: selection_datum,
  on: selection_on,
  dispatch: selection_dispatch,
  [Symbol.iterator]: selection_iterator
};

function select(selector) {
  return typeof selector === "string"
      ? new Selection$1([[document.querySelector(selector)]], [document.documentElement])
      : new Selection$1([[selector]], root$1);
}

function define(constructor, factory, prototype) {
  constructor.prototype = factory.prototype = prototype;
  prototype.constructor = constructor;
}

function extend(parent, definition) {
  var prototype = Object.create(parent.prototype);
  for (var key in definition) prototype[key] = definition[key];
  return prototype;
}

function Color() {}

var darker = 0.7;
var brighter = 1 / darker;

var reI = "\\s*([+-]?\\d+)\\s*",
    reN = "\\s*([+-]?(?:\\d*\\.)?\\d+(?:[eE][+-]?\\d+)?)\\s*",
    reP = "\\s*([+-]?(?:\\d*\\.)?\\d+(?:[eE][+-]?\\d+)?)%\\s*",
    reHex = /^#([0-9a-f]{3,8})$/,
    reRgbInteger = new RegExp(`^rgb\\(${reI},${reI},${reI}\\)$`),
    reRgbPercent = new RegExp(`^rgb\\(${reP},${reP},${reP}\\)$`),
    reRgbaInteger = new RegExp(`^rgba\\(${reI},${reI},${reI},${reN}\\)$`),
    reRgbaPercent = new RegExp(`^rgba\\(${reP},${reP},${reP},${reN}\\)$`),
    reHslPercent = new RegExp(`^hsl\\(${reN},${reP},${reP}\\)$`),
    reHslaPercent = new RegExp(`^hsla\\(${reN},${reP},${reP},${reN}\\)$`);

var named = {
  aliceblue: 0xf0f8ff,
  antiquewhite: 0xfaebd7,
  aqua: 0x00ffff,
  aquamarine: 0x7fffd4,
  azure: 0xf0ffff,
  beige: 0xf5f5dc,
  bisque: 0xffe4c4,
  black: 0x000000,
  blanchedalmond: 0xffebcd,
  blue: 0x0000ff,
  blueviolet: 0x8a2be2,
  brown: 0xa52a2a,
  burlywood: 0xdeb887,
  cadetblue: 0x5f9ea0,
  chartreuse: 0x7fff00,
  chocolate: 0xd2691e,
  coral: 0xff7f50,
  cornflowerblue: 0x6495ed,
  cornsilk: 0xfff8dc,
  crimson: 0xdc143c,
  cyan: 0x00ffff,
  darkblue: 0x00008b,
  darkcyan: 0x008b8b,
  darkgoldenrod: 0xb8860b,
  darkgray: 0xa9a9a9,
  darkgreen: 0x006400,
  darkgrey: 0xa9a9a9,
  darkkhaki: 0xbdb76b,
  darkmagenta: 0x8b008b,
  darkolivegreen: 0x556b2f,
  darkorange: 0xff8c00,
  darkorchid: 0x9932cc,
  darkred: 0x8b0000,
  darksalmon: 0xe9967a,
  darkseagreen: 0x8fbc8f,
  darkslateblue: 0x483d8b,
  darkslategray: 0x2f4f4f,
  darkslategrey: 0x2f4f4f,
  darkturquoise: 0x00ced1,
  darkviolet: 0x9400d3,
  deeppink: 0xff1493,
  deepskyblue: 0x00bfff,
  dimgray: 0x696969,
  dimgrey: 0x696969,
  dodgerblue: 0x1e90ff,
  firebrick: 0xb22222,
  floralwhite: 0xfffaf0,
  forestgreen: 0x228b22,
  fuchsia: 0xff00ff,
  gainsboro: 0xdcdcdc,
  ghostwhite: 0xf8f8ff,
  gold: 0xffd700,
  goldenrod: 0xdaa520,
  gray: 0x808080,
  green: 0x008000,
  greenyellow: 0xadff2f,
  grey: 0x808080,
  honeydew: 0xf0fff0,
  hotpink: 0xff69b4,
  indianred: 0xcd5c5c,
  indigo: 0x4b0082,
  ivory: 0xfffff0,
  khaki: 0xf0e68c,
  lavender: 0xe6e6fa,
  lavenderblush: 0xfff0f5,
  lawngreen: 0x7cfc00,
  lemonchiffon: 0xfffacd,
  lightblue: 0xadd8e6,
  lightcoral: 0xf08080,
  lightcyan: 0xe0ffff,
  lightgoldenrodyellow: 0xfafad2,
  lightgray: 0xd3d3d3,
  lightgreen: 0x90ee90,
  lightgrey: 0xd3d3d3,
  lightpink: 0xffb6c1,
  lightsalmon: 0xffa07a,
  lightseagreen: 0x20b2aa,
  lightskyblue: 0x87cefa,
  lightslategray: 0x778899,
  lightslategrey: 0x778899,
  lightsteelblue: 0xb0c4de,
  lightyellow: 0xffffe0,
  lime: 0x00ff00,
  limegreen: 0x32cd32,
  linen: 0xfaf0e6,
  magenta: 0xff00ff,
  maroon: 0x800000,
  mediumaquamarine: 0x66cdaa,
  mediumblue: 0x0000cd,
  mediumorchid: 0xba55d3,
  mediumpurple: 0x9370db,
  mediumseagreen: 0x3cb371,
  mediumslateblue: 0x7b68ee,
  mediumspringgreen: 0x00fa9a,
  mediumturquoise: 0x48d1cc,
  mediumvioletred: 0xc71585,
  midnightblue: 0x191970,
  mintcream: 0xf5fffa,
  mistyrose: 0xffe4e1,
  moccasin: 0xffe4b5,
  navajowhite: 0xffdead,
  navy: 0x000080,
  oldlace: 0xfdf5e6,
  olive: 0x808000,
  olivedrab: 0x6b8e23,
  orange: 0xffa500,
  orangered: 0xff4500,
  orchid: 0xda70d6,
  palegoldenrod: 0xeee8aa,
  palegreen: 0x98fb98,
  paleturquoise: 0xafeeee,
  palevioletred: 0xdb7093,
  papayawhip: 0xffefd5,
  peachpuff: 0xffdab9,
  peru: 0xcd853f,
  pink: 0xffc0cb,
  plum: 0xdda0dd,
  powderblue: 0xb0e0e6,
  purple: 0x800080,
  rebeccapurple: 0x663399,
  red: 0xff0000,
  rosybrown: 0xbc8f8f,
  royalblue: 0x4169e1,
  saddlebrown: 0x8b4513,
  salmon: 0xfa8072,
  sandybrown: 0xf4a460,
  seagreen: 0x2e8b57,
  seashell: 0xfff5ee,
  sienna: 0xa0522d,
  silver: 0xc0c0c0,
  skyblue: 0x87ceeb,
  slateblue: 0x6a5acd,
  slategray: 0x708090,
  slategrey: 0x708090,
  snow: 0xfffafa,
  springgreen: 0x00ff7f,
  steelblue: 0x4682b4,
  tan: 0xd2b48c,
  teal: 0x008080,
  thistle: 0xd8bfd8,
  tomato: 0xff6347,
  turquoise: 0x40e0d0,
  violet: 0xee82ee,
  wheat: 0xf5deb3,
  white: 0xffffff,
  whitesmoke: 0xf5f5f5,
  yellow: 0xffff00,
  yellowgreen: 0x9acd32
};

define(Color, color, {
  copy(channels) {
    return Object.assign(new this.constructor, this, channels);
  },
  displayable() {
    return this.rgb().displayable();
  },
  hex: color_formatHex, // Deprecated! Use color.formatHex.
  formatHex: color_formatHex,
  formatHex8: color_formatHex8,
  formatHsl: color_formatHsl,
  formatRgb: color_formatRgb,
  toString: color_formatRgb
});

function color_formatHex() {
  return this.rgb().formatHex();
}

function color_formatHex8() {
  return this.rgb().formatHex8();
}

function color_formatHsl() {
  return hslConvert(this).formatHsl();
}

function color_formatRgb() {
  return this.rgb().formatRgb();
}

function color(format) {
  var m, l;
  format = (format + "").trim().toLowerCase();
  return (m = reHex.exec(format)) ? (l = m[1].length, m = parseInt(m[1], 16), l === 6 ? rgbn(m) // #ff0000
      : l === 3 ? new Rgb((m >> 8 & 0xf) | (m >> 4 & 0xf0), (m >> 4 & 0xf) | (m & 0xf0), ((m & 0xf) << 4) | (m & 0xf), 1) // #f00
      : l === 8 ? rgba(m >> 24 & 0xff, m >> 16 & 0xff, m >> 8 & 0xff, (m & 0xff) / 0xff) // #ff000000
      : l === 4 ? rgba((m >> 12 & 0xf) | (m >> 8 & 0xf0), (m >> 8 & 0xf) | (m >> 4 & 0xf0), (m >> 4 & 0xf) | (m & 0xf0), (((m & 0xf) << 4) | (m & 0xf)) / 0xff) // #f000
      : null) // invalid hex
      : (m = reRgbInteger.exec(format)) ? new Rgb(m[1], m[2], m[3], 1) // rgb(255, 0, 0)
      : (m = reRgbPercent.exec(format)) ? new Rgb(m[1] * 255 / 100, m[2] * 255 / 100, m[3] * 255 / 100, 1) // rgb(100%, 0%, 0%)
      : (m = reRgbaInteger.exec(format)) ? rgba(m[1], m[2], m[3], m[4]) // rgba(255, 0, 0, 1)
      : (m = reRgbaPercent.exec(format)) ? rgba(m[1] * 255 / 100, m[2] * 255 / 100, m[3] * 255 / 100, m[4]) // rgb(100%, 0%, 0%, 1)
      : (m = reHslPercent.exec(format)) ? hsla(m[1], m[2] / 100, m[3] / 100, 1) // hsl(120, 50%, 50%)
      : (m = reHslaPercent.exec(format)) ? hsla(m[1], m[2] / 100, m[3] / 100, m[4]) // hsla(120, 50%, 50%, 1)
      : named.hasOwnProperty(format) ? rgbn(named[format]) // eslint-disable-line no-prototype-builtins
      : format === "transparent" ? new Rgb(NaN, NaN, NaN, 0)
      : null;
}

function rgbn(n) {
  return new Rgb(n >> 16 & 0xff, n >> 8 & 0xff, n & 0xff, 1);
}

function rgba(r, g, b, a) {
  if (a <= 0) r = g = b = NaN;
  return new Rgb(r, g, b, a);
}

function rgbConvert(o) {
  if (!(o instanceof Color)) o = color(o);
  if (!o) return new Rgb;
  o = o.rgb();
  return new Rgb(o.r, o.g, o.b, o.opacity);
}

function rgb(r, g, b, opacity) {
  return arguments.length === 1 ? rgbConvert(r) : new Rgb(r, g, b, opacity == null ? 1 : opacity);
}

function Rgb(r, g, b, opacity) {
  this.r = +r;
  this.g = +g;
  this.b = +b;
  this.opacity = +opacity;
}

define(Rgb, rgb, extend(Color, {
  brighter(k) {
    k = k == null ? brighter : Math.pow(brighter, k);
    return new Rgb(this.r * k, this.g * k, this.b * k, this.opacity);
  },
  darker(k) {
    k = k == null ? darker : Math.pow(darker, k);
    return new Rgb(this.r * k, this.g * k, this.b * k, this.opacity);
  },
  rgb() {
    return this;
  },
  clamp() {
    return new Rgb(clampi(this.r), clampi(this.g), clampi(this.b), clampa(this.opacity));
  },
  displayable() {
    return (-0.5 <= this.r && this.r < 255.5)
        && (-0.5 <= this.g && this.g < 255.5)
        && (-0.5 <= this.b && this.b < 255.5)
        && (0 <= this.opacity && this.opacity <= 1);
  },
  hex: rgb_formatHex, // Deprecated! Use color.formatHex.
  formatHex: rgb_formatHex,
  formatHex8: rgb_formatHex8,
  formatRgb: rgb_formatRgb,
  toString: rgb_formatRgb
}));

function rgb_formatHex() {
  return `#${hex(this.r)}${hex(this.g)}${hex(this.b)}`;
}

function rgb_formatHex8() {
  return `#${hex(this.r)}${hex(this.g)}${hex(this.b)}${hex((isNaN(this.opacity) ? 1 : this.opacity) * 255)}`;
}

function rgb_formatRgb() {
  const a = clampa(this.opacity);
  return `${a === 1 ? "rgb(" : "rgba("}${clampi(this.r)}, ${clampi(this.g)}, ${clampi(this.b)}${a === 1 ? ")" : `, ${a})`}`;
}

function clampa(opacity) {
  return isNaN(opacity) ? 1 : Math.max(0, Math.min(1, opacity));
}

function clampi(value) {
  return Math.max(0, Math.min(255, Math.round(value) || 0));
}

function hex(value) {
  value = clampi(value);
  return (value < 16 ? "0" : "") + value.toString(16);
}

function hsla(h, s, l, a) {
  if (a <= 0) h = s = l = NaN;
  else if (l <= 0 || l >= 1) h = s = NaN;
  else if (s <= 0) h = NaN;
  return new Hsl(h, s, l, a);
}

function hslConvert(o) {
  if (o instanceof Hsl) return new Hsl(o.h, o.s, o.l, o.opacity);
  if (!(o instanceof Color)) o = color(o);
  if (!o) return new Hsl;
  if (o instanceof Hsl) return o;
  o = o.rgb();
  var r = o.r / 255,
      g = o.g / 255,
      b = o.b / 255,
      min = Math.min(r, g, b),
      max = Math.max(r, g, b),
      h = NaN,
      s = max - min,
      l = (max + min) / 2;
  if (s) {
    if (r === max) h = (g - b) / s + (g < b) * 6;
    else if (g === max) h = (b - r) / s + 2;
    else h = (r - g) / s + 4;
    s /= l < 0.5 ? max + min : 2 - max - min;
    h *= 60;
  } else {
    s = l > 0 && l < 1 ? 0 : h;
  }
  return new Hsl(h, s, l, o.opacity);
}

function hsl(h, s, l, opacity) {
  return arguments.length === 1 ? hslConvert(h) : new Hsl(h, s, l, opacity == null ? 1 : opacity);
}

function Hsl(h, s, l, opacity) {
  this.h = +h;
  this.s = +s;
  this.l = +l;
  this.opacity = +opacity;
}

define(Hsl, hsl, extend(Color, {
  brighter(k) {
    k = k == null ? brighter : Math.pow(brighter, k);
    return new Hsl(this.h, this.s, this.l * k, this.opacity);
  },
  darker(k) {
    k = k == null ? darker : Math.pow(darker, k);
    return new Hsl(this.h, this.s, this.l * k, this.opacity);
  },
  rgb() {
    var h = this.h % 360 + (this.h < 0) * 360,
        s = isNaN(h) || isNaN(this.s) ? 0 : this.s,
        l = this.l,
        m2 = l + (l < 0.5 ? l : 1 - l) * s,
        m1 = 2 * l - m2;
    return new Rgb(
      hsl2rgb(h >= 240 ? h - 240 : h + 120, m1, m2),
      hsl2rgb(h, m1, m2),
      hsl2rgb(h < 120 ? h + 240 : h - 120, m1, m2),
      this.opacity
    );
  },
  clamp() {
    return new Hsl(clamph(this.h), clampt(this.s), clampt(this.l), clampa(this.opacity));
  },
  displayable() {
    return (0 <= this.s && this.s <= 1 || isNaN(this.s))
        && (0 <= this.l && this.l <= 1)
        && (0 <= this.opacity && this.opacity <= 1);
  },
  formatHsl() {
    const a = clampa(this.opacity);
    return `${a === 1 ? "hsl(" : "hsla("}${clamph(this.h)}, ${clampt(this.s) * 100}%, ${clampt(this.l) * 100}%${a === 1 ? ")" : `, ${a})`}`;
  }
}));

function clamph(value) {
  value = (value || 0) % 360;
  return value < 0 ? value + 360 : value;
}

function clampt(value) {
  return Math.max(0, Math.min(1, value || 0));
}

/* From FvD 13.37, CSS Color Module Level 3 */
function hsl2rgb(h, m1, m2) {
  return (h < 60 ? m1 + (m2 - m1) * h / 60
      : h < 180 ? m2
      : h < 240 ? m1 + (m2 - m1) * (240 - h) / 60
      : m1) * 255;
}

const constant$2 = x => () => x;

function linear(a, d) {
  return function(t) {
    return a + t * d;
  };
}

function exponential(a, b, y) {
  return a = Math.pow(a, y), b = Math.pow(b, y) - a, y = 1 / y, function(t) {
    return Math.pow(a + t * b, y);
  };
}

function hue(a, b) {
  var d = b - a;
  return d ? linear(a, d > 180 || d < -180 ? d - 360 * Math.round(d / 360) : d) : constant$2(isNaN(a) ? b : a);
}

function gamma(y) {
  return (y = +y) === 1 ? nogamma : function(a, b) {
    return b - a ? exponential(a, b, y) : constant$2(isNaN(a) ? b : a);
  };
}

function nogamma(a, b) {
  var d = b - a;
  return d ? linear(a, d) : constant$2(isNaN(a) ? b : a);
}

const interpolateRgb = (function rgbGamma(y) {
  var color = gamma(y);

  function rgb$1(start, end) {
    var r = color((start = rgb(start)).r, (end = rgb(end)).r),
        g = color(start.g, end.g),
        b = color(start.b, end.b),
        opacity = nogamma(start.opacity, end.opacity);
    return function(t) {
      start.r = r(t);
      start.g = g(t);
      start.b = b(t);
      start.opacity = opacity(t);
      return start + "";
    };
  }

  rgb$1.gamma = rgbGamma;

  return rgb$1;
})(1);

function interpolateNumber(a, b) {
  return a = +a, b = +b, function(t) {
    return a * (1 - t) + b * t;
  };
}

var reA = /[-+]?(?:\d+\.?\d*|\.?\d+)(?:[eE][-+]?\d+)?/g,
    reB = new RegExp(reA.source, "g");

function zero(b) {
  return function() {
    return b;
  };
}

function one(b) {
  return function(t) {
    return b(t) + "";
  };
}

function interpolateString(a, b) {
  var bi = reA.lastIndex = reB.lastIndex = 0, // scan index for next number in b
      am, // current match in a
      bm, // current match in b
      bs, // string preceding current number in b, if any
      i = -1, // index in s
      s = [], // string constants and placeholders
      q = []; // number interpolators

  // Coerce inputs to strings.
  a = a + "", b = b + "";

  // Interpolate pairs of numbers in a & b.
  while ((am = reA.exec(a))
      && (bm = reB.exec(b))) {
    if ((bs = bm.index) > bi) { // a string precedes the next number in b
      bs = b.slice(bi, bs);
      if (s[i]) s[i] += bs; // coalesce with previous string
      else s[++i] = bs;
    }
    if ((am = am[0]) === (bm = bm[0])) { // numbers in a & b match
      if (s[i]) s[i] += bm; // coalesce with previous string
      else s[++i] = bm;
    } else { // interpolate non-matching numbers
      s[++i] = null;
      q.push({i: i, x: interpolateNumber(am, bm)});
    }
    bi = reB.lastIndex;
  }

  // Add remains of b.
  if (bi < b.length) {
    bs = b.slice(bi);
    if (s[i]) s[i] += bs; // coalesce with previous string
    else s[++i] = bs;
  }

  // Special optimization for only a single match.
  // Otherwise, interpolate each of the numbers and rejoin the string.
  return s.length < 2 ? (q[0]
      ? one(q[0].x)
      : zero(b))
      : (b = q.length, function(t) {
          for (var i = 0, o; i < b; ++i) s[(o = q[i]).i] = o.x(t);
          return s.join("");
        });
}

var degrees = 180 / Math.PI;

var identity$1 = {
  translateX: 0,
  translateY: 0,
  rotate: 0,
  skewX: 0,
  scaleX: 1,
  scaleY: 1
};

function decompose(a, b, c, d, e, f) {
  var scaleX, scaleY, skewX;
  if (scaleX = Math.sqrt(a * a + b * b)) a /= scaleX, b /= scaleX;
  if (skewX = a * c + b * d) c -= a * skewX, d -= b * skewX;
  if (scaleY = Math.sqrt(c * c + d * d)) c /= scaleY, d /= scaleY, skewX /= scaleY;
  if (a * d < b * c) a = -a, b = -b, skewX = -skewX, scaleX = -scaleX;
  return {
    translateX: e,
    translateY: f,
    rotate: Math.atan2(b, a) * degrees,
    skewX: Math.atan(skewX) * degrees,
    scaleX: scaleX,
    scaleY: scaleY
  };
}

var svgNode;

/* eslint-disable no-undef */
function parseCss(value) {
  const m = new (typeof DOMMatrix === "function" ? DOMMatrix : WebKitCSSMatrix)(value + "");
  return m.isIdentity ? identity$1 : decompose(m.a, m.b, m.c, m.d, m.e, m.f);
}

function parseSvg(value) {
  if (value == null) return identity$1;
  if (!svgNode) svgNode = document.createElementNS("http://www.w3.org/2000/svg", "g");
  svgNode.setAttribute("transform", value);
  if (!(value = svgNode.transform.baseVal.consolidate())) return identity$1;
  value = value.matrix;
  return decompose(value.a, value.b, value.c, value.d, value.e, value.f);
}

function interpolateTransform(parse, pxComma, pxParen, degParen) {

  function pop(s) {
    return s.length ? s.pop() + " " : "";
  }

  function translate(xa, ya, xb, yb, s, q) {
    if (xa !== xb || ya !== yb) {
      var i = s.push("translate(", null, pxComma, null, pxParen);
      q.push({i: i - 4, x: interpolateNumber(xa, xb)}, {i: i - 2, x: interpolateNumber(ya, yb)});
    } else if (xb || yb) {
      s.push("translate(" + xb + pxComma + yb + pxParen);
    }
  }

  function rotate(a, b, s, q) {
    if (a !== b) {
      if (a - b > 180) b += 360; else if (b - a > 180) a += 360; // shortest path
      q.push({i: s.push(pop(s) + "rotate(", null, degParen) - 2, x: interpolateNumber(a, b)});
    } else if (b) {
      s.push(pop(s) + "rotate(" + b + degParen);
    }
  }

  function skewX(a, b, s, q) {
    if (a !== b) {
      q.push({i: s.push(pop(s) + "skewX(", null, degParen) - 2, x: interpolateNumber(a, b)});
    } else if (b) {
      s.push(pop(s) + "skewX(" + b + degParen);
    }
  }

  function scale(xa, ya, xb, yb, s, q) {
    if (xa !== xb || ya !== yb) {
      var i = s.push(pop(s) + "scale(", null, ",", null, ")");
      q.push({i: i - 4, x: interpolateNumber(xa, xb)}, {i: i - 2, x: interpolateNumber(ya, yb)});
    } else if (xb !== 1 || yb !== 1) {
      s.push(pop(s) + "scale(" + xb + "," + yb + ")");
    }
  }

  return function(a, b) {
    var s = [], // string constants and placeholders
        q = []; // number interpolators
    a = parse(a), b = parse(b);
    translate(a.translateX, a.translateY, b.translateX, b.translateY, s, q);
    rotate(a.rotate, b.rotate, s, q);
    skewX(a.skewX, b.skewX, s, q);
    scale(a.scaleX, a.scaleY, b.scaleX, b.scaleY, s, q);
    a = b = null; // gc
    return function(t) {
      var i = -1, n = q.length, o;
      while (++i < n) s[(o = q[i]).i] = o.x(t);
      return s.join("");
    };
  };
}

var interpolateTransformCss = interpolateTransform(parseCss, "px, ", "px)", "deg)");
var interpolateTransformSvg = interpolateTransform(parseSvg, ", ", ")", ")");

var frame = 0, // is an animation frame pending?
    timeout$1 = 0, // is a timeout pending?
    interval = 0, // are any timers active?
    pokeDelay = 1000, // how frequently we check for clock skew
    taskHead,
    taskTail,
    clockLast = 0,
    clockNow = 0,
    clockSkew = 0,
    clock = typeof performance === "object" && performance.now ? performance : Date,
    setFrame = typeof window === "object" && window.requestAnimationFrame ? window.requestAnimationFrame.bind(window) : function(f) { setTimeout(f, 17); };

function now() {
  return clockNow || (setFrame(clearNow), clockNow = clock.now() + clockSkew);
}

function clearNow() {
  clockNow = 0;
}

function Timer() {
  this._call =
  this._time =
  this._next = null;
}

Timer.prototype = timer.prototype = {
  constructor: Timer,
  restart: function(callback, delay, time) {
    if (typeof callback !== "function") throw new TypeError("callback is not a function");
    time = (time == null ? now() : +time) + (delay == null ? 0 : +delay);
    if (!this._next && taskTail !== this) {
      if (taskTail) taskTail._next = this;
      else taskHead = this;
      taskTail = this;
    }
    this._call = callback;
    this._time = time;
    sleep();
  },
  stop: function() {
    if (this._call) {
      this._call = null;
      this._time = Infinity;
      sleep();
    }
  }
};

function timer(callback, delay, time) {
  var t = new Timer;
  t.restart(callback, delay, time);
  return t;
}

function timerFlush() {
  now(); // Get the current time, if not already set.
  ++frame; // Pretend we’ve set an alarm, if we haven’t already.
  var t = taskHead, e;
  while (t) {
    if ((e = clockNow - t._time) >= 0) t._call.call(undefined, e);
    t = t._next;
  }
  --frame;
}

function wake() {
  clockNow = (clockLast = clock.now()) + clockSkew;
  frame = timeout$1 = 0;
  try {
    timerFlush();
  } finally {
    frame = 0;
    nap();
    clockNow = 0;
  }
}

function poke() {
  var now = clock.now(), delay = now - clockLast;
  if (delay > pokeDelay) clockSkew -= delay, clockLast = now;
}

function nap() {
  var t0, t1 = taskHead, t2, time = Infinity;
  while (t1) {
    if (t1._call) {
      if (time > t1._time) time = t1._time;
      t0 = t1, t1 = t1._next;
    } else {
      t2 = t1._next, t1._next = null;
      t1 = t0 ? t0._next = t2 : taskHead = t2;
    }
  }
  taskTail = t0;
  sleep(time);
}

function sleep(time) {
  if (frame) return; // Soonest alarm already set, or will be.
  if (timeout$1) timeout$1 = clearTimeout(timeout$1);
  var delay = time - clockNow; // Strictly less than if we recomputed clockNow.
  if (delay > 24) {
    if (time < Infinity) timeout$1 = setTimeout(wake, time - clock.now() - clockSkew);
    if (interval) interval = clearInterval(interval);
  } else {
    if (!interval) clockLast = clock.now(), interval = setInterval(poke, pokeDelay);
    frame = 1, setFrame(wake);
  }
}

function timeout(callback, delay, time) {
  var t = new Timer;
  delay = delay == null ? 0 : +delay;
  t.restart(elapsed => {
    t.stop();
    callback(elapsed + delay);
  }, delay, time);
  return t;
}

var emptyOn = dispatch("start", "end", "cancel", "interrupt");
var emptyTween = [];

var CREATED = 0;
var SCHEDULED = 1;
var STARTING = 2;
var STARTED = 3;
var RUNNING = 4;
var ENDING = 5;
var ENDED = 6;

function schedule(node, name, id, index, group, timing) {
  var schedules = node.__transition;
  if (!schedules) node.__transition = {};
  else if (id in schedules) return;
  create(node, id, {
    name: name,
    index: index, // For context during callback.
    group: group, // For context during callback.
    on: emptyOn,
    tween: emptyTween,
    time: timing.time,
    delay: timing.delay,
    duration: timing.duration,
    ease: timing.ease,
    timer: null,
    state: CREATED
  });
}

function init$1(node, id) {
  var schedule = get(node, id);
  if (schedule.state > CREATED) throw new Error("too late; already scheduled");
  return schedule;
}

function set(node, id) {
  var schedule = get(node, id);
  if (schedule.state > STARTED) throw new Error("too late; already running");
  return schedule;
}

function get(node, id) {
  var schedule = node.__transition;
  if (!schedule || !(schedule = schedule[id])) throw new Error("transition not found");
  return schedule;
}

function create(node, id, self) {
  var schedules = node.__transition,
      tween;

  // Initialize the self timer when the transition is created.
  // Note the actual delay is not known until the first callback!
  schedules[id] = self;
  self.timer = timer(schedule, 0, self.time);

  function schedule(elapsed) {
    self.state = SCHEDULED;
    self.timer.restart(start, self.delay, self.time);

    // If the elapsed delay is less than our first sleep, start immediately.
    if (self.delay <= elapsed) start(elapsed - self.delay);
  }

  function start(elapsed) {
    var i, j, n, o;

    // If the state is not SCHEDULED, then we previously errored on start.
    if (self.state !== SCHEDULED) return stop();

    for (i in schedules) {
      o = schedules[i];
      if (o.name !== self.name) continue;

      // While this element already has a starting transition during this frame,
      // defer starting an interrupting transition until that transition has a
      // chance to tick (and possibly end); see d3/d3-transition#54!
      if (o.state === STARTED) return timeout(start);

      // Interrupt the active transition, if any.
      if (o.state === RUNNING) {
        o.state = ENDED;
        o.timer.stop();
        o.on.call("interrupt", node, node.__data__, o.index, o.group);
        delete schedules[i];
      }

      // Cancel any pre-empted transitions.
      else if (+i < id) {
        o.state = ENDED;
        o.timer.stop();
        o.on.call("cancel", node, node.__data__, o.index, o.group);
        delete schedules[i];
      }
    }

    // Defer the first tick to end of the current frame; see d3/d3#1576.
    // Note the transition may be canceled after start and before the first tick!
    // Note this must be scheduled before the start event; see d3/d3-transition#16!
    // Assuming this is successful, subsequent callbacks go straight to tick.
    timeout(function() {
      if (self.state === STARTED) {
        self.state = RUNNING;
        self.timer.restart(tick, self.delay, self.time);
        tick(elapsed);
      }
    });

    // Dispatch the start event.
    // Note this must be done before the tween are initialized.
    self.state = STARTING;
    self.on.call("start", node, node.__data__, self.index, self.group);
    if (self.state !== STARTING) return; // interrupted
    self.state = STARTED;

    // Initialize the tween, deleting null tween.
    tween = new Array(n = self.tween.length);
    for (i = 0, j = -1; i < n; ++i) {
      if (o = self.tween[i].value.call(node, node.__data__, self.index, self.group)) {
        tween[++j] = o;
      }
    }
    tween.length = j + 1;
  }

  function tick(elapsed) {
    var t = elapsed < self.duration ? self.ease.call(null, elapsed / self.duration) : (self.timer.restart(stop), self.state = ENDING, 1),
        i = -1,
        n = tween.length;

    while (++i < n) {
      tween[i].call(node, t);
    }

    // Dispatch the end event.
    if (self.state === ENDING) {
      self.on.call("end", node, node.__data__, self.index, self.group);
      stop();
    }
  }

  function stop() {
    self.state = ENDED;
    self.timer.stop();
    delete schedules[id];
    for (var i in schedules) return; // eslint-disable-line no-unused-vars
    delete node.__transition;
  }
}

function interrupt(node, name) {
  var schedules = node.__transition,
      schedule,
      active,
      empty = true,
      i;

  if (!schedules) return;

  name = name == null ? null : name + "";

  for (i in schedules) {
    if ((schedule = schedules[i]).name !== name) { empty = false; continue; }
    active = schedule.state > STARTING && schedule.state < ENDING;
    schedule.state = ENDED;
    schedule.timer.stop();
    schedule.on.call(active ? "interrupt" : "cancel", node, node.__data__, schedule.index, schedule.group);
    delete schedules[i];
  }

  if (empty) delete node.__transition;
}

function selection_interrupt(name) {
  return this.each(function() {
    interrupt(this, name);
  });
}

function tweenRemove(id, name) {
  var tween0, tween1;
  return function() {
    var schedule = set(this, id),
        tween = schedule.tween;

    // If this node shared tween with the previous node,
    // just assign the updated shared tween and we’re done!
    // Otherwise, copy-on-write.
    if (tween !== tween0) {
      tween1 = tween0 = tween;
      for (var i = 0, n = tween1.length; i < n; ++i) {
        if (tween1[i].name === name) {
          tween1 = tween1.slice();
          tween1.splice(i, 1);
          break;
        }
      }
    }

    schedule.tween = tween1;
  };
}

function tweenFunction(id, name, value) {
  var tween0, tween1;
  if (typeof value !== "function") throw new Error;
  return function() {
    var schedule = set(this, id),
        tween = schedule.tween;

    // If this node shared tween with the previous node,
    // just assign the updated shared tween and we’re done!
    // Otherwise, copy-on-write.
    if (tween !== tween0) {
      tween1 = (tween0 = tween).slice();
      for (var t = {name: name, value: value}, i = 0, n = tween1.length; i < n; ++i) {
        if (tween1[i].name === name) {
          tween1[i] = t;
          break;
        }
      }
      if (i === n) tween1.push(t);
    }

    schedule.tween = tween1;
  };
}

function transition_tween(name, value) {
  var id = this._id;

  name += "";

  if (arguments.length < 2) {
    var tween = get(this.node(), id).tween;
    for (var i = 0, n = tween.length, t; i < n; ++i) {
      if ((t = tween[i]).name === name) {
        return t.value;
      }
    }
    return null;
  }

  return this.each((value == null ? tweenRemove : tweenFunction)(id, name, value));
}

function tweenValue(transition, name, value) {
  var id = transition._id;

  transition.each(function() {
    var schedule = set(this, id);
    (schedule.value || (schedule.value = {}))[name] = value.apply(this, arguments);
  });

  return function(node) {
    return get(node, id).value[name];
  };
}

function interpolate(a, b) {
  var c;
  return (typeof b === "number" ? interpolateNumber
      : b instanceof color ? interpolateRgb
      : (c = color(b)) ? (b = c, interpolateRgb)
      : interpolateString)(a, b);
}

function attrRemove(name) {
  return function() {
    this.removeAttribute(name);
  };
}

function attrRemoveNS(fullname) {
  return function() {
    this.removeAttributeNS(fullname.space, fullname.local);
  };
}

function attrConstant(name, interpolate, value1) {
  var string00,
      string1 = value1 + "",
      interpolate0;
  return function() {
    var string0 = this.getAttribute(name);
    return string0 === string1 ? null
        : string0 === string00 ? interpolate0
        : interpolate0 = interpolate(string00 = string0, value1);
  };
}

function attrConstantNS(fullname, interpolate, value1) {
  var string00,
      string1 = value1 + "",
      interpolate0;
  return function() {
    var string0 = this.getAttributeNS(fullname.space, fullname.local);
    return string0 === string1 ? null
        : string0 === string00 ? interpolate0
        : interpolate0 = interpolate(string00 = string0, value1);
  };
}

function attrFunction(name, interpolate, value) {
  var string00,
      string10,
      interpolate0;
  return function() {
    var string0, value1 = value(this), string1;
    if (value1 == null) return void this.removeAttribute(name);
    string0 = this.getAttribute(name);
    string1 = value1 + "";
    return string0 === string1 ? null
        : string0 === string00 && string1 === string10 ? interpolate0
        : (string10 = string1, interpolate0 = interpolate(string00 = string0, value1));
  };
}

function attrFunctionNS(fullname, interpolate, value) {
  var string00,
      string10,
      interpolate0;
  return function() {
    var string0, value1 = value(this), string1;
    if (value1 == null) return void this.removeAttributeNS(fullname.space, fullname.local);
    string0 = this.getAttributeNS(fullname.space, fullname.local);
    string1 = value1 + "";
    return string0 === string1 ? null
        : string0 === string00 && string1 === string10 ? interpolate0
        : (string10 = string1, interpolate0 = interpolate(string00 = string0, value1));
  };
}

function transition_attr(name, value) {
  var fullname = namespace(name), i = fullname === "transform" ? interpolateTransformSvg : interpolate;
  return this.attrTween(name, typeof value === "function"
      ? (fullname.local ? attrFunctionNS : attrFunction)(fullname, i, tweenValue(this, "attr." + name, value))
      : value == null ? (fullname.local ? attrRemoveNS : attrRemove)(fullname)
      : (fullname.local ? attrConstantNS : attrConstant)(fullname, i, value));
}

function attrInterpolate(name, i) {
  return function(t) {
    this.setAttribute(name, i.call(this, t));
  };
}

function attrInterpolateNS(fullname, i) {
  return function(t) {
    this.setAttributeNS(fullname.space, fullname.local, i.call(this, t));
  };
}

function attrTweenNS(fullname, value) {
  var t0, i0;
  function tween() {
    var i = value.apply(this, arguments);
    if (i !== i0) t0 = (i0 = i) && attrInterpolateNS(fullname, i);
    return t0;
  }
  tween._value = value;
  return tween;
}

function attrTween(name, value) {
  var t0, i0;
  function tween() {
    var i = value.apply(this, arguments);
    if (i !== i0) t0 = (i0 = i) && attrInterpolate(name, i);
    return t0;
  }
  tween._value = value;
  return tween;
}

function transition_attrTween(name, value) {
  var key = "attr." + name;
  if (arguments.length < 2) return (key = this.tween(key)) && key._value;
  if (value == null) return this.tween(key, null);
  if (typeof value !== "function") throw new Error;
  var fullname = namespace(name);
  return this.tween(key, (fullname.local ? attrTweenNS : attrTween)(fullname, value));
}

function delayFunction(id, value) {
  return function() {
    init$1(this, id).delay = +value.apply(this, arguments);
  };
}

function delayConstant(id, value) {
  return value = +value, function() {
    init$1(this, id).delay = value;
  };
}

function transition_delay(value) {
  var id = this._id;

  return arguments.length
      ? this.each((typeof value === "function"
          ? delayFunction
          : delayConstant)(id, value))
      : get(this.node(), id).delay;
}

function durationFunction(id, value) {
  return function() {
    set(this, id).duration = +value.apply(this, arguments);
  };
}

function durationConstant(id, value) {
  return value = +value, function() {
    set(this, id).duration = value;
  };
}

function transition_duration(value) {
  var id = this._id;

  return arguments.length
      ? this.each((typeof value === "function"
          ? durationFunction
          : durationConstant)(id, value))
      : get(this.node(), id).duration;
}

function easeConstant(id, value) {
  if (typeof value !== "function") throw new Error;
  return function() {
    set(this, id).ease = value;
  };
}

function transition_ease(value) {
  var id = this._id;

  return arguments.length
      ? this.each(easeConstant(id, value))
      : get(this.node(), id).ease;
}

function easeVarying(id, value) {
  return function() {
    var v = value.apply(this, arguments);
    if (typeof v !== "function") throw new Error;
    set(this, id).ease = v;
  };
}

function transition_easeVarying(value) {
  if (typeof value !== "function") throw new Error;
  return this.each(easeVarying(this._id, value));
}

function transition_filter(match) {
  if (typeof match !== "function") match = matcher(match);

  for (var groups = this._groups, m = groups.length, subgroups = new Array(m), j = 0; j < m; ++j) {
    for (var group = groups[j], n = group.length, subgroup = subgroups[j] = [], node, i = 0; i < n; ++i) {
      if ((node = group[i]) && match.call(node, node.__data__, i, group)) {
        subgroup.push(node);
      }
    }
  }

  return new Transition(subgroups, this._parents, this._name, this._id);
}

function transition_merge(transition) {
  if (transition._id !== this._id) throw new Error;

  for (var groups0 = this._groups, groups1 = transition._groups, m0 = groups0.length, m1 = groups1.length, m = Math.min(m0, m1), merges = new Array(m0), j = 0; j < m; ++j) {
    for (var group0 = groups0[j], group1 = groups1[j], n = group0.length, merge = merges[j] = new Array(n), node, i = 0; i < n; ++i) {
      if (node = group0[i] || group1[i]) {
        merge[i] = node;
      }
    }
  }

  for (; j < m0; ++j) {
    merges[j] = groups0[j];
  }

  return new Transition(merges, this._parents, this._name, this._id);
}

function start(name) {
  return (name + "").trim().split(/^|\s+/).every(function(t) {
    var i = t.indexOf(".");
    if (i >= 0) t = t.slice(0, i);
    return !t || t === "start";
  });
}

function onFunction(id, name, listener) {
  var on0, on1, sit = start(name) ? init$1 : set;
  return function() {
    var schedule = sit(this, id),
        on = schedule.on;

    // If this node shared a dispatch with the previous node,
    // just assign the updated shared dispatch and we’re done!
    // Otherwise, copy-on-write.
    if (on !== on0) (on1 = (on0 = on).copy()).on(name, listener);

    schedule.on = on1;
  };
}

function transition_on(name, listener) {
  var id = this._id;

  return arguments.length < 2
      ? get(this.node(), id).on.on(name)
      : this.each(onFunction(id, name, listener));
}

function removeFunction(id) {
  return function() {
    var parent = this.parentNode;
    for (var i in this.__transition) if (+i !== id) return;
    if (parent) parent.removeChild(this);
  };
}

function transition_remove() {
  return this.on("end.remove", removeFunction(this._id));
}

function transition_select(select) {
  var name = this._name,
      id = this._id;

  if (typeof select !== "function") select = selector(select);

  for (var groups = this._groups, m = groups.length, subgroups = new Array(m), j = 0; j < m; ++j) {
    for (var group = groups[j], n = group.length, subgroup = subgroups[j] = new Array(n), node, subnode, i = 0; i < n; ++i) {
      if ((node = group[i]) && (subnode = select.call(node, node.__data__, i, group))) {
        if ("__data__" in node) subnode.__data__ = node.__data__;
        subgroup[i] = subnode;
        schedule(subgroup[i], name, id, i, subgroup, get(node, id));
      }
    }
  }

  return new Transition(subgroups, this._parents, name, id);
}

function transition_selectAll(select) {
  var name = this._name,
      id = this._id;

  if (typeof select !== "function") select = selectorAll(select);

  for (var groups = this._groups, m = groups.length, subgroups = [], parents = [], j = 0; j < m; ++j) {
    for (var group = groups[j], n = group.length, node, i = 0; i < n; ++i) {
      if (node = group[i]) {
        for (var children = select.call(node, node.__data__, i, group), child, inherit = get(node, id), k = 0, l = children.length; k < l; ++k) {
          if (child = children[k]) {
            schedule(child, name, id, k, children, inherit);
          }
        }
        subgroups.push(children);
        parents.push(node);
      }
    }
  }

  return new Transition(subgroups, parents, name, id);
}

var Selection = selection.prototype.constructor;

function transition_selection() {
  return new Selection(this._groups, this._parents);
}

function styleNull(name, interpolate) {
  var string00,
      string10,
      interpolate0;
  return function() {
    var string0 = styleValue(this, name),
        string1 = (this.style.removeProperty(name), styleValue(this, name));
    return string0 === string1 ? null
        : string0 === string00 && string1 === string10 ? interpolate0
        : interpolate0 = interpolate(string00 = string0, string10 = string1);
  };
}

function styleRemove(name) {
  return function() {
    this.style.removeProperty(name);
  };
}

function styleConstant(name, interpolate, value1) {
  var string00,
      string1 = value1 + "",
      interpolate0;
  return function() {
    var string0 = styleValue(this, name);
    return string0 === string1 ? null
        : string0 === string00 ? interpolate0
        : interpolate0 = interpolate(string00 = string0, value1);
  };
}

function styleFunction(name, interpolate, value) {
  var string00,
      string10,
      interpolate0;
  return function() {
    var string0 = styleValue(this, name),
        value1 = value(this),
        string1 = value1 + "";
    if (value1 == null) string1 = value1 = (this.style.removeProperty(name), styleValue(this, name));
    return string0 === string1 ? null
        : string0 === string00 && string1 === string10 ? interpolate0
        : (string10 = string1, interpolate0 = interpolate(string00 = string0, value1));
  };
}

function styleMaybeRemove(id, name) {
  var on0, on1, listener0, key = "style." + name, event = "end." + key, remove;
  return function() {
    var schedule = set(this, id),
        on = schedule.on,
        listener = schedule.value[key] == null ? remove || (remove = styleRemove(name)) : undefined;

    // If this node shared a dispatch with the previous node,
    // just assign the updated shared dispatch and we’re done!
    // Otherwise, copy-on-write.
    if (on !== on0 || listener0 !== listener) (on1 = (on0 = on).copy()).on(event, listener0 = listener);

    schedule.on = on1;
  };
}

function transition_style(name, value, priority) {
  var i = (name += "") === "transform" ? interpolateTransformCss : interpolate;
  return value == null ? this
      .styleTween(name, styleNull(name, i))
      .on("end.style." + name, styleRemove(name))
    : typeof value === "function" ? this
      .styleTween(name, styleFunction(name, i, tweenValue(this, "style." + name, value)))
      .each(styleMaybeRemove(this._id, name))
    : this
      .styleTween(name, styleConstant(name, i, value), priority)
      .on("end.style." + name, null);
}

function styleInterpolate(name, i, priority) {
  return function(t) {
    this.style.setProperty(name, i.call(this, t), priority);
  };
}

function styleTween(name, value, priority) {
  var t, i0;
  function tween() {
    var i = value.apply(this, arguments);
    if (i !== i0) t = (i0 = i) && styleInterpolate(name, i, priority);
    return t;
  }
  tween._value = value;
  return tween;
}

function transition_styleTween(name, value, priority) {
  var key = "style." + (name += "");
  if (arguments.length < 2) return (key = this.tween(key)) && key._value;
  if (value == null) return this.tween(key, null);
  if (typeof value !== "function") throw new Error;
  return this.tween(key, styleTween(name, value, priority == null ? "" : priority));
}

function textConstant(value) {
  return function() {
    this.textContent = value;
  };
}

function textFunction(value) {
  return function() {
    var value1 = value(this);
    this.textContent = value1 == null ? "" : value1;
  };
}

function transition_text(value) {
  return this.tween("text", typeof value === "function"
      ? textFunction(tweenValue(this, "text", value))
      : textConstant(value == null ? "" : value + ""));
}

function textInterpolate(i) {
  return function(t) {
    this.textContent = i.call(this, t);
  };
}

function textTween(value) {
  var t0, i0;
  function tween() {
    var i = value.apply(this, arguments);
    if (i !== i0) t0 = (i0 = i) && textInterpolate(i);
    return t0;
  }
  tween._value = value;
  return tween;
}

function transition_textTween(value) {
  var key = "text";
  if (arguments.length < 1) return (key = this.tween(key)) && key._value;
  if (value == null) return this.tween(key, null);
  if (typeof value !== "function") throw new Error;
  return this.tween(key, textTween(value));
}

function transition_transition() {
  var name = this._name,
      id0 = this._id,
      id1 = newId();

  for (var groups = this._groups, m = groups.length, j = 0; j < m; ++j) {
    for (var group = groups[j], n = group.length, node, i = 0; i < n; ++i) {
      if (node = group[i]) {
        var inherit = get(node, id0);
        schedule(node, name, id1, i, group, {
          time: inherit.time + inherit.delay + inherit.duration,
          delay: 0,
          duration: inherit.duration,
          ease: inherit.ease
        });
      }
    }
  }

  return new Transition(groups, this._parents, name, id1);
}

function transition_end() {
  var on0, on1, that = this, id = that._id, size = that.size();
  return new Promise(function(resolve, reject) {
    var cancel = {value: reject},
        end = {value: function() { if (--size === 0) resolve(); }};

    that.each(function() {
      var schedule = set(this, id),
          on = schedule.on;

      // If this node shared a dispatch with the previous node,
      // just assign the updated shared dispatch and we’re done!
      // Otherwise, copy-on-write.
      if (on !== on0) {
        on1 = (on0 = on).copy();
        on1._.cancel.push(cancel);
        on1._.interrupt.push(cancel);
        on1._.end.push(end);
      }

      schedule.on = on1;
    });

    // The selection was empty, resolve end immediately
    if (size === 0) resolve();
  });
}

var id$1 = 0;

function Transition(groups, parents, name, id) {
  this._groups = groups;
  this._parents = parents;
  this._name = name;
  this._id = id;
}

function newId() {
  return ++id$1;
}

var selection_prototype = selection.prototype;

Transition.prototype = {
  constructor: Transition,
  select: transition_select,
  selectAll: transition_selectAll,
  selectChild: selection_prototype.selectChild,
  selectChildren: selection_prototype.selectChildren,
  filter: transition_filter,
  merge: transition_merge,
  selection: transition_selection,
  transition: transition_transition,
  call: selection_prototype.call,
  nodes: selection_prototype.nodes,
  node: selection_prototype.node,
  size: selection_prototype.size,
  empty: selection_prototype.empty,
  each: selection_prototype.each,
  on: transition_on,
  attr: transition_attr,
  attrTween: transition_attrTween,
  style: transition_style,
  styleTween: transition_styleTween,
  text: transition_text,
  textTween: transition_textTween,
  remove: transition_remove,
  tween: transition_tween,
  delay: transition_delay,
  duration: transition_duration,
  ease: transition_ease,
  easeVarying: transition_easeVarying,
  end: transition_end,
  [Symbol.iterator]: selection_prototype[Symbol.iterator]
};

function cubicInOut(t) {
  return ((t *= 2) <= 1 ? t * t * t : (t -= 2) * t * t + 2) / 2;
}

var defaultTiming = {
  time: null, // Set on use.
  delay: 0,
  duration: 250,
  ease: cubicInOut
};

function inherit(node, id) {
  var timing;
  while (!(timing = node.__transition) || !(timing = timing[id])) {
    if (!(node = node.parentNode)) {
      throw new Error(`transition ${id} not found`);
    }
  }
  return timing;
}

function selection_transition(name) {
  var id,
      timing;

  if (name instanceof Transition) {
    id = name._id, name = name._name;
  } else {
    id = newId(), (timing = defaultTiming).time = now(), name = name == null ? null : name + "";
  }

  for (var groups = this._groups, m = groups.length, j = 0; j < m; ++j) {
    for (var group = groups[j], n = group.length, node, i = 0; i < n; ++i) {
      if (node = group[i]) {
        schedule(node, name, id, i, group, timing || inherit(node, id));
      }
    }
  }

  return new Transition(groups, this._parents, name, id);
}

selection.prototype.interrupt = selection_interrupt;
selection.prototype.transition = selection_transition;

const pi$1 = Math.PI,
    tau$1 = 2 * pi$1,
    epsilon$1 = 1e-6,
    tauEpsilon = tau$1 - epsilon$1;

function append$1(strings) {
  this._ += strings[0];
  for (let i = 1, n = strings.length; i < n; ++i) {
    this._ += arguments[i] + strings[i];
  }
}

function appendRound(digits) {
  let d = Math.floor(digits);
  if (!(d >= 0)) throw new Error(`invalid digits: ${digits}`);
  if (d > 15) return append$1;
  const k = 10 ** d;
  return function(strings) {
    this._ += strings[0];
    for (let i = 1, n = strings.length; i < n; ++i) {
      this._ += Math.round(arguments[i] * k) / k + strings[i];
    }
  };
}

class Path {
  constructor(digits) {
    this._x0 = this._y0 = // start of current subpath
    this._x1 = this._y1 = null; // end of current subpath
    this._ = "";
    this._append = digits == null ? append$1 : appendRound(digits);
  }
  moveTo(x, y) {
    this._append`M${this._x0 = this._x1 = +x},${this._y0 = this._y1 = +y}`;
  }
  closePath() {
    if (this._x1 !== null) {
      this._x1 = this._x0, this._y1 = this._y0;
      this._append`Z`;
    }
  }
  lineTo(x, y) {
    this._append`L${this._x1 = +x},${this._y1 = +y}`;
  }
  quadraticCurveTo(x1, y1, x, y) {
    this._append`Q${+x1},${+y1},${this._x1 = +x},${this._y1 = +y}`;
  }
  bezierCurveTo(x1, y1, x2, y2, x, y) {
    this._append`C${+x1},${+y1},${+x2},${+y2},${this._x1 = +x},${this._y1 = +y}`;
  }
  arcTo(x1, y1, x2, y2, r) {
    x1 = +x1, y1 = +y1, x2 = +x2, y2 = +y2, r = +r;

    // Is the radius negative? Error.
    if (r < 0) throw new Error(`negative radius: ${r}`);

    let x0 = this._x1,
        y0 = this._y1,
        x21 = x2 - x1,
        y21 = y2 - y1,
        x01 = x0 - x1,
        y01 = y0 - y1,
        l01_2 = x01 * x01 + y01 * y01;

    // Is this path empty? Move to (x1,y1).
    if (this._x1 === null) {
      this._append`M${this._x1 = x1},${this._y1 = y1}`;
    }

    // Or, is (x1,y1) coincident with (x0,y0)? Do nothing.
    else if (!(l01_2 > epsilon$1));

    // Or, are (x0,y0), (x1,y1) and (x2,y2) collinear?
    // Equivalently, is (x1,y1) coincident with (x2,y2)?
    // Or, is the radius zero? Line to (x1,y1).
    else if (!(Math.abs(y01 * x21 - y21 * x01) > epsilon$1) || !r) {
      this._append`L${this._x1 = x1},${this._y1 = y1}`;
    }

    // Otherwise, draw an arc!
    else {
      let x20 = x2 - x0,
          y20 = y2 - y0,
          l21_2 = x21 * x21 + y21 * y21,
          l20_2 = x20 * x20 + y20 * y20,
          l21 = Math.sqrt(l21_2),
          l01 = Math.sqrt(l01_2),
          l = r * Math.tan((pi$1 - Math.acos((l21_2 + l01_2 - l20_2) / (2 * l21 * l01))) / 2),
          t01 = l / l01,
          t21 = l / l21;

      // If the start tangent is not coincident with (x0,y0), line to.
      if (Math.abs(t01 - 1) > epsilon$1) {
        this._append`L${x1 + t01 * x01},${y1 + t01 * y01}`;
      }

      this._append`A${r},${r},0,0,${+(y01 * x20 > x01 * y20)},${this._x1 = x1 + t21 * x21},${this._y1 = y1 + t21 * y21}`;
    }
  }
  arc(x, y, r, a0, a1, ccw) {
    x = +x, y = +y, r = +r, ccw = !!ccw;

    // Is the radius negative? Error.
    if (r < 0) throw new Error(`negative radius: ${r}`);

    let dx = r * Math.cos(a0),
        dy = r * Math.sin(a0),
        x0 = x + dx,
        y0 = y + dy,
        cw = 1 ^ ccw,
        da = ccw ? a0 - a1 : a1 - a0;

    // Is this path empty? Move to (x0,y0).
    if (this._x1 === null) {
      this._append`M${x0},${y0}`;
    }

    // Or, is (x0,y0) not coincident with the previous point? Line to (x0,y0).
    else if (Math.abs(this._x1 - x0) > epsilon$1 || Math.abs(this._y1 - y0) > epsilon$1) {
      this._append`L${x0},${y0}`;
    }

    // Is this arc empty? We’re done.
    if (!r) return;

    // Does the angle go the wrong way? Flip the direction.
    if (da < 0) da = da % tau$1 + tau$1;

    // Is this a complete circle? Draw two arcs to complete the circle.
    if (da > tauEpsilon) {
      this._append`A${r},${r},0,1,${cw},${x - dx},${y - dy}A${r},${r},0,1,${cw},${this._x1 = x0},${this._y1 = y0}`;
    }

    // Is this arc non-empty? Draw an arc!
    else if (da > epsilon$1) {
      this._append`A${r},${r},0,${+(da >= pi$1)},${cw},${this._x1 = x + r * Math.cos(a1)},${this._y1 = y + r * Math.sin(a1)}`;
    }
  }
  rect(x, y, w, h) {
    this._append`M${this._x0 = this._x1 = +x},${this._y0 = this._y1 = +y}h${w = +w}v${+h}h${-w}Z`;
  }
  toString() {
    return this._;
  }
}

function constant$1(x) {
  return function constant() {
    return x;
  };
}

const abs$1 = Math.abs;
const atan2 = Math.atan2;
const cos = Math.cos;
const max = Math.max;
const min = Math.min;
const sin = Math.sin;
const sqrt = Math.sqrt;

const epsilon = 1e-12;
const pi = Math.PI;
const halfPi = pi / 2;
const tau = 2 * pi;

function acos(x) {
  return x > 1 ? 0 : x < -1 ? pi : Math.acos(x);
}

function asin(x) {
  return x >= 1 ? halfPi : x <= -1 ? -halfPi : Math.asin(x);
}

function withPath(shape) {
  let digits = 3;

  shape.digits = function(_) {
    if (!arguments.length) return digits;
    if (_ == null) {
      digits = null;
    } else {
      const d = Math.floor(_);
      if (!(d >= 0)) throw new RangeError(`invalid digits: ${_}`);
      digits = d;
    }
    return shape;
  };

  return () => new Path(digits);
}

function array(x) {
  return typeof x === "object" && "length" in x
    ? x // Array, TypedArray, NodeList, array-like
    : Array.from(x); // Map, Set, iterable, string, or anything else
}

function Linear(context) {
  this._context = context;
}

Linear.prototype = {
  areaStart: function() {
    this._line = 0;
  },
  areaEnd: function() {
    this._line = NaN;
  },
  lineStart: function() {
    this._point = 0;
  },
  lineEnd: function() {
    if (this._line || (this._line !== 0 && this._point === 1)) this._context.closePath();
    this._line = 1 - this._line;
  },
  point: function(x, y) {
    x = +x, y = +y;
    switch (this._point) {
      case 0: this._point = 1; this._line ? this._context.lineTo(x, y) : this._context.moveTo(x, y); break;
      case 1: this._point = 2; // falls through
      default: this._context.lineTo(x, y); break;
    }
  }
};

function curveLinear(context) {
  return new Linear(context);
}

function x$1(p) {
  return p[0];
}

function y$2(p) {
  return p[1];
}

function line$1(x, y) {
  var defined = constant$1(true),
      context = null,
      curve = curveLinear,
      output = null,
      path = withPath(line);

  x = typeof x === "function" ? x : (x === undefined) ? x$1 : constant$1(x);
  y = typeof y === "function" ? y : (y === undefined) ? y$2 : constant$1(y);

  function line(data) {
    var i,
        n = (data = array(data)).length,
        d,
        defined0 = false,
        buffer;

    if (context == null) output = curve(buffer = path());

    for (i = 0; i <= n; ++i) {
      if (!(i < n && defined(d = data[i], i, data)) === defined0) {
        if (defined0 = !defined0) output.lineStart();
        else output.lineEnd();
      }
      if (defined0) output.point(+x(d, i, data), +y(d, i, data));
    }

    if (buffer) return output = null, buffer + "" || null;
  }

  line.x = function(_) {
    return arguments.length ? (x = typeof _ === "function" ? _ : constant$1(+_), line) : x;
  };

  line.y = function(_) {
    return arguments.length ? (y = typeof _ === "function" ? _ : constant$1(+_), line) : y;
  };

  line.defined = function(_) {
    return arguments.length ? (defined = typeof _ === "function" ? _ : constant$1(!!_), line) : defined;
  };

  line.curve = function(_) {
    return arguments.length ? (curve = _, context != null && (output = curve(context)), line) : curve;
  };

  line.context = function(_) {
    return arguments.length ? (_ == null ? context = output = null : output = curve(context = _), line) : context;
  };

  return line;
}

class Bump {
  constructor(context, x) {
    this._context = context;
    this._x = x;
  }
  areaStart() {
    this._line = 0;
  }
  areaEnd() {
    this._line = NaN;
  }
  lineStart() {
    this._point = 0;
  }
  lineEnd() {
    if (this._line || (this._line !== 0 && this._point === 1)) this._context.closePath();
    this._line = 1 - this._line;
  }
  point(x, y) {
    x = +x, y = +y;
    switch (this._point) {
      case 0: {
        this._point = 1;
        if (this._line) this._context.lineTo(x, y);
        else this._context.moveTo(x, y);
        break;
      }
      case 1: this._point = 2; // falls through
      default: {
        if (this._x) this._context.bezierCurveTo(this._x0 = (this._x0 + x) / 2, this._y0, this._x0, y, x, y);
        else this._context.bezierCurveTo(this._x0, this._y0 = (this._y0 + y) / 2, x, this._y0, x, y);
        break;
      }
    }
    this._x0 = x, this._y0 = y;
  }
}

function bumpX(context) {
  return new Bump(context, true);
}

function bumpY(context) {
  return new Bump(context, false);
}

function noop() {}

function point$4(that, x, y) {
  that._context.bezierCurveTo(
    (2 * that._x0 + that._x1) / 3,
    (2 * that._y0 + that._y1) / 3,
    (that._x0 + 2 * that._x1) / 3,
    (that._y0 + 2 * that._y1) / 3,
    (that._x0 + 4 * that._x1 + x) / 6,
    (that._y0 + 4 * that._y1 + y) / 6
  );
}

function Basis(context) {
  this._context = context;
}

Basis.prototype = {
  areaStart: function() {
    this._line = 0;
  },
  areaEnd: function() {
    this._line = NaN;
  },
  lineStart: function() {
    this._x0 = this._x1 =
    this._y0 = this._y1 = NaN;
    this._point = 0;
  },
  lineEnd: function() {
    switch (this._point) {
      case 3: point$4(this, this._x1, this._y1); // falls through
      case 2: this._context.lineTo(this._x1, this._y1); break;
    }
    if (this._line || (this._line !== 0 && this._point === 1)) this._context.closePath();
    this._line = 1 - this._line;
  },
  point: function(x, y) {
    x = +x, y = +y;
    switch (this._point) {
      case 0: this._point = 1; this._line ? this._context.lineTo(x, y) : this._context.moveTo(x, y); break;
      case 1: this._point = 2; break;
      case 2: this._point = 3; this._context.lineTo((5 * this._x0 + this._x1) / 6, (5 * this._y0 + this._y1) / 6); // falls through
      default: point$4(this, x, y); break;
    }
    this._x0 = this._x1, this._x1 = x;
    this._y0 = this._y1, this._y1 = y;
  }
};

function curveBasis(context) {
  return new Basis(context);
}

function BasisClosed(context) {
  this._context = context;
}

BasisClosed.prototype = {
  areaStart: noop,
  areaEnd: noop,
  lineStart: function() {
    this._x0 = this._x1 = this._x2 = this._x3 = this._x4 =
    this._y0 = this._y1 = this._y2 = this._y3 = this._y4 = NaN;
    this._point = 0;
  },
  lineEnd: function() {
    switch (this._point) {
      case 1: {
        this._context.moveTo(this._x2, this._y2);
        this._context.closePath();
        break;
      }
      case 2: {
        this._context.moveTo((this._x2 + 2 * this._x3) / 3, (this._y2 + 2 * this._y3) / 3);
        this._context.lineTo((this._x3 + 2 * this._x2) / 3, (this._y3 + 2 * this._y2) / 3);
        this._context.closePath();
        break;
      }
      case 3: {
        this.point(this._x2, this._y2);
        this.point(this._x3, this._y3);
        this.point(this._x4, this._y4);
        break;
      }
    }
  },
  point: function(x, y) {
    x = +x, y = +y;
    switch (this._point) {
      case 0: this._point = 1; this._x2 = x, this._y2 = y; break;
      case 1: this._point = 2; this._x3 = x, this._y3 = y; break;
      case 2: this._point = 3; this._x4 = x, this._y4 = y; this._context.moveTo((this._x0 + 4 * this._x1 + x) / 6, (this._y0 + 4 * this._y1 + y) / 6); break;
      default: point$4(this, x, y); break;
    }
    this._x0 = this._x1, this._x1 = x;
    this._y0 = this._y1, this._y1 = y;
  }
};

function curveBasisClosed(context) {
  return new BasisClosed(context);
}

function BasisOpen(context) {
  this._context = context;
}

BasisOpen.prototype = {
  areaStart: function() {
    this._line = 0;
  },
  areaEnd: function() {
    this._line = NaN;
  },
  lineStart: function() {
    this._x0 = this._x1 =
    this._y0 = this._y1 = NaN;
    this._point = 0;
  },
  lineEnd: function() {
    if (this._line || (this._line !== 0 && this._point === 3)) this._context.closePath();
    this._line = 1 - this._line;
  },
  point: function(x, y) {
    x = +x, y = +y;
    switch (this._point) {
      case 0: this._point = 1; break;
      case 1: this._point = 2; break;
      case 2: this._point = 3; var x0 = (this._x0 + 4 * this._x1 + x) / 6, y0 = (this._y0 + 4 * this._y1 + y) / 6; this._line ? this._context.lineTo(x0, y0) : this._context.moveTo(x0, y0); break;
      case 3: this._point = 4; // falls through
      default: point$4(this, x, y); break;
    }
    this._x0 = this._x1, this._x1 = x;
    this._y0 = this._y1, this._y1 = y;
  }
};

function curveBasisOpen(context) {
  return new BasisOpen(context);
}

function Bundle(context, beta) {
  this._basis = new Basis(context);
  this._beta = beta;
}

Bundle.prototype = {
  lineStart: function() {
    this._x = [];
    this._y = [];
    this._basis.lineStart();
  },
  lineEnd: function() {
    var x = this._x,
        y = this._y,
        j = x.length - 1;

    if (j > 0) {
      var x0 = x[0],
          y0 = y[0],
          dx = x[j] - x0,
          dy = y[j] - y0,
          i = -1,
          t;

      while (++i <= j) {
        t = i / j;
        this._basis.point(
          this._beta * x[i] + (1 - this._beta) * (x0 + t * dx),
          this._beta * y[i] + (1 - this._beta) * (y0 + t * dy)
        );
      }
    }

    this._x = this._y = null;
    this._basis.lineEnd();
  },
  point: function(x, y) {
    this._x.push(+x);
    this._y.push(+y);
  }
};

const curveBundle = (function custom(beta) {

  function bundle(context) {
    return beta === 1 ? new Basis(context) : new Bundle(context, beta);
  }

  bundle.beta = function(beta) {
    return custom(+beta);
  };

  return bundle;
})(0.85);

function point$3(that, x, y) {
  that._context.bezierCurveTo(
    that._x1 + that._k * (that._x2 - that._x0),
    that._y1 + that._k * (that._y2 - that._y0),
    that._x2 + that._k * (that._x1 - x),
    that._y2 + that._k * (that._y1 - y),
    that._x2,
    that._y2
  );
}

function Cardinal(context, tension) {
  this._context = context;
  this._k = (1 - tension) / 6;
}

Cardinal.prototype = {
  areaStart: function() {
    this._line = 0;
  },
  areaEnd: function() {
    this._line = NaN;
  },
  lineStart: function() {
    this._x0 = this._x1 = this._x2 =
    this._y0 = this._y1 = this._y2 = NaN;
    this._point = 0;
  },
  lineEnd: function() {
    switch (this._point) {
      case 2: this._context.lineTo(this._x2, this._y2); break;
      case 3: point$3(this, this._x1, this._y1); break;
    }
    if (this._line || (this._line !== 0 && this._point === 1)) this._context.closePath();
    this._line = 1 - this._line;
  },
  point: function(x, y) {
    x = +x, y = +y;
    switch (this._point) {
      case 0: this._point = 1; this._line ? this._context.lineTo(x, y) : this._context.moveTo(x, y); break;
      case 1: this._point = 2; this._x1 = x, this._y1 = y; break;
      case 2: this._point = 3; // falls through
      default: point$3(this, x, y); break;
    }
    this._x0 = this._x1, this._x1 = this._x2, this._x2 = x;
    this._y0 = this._y1, this._y1 = this._y2, this._y2 = y;
  }
};

const curveCardinal = (function custom(tension) {

  function cardinal(context) {
    return new Cardinal(context, tension);
  }

  cardinal.tension = function(tension) {
    return custom(+tension);
  };

  return cardinal;
})(0);

function CardinalClosed(context, tension) {
  this._context = context;
  this._k = (1 - tension) / 6;
}

CardinalClosed.prototype = {
  areaStart: noop,
  areaEnd: noop,
  lineStart: function() {
    this._x0 = this._x1 = this._x2 = this._x3 = this._x4 = this._x5 =
    this._y0 = this._y1 = this._y2 = this._y3 = this._y4 = this._y5 = NaN;
    this._point = 0;
  },
  lineEnd: function() {
    switch (this._point) {
      case 1: {
        this._context.moveTo(this._x3, this._y3);
        this._context.closePath();
        break;
      }
      case 2: {
        this._context.lineTo(this._x3, this._y3);
        this._context.closePath();
        break;
      }
      case 3: {
        this.point(this._x3, this._y3);
        this.point(this._x4, this._y4);
        this.point(this._x5, this._y5);
        break;
      }
    }
  },
  point: function(x, y) {
    x = +x, y = +y;
    switch (this._point) {
      case 0: this._point = 1; this._x3 = x, this._y3 = y; break;
      case 1: this._point = 2; this._context.moveTo(this._x4 = x, this._y4 = y); break;
      case 2: this._point = 3; this._x5 = x, this._y5 = y; break;
      default: point$3(this, x, y); break;
    }
    this._x0 = this._x1, this._x1 = this._x2, this._x2 = x;
    this._y0 = this._y1, this._y1 = this._y2, this._y2 = y;
  }
};

const curveCardinalClosed = (function custom(tension) {

  function cardinal(context) {
    return new CardinalClosed(context, tension);
  }

  cardinal.tension = function(tension) {
    return custom(+tension);
  };

  return cardinal;
})(0);

function CardinalOpen(context, tension) {
  this._context = context;
  this._k = (1 - tension) / 6;
}

CardinalOpen.prototype = {
  areaStart: function() {
    this._line = 0;
  },
  areaEnd: function() {
    this._line = NaN;
  },
  lineStart: function() {
    this._x0 = this._x1 = this._x2 =
    this._y0 = this._y1 = this._y2 = NaN;
    this._point = 0;
  },
  lineEnd: function() {
    if (this._line || (this._line !== 0 && this._point === 3)) this._context.closePath();
    this._line = 1 - this._line;
  },
  point: function(x, y) {
    x = +x, y = +y;
    switch (this._point) {
      case 0: this._point = 1; break;
      case 1: this._point = 2; break;
      case 2: this._point = 3; this._line ? this._context.lineTo(this._x2, this._y2) : this._context.moveTo(this._x2, this._y2); break;
      case 3: this._point = 4; // falls through
      default: point$3(this, x, y); break;
    }
    this._x0 = this._x1, this._x1 = this._x2, this._x2 = x;
    this._y0 = this._y1, this._y1 = this._y2, this._y2 = y;
  }
};

const curveCardinalOpen = (function custom(tension) {

  function cardinal(context) {
    return new CardinalOpen(context, tension);
  }

  cardinal.tension = function(tension) {
    return custom(+tension);
  };

  return cardinal;
})(0);

function point$2(that, x, y) {
  var x1 = that._x1,
      y1 = that._y1,
      x2 = that._x2,
      y2 = that._y2;

  if (that._l01_a > epsilon) {
    var a = 2 * that._l01_2a + 3 * that._l01_a * that._l12_a + that._l12_2a,
        n = 3 * that._l01_a * (that._l01_a + that._l12_a);
    x1 = (x1 * a - that._x0 * that._l12_2a + that._x2 * that._l01_2a) / n;
    y1 = (y1 * a - that._y0 * that._l12_2a + that._y2 * that._l01_2a) / n;
  }

  if (that._l23_a > epsilon) {
    var b = 2 * that._l23_2a + 3 * that._l23_a * that._l12_a + that._l12_2a,
        m = 3 * that._l23_a * (that._l23_a + that._l12_a);
    x2 = (x2 * b + that._x1 * that._l23_2a - x * that._l12_2a) / m;
    y2 = (y2 * b + that._y1 * that._l23_2a - y * that._l12_2a) / m;
  }

  that._context.bezierCurveTo(x1, y1, x2, y2, that._x2, that._y2);
}

function CatmullRom(context, alpha) {
  this._context = context;
  this._alpha = alpha;
}

CatmullRom.prototype = {
  areaStart: function() {
    this._line = 0;
  },
  areaEnd: function() {
    this._line = NaN;
  },
  lineStart: function() {
    this._x0 = this._x1 = this._x2 =
    this._y0 = this._y1 = this._y2 = NaN;
    this._l01_a = this._l12_a = this._l23_a =
    this._l01_2a = this._l12_2a = this._l23_2a =
    this._point = 0;
  },
  lineEnd: function() {
    switch (this._point) {
      case 2: this._context.lineTo(this._x2, this._y2); break;
      case 3: this.point(this._x2, this._y2); break;
    }
    if (this._line || (this._line !== 0 && this._point === 1)) this._context.closePath();
    this._line = 1 - this._line;
  },
  point: function(x, y) {
    x = +x, y = +y;

    if (this._point) {
      var x23 = this._x2 - x,
          y23 = this._y2 - y;
      this._l23_a = Math.sqrt(this._l23_2a = Math.pow(x23 * x23 + y23 * y23, this._alpha));
    }

    switch (this._point) {
      case 0: this._point = 1; this._line ? this._context.lineTo(x, y) : this._context.moveTo(x, y); break;
      case 1: this._point = 2; break;
      case 2: this._point = 3; // falls through
      default: point$2(this, x, y); break;
    }

    this._l01_a = this._l12_a, this._l12_a = this._l23_a;
    this._l01_2a = this._l12_2a, this._l12_2a = this._l23_2a;
    this._x0 = this._x1, this._x1 = this._x2, this._x2 = x;
    this._y0 = this._y1, this._y1 = this._y2, this._y2 = y;
  }
};

const curveCatmullRom = (function custom(alpha) {

  function catmullRom(context) {
    return alpha ? new CatmullRom(context, alpha) : new Cardinal(context, 0);
  }

  catmullRom.alpha = function(alpha) {
    return custom(+alpha);
  };

  return catmullRom;
})(0.5);

function CatmullRomClosed(context, alpha) {
  this._context = context;
  this._alpha = alpha;
}

CatmullRomClosed.prototype = {
  areaStart: noop,
  areaEnd: noop,
  lineStart: function() {
    this._x0 = this._x1 = this._x2 = this._x3 = this._x4 = this._x5 =
    this._y0 = this._y1 = this._y2 = this._y3 = this._y4 = this._y5 = NaN;
    this._l01_a = this._l12_a = this._l23_a =
    this._l01_2a = this._l12_2a = this._l23_2a =
    this._point = 0;
  },
  lineEnd: function() {
    switch (this._point) {
      case 1: {
        this._context.moveTo(this._x3, this._y3);
        this._context.closePath();
        break;
      }
      case 2: {
        this._context.lineTo(this._x3, this._y3);
        this._context.closePath();
        break;
      }
      case 3: {
        this.point(this._x3, this._y3);
        this.point(this._x4, this._y4);
        this.point(this._x5, this._y5);
        break;
      }
    }
  },
  point: function(x, y) {
    x = +x, y = +y;

    if (this._point) {
      var x23 = this._x2 - x,
          y23 = this._y2 - y;
      this._l23_a = Math.sqrt(this._l23_2a = Math.pow(x23 * x23 + y23 * y23, this._alpha));
    }

    switch (this._point) {
      case 0: this._point = 1; this._x3 = x, this._y3 = y; break;
      case 1: this._point = 2; this._context.moveTo(this._x4 = x, this._y4 = y); break;
      case 2: this._point = 3; this._x5 = x, this._y5 = y; break;
      default: point$2(this, x, y); break;
    }

    this._l01_a = this._l12_a, this._l12_a = this._l23_a;
    this._l01_2a = this._l12_2a, this._l12_2a = this._l23_2a;
    this._x0 = this._x1, this._x1 = this._x2, this._x2 = x;
    this._y0 = this._y1, this._y1 = this._y2, this._y2 = y;
  }
};

const curveCatmullRomClosed = (function custom(alpha) {

  function catmullRom(context) {
    return alpha ? new CatmullRomClosed(context, alpha) : new CardinalClosed(context, 0);
  }

  catmullRom.alpha = function(alpha) {
    return custom(+alpha);
  };

  return catmullRom;
})(0.5);

function CatmullRomOpen(context, alpha) {
  this._context = context;
  this._alpha = alpha;
}

CatmullRomOpen.prototype = {
  areaStart: function() {
    this._line = 0;
  },
  areaEnd: function() {
    this._line = NaN;
  },
  lineStart: function() {
    this._x0 = this._x1 = this._x2 =
    this._y0 = this._y1 = this._y2 = NaN;
    this._l01_a = this._l12_a = this._l23_a =
    this._l01_2a = this._l12_2a = this._l23_2a =
    this._point = 0;
  },
  lineEnd: function() {
    if (this._line || (this._line !== 0 && this._point === 3)) this._context.closePath();
    this._line = 1 - this._line;
  },
  point: function(x, y) {
    x = +x, y = +y;

    if (this._point) {
      var x23 = this._x2 - x,
          y23 = this._y2 - y;
      this._l23_a = Math.sqrt(this._l23_2a = Math.pow(x23 * x23 + y23 * y23, this._alpha));
    }

    switch (this._point) {
      case 0: this._point = 1; break;
      case 1: this._point = 2; break;
      case 2: this._point = 3; this._line ? this._context.lineTo(this._x2, this._y2) : this._context.moveTo(this._x2, this._y2); break;
      case 3: this._point = 4; // falls through
      default: point$2(this, x, y); break;
    }

    this._l01_a = this._l12_a, this._l12_a = this._l23_a;
    this._l01_2a = this._l12_2a, this._l12_2a = this._l23_2a;
    this._x0 = this._x1, this._x1 = this._x2, this._x2 = x;
    this._y0 = this._y1, this._y1 = this._y2, this._y2 = y;
  }
};

const curveCatmullRomOpen = (function custom(alpha) {

  function catmullRom(context) {
    return alpha ? new CatmullRomOpen(context, alpha) : new CardinalOpen(context, 0);
  }

  catmullRom.alpha = function(alpha) {
    return custom(+alpha);
  };

  return catmullRom;
})(0.5);

function LinearClosed(context) {
  this._context = context;
}

LinearClosed.prototype = {
  areaStart: noop,
  areaEnd: noop,
  lineStart: function() {
    this._point = 0;
  },
  lineEnd: function() {
    if (this._point) this._context.closePath();
  },
  point: function(x, y) {
    x = +x, y = +y;
    if (this._point) this._context.lineTo(x, y);
    else this._point = 1, this._context.moveTo(x, y);
  }
};

function curveLinearClosed(context) {
  return new LinearClosed(context);
}

function sign(x) {
  return x < 0 ? -1 : 1;
}

// Calculate the slopes of the tangents (Hermite-type interpolation) based on
// the following paper: Steffen, M. 1990. A Simple Method for Monotonic
// Interpolation in One Dimension. Astronomy and Astrophysics, Vol. 239, NO.
// NOV(II), P. 443, 1990.
function slope3(that, x2, y2) {
  var h0 = that._x1 - that._x0,
      h1 = x2 - that._x1,
      s0 = (that._y1 - that._y0) / (h0 || h1 < 0 && -0),
      s1 = (y2 - that._y1) / (h1 || h0 < 0 && -0),
      p = (s0 * h1 + s1 * h0) / (h0 + h1);
  return (sign(s0) + sign(s1)) * Math.min(Math.abs(s0), Math.abs(s1), 0.5 * Math.abs(p)) || 0;
}

// Calculate a one-sided slope.
function slope2(that, t) {
  var h = that._x1 - that._x0;
  return h ? (3 * (that._y1 - that._y0) / h - t) / 2 : t;
}

// According to https://en.wikipedia.org/wiki/Cubic_Hermite_spline#Representations
// "you can express cubic Hermite interpolation in terms of cubic Bézier curves
// with respect to the four values p0, p0 + m0 / 3, p1 - m1 / 3, p1".
function point$1(that, t0, t1) {
  var x0 = that._x0,
      y0 = that._y0,
      x1 = that._x1,
      y1 = that._y1,
      dx = (x1 - x0) / 3;
  that._context.bezierCurveTo(x0 + dx, y0 + dx * t0, x1 - dx, y1 - dx * t1, x1, y1);
}

function MonotoneX(context) {
  this._context = context;
}

MonotoneX.prototype = {
  areaStart: function() {
    this._line = 0;
  },
  areaEnd: function() {
    this._line = NaN;
  },
  lineStart: function() {
    this._x0 = this._x1 =
    this._y0 = this._y1 =
    this._t0 = NaN;
    this._point = 0;
  },
  lineEnd: function() {
    switch (this._point) {
      case 2: this._context.lineTo(this._x1, this._y1); break;
      case 3: point$1(this, this._t0, slope2(this, this._t0)); break;
    }
    if (this._line || (this._line !== 0 && this._point === 1)) this._context.closePath();
    this._line = 1 - this._line;
  },
  point: function(x, y) {
    var t1 = NaN;

    x = +x, y = +y;
    if (x === this._x1 && y === this._y1) return; // Ignore coincident points.
    switch (this._point) {
      case 0: this._point = 1; this._line ? this._context.lineTo(x, y) : this._context.moveTo(x, y); break;
      case 1: this._point = 2; break;
      case 2: this._point = 3; point$1(this, slope2(this, t1 = slope3(this, x, y)), t1); break;
      default: point$1(this, this._t0, t1 = slope3(this, x, y)); break;
    }

    this._x0 = this._x1, this._x1 = x;
    this._y0 = this._y1, this._y1 = y;
    this._t0 = t1;
  }
};

function MonotoneY(context) {
  this._context = new ReflectContext(context);
}

(MonotoneY.prototype = Object.create(MonotoneX.prototype)).point = function(x, y) {
  MonotoneX.prototype.point.call(this, y, x);
};

function ReflectContext(context) {
  this._context = context;
}

ReflectContext.prototype = {
  moveTo: function(x, y) { this._context.moveTo(y, x); },
  closePath: function() { this._context.closePath(); },
  lineTo: function(x, y) { this._context.lineTo(y, x); },
  bezierCurveTo: function(x1, y1, x2, y2, x, y) { this._context.bezierCurveTo(y1, x1, y2, x2, y, x); }
};

function monotoneX(context) {
  return new MonotoneX(context);
}

function monotoneY(context) {
  return new MonotoneY(context);
}

function Natural(context) {
  this._context = context;
}

Natural.prototype = {
  areaStart: function() {
    this._line = 0;
  },
  areaEnd: function() {
    this._line = NaN;
  },
  lineStart: function() {
    this._x = [];
    this._y = [];
  },
  lineEnd: function() {
    var x = this._x,
        y = this._y,
        n = x.length;

    if (n) {
      this._line ? this._context.lineTo(x[0], y[0]) : this._context.moveTo(x[0], y[0]);
      if (n === 2) {
        this._context.lineTo(x[1], y[1]);
      } else {
        var px = controlPoints(x),
            py = controlPoints(y);
        for (var i0 = 0, i1 = 1; i1 < n; ++i0, ++i1) {
          this._context.bezierCurveTo(px[0][i0], py[0][i0], px[1][i0], py[1][i0], x[i1], y[i1]);
        }
      }
    }

    if (this._line || (this._line !== 0 && n === 1)) this._context.closePath();
    this._line = 1 - this._line;
    this._x = this._y = null;
  },
  point: function(x, y) {
    this._x.push(+x);
    this._y.push(+y);
  }
};

// See https://www.particleincell.com/2012/bezier-splines/ for derivation.
function controlPoints(x) {
  var i,
      n = x.length - 1,
      m,
      a = new Array(n),
      b = new Array(n),
      r = new Array(n);
  a[0] = 0, b[0] = 2, r[0] = x[0] + 2 * x[1];
  for (i = 1; i < n - 1; ++i) a[i] = 1, b[i] = 4, r[i] = 4 * x[i] + 2 * x[i + 1];
  a[n - 1] = 2, b[n - 1] = 7, r[n - 1] = 8 * x[n - 1] + x[n];
  for (i = 1; i < n; ++i) m = a[i] / b[i - 1], b[i] -= m, r[i] -= m * r[i - 1];
  a[n - 1] = r[n - 1] / b[n - 1];
  for (i = n - 2; i >= 0; --i) a[i] = (r[i] - a[i + 1]) / b[i];
  b[n - 1] = (x[n] + a[n - 1]) / 2;
  for (i = 0; i < n - 1; ++i) b[i] = 2 * x[i + 1] - a[i + 1];
  return [a, b];
}

function curveNatural(context) {
  return new Natural(context);
}

function Step(context, t) {
  this._context = context;
  this._t = t;
}

Step.prototype = {
  areaStart: function() {
    this._line = 0;
  },
  areaEnd: function() {
    this._line = NaN;
  },
  lineStart: function() {
    this._x = this._y = NaN;
    this._point = 0;
  },
  lineEnd: function() {
    if (0 < this._t && this._t < 1 && this._point === 2) this._context.lineTo(this._x, this._y);
    if (this._line || (this._line !== 0 && this._point === 1)) this._context.closePath();
    if (this._line >= 0) this._t = 1 - this._t, this._line = 1 - this._line;
  },
  point: function(x, y) {
    x = +x, y = +y;
    switch (this._point) {
      case 0: this._point = 1; this._line ? this._context.lineTo(x, y) : this._context.moveTo(x, y); break;
      case 1: this._point = 2; // falls through
      default: {
        if (this._t <= 0) {
          this._context.lineTo(this._x, y);
          this._context.lineTo(x, y);
        } else {
          var x1 = this._x * (1 - this._t) + x * this._t;
          this._context.lineTo(x1, this._y);
          this._context.lineTo(x1, y);
        }
        break;
      }
    }
    this._x = x, this._y = y;
  }
};

function curveStep(context) {
  return new Step(context, 0.5);
}

function stepBefore(context) {
  return new Step(context, 0);
}

function stepAfter(context) {
  return new Step(context, 1);
}

function Transform(k, x, y) {
  this.k = k;
  this.x = x;
  this.y = y;
}

Transform.prototype = {
  constructor: Transform,
  scale: function(k) {
    return k === 1 ? this : new Transform(this.k * k, this.x, this.y);
  },
  translate: function(x, y) {
    return x === 0 & y === 0 ? this : new Transform(this.k, this.x + this.k * x, this.y + this.k * y);
  },
  apply: function(point) {
    return [point[0] * this.k + this.x, point[1] * this.k + this.y];
  },
  applyX: function(x) {
    return x * this.k + this.x;
  },
  applyY: function(y) {
    return y * this.k + this.y;
  },
  invert: function(location) {
    return [(location[0] - this.x) / this.k, (location[1] - this.y) / this.k];
  },
  invertX: function(x) {
    return (x - this.x) / this.k;
  },
  invertY: function(y) {
    return (y - this.y) / this.k;
  },
  rescaleX: function(x) {
    return x.copy().domain(x.range().map(this.invertX, this).map(x.invert, x));
  },
  rescaleY: function(y) {
    return y.copy().domain(y.range().map(this.invertY, this).map(y.invert, y));
  },
  toString: function() {
    return "translate(" + this.x + "," + this.y + ") scale(" + this.k + ")";
  }
};

Transform.prototype;

/** Detect free variable `global` from Node.js. */
var freeGlobal = typeof global == 'object' && global && global.Object === Object && global;

/** Detect free variable `self`. */
var freeSelf = typeof self == 'object' && self && self.Object === Object && self;

/** Used as a reference to the global object. */
var root = freeGlobal || freeSelf || Function('return this')();

/** Built-in value references. */
var Symbol$1 = root.Symbol;

/** Used for built-in method references. */
var objectProto$c = Object.prototype;

/** Used to check objects for own properties. */
var hasOwnProperty$a = objectProto$c.hasOwnProperty;

/**
 * Used to resolve the
 * [`toStringTag`](http://ecma-international.org/ecma-262/7.0/#sec-object.prototype.tostring)
 * of values.
 */
var nativeObjectToString$1 = objectProto$c.toString;

/** Built-in value references. */
var symToStringTag$1 = Symbol$1 ? Symbol$1.toStringTag : undefined;

/**
 * A specialized version of `baseGetTag` which ignores `Symbol.toStringTag` values.
 *
 * @private
 * @param {*} value The value to query.
 * @returns {string} Returns the raw `toStringTag`.
 */
function getRawTag(value) {
  var isOwn = hasOwnProperty$a.call(value, symToStringTag$1),
      tag = value[symToStringTag$1];

  try {
    value[symToStringTag$1] = undefined;
    var unmasked = true;
  } catch (e) {}

  var result = nativeObjectToString$1.call(value);
  if (unmasked) {
    if (isOwn) {
      value[symToStringTag$1] = tag;
    } else {
      delete value[symToStringTag$1];
    }
  }
  return result;
}

/** Used for built-in method references. */
var objectProto$b = Object.prototype;

/**
 * Used to resolve the
 * [`toStringTag`](http://ecma-international.org/ecma-262/7.0/#sec-object.prototype.tostring)
 * of values.
 */
var nativeObjectToString = objectProto$b.toString;

/**
 * Converts `value` to a string using `Object.prototype.toString`.
 *
 * @private
 * @param {*} value The value to convert.
 * @returns {string} Returns the converted string.
 */
function objectToString(value) {
  return nativeObjectToString.call(value);
}

/** `Object#toString` result references. */
var nullTag = '[object Null]',
    undefinedTag = '[object Undefined]';

/** Built-in value references. */
var symToStringTag = Symbol$1 ? Symbol$1.toStringTag : undefined;

/**
 * The base implementation of `getTag` without fallbacks for buggy environments.
 *
 * @private
 * @param {*} value The value to query.
 * @returns {string} Returns the `toStringTag`.
 */
function baseGetTag(value) {
  if (value == null) {
    return value === undefined ? undefinedTag : nullTag;
  }
  return (symToStringTag && symToStringTag in Object(value))
    ? getRawTag(value)
    : objectToString(value);
}

/**
 * Checks if `value` is the
 * [language type](http://www.ecma-international.org/ecma-262/7.0/#sec-ecmascript-language-types)
 * of `Object`. (e.g. arrays, functions, objects, regexes, `new Number(0)`, and `new String('')`)
 *
 * @static
 * @memberOf _
 * @since 0.1.0
 * @category Lang
 * @param {*} value The value to check.
 * @returns {boolean} Returns `true` if `value` is an object, else `false`.
 * @example
 *
 * _.isObject({});
 * // => true
 *
 * _.isObject([1, 2, 3]);
 * // => true
 *
 * _.isObject(_.noop);
 * // => true
 *
 * _.isObject(null);
 * // => false
 */
function isObject(value) {
  var type = typeof value;
  return value != null && (type == 'object' || type == 'function');
}

/** `Object#toString` result references. */
var asyncTag = '[object AsyncFunction]',
    funcTag$1 = '[object Function]',
    genTag = '[object GeneratorFunction]',
    proxyTag = '[object Proxy]';

/**
 * Checks if `value` is classified as a `Function` object.
 *
 * @static
 * @memberOf _
 * @since 0.1.0
 * @category Lang
 * @param {*} value The value to check.
 * @returns {boolean} Returns `true` if `value` is a function, else `false`.
 * @example
 *
 * _.isFunction(_);
 * // => true
 *
 * _.isFunction(/abc/);
 * // => false
 */
function isFunction(value) {
  if (!isObject(value)) {
    return false;
  }
  // The use of `Object#toString` avoids issues with the `typeof` operator
  // in Safari 9 which returns 'object' for typed arrays and other constructors.
  var tag = baseGetTag(value);
  return tag == funcTag$1 || tag == genTag || tag == asyncTag || tag == proxyTag;
}

/** Used to detect overreaching core-js shims. */
var coreJsData = root['__core-js_shared__'];

/** Used to detect methods masquerading as native. */
var maskSrcKey = (function() {
  var uid = /[^.]+$/.exec(coreJsData && coreJsData.keys && coreJsData.keys.IE_PROTO || '');
  return uid ? ('Symbol(src)_1.' + uid) : '';
}());

/**
 * Checks if `func` has its source masked.
 *
 * @private
 * @param {Function} func The function to check.
 * @returns {boolean} Returns `true` if `func` is masked, else `false`.
 */
function isMasked(func) {
  return !!maskSrcKey && (maskSrcKey in func);
}

/** Used for built-in method references. */
var funcProto$2 = Function.prototype;

/** Used to resolve the decompiled source of functions. */
var funcToString$2 = funcProto$2.toString;

/**
 * Converts `func` to its source code.
 *
 * @private
 * @param {Function} func The function to convert.
 * @returns {string} Returns the source code.
 */
function toSource(func) {
  if (func != null) {
    try {
      return funcToString$2.call(func);
    } catch (e) {}
    try {
      return (func + '');
    } catch (e) {}
  }
  return '';
}

/**
 * Used to match `RegExp`
 * [syntax characters](http://ecma-international.org/ecma-262/7.0/#sec-patterns).
 */
var reRegExpChar = /[\\^$.*+?()[\]{}|]/g;

/** Used to detect host constructors (Safari). */
var reIsHostCtor = /^\[object .+?Constructor\]$/;

/** Used for built-in method references. */
var funcProto$1 = Function.prototype,
    objectProto$a = Object.prototype;

/** Used to resolve the decompiled source of functions. */
var funcToString$1 = funcProto$1.toString;

/** Used to check objects for own properties. */
var hasOwnProperty$9 = objectProto$a.hasOwnProperty;

/** Used to detect if a method is native. */
var reIsNative = RegExp('^' +
  funcToString$1.call(hasOwnProperty$9).replace(reRegExpChar, '\\$&')
  .replace(/hasOwnProperty|(function).*?(?=\\\()| for .+?(?=\\\])/g, '$1.*?') + '$'
);

/**
 * The base implementation of `_.isNative` without bad shim checks.
 *
 * @private
 * @param {*} value The value to check.
 * @returns {boolean} Returns `true` if `value` is a native function,
 *  else `false`.
 */
function baseIsNative(value) {
  if (!isObject(value) || isMasked(value)) {
    return false;
  }
  var pattern = isFunction(value) ? reIsNative : reIsHostCtor;
  return pattern.test(toSource(value));
}

/**
 * Gets the value at `key` of `object`.
 *
 * @private
 * @param {Object} [object] The object to query.
 * @param {string} key The key of the property to get.
 * @returns {*} Returns the property value.
 */
function getValue(object, key) {
  return object == null ? undefined : object[key];
}

/**
 * Gets the native function at `key` of `object`.
 *
 * @private
 * @param {Object} object The object to query.
 * @param {string} key The key of the method to get.
 * @returns {*} Returns the function if it's native, else `undefined`.
 */
function getNative(object, key) {
  var value = getValue(object, key);
  return baseIsNative(value) ? value : undefined;
}

/* Built-in method references that are verified to be native. */
var nativeCreate = getNative(Object, 'create');

/**
 * Removes all key-value entries from the hash.
 *
 * @private
 * @name clear
 * @memberOf Hash
 */
function hashClear() {
  this.__data__ = nativeCreate ? nativeCreate(null) : {};
  this.size = 0;
}

/**
 * Removes `key` and its value from the hash.
 *
 * @private
 * @name delete
 * @memberOf Hash
 * @param {Object} hash The hash to modify.
 * @param {string} key The key of the value to remove.
 * @returns {boolean} Returns `true` if the entry was removed, else `false`.
 */
function hashDelete(key) {
  var result = this.has(key) && delete this.__data__[key];
  this.size -= result ? 1 : 0;
  return result;
}

/** Used to stand-in for `undefined` hash values. */
var HASH_UNDEFINED$1 = '__lodash_hash_undefined__';

/** Used for built-in method references. */
var objectProto$9 = Object.prototype;

/** Used to check objects for own properties. */
var hasOwnProperty$8 = objectProto$9.hasOwnProperty;

/**
 * Gets the hash value for `key`.
 *
 * @private
 * @name get
 * @memberOf Hash
 * @param {string} key The key of the value to get.
 * @returns {*} Returns the entry value.
 */
function hashGet(key) {
  var data = this.__data__;
  if (nativeCreate) {
    var result = data[key];
    return result === HASH_UNDEFINED$1 ? undefined : result;
  }
  return hasOwnProperty$8.call(data, key) ? data[key] : undefined;
}

/** Used for built-in method references. */
var objectProto$8 = Object.prototype;

/** Used to check objects for own properties. */
var hasOwnProperty$7 = objectProto$8.hasOwnProperty;

/**
 * Checks if a hash value for `key` exists.
 *
 * @private
 * @name has
 * @memberOf Hash
 * @param {string} key The key of the entry to check.
 * @returns {boolean} Returns `true` if an entry for `key` exists, else `false`.
 */
function hashHas(key) {
  var data = this.__data__;
  return nativeCreate ? (data[key] !== undefined) : hasOwnProperty$7.call(data, key);
}

/** Used to stand-in for `undefined` hash values. */
var HASH_UNDEFINED = '__lodash_hash_undefined__';

/**
 * Sets the hash `key` to `value`.
 *
 * @private
 * @name set
 * @memberOf Hash
 * @param {string} key The key of the value to set.
 * @param {*} value The value to set.
 * @returns {Object} Returns the hash instance.
 */
function hashSet(key, value) {
  var data = this.__data__;
  this.size += this.has(key) ? 0 : 1;
  data[key] = (nativeCreate && value === undefined) ? HASH_UNDEFINED : value;
  return this;
}

/**
 * Creates a hash object.
 *
 * @private
 * @constructor
 * @param {Array} [entries] The key-value pairs to cache.
 */
function Hash(entries) {
  var index = -1,
      length = entries == null ? 0 : entries.length;

  this.clear();
  while (++index < length) {
    var entry = entries[index];
    this.set(entry[0], entry[1]);
  }
}

// Add methods to `Hash`.
Hash.prototype.clear = hashClear;
Hash.prototype['delete'] = hashDelete;
Hash.prototype.get = hashGet;
Hash.prototype.has = hashHas;
Hash.prototype.set = hashSet;

/**
 * Removes all key-value entries from the list cache.
 *
 * @private
 * @name clear
 * @memberOf ListCache
 */
function listCacheClear() {
  this.__data__ = [];
  this.size = 0;
}

/**
 * Performs a
 * [`SameValueZero`](http://ecma-international.org/ecma-262/7.0/#sec-samevaluezero)
 * comparison between two values to determine if they are equivalent.
 *
 * @static
 * @memberOf _
 * @since 4.0.0
 * @category Lang
 * @param {*} value The value to compare.
 * @param {*} other The other value to compare.
 * @returns {boolean} Returns `true` if the values are equivalent, else `false`.
 * @example
 *
 * var object = { 'a': 1 };
 * var other = { 'a': 1 };
 *
 * _.eq(object, object);
 * // => true
 *
 * _.eq(object, other);
 * // => false
 *
 * _.eq('a', 'a');
 * // => true
 *
 * _.eq('a', Object('a'));
 * // => false
 *
 * _.eq(NaN, NaN);
 * // => true
 */
function eq(value, other) {
  return value === other || (value !== value && other !== other);
}

/**
 * Gets the index at which the `key` is found in `array` of key-value pairs.
 *
 * @private
 * @param {Array} array The array to inspect.
 * @param {*} key The key to search for.
 * @returns {number} Returns the index of the matched value, else `-1`.
 */
function assocIndexOf(array, key) {
  var length = array.length;
  while (length--) {
    if (eq(array[length][0], key)) {
      return length;
    }
  }
  return -1;
}

/** Used for built-in method references. */
var arrayProto = Array.prototype;

/** Built-in value references. */
var splice = arrayProto.splice;

/**
 * Removes `key` and its value from the list cache.
 *
 * @private
 * @name delete
 * @memberOf ListCache
 * @param {string} key The key of the value to remove.
 * @returns {boolean} Returns `true` if the entry was removed, else `false`.
 */
function listCacheDelete(key) {
  var data = this.__data__,
      index = assocIndexOf(data, key);

  if (index < 0) {
    return false;
  }
  var lastIndex = data.length - 1;
  if (index == lastIndex) {
    data.pop();
  } else {
    splice.call(data, index, 1);
  }
  --this.size;
  return true;
}

/**
 * Gets the list cache value for `key`.
 *
 * @private
 * @name get
 * @memberOf ListCache
 * @param {string} key The key of the value to get.
 * @returns {*} Returns the entry value.
 */
function listCacheGet(key) {
  var data = this.__data__,
      index = assocIndexOf(data, key);

  return index < 0 ? undefined : data[index][1];
}

/**
 * Checks if a list cache value for `key` exists.
 *
 * @private
 * @name has
 * @memberOf ListCache
 * @param {string} key The key of the entry to check.
 * @returns {boolean} Returns `true` if an entry for `key` exists, else `false`.
 */
function listCacheHas(key) {
  return assocIndexOf(this.__data__, key) > -1;
}

/**
 * Sets the list cache `key` to `value`.
 *
 * @private
 * @name set
 * @memberOf ListCache
 * @param {string} key The key of the value to set.
 * @param {*} value The value to set.
 * @returns {Object} Returns the list cache instance.
 */
function listCacheSet(key, value) {
  var data = this.__data__,
      index = assocIndexOf(data, key);

  if (index < 0) {
    ++this.size;
    data.push([key, value]);
  } else {
    data[index][1] = value;
  }
  return this;
}

/**
 * Creates an list cache object.
 *
 * @private
 * @constructor
 * @param {Array} [entries] The key-value pairs to cache.
 */
function ListCache(entries) {
  var index = -1,
      length = entries == null ? 0 : entries.length;

  this.clear();
  while (++index < length) {
    var entry = entries[index];
    this.set(entry[0], entry[1]);
  }
}

// Add methods to `ListCache`.
ListCache.prototype.clear = listCacheClear;
ListCache.prototype['delete'] = listCacheDelete;
ListCache.prototype.get = listCacheGet;
ListCache.prototype.has = listCacheHas;
ListCache.prototype.set = listCacheSet;

/* Built-in method references that are verified to be native. */
var Map$1 = getNative(root, 'Map');

/**
 * Removes all key-value entries from the map.
 *
 * @private
 * @name clear
 * @memberOf MapCache
 */
function mapCacheClear() {
  this.size = 0;
  this.__data__ = {
    'hash': new Hash,
    'map': new (Map$1 || ListCache),
    'string': new Hash
  };
}

/**
 * Checks if `value` is suitable for use as unique object key.
 *
 * @private
 * @param {*} value The value to check.
 * @returns {boolean} Returns `true` if `value` is suitable, else `false`.
 */
function isKeyable(value) {
  var type = typeof value;
  return (type == 'string' || type == 'number' || type == 'symbol' || type == 'boolean')
    ? (value !== '__proto__')
    : (value === null);
}

/**
 * Gets the data for `map`.
 *
 * @private
 * @param {Object} map The map to query.
 * @param {string} key The reference key.
 * @returns {*} Returns the map data.
 */
function getMapData(map, key) {
  var data = map.__data__;
  return isKeyable(key)
    ? data[typeof key == 'string' ? 'string' : 'hash']
    : data.map;
}

/**
 * Removes `key` and its value from the map.
 *
 * @private
 * @name delete
 * @memberOf MapCache
 * @param {string} key The key of the value to remove.
 * @returns {boolean} Returns `true` if the entry was removed, else `false`.
 */
function mapCacheDelete(key) {
  var result = getMapData(this, key)['delete'](key);
  this.size -= result ? 1 : 0;
  return result;
}

/**
 * Gets the map value for `key`.
 *
 * @private
 * @name get
 * @memberOf MapCache
 * @param {string} key The key of the value to get.
 * @returns {*} Returns the entry value.
 */
function mapCacheGet(key) {
  return getMapData(this, key).get(key);
}

/**
 * Checks if a map value for `key` exists.
 *
 * @private
 * @name has
 * @memberOf MapCache
 * @param {string} key The key of the entry to check.
 * @returns {boolean} Returns `true` if an entry for `key` exists, else `false`.
 */
function mapCacheHas(key) {
  return getMapData(this, key).has(key);
}

/**
 * Sets the map `key` to `value`.
 *
 * @private
 * @name set
 * @memberOf MapCache
 * @param {string} key The key of the value to set.
 * @param {*} value The value to set.
 * @returns {Object} Returns the map cache instance.
 */
function mapCacheSet(key, value) {
  var data = getMapData(this, key),
      size = data.size;

  data.set(key, value);
  this.size += data.size == size ? 0 : 1;
  return this;
}

/**
 * Creates a map cache object to store key-value pairs.
 *
 * @private
 * @constructor
 * @param {Array} [entries] The key-value pairs to cache.
 */
function MapCache(entries) {
  var index = -1,
      length = entries == null ? 0 : entries.length;

  this.clear();
  while (++index < length) {
    var entry = entries[index];
    this.set(entry[0], entry[1]);
  }
}

// Add methods to `MapCache`.
MapCache.prototype.clear = mapCacheClear;
MapCache.prototype['delete'] = mapCacheDelete;
MapCache.prototype.get = mapCacheGet;
MapCache.prototype.has = mapCacheHas;
MapCache.prototype.set = mapCacheSet;

/** Error message constants. */
var FUNC_ERROR_TEXT = 'Expected a function';

/**
 * Creates a function that memoizes the result of `func`. If `resolver` is
 * provided, it determines the cache key for storing the result based on the
 * arguments provided to the memoized function. By default, the first argument
 * provided to the memoized function is used as the map cache key. The `func`
 * is invoked with the `this` binding of the memoized function.
 *
 * **Note:** The cache is exposed as the `cache` property on the memoized
 * function. Its creation may be customized by replacing the `_.memoize.Cache`
 * constructor with one whose instances implement the
 * [`Map`](http://ecma-international.org/ecma-262/7.0/#sec-properties-of-the-map-prototype-object)
 * method interface of `clear`, `delete`, `get`, `has`, and `set`.
 *
 * @static
 * @memberOf _
 * @since 0.1.0
 * @category Function
 * @param {Function} func The function to have its output memoized.
 * @param {Function} [resolver] The function to resolve the cache key.
 * @returns {Function} Returns the new memoized function.
 * @example
 *
 * var object = { 'a': 1, 'b': 2 };
 * var other = { 'c': 3, 'd': 4 };
 *
 * var values = _.memoize(_.values);
 * values(object);
 * // => [1, 2]
 *
 * values(other);
 * // => [3, 4]
 *
 * object.a = 2;
 * values(object);
 * // => [1, 2]
 *
 * // Modify the result cache.
 * values.cache.set(object, ['a', 'b']);
 * values(object);
 * // => ['a', 'b']
 *
 * // Replace `_.memoize.Cache`.
 * _.memoize.Cache = WeakMap;
 */
function memoize(func, resolver) {
  if (typeof func != 'function' || (resolver != null && typeof resolver != 'function')) {
    throw new TypeError(FUNC_ERROR_TEXT);
  }
  var memoized = function() {
    var args = arguments,
        key = resolver ? resolver.apply(this, args) : args[0],
        cache = memoized.cache;

    if (cache.has(key)) {
      return cache.get(key);
    }
    var result = func.apply(this, args);
    memoized.cache = cache.set(key, result) || cache;
    return result;
  };
  memoized.cache = new (memoize.Cache || MapCache);
  return memoized;
}

// Expose `MapCache`.
memoize.Cache = MapCache;

/**
 * Removes all key-value entries from the stack.
 *
 * @private
 * @name clear
 * @memberOf Stack
 */
function stackClear() {
  this.__data__ = new ListCache;
  this.size = 0;
}

/**
 * Removes `key` and its value from the stack.
 *
 * @private
 * @name delete
 * @memberOf Stack
 * @param {string} key The key of the value to remove.
 * @returns {boolean} Returns `true` if the entry was removed, else `false`.
 */
function stackDelete(key) {
  var data = this.__data__,
      result = data['delete'](key);

  this.size = data.size;
  return result;
}

/**
 * Gets the stack value for `key`.
 *
 * @private
 * @name get
 * @memberOf Stack
 * @param {string} key The key of the value to get.
 * @returns {*} Returns the entry value.
 */
function stackGet(key) {
  return this.__data__.get(key);
}

/**
 * Checks if a stack value for `key` exists.
 *
 * @private
 * @name has
 * @memberOf Stack
 * @param {string} key The key of the entry to check.
 * @returns {boolean} Returns `true` if an entry for `key` exists, else `false`.
 */
function stackHas(key) {
  return this.__data__.has(key);
}

/** Used as the size to enable large array optimizations. */
var LARGE_ARRAY_SIZE = 200;

/**
 * Sets the stack `key` to `value`.
 *
 * @private
 * @name set
 * @memberOf Stack
 * @param {string} key The key of the value to set.
 * @param {*} value The value to set.
 * @returns {Object} Returns the stack cache instance.
 */
function stackSet(key, value) {
  var data = this.__data__;
  if (data instanceof ListCache) {
    var pairs = data.__data__;
    if (!Map$1 || (pairs.length < LARGE_ARRAY_SIZE - 1)) {
      pairs.push([key, value]);
      this.size = ++data.size;
      return this;
    }
    data = this.__data__ = new MapCache(pairs);
  }
  data.set(key, value);
  this.size = data.size;
  return this;
}

/**
 * Creates a stack cache object to store key-value pairs.
 *
 * @private
 * @constructor
 * @param {Array} [entries] The key-value pairs to cache.
 */
function Stack(entries) {
  var data = this.__data__ = new ListCache(entries);
  this.size = data.size;
}

// Add methods to `Stack`.
Stack.prototype.clear = stackClear;
Stack.prototype['delete'] = stackDelete;
Stack.prototype.get = stackGet;
Stack.prototype.has = stackHas;
Stack.prototype.set = stackSet;

var defineProperty = (function() {
  try {
    var func = getNative(Object, 'defineProperty');
    func({}, '', {});
    return func;
  } catch (e) {}
}());

/**
 * The base implementation of `assignValue` and `assignMergeValue` without
 * value checks.
 *
 * @private
 * @param {Object} object The object to modify.
 * @param {string} key The key of the property to assign.
 * @param {*} value The value to assign.
 */
function baseAssignValue(object, key, value) {
  if (key == '__proto__' && defineProperty) {
    defineProperty(object, key, {
      'configurable': true,
      'enumerable': true,
      'value': value,
      'writable': true
    });
  } else {
    object[key] = value;
  }
}

/**
 * This function is like `assignValue` except that it doesn't assign
 * `undefined` values.
 *
 * @private
 * @param {Object} object The object to modify.
 * @param {string} key The key of the property to assign.
 * @param {*} value The value to assign.
 */
function assignMergeValue(object, key, value) {
  if ((value !== undefined && !eq(object[key], value)) ||
      (value === undefined && !(key in object))) {
    baseAssignValue(object, key, value);
  }
}

/**
 * Creates a base function for methods like `_.forIn` and `_.forOwn`.
 *
 * @private
 * @param {boolean} [fromRight] Specify iterating from right to left.
 * @returns {Function} Returns the new base function.
 */
function createBaseFor(fromRight) {
  return function(object, iteratee, keysFunc) {
    var index = -1,
        iterable = Object(object),
        props = keysFunc(object),
        length = props.length;

    while (length--) {
      var key = props[++index];
      if (iteratee(iterable[key], key, iterable) === false) {
        break;
      }
    }
    return object;
  };
}

/**
 * The base implementation of `baseForOwn` which iterates over `object`
 * properties returned by `keysFunc` and invokes `iteratee` for each property.
 * Iteratee functions may exit iteration early by explicitly returning `false`.
 *
 * @private
 * @param {Object} object The object to iterate over.
 * @param {Function} iteratee The function invoked per iteration.
 * @param {Function} keysFunc The function to get the keys of `object`.
 * @returns {Object} Returns `object`.
 */
var baseFor = createBaseFor();

/** Detect free variable `exports`. */
var freeExports$2 = typeof exports == 'object' && exports && !exports.nodeType && exports;

/** Detect free variable `module`. */
var freeModule$2 = freeExports$2 && typeof module == 'object' && module && !module.nodeType && module;

/** Detect the popular CommonJS extension `module.exports`. */
var moduleExports$2 = freeModule$2 && freeModule$2.exports === freeExports$2;

/** Built-in value references. */
var Buffer$1 = moduleExports$2 ? root.Buffer : undefined,
    allocUnsafe = Buffer$1 ? Buffer$1.allocUnsafe : undefined;

/**
 * Creates a clone of  `buffer`.
 *
 * @private
 * @param {Buffer} buffer The buffer to clone.
 * @param {boolean} [isDeep] Specify a deep clone.
 * @returns {Buffer} Returns the cloned buffer.
 */
function cloneBuffer(buffer, isDeep) {
  if (isDeep) {
    return buffer.slice();
  }
  var length = buffer.length,
      result = allocUnsafe ? allocUnsafe(length) : new buffer.constructor(length);

  buffer.copy(result);
  return result;
}

/** Built-in value references. */
var Uint8Array$1 = root.Uint8Array;

/**
 * Creates a clone of `arrayBuffer`.
 *
 * @private
 * @param {ArrayBuffer} arrayBuffer The array buffer to clone.
 * @returns {ArrayBuffer} Returns the cloned array buffer.
 */
function cloneArrayBuffer(arrayBuffer) {
  var result = new arrayBuffer.constructor(arrayBuffer.byteLength);
  new Uint8Array$1(result).set(new Uint8Array$1(arrayBuffer));
  return result;
}

/**
 * Creates a clone of `typedArray`.
 *
 * @private
 * @param {Object} typedArray The typed array to clone.
 * @param {boolean} [isDeep] Specify a deep clone.
 * @returns {Object} Returns the cloned typed array.
 */
function cloneTypedArray(typedArray, isDeep) {
  var buffer = isDeep ? cloneArrayBuffer(typedArray.buffer) : typedArray.buffer;
  return new typedArray.constructor(buffer, typedArray.byteOffset, typedArray.length);
}

/**
 * Copies the values of `source` to `array`.
 *
 * @private
 * @param {Array} source The array to copy values from.
 * @param {Array} [array=[]] The array to copy values to.
 * @returns {Array} Returns `array`.
 */
function copyArray(source, array) {
  var index = -1,
      length = source.length;

  array || (array = Array(length));
  while (++index < length) {
    array[index] = source[index];
  }
  return array;
}

/** Built-in value references. */
var objectCreate = Object.create;

/**
 * The base implementation of `_.create` without support for assigning
 * properties to the created object.
 *
 * @private
 * @param {Object} proto The object to inherit from.
 * @returns {Object} Returns the new object.
 */
var baseCreate = (function() {
  function object() {}
  return function(proto) {
    if (!isObject(proto)) {
      return {};
    }
    if (objectCreate) {
      return objectCreate(proto);
    }
    object.prototype = proto;
    var result = new object;
    object.prototype = undefined;
    return result;
  };
}());

/**
 * Creates a unary function that invokes `func` with its argument transformed.
 *
 * @private
 * @param {Function} func The function to wrap.
 * @param {Function} transform The argument transform.
 * @returns {Function} Returns the new function.
 */
function overArg(func, transform) {
  return function(arg) {
    return func(transform(arg));
  };
}

/** Built-in value references. */
var getPrototype = overArg(Object.getPrototypeOf, Object);

/** Used for built-in method references. */
var objectProto$7 = Object.prototype;

/**
 * Checks if `value` is likely a prototype object.
 *
 * @private
 * @param {*} value The value to check.
 * @returns {boolean} Returns `true` if `value` is a prototype, else `false`.
 */
function isPrototype(value) {
  var Ctor = value && value.constructor,
      proto = (typeof Ctor == 'function' && Ctor.prototype) || objectProto$7;

  return value === proto;
}

/**
 * Initializes an object clone.
 *
 * @private
 * @param {Object} object The object to clone.
 * @returns {Object} Returns the initialized clone.
 */
function initCloneObject(object) {
  return (typeof object.constructor == 'function' && !isPrototype(object))
    ? baseCreate(getPrototype(object))
    : {};
}

/**
 * Checks if `value` is object-like. A value is object-like if it's not `null`
 * and has a `typeof` result of "object".
 *
 * @static
 * @memberOf _
 * @since 4.0.0
 * @category Lang
 * @param {*} value The value to check.
 * @returns {boolean} Returns `true` if `value` is object-like, else `false`.
 * @example
 *
 * _.isObjectLike({});
 * // => true
 *
 * _.isObjectLike([1, 2, 3]);
 * // => true
 *
 * _.isObjectLike(_.noop);
 * // => false
 *
 * _.isObjectLike(null);
 * // => false
 */
function isObjectLike(value) {
  return value != null && typeof value == 'object';
}

/** `Object#toString` result references. */
var argsTag$1 = '[object Arguments]';

/**
 * The base implementation of `_.isArguments`.
 *
 * @private
 * @param {*} value The value to check.
 * @returns {boolean} Returns `true` if `value` is an `arguments` object,
 */
function baseIsArguments(value) {
  return isObjectLike(value) && baseGetTag(value) == argsTag$1;
}

/** Used for built-in method references. */
var objectProto$6 = Object.prototype;

/** Used to check objects for own properties. */
var hasOwnProperty$6 = objectProto$6.hasOwnProperty;

/** Built-in value references. */
var propertyIsEnumerable = objectProto$6.propertyIsEnumerable;

/**
 * Checks if `value` is likely an `arguments` object.
 *
 * @static
 * @memberOf _
 * @since 0.1.0
 * @category Lang
 * @param {*} value The value to check.
 * @returns {boolean} Returns `true` if `value` is an `arguments` object,
 *  else `false`.
 * @example
 *
 * _.isArguments(function() { return arguments; }());
 * // => true
 *
 * _.isArguments([1, 2, 3]);
 * // => false
 */
var isArguments = baseIsArguments(function() { return arguments; }()) ? baseIsArguments : function(value) {
  return isObjectLike(value) && hasOwnProperty$6.call(value, 'callee') &&
    !propertyIsEnumerable.call(value, 'callee');
};

/**
 * Checks if `value` is classified as an `Array` object.
 *
 * @static
 * @memberOf _
 * @since 0.1.0
 * @category Lang
 * @param {*} value The value to check.
 * @returns {boolean} Returns `true` if `value` is an array, else `false`.
 * @example
 *
 * _.isArray([1, 2, 3]);
 * // => true
 *
 * _.isArray(document.body.children);
 * // => false
 *
 * _.isArray('abc');
 * // => false
 *
 * _.isArray(_.noop);
 * // => false
 */
var isArray = Array.isArray;

/** Used as references for various `Number` constants. */
var MAX_SAFE_INTEGER$1 = 9007199254740991;

/**
 * Checks if `value` is a valid array-like length.
 *
 * **Note:** This method is loosely based on
 * [`ToLength`](http://ecma-international.org/ecma-262/7.0/#sec-tolength).
 *
 * @static
 * @memberOf _
 * @since 4.0.0
 * @category Lang
 * @param {*} value The value to check.
 * @returns {boolean} Returns `true` if `value` is a valid length, else `false`.
 * @example
 *
 * _.isLength(3);
 * // => true
 *
 * _.isLength(Number.MIN_VALUE);
 * // => false
 *
 * _.isLength(Infinity);
 * // => false
 *
 * _.isLength('3');
 * // => false
 */
function isLength(value) {
  return typeof value == 'number' &&
    value > -1 && value % 1 == 0 && value <= MAX_SAFE_INTEGER$1;
}

/**
 * Checks if `value` is array-like. A value is considered array-like if it's
 * not a function and has a `value.length` that's an integer greater than or
 * equal to `0` and less than or equal to `Number.MAX_SAFE_INTEGER`.
 *
 * @static
 * @memberOf _
 * @since 4.0.0
 * @category Lang
 * @param {*} value The value to check.
 * @returns {boolean} Returns `true` if `value` is array-like, else `false`.
 * @example
 *
 * _.isArrayLike([1, 2, 3]);
 * // => true
 *
 * _.isArrayLike(document.body.children);
 * // => true
 *
 * _.isArrayLike('abc');
 * // => true
 *
 * _.isArrayLike(_.noop);
 * // => false
 */
function isArrayLike(value) {
  return value != null && isLength(value.length) && !isFunction(value);
}

/**
 * This method is like `_.isArrayLike` except that it also checks if `value`
 * is an object.
 *
 * @static
 * @memberOf _
 * @since 4.0.0
 * @category Lang
 * @param {*} value The value to check.
 * @returns {boolean} Returns `true` if `value` is an array-like object,
 *  else `false`.
 * @example
 *
 * _.isArrayLikeObject([1, 2, 3]);
 * // => true
 *
 * _.isArrayLikeObject(document.body.children);
 * // => true
 *
 * _.isArrayLikeObject('abc');
 * // => false
 *
 * _.isArrayLikeObject(_.noop);
 * // => false
 */
function isArrayLikeObject(value) {
  return isObjectLike(value) && isArrayLike(value);
}

/**
 * This method returns `false`.
 *
 * @static
 * @memberOf _
 * @since 4.13.0
 * @category Util
 * @returns {boolean} Returns `false`.
 * @example
 *
 * _.times(2, _.stubFalse);
 * // => [false, false]
 */
function stubFalse() {
  return false;
}

/** Detect free variable `exports`. */
var freeExports$1 = typeof exports == 'object' && exports && !exports.nodeType && exports;

/** Detect free variable `module`. */
var freeModule$1 = freeExports$1 && typeof module == 'object' && module && !module.nodeType && module;

/** Detect the popular CommonJS extension `module.exports`. */
var moduleExports$1 = freeModule$1 && freeModule$1.exports === freeExports$1;

/** Built-in value references. */
var Buffer = moduleExports$1 ? root.Buffer : undefined;

/* Built-in method references for those with the same name as other `lodash` methods. */
var nativeIsBuffer = Buffer ? Buffer.isBuffer : undefined;

/**
 * Checks if `value` is a buffer.
 *
 * @static
 * @memberOf _
 * @since 4.3.0
 * @category Lang
 * @param {*} value The value to check.
 * @returns {boolean} Returns `true` if `value` is a buffer, else `false`.
 * @example
 *
 * _.isBuffer(new Buffer(2));
 * // => true
 *
 * _.isBuffer(new Uint8Array(2));
 * // => false
 */
var isBuffer = nativeIsBuffer || stubFalse;

/** `Object#toString` result references. */
var objectTag$2 = '[object Object]';

/** Used for built-in method references. */
var funcProto = Function.prototype,
    objectProto$5 = Object.prototype;

/** Used to resolve the decompiled source of functions. */
var funcToString = funcProto.toString;

/** Used to check objects for own properties. */
var hasOwnProperty$5 = objectProto$5.hasOwnProperty;

/** Used to infer the `Object` constructor. */
var objectCtorString = funcToString.call(Object);

/**
 * Checks if `value` is a plain object, that is, an object created by the
 * `Object` constructor or one with a `[[Prototype]]` of `null`.
 *
 * @static
 * @memberOf _
 * @since 0.8.0
 * @category Lang
 * @param {*} value The value to check.
 * @returns {boolean} Returns `true` if `value` is a plain object, else `false`.
 * @example
 *
 * function Foo() {
 *   this.a = 1;
 * }
 *
 * _.isPlainObject(new Foo);
 * // => false
 *
 * _.isPlainObject([1, 2, 3]);
 * // => false
 *
 * _.isPlainObject({ 'x': 0, 'y': 0 });
 * // => true
 *
 * _.isPlainObject(Object.create(null));
 * // => true
 */
function isPlainObject(value) {
  if (!isObjectLike(value) || baseGetTag(value) != objectTag$2) {
    return false;
  }
  var proto = getPrototype(value);
  if (proto === null) {
    return true;
  }
  var Ctor = hasOwnProperty$5.call(proto, 'constructor') && proto.constructor;
  return typeof Ctor == 'function' && Ctor instanceof Ctor &&
    funcToString.call(Ctor) == objectCtorString;
}

/** `Object#toString` result references. */
var argsTag = '[object Arguments]',
    arrayTag = '[object Array]',
    boolTag = '[object Boolean]',
    dateTag = '[object Date]',
    errorTag = '[object Error]',
    funcTag = '[object Function]',
    mapTag$2 = '[object Map]',
    numberTag = '[object Number]',
    objectTag$1 = '[object Object]',
    regexpTag = '[object RegExp]',
    setTag$2 = '[object Set]',
    stringTag = '[object String]',
    weakMapTag$1 = '[object WeakMap]';

var arrayBufferTag = '[object ArrayBuffer]',
    dataViewTag$1 = '[object DataView]',
    float32Tag = '[object Float32Array]',
    float64Tag = '[object Float64Array]',
    int8Tag = '[object Int8Array]',
    int16Tag = '[object Int16Array]',
    int32Tag = '[object Int32Array]',
    uint8Tag = '[object Uint8Array]',
    uint8ClampedTag = '[object Uint8ClampedArray]',
    uint16Tag = '[object Uint16Array]',
    uint32Tag = '[object Uint32Array]';

/** Used to identify `toStringTag` values of typed arrays. */
var typedArrayTags = {};
typedArrayTags[float32Tag] = typedArrayTags[float64Tag] =
typedArrayTags[int8Tag] = typedArrayTags[int16Tag] =
typedArrayTags[int32Tag] = typedArrayTags[uint8Tag] =
typedArrayTags[uint8ClampedTag] = typedArrayTags[uint16Tag] =
typedArrayTags[uint32Tag] = true;
typedArrayTags[argsTag] = typedArrayTags[arrayTag] =
typedArrayTags[arrayBufferTag] = typedArrayTags[boolTag] =
typedArrayTags[dataViewTag$1] = typedArrayTags[dateTag] =
typedArrayTags[errorTag] = typedArrayTags[funcTag] =
typedArrayTags[mapTag$2] = typedArrayTags[numberTag] =
typedArrayTags[objectTag$1] = typedArrayTags[regexpTag] =
typedArrayTags[setTag$2] = typedArrayTags[stringTag] =
typedArrayTags[weakMapTag$1] = false;

/**
 * The base implementation of `_.isTypedArray` without Node.js optimizations.
 *
 * @private
 * @param {*} value The value to check.
 * @returns {boolean} Returns `true` if `value` is a typed array, else `false`.
 */
function baseIsTypedArray(value) {
  return isObjectLike(value) &&
    isLength(value.length) && !!typedArrayTags[baseGetTag(value)];
}

/**
 * The base implementation of `_.unary` without support for storing metadata.
 *
 * @private
 * @param {Function} func The function to cap arguments for.
 * @returns {Function} Returns the new capped function.
 */
function baseUnary(func) {
  return function(value) {
    return func(value);
  };
}

/** Detect free variable `exports`. */
var freeExports = typeof exports == 'object' && exports && !exports.nodeType && exports;

/** Detect free variable `module`. */
var freeModule = freeExports && typeof module == 'object' && module && !module.nodeType && module;

/** Detect the popular CommonJS extension `module.exports`. */
var moduleExports = freeModule && freeModule.exports === freeExports;

/** Detect free variable `process` from Node.js. */
var freeProcess = moduleExports && freeGlobal.process;

/** Used to access faster Node.js helpers. */
var nodeUtil = (function() {
  try {
    // Use `util.types` for Node.js 10+.
    var types = freeModule && freeModule.require && freeModule.require('util').types;

    if (types) {
      return types;
    }

    // Legacy `process.binding('util')` for Node.js < 10.
    return freeProcess && freeProcess.binding && freeProcess.binding('util');
  } catch (e) {}
}());

/* Node.js helper references. */
var nodeIsTypedArray = nodeUtil && nodeUtil.isTypedArray;

/**
 * Checks if `value` is classified as a typed array.
 *
 * @static
 * @memberOf _
 * @since 3.0.0
 * @category Lang
 * @param {*} value The value to check.
 * @returns {boolean} Returns `true` if `value` is a typed array, else `false`.
 * @example
 *
 * _.isTypedArray(new Uint8Array);
 * // => true
 *
 * _.isTypedArray([]);
 * // => false
 */
var isTypedArray = nodeIsTypedArray ? baseUnary(nodeIsTypedArray) : baseIsTypedArray;

/**
 * Gets the value at `key`, unless `key` is "__proto__" or "constructor".
 *
 * @private
 * @param {Object} object The object to query.
 * @param {string} key The key of the property to get.
 * @returns {*} Returns the property value.
 */
function safeGet(object, key) {
  if (key === 'constructor' && typeof object[key] === 'function') {
    return;
  }

  if (key == '__proto__') {
    return;
  }

  return object[key];
}

/** Used for built-in method references. */
var objectProto$4 = Object.prototype;

/** Used to check objects for own properties. */
var hasOwnProperty$4 = objectProto$4.hasOwnProperty;

/**
 * Assigns `value` to `key` of `object` if the existing value is not equivalent
 * using [`SameValueZero`](http://ecma-international.org/ecma-262/7.0/#sec-samevaluezero)
 * for equality comparisons.
 *
 * @private
 * @param {Object} object The object to modify.
 * @param {string} key The key of the property to assign.
 * @param {*} value The value to assign.
 */
function assignValue(object, key, value) {
  var objValue = object[key];
  if (!(hasOwnProperty$4.call(object, key) && eq(objValue, value)) ||
      (value === undefined && !(key in object))) {
    baseAssignValue(object, key, value);
  }
}

/**
 * Copies properties of `source` to `object`.
 *
 * @private
 * @param {Object} source The object to copy properties from.
 * @param {Array} props The property identifiers to copy.
 * @param {Object} [object={}] The object to copy properties to.
 * @param {Function} [customizer] The function to customize copied values.
 * @returns {Object} Returns `object`.
 */
function copyObject(source, props, object, customizer) {
  var isNew = !object;
  object || (object = {});

  var index = -1,
      length = props.length;

  while (++index < length) {
    var key = props[index];

    var newValue = undefined;

    if (newValue === undefined) {
      newValue = source[key];
    }
    if (isNew) {
      baseAssignValue(object, key, newValue);
    } else {
      assignValue(object, key, newValue);
    }
  }
  return object;
}

/**
 * The base implementation of `_.times` without support for iteratee shorthands
 * or max array length checks.
 *
 * @private
 * @param {number} n The number of times to invoke `iteratee`.
 * @param {Function} iteratee The function invoked per iteration.
 * @returns {Array} Returns the array of results.
 */
function baseTimes(n, iteratee) {
  var index = -1,
      result = Array(n);

  while (++index < n) {
    result[index] = iteratee(index);
  }
  return result;
}

/** Used as references for various `Number` constants. */
var MAX_SAFE_INTEGER = 9007199254740991;

/** Used to detect unsigned integer values. */
var reIsUint = /^(?:0|[1-9]\d*)$/;

/**
 * Checks if `value` is a valid array-like index.
 *
 * @private
 * @param {*} value The value to check.
 * @param {number} [length=MAX_SAFE_INTEGER] The upper bounds of a valid index.
 * @returns {boolean} Returns `true` if `value` is a valid index, else `false`.
 */
function isIndex(value, length) {
  var type = typeof value;
  length = length == null ? MAX_SAFE_INTEGER : length;

  return !!length &&
    (type == 'number' ||
      (type != 'symbol' && reIsUint.test(value))) &&
        (value > -1 && value % 1 == 0 && value < length);
}

/** Used for built-in method references. */
var objectProto$3 = Object.prototype;

/** Used to check objects for own properties. */
var hasOwnProperty$3 = objectProto$3.hasOwnProperty;

/**
 * Creates an array of the enumerable property names of the array-like `value`.
 *
 * @private
 * @param {*} value The value to query.
 * @param {boolean} inherited Specify returning inherited property names.
 * @returns {Array} Returns the array of property names.
 */
function arrayLikeKeys(value, inherited) {
  var isArr = isArray(value),
      isArg = !isArr && isArguments(value),
      isBuff = !isArr && !isArg && isBuffer(value),
      isType = !isArr && !isArg && !isBuff && isTypedArray(value),
      skipIndexes = isArr || isArg || isBuff || isType,
      result = skipIndexes ? baseTimes(value.length, String) : [],
      length = result.length;

  for (var key in value) {
    if ((inherited || hasOwnProperty$3.call(value, key)) &&
        !(skipIndexes && (
           // Safari 9 has enumerable `arguments.length` in strict mode.
           key == 'length' ||
           // Node.js 0.10 has enumerable non-index properties on buffers.
           (isBuff && (key == 'offset' || key == 'parent')) ||
           // PhantomJS 2 has enumerable non-index properties on typed arrays.
           (isType && (key == 'buffer' || key == 'byteLength' || key == 'byteOffset')) ||
           // Skip index properties.
           isIndex(key, length)
        ))) {
      result.push(key);
    }
  }
  return result;
}

/**
 * This function is like
 * [`Object.keys`](http://ecma-international.org/ecma-262/7.0/#sec-object.keys)
 * except that it includes inherited enumerable properties.
 *
 * @private
 * @param {Object} object The object to query.
 * @returns {Array} Returns the array of property names.
 */
function nativeKeysIn(object) {
  var result = [];
  if (object != null) {
    for (var key in Object(object)) {
      result.push(key);
    }
  }
  return result;
}

/** Used for built-in method references. */
var objectProto$2 = Object.prototype;

/** Used to check objects for own properties. */
var hasOwnProperty$2 = objectProto$2.hasOwnProperty;

/**
 * The base implementation of `_.keysIn` which doesn't treat sparse arrays as dense.
 *
 * @private
 * @param {Object} object The object to query.
 * @returns {Array} Returns the array of property names.
 */
function baseKeysIn(object) {
  if (!isObject(object)) {
    return nativeKeysIn(object);
  }
  var isProto = isPrototype(object),
      result = [];

  for (var key in object) {
    if (!(key == 'constructor' && (isProto || !hasOwnProperty$2.call(object, key)))) {
      result.push(key);
    }
  }
  return result;
}

/**
 * Creates an array of the own and inherited enumerable property names of `object`.
 *
 * **Note:** Non-object values are coerced to objects.
 *
 * @static
 * @memberOf _
 * @since 3.0.0
 * @category Object
 * @param {Object} object The object to query.
 * @returns {Array} Returns the array of property names.
 * @example
 *
 * function Foo() {
 *   this.a = 1;
 *   this.b = 2;
 * }
 *
 * Foo.prototype.c = 3;
 *
 * _.keysIn(new Foo);
 * // => ['a', 'b', 'c'] (iteration order is not guaranteed)
 */
function keysIn(object) {
  return isArrayLike(object) ? arrayLikeKeys(object, true) : baseKeysIn(object);
}

/**
 * Converts `value` to a plain object flattening inherited enumerable string
 * keyed properties of `value` to own properties of the plain object.
 *
 * @static
 * @memberOf _
 * @since 3.0.0
 * @category Lang
 * @param {*} value The value to convert.
 * @returns {Object} Returns the converted plain object.
 * @example
 *
 * function Foo() {
 *   this.b = 2;
 * }
 *
 * Foo.prototype.c = 3;
 *
 * _.assign({ 'a': 1 }, new Foo);
 * // => { 'a': 1, 'b': 2 }
 *
 * _.assign({ 'a': 1 }, _.toPlainObject(new Foo));
 * // => { 'a': 1, 'b': 2, 'c': 3 }
 */
function toPlainObject(value) {
  return copyObject(value, keysIn(value));
}

/**
 * A specialized version of `baseMerge` for arrays and objects which performs
 * deep merges and tracks traversed objects enabling objects with circular
 * references to be merged.
 *
 * @private
 * @param {Object} object The destination object.
 * @param {Object} source The source object.
 * @param {string} key The key of the value to merge.
 * @param {number} srcIndex The index of `source`.
 * @param {Function} mergeFunc The function to merge values.
 * @param {Function} [customizer] The function to customize assigned values.
 * @param {Object} [stack] Tracks traversed source values and their merged
 *  counterparts.
 */
function baseMergeDeep(object, source, key, srcIndex, mergeFunc, customizer, stack) {
  var objValue = safeGet(object, key),
      srcValue = safeGet(source, key),
      stacked = stack.get(srcValue);

  if (stacked) {
    assignMergeValue(object, key, stacked);
    return;
  }
  var newValue = customizer
    ? customizer(objValue, srcValue, (key + ''), object, source, stack)
    : undefined;

  var isCommon = newValue === undefined;

  if (isCommon) {
    var isArr = isArray(srcValue),
        isBuff = !isArr && isBuffer(srcValue),
        isTyped = !isArr && !isBuff && isTypedArray(srcValue);

    newValue = srcValue;
    if (isArr || isBuff || isTyped) {
      if (isArray(objValue)) {
        newValue = objValue;
      }
      else if (isArrayLikeObject(objValue)) {
        newValue = copyArray(objValue);
      }
      else if (isBuff) {
        isCommon = false;
        newValue = cloneBuffer(srcValue, true);
      }
      else if (isTyped) {
        isCommon = false;
        newValue = cloneTypedArray(srcValue, true);
      }
      else {
        newValue = [];
      }
    }
    else if (isPlainObject(srcValue) || isArguments(srcValue)) {
      newValue = objValue;
      if (isArguments(objValue)) {
        newValue = toPlainObject(objValue);
      }
      else if (!isObject(objValue) || isFunction(objValue)) {
        newValue = initCloneObject(srcValue);
      }
    }
    else {
      isCommon = false;
    }
  }
  if (isCommon) {
    // Recursively merge objects and arrays (susceptible to call stack limits).
    stack.set(srcValue, newValue);
    mergeFunc(newValue, srcValue, srcIndex, customizer, stack);
    stack['delete'](srcValue);
  }
  assignMergeValue(object, key, newValue);
}

/**
 * The base implementation of `_.merge` without support for multiple sources.
 *
 * @private
 * @param {Object} object The destination object.
 * @param {Object} source The source object.
 * @param {number} srcIndex The index of `source`.
 * @param {Function} [customizer] The function to customize merged values.
 * @param {Object} [stack] Tracks traversed source values and their merged
 *  counterparts.
 */
function baseMerge(object, source, srcIndex, customizer, stack) {
  if (object === source) {
    return;
  }
  baseFor(source, function(srcValue, key) {
    stack || (stack = new Stack);
    if (isObject(srcValue)) {
      baseMergeDeep(object, source, key, srcIndex, baseMerge, customizer, stack);
    }
    else {
      var newValue = customizer
        ? customizer(safeGet(object, key), srcValue, (key + ''), object, source, stack)
        : undefined;

      if (newValue === undefined) {
        newValue = srcValue;
      }
      assignMergeValue(object, key, newValue);
    }
  }, keysIn);
}

/**
 * This method returns the first argument it receives.
 *
 * @static
 * @since 0.1.0
 * @memberOf _
 * @category Util
 * @param {*} value Any value.
 * @returns {*} Returns `value`.
 * @example
 *
 * var object = { 'a': 1 };
 *
 * console.log(_.identity(object) === object);
 * // => true
 */
function identity(value) {
  return value;
}

/**
 * A faster alternative to `Function#apply`, this function invokes `func`
 * with the `this` binding of `thisArg` and the arguments of `args`.
 *
 * @private
 * @param {Function} func The function to invoke.
 * @param {*} thisArg The `this` binding of `func`.
 * @param {Array} args The arguments to invoke `func` with.
 * @returns {*} Returns the result of `func`.
 */
function apply(func, thisArg, args) {
  switch (args.length) {
    case 0: return func.call(thisArg);
    case 1: return func.call(thisArg, args[0]);
    case 2: return func.call(thisArg, args[0], args[1]);
    case 3: return func.call(thisArg, args[0], args[1], args[2]);
  }
  return func.apply(thisArg, args);
}

/* Built-in method references for those with the same name as other `lodash` methods. */
var nativeMax = Math.max;

/**
 * A specialized version of `baseRest` which transforms the rest array.
 *
 * @private
 * @param {Function} func The function to apply a rest parameter to.
 * @param {number} [start=func.length-1] The start position of the rest parameter.
 * @param {Function} transform The rest array transform.
 * @returns {Function} Returns the new function.
 */
function overRest(func, start, transform) {
  start = nativeMax(start === undefined ? (func.length - 1) : start, 0);
  return function() {
    var args = arguments,
        index = -1,
        length = nativeMax(args.length - start, 0),
        array = Array(length);

    while (++index < length) {
      array[index] = args[start + index];
    }
    index = -1;
    var otherArgs = Array(start + 1);
    while (++index < start) {
      otherArgs[index] = args[index];
    }
    otherArgs[start] = transform(array);
    return apply(func, this, otherArgs);
  };
}

/**
 * Creates a function that returns `value`.
 *
 * @static
 * @memberOf _
 * @since 2.4.0
 * @category Util
 * @param {*} value The value to return from the new function.
 * @returns {Function} Returns the new constant function.
 * @example
 *
 * var objects = _.times(2, _.constant({ 'a': 1 }));
 *
 * console.log(objects);
 * // => [{ 'a': 1 }, { 'a': 1 }]
 *
 * console.log(objects[0] === objects[1]);
 * // => true
 */
function constant(value) {
  return function() {
    return value;
  };
}

/**
 * The base implementation of `setToString` without support for hot loop shorting.
 *
 * @private
 * @param {Function} func The function to modify.
 * @param {Function} string The `toString` result.
 * @returns {Function} Returns `func`.
 */
var baseSetToString = !defineProperty ? identity : function(func, string) {
  return defineProperty(func, 'toString', {
    'configurable': true,
    'enumerable': false,
    'value': constant(string),
    'writable': true
  });
};

/** Used to detect hot functions by number of calls within a span of milliseconds. */
var HOT_COUNT = 800,
    HOT_SPAN = 16;

/* Built-in method references for those with the same name as other `lodash` methods. */
var nativeNow = Date.now;

/**
 * Creates a function that'll short out and invoke `identity` instead
 * of `func` when it's called `HOT_COUNT` or more times in `HOT_SPAN`
 * milliseconds.
 *
 * @private
 * @param {Function} func The function to restrict.
 * @returns {Function} Returns the new shortable function.
 */
function shortOut(func) {
  var count = 0,
      lastCalled = 0;

  return function() {
    var stamp = nativeNow(),
        remaining = HOT_SPAN - (stamp - lastCalled);

    lastCalled = stamp;
    if (remaining > 0) {
      if (++count >= HOT_COUNT) {
        return arguments[0];
      }
    } else {
      count = 0;
    }
    return func.apply(undefined, arguments);
  };
}

/**
 * Sets the `toString` method of `func` to return `string`.
 *
 * @private
 * @param {Function} func The function to modify.
 * @param {Function} string The `toString` result.
 * @returns {Function} Returns `func`.
 */
var setToString = shortOut(baseSetToString);

/**
 * The base implementation of `_.rest` which doesn't validate or coerce arguments.
 *
 * @private
 * @param {Function} func The function to apply a rest parameter to.
 * @param {number} [start=func.length-1] The start position of the rest parameter.
 * @returns {Function} Returns the new function.
 */
function baseRest(func, start) {
  return setToString(overRest(func, start, identity), func + '');
}

/**
 * Checks if the given arguments are from an iteratee call.
 *
 * @private
 * @param {*} value The potential iteratee value argument.
 * @param {*} index The potential iteratee index or key argument.
 * @param {*} object The potential iteratee object argument.
 * @returns {boolean} Returns `true` if the arguments are from an iteratee call,
 *  else `false`.
 */
function isIterateeCall(value, index, object) {
  if (!isObject(object)) {
    return false;
  }
  var type = typeof index;
  if (type == 'number'
        ? (isArrayLike(object) && isIndex(index, object.length))
        : (type == 'string' && index in object)
      ) {
    return eq(object[index], value);
  }
  return false;
}

/**
 * Creates a function like `_.assign`.
 *
 * @private
 * @param {Function} assigner The function to assign values.
 * @returns {Function} Returns the new assigner function.
 */
function createAssigner(assigner) {
  return baseRest(function(object, sources) {
    var index = -1,
        length = sources.length,
        customizer = length > 1 ? sources[length - 1] : undefined,
        guard = length > 2 ? sources[2] : undefined;

    customizer = (assigner.length > 3 && typeof customizer == 'function')
      ? (length--, customizer)
      : undefined;

    if (guard && isIterateeCall(sources[0], sources[1], guard)) {
      customizer = length < 3 ? undefined : customizer;
      length = 1;
    }
    object = Object(object);
    while (++index < length) {
      var source = sources[index];
      if (source) {
        assigner(object, source, index, customizer);
      }
    }
    return object;
  });
}

/**
 * This method is like `_.assign` except that it recursively merges own and
 * inherited enumerable string keyed properties of source objects into the
 * destination object. Source properties that resolve to `undefined` are
 * skipped if a destination value exists. Array and plain object properties
 * are merged recursively. Other objects and value types are overridden by
 * assignment. Source objects are applied from left to right. Subsequent
 * sources overwrite property assignments of previous sources.
 *
 * **Note:** This method mutates `object`.
 *
 * @static
 * @memberOf _
 * @since 0.5.0
 * @category Object
 * @param {Object} object The destination object.
 * @param {...Object} [sources] The source objects.
 * @returns {Object} Returns `object`.
 * @example
 *
 * var object = {
 *   'a': [{ 'b': 2 }, { 'd': 4 }]
 * };
 *
 * var other = {
 *   'a': [{ 'c': 3 }, { 'e': 5 }]
 * };
 *
 * _.merge(object, other);
 * // => { 'a': [{ 'b': 2, 'c': 3 }, { 'd': 4, 'e': 5 }] }
 */
var merge = createAssigner(function(object, source, srcIndex) {
  baseMerge(object, source, srcIndex);
});

var ZERO_WIDTH_SPACE = "\u200B";
var d3CurveTypes = {
  curveBasis,
  curveBasisClosed,
  curveBasisOpen,
  curveBumpX: bumpX,
  curveBumpY: bumpY,
  curveBundle,
  curveCardinalClosed,
  curveCardinalOpen,
  curveCardinal,
  curveCatmullRomClosed,
  curveCatmullRomOpen,
  curveCatmullRom,
  curveLinear,
  curveLinearClosed,
  curveMonotoneX: monotoneX,
  curveMonotoneY: monotoneY,
  curveNatural,
  curveStep,
  curveStepAfter: stepAfter,
  curveStepBefore: stepBefore
};
var directiveWithoutOpen = /\s*(?:(\w+)(?=:):|(\w+))\s*(?:(\w+)|((?:(?!}%{2}).|\r?\n)*))?\s*(?:}%{2})?/gi;
var detectInit = /* @__PURE__ */ __name(function(text, config) {
  const inits = detectDirective(text, /(?:init\b)|(?:initialize\b)/);
  let results = {};
  if (Array.isArray(inits)) {
    const args = inits.map((init) => init.args);
    sanitizeDirective(args);
    results = assignWithDepth_default(results, [...args]);
  } else {
    results = inits.args;
  }
  if (!results) {
    return;
  }
  let type = detectType$1(text, config);
  const prop = "config";
  if (results[prop] !== void 0) {
    if (type === "flowchart-v2") {
      type = "flowchart";
    }
    results[type] = results[prop];
    delete results[prop];
  }
  return results;
}, "detectInit");
var detectDirective = /* @__PURE__ */ __name(function(text, type = null) {
  try {
    const commentWithoutDirectives = new RegExp(
      `[%]{2}(?![{]${directiveWithoutOpen.source})(?=[}][%]{2}).*
`,
      "ig"
    );
    text = text.trim().replace(commentWithoutDirectives, "").replace(/'/gm, '"');
    log.debug(
      `Detecting diagram directive${type !== null ? " type:" + type : ""} based on the text:${text}`
    );
    let match;
    const result = [];
    while ((match = directiveRegex.exec(text)) !== null) {
      if (match.index === directiveRegex.lastIndex) {
        directiveRegex.lastIndex++;
      }
      if (match && !type || type && match[1]?.match(type) || type && match[2]?.match(type)) {
        const type2 = match[1] ? match[1] : match[2];
        const args = match[3] ? match[3].trim() : match[4] ? JSON.parse(match[4].trim()) : null;
        result.push({ type: type2, args });
      }
    }
    if (result.length === 0) {
      return { type: text, args: null };
    }
    return result.length === 1 ? result[0] : result;
  } catch (error) {
    log.error(
      `ERROR: ${error.message} - Unable to parse directive type: '${type}' based on the text: '${text}'`
    );
    return { type: void 0, args: null };
  }
}, "detectDirective");
var removeDirectives = /* @__PURE__ */ __name(function(text) {
  return text.replace(directiveRegex, "");
}, "removeDirectives");
var isSubstringInArray = /* @__PURE__ */ __name(function(str, arr) {
  for (const [i, element] of arr.entries()) {
    if (element.match(str)) {
      return i;
    }
  }
  return -1;
}, "isSubstringInArray");
function interpolateToCurve(interpolate, defaultCurve) {
  if (!interpolate) {
    return defaultCurve;
  }
  const curveName = `curve${interpolate.charAt(0).toUpperCase() + interpolate.slice(1)}`;
  return d3CurveTypes[curveName] ?? defaultCurve;
}
__name(interpolateToCurve, "interpolateToCurve");
function formatUrl(linkStr, config) {
  const url = linkStr.trim();
  if (!url) {
    return void 0;
  }
  if (config.securityLevel !== "loose") {
    return distExports.sanitizeUrl(url);
  }
  return url;
}
__name(formatUrl, "formatUrl");
var runFunc = /* @__PURE__ */ __name((functionName, ...params) => {
  const arrPaths = functionName.split(".");
  const len = arrPaths.length - 1;
  const fnName = arrPaths[len];
  let obj = window;
  for (let i = 0; i < len; i++) {
    obj = obj[arrPaths[i]];
    if (!obj) {
      log.error(`Function name: ${functionName} not found in window`);
      return;
    }
  }
  obj[fnName](...params);
}, "runFunc");
function distance(p1, p2) {
  if (!p1 || !p2) {
    return 0;
  }
  return Math.sqrt(Math.pow(p2.x - p1.x, 2) + Math.pow(p2.y - p1.y, 2));
}
__name(distance, "distance");
function traverseEdge(points) {
  let prevPoint;
  let totalDistance = 0;
  points.forEach((point) => {
    totalDistance += distance(point, prevPoint);
    prevPoint = point;
  });
  const remainingDistance = totalDistance / 2;
  return calculatePoint(points, remainingDistance);
}
__name(traverseEdge, "traverseEdge");
function calcLabelPosition(points) {
  if (points.length === 1) {
    return points[0];
  }
  return traverseEdge(points);
}
__name(calcLabelPosition, "calcLabelPosition");
var roundNumber = /* @__PURE__ */ __name((num, precision = 2) => {
  const factor = Math.pow(10, precision);
  return Math.round(num * factor) / factor;
}, "roundNumber");
var calculatePoint = /* @__PURE__ */ __name((points, distanceToTraverse) => {
  let prevPoint = void 0;
  let remainingDistance = distanceToTraverse;
  for (const point of points) {
    if (prevPoint) {
      const vectorDistance = distance(point, prevPoint);
      if (vectorDistance === 0) {
        return prevPoint;
      }
      if (vectorDistance < remainingDistance) {
        remainingDistance -= vectorDistance;
      } else {
        const distanceRatio = remainingDistance / vectorDistance;
        if (distanceRatio <= 0) {
          return prevPoint;
        }
        if (distanceRatio >= 1) {
          return { x: point.x, y: point.y };
        }
        if (distanceRatio > 0 && distanceRatio < 1) {
          return {
            x: roundNumber((1 - distanceRatio) * prevPoint.x + distanceRatio * point.x, 5),
            y: roundNumber((1 - distanceRatio) * prevPoint.y + distanceRatio * point.y, 5)
          };
        }
      }
    }
    prevPoint = point;
  }
  throw new Error("Could not find a suitable point for the given distance");
}, "calculatePoint");
var calcCardinalityPosition = /* @__PURE__ */ __name((isRelationTypePresent, points, initialPosition) => {
  log.info(`our points ${JSON.stringify(points)}`);
  if (points[0] !== initialPosition) {
    points = points.reverse();
  }
  const distanceToCardinalityPoint = 25;
  const center = calculatePoint(points, distanceToCardinalityPoint);
  const d = isRelationTypePresent ? 10 : 5;
  const angle = Math.atan2(points[0].y - center.y, points[0].x - center.x);
  const cardinalityPosition = { x: 0, y: 0 };
  cardinalityPosition.x = Math.sin(angle) * d + (points[0].x + center.x) / 2;
  cardinalityPosition.y = -Math.cos(angle) * d + (points[0].y + center.y) / 2;
  return cardinalityPosition;
}, "calcCardinalityPosition");
function calcTerminalLabelPosition(terminalMarkerSize, position, _points) {
  const points = structuredClone(_points);
  log.info("our points", points);
  if (position !== "start_left" && position !== "start_right") {
    points.reverse();
  }
  const distanceToCardinalityPoint = 25 + terminalMarkerSize;
  const center = calculatePoint(points, distanceToCardinalityPoint);
  const d = 10 + terminalMarkerSize * 0.5;
  const angle = Math.atan2(points[0].y - center.y, points[0].x - center.x);
  const cardinalityPosition = { x: 0, y: 0 };
  if (position === "start_left") {
    cardinalityPosition.x = Math.sin(angle + Math.PI) * d + (points[0].x + center.x) / 2;
    cardinalityPosition.y = -Math.cos(angle + Math.PI) * d + (points[0].y + center.y) / 2;
  } else if (position === "end_right") {
    cardinalityPosition.x = Math.sin(angle - Math.PI) * d + (points[0].x + center.x) / 2 - 5;
    cardinalityPosition.y = -Math.cos(angle - Math.PI) * d + (points[0].y + center.y) / 2 - 5;
  } else if (position === "end_left") {
    cardinalityPosition.x = Math.sin(angle) * d + (points[0].x + center.x) / 2 - 5;
    cardinalityPosition.y = -Math.cos(angle) * d + (points[0].y + center.y) / 2 - 5;
  } else {
    cardinalityPosition.x = Math.sin(angle) * d + (points[0].x + center.x) / 2;
    cardinalityPosition.y = -Math.cos(angle) * d + (points[0].y + center.y) / 2;
  }
  return cardinalityPosition;
}
__name(calcTerminalLabelPosition, "calcTerminalLabelPosition");
function getStylesFromArray(arr) {
  let style = "";
  let labelStyle = "";
  for (const element of arr) {
    if (element !== void 0) {
      if (element.startsWith("color:") || element.startsWith("text-align:")) {
        labelStyle = labelStyle + element + ";";
      } else {
        style = style + element + ";";
      }
    }
  }
  return { style, labelStyle };
}
__name(getStylesFromArray, "getStylesFromArray");
var cnt = 0;
var generateId = /* @__PURE__ */ __name(() => {
  cnt++;
  return "id-" + Math.random().toString(36).substr(2, 12) + "-" + cnt;
}, "generateId");
function makeRandomHex(length) {
  let result = "";
  const characters = "0123456789abcdef";
  const charactersLength = characters.length;
  for (let i = 0; i < length; i++) {
    result += characters.charAt(Math.floor(Math.random() * charactersLength));
  }
  return result;
}
__name(makeRandomHex, "makeRandomHex");
var random = /* @__PURE__ */ __name((options) => {
  return makeRandomHex(options.length);
}, "random");
var getTextObj = /* @__PURE__ */ __name(function() {
  return {
    x: 0,
    y: 0,
    fill: void 0,
    anchor: "start",
    style: "#666",
    width: 100,
    height: 100,
    textMargin: 0,
    rx: 0,
    ry: 0,
    valign: void 0,
    text: ""
  };
}, "getTextObj");
var drawSimpleText = /* @__PURE__ */ __name(function(elem, textData) {
  const nText = textData.text.replace(common_default.lineBreakRegex, " ");
  const [, _fontSizePx] = parseFontSize(textData.fontSize);
  const textElem = elem.append("text");
  textElem.attr("x", textData.x);
  textElem.attr("y", textData.y);
  textElem.style("text-anchor", textData.anchor);
  textElem.style("font-family", textData.fontFamily);
  textElem.style("font-size", _fontSizePx);
  textElem.style("font-weight", textData.fontWeight);
  textElem.attr("fill", textData.fill);
  if (textData.class !== void 0) {
    textElem.attr("class", textData.class);
  }
  const span = textElem.append("tspan");
  span.attr("x", textData.x + textData.textMargin * 2);
  span.attr("fill", textData.fill);
  span.text(nText);
  return textElem;
}, "drawSimpleText");
var wrapLabel = memoize(
  (label, maxWidth, config) => {
    if (!label) {
      return label;
    }
    config = Object.assign(
      { fontSize: 12, fontWeight: 400, fontFamily: "Arial", joinWith: "<br/>" },
      config
    );
    if (common_default.lineBreakRegex.test(label)) {
      return label;
    }
    const words = label.split(" ").filter(Boolean);
    const completedLines = [];
    let nextLine = "";
    words.forEach((word, index) => {
      const wordLength = calculateTextWidth(`${word} `, config);
      const nextLineLength = calculateTextWidth(nextLine, config);
      if (wordLength > maxWidth) {
        const { hyphenatedStrings, remainingWord } = breakString(word, maxWidth, "-", config);
        completedLines.push(nextLine, ...hyphenatedStrings);
        nextLine = remainingWord;
      } else if (nextLineLength + wordLength >= maxWidth) {
        completedLines.push(nextLine);
        nextLine = word;
      } else {
        nextLine = [nextLine, word].filter(Boolean).join(" ");
      }
      const currentWord = index + 1;
      const isLastWord = currentWord === words.length;
      if (isLastWord) {
        completedLines.push(nextLine);
      }
    });
    return completedLines.filter((line) => line !== "").join(config.joinWith);
  },
  (label, maxWidth, config) => `${label}${maxWidth}${config.fontSize}${config.fontWeight}${config.fontFamily}${config.joinWith}`
);
var breakString = memoize(
  (word, maxWidth, hyphenCharacter = "-", config) => {
    config = Object.assign(
      { fontSize: 12, fontWeight: 400, fontFamily: "Arial", margin: 0 },
      config
    );
    const characters = [...word];
    const lines = [];
    let currentLine = "";
    characters.forEach((character, index) => {
      const nextLine = `${currentLine}${character}`;
      const lineWidth = calculateTextWidth(nextLine, config);
      if (lineWidth >= maxWidth) {
        const currentCharacter = index + 1;
        const isLastLine = characters.length === currentCharacter;
        const hyphenatedNextLine = `${nextLine}${hyphenCharacter}`;
        lines.push(isLastLine ? nextLine : hyphenatedNextLine);
        currentLine = "";
      } else {
        currentLine = nextLine;
      }
    });
    return { hyphenatedStrings: lines, remainingWord: currentLine };
  },
  (word, maxWidth, hyphenCharacter = "-", config) => `${word}${maxWidth}${hyphenCharacter}${config.fontSize}${config.fontWeight}${config.fontFamily}`
);
function calculateTextHeight(text, config) {
  return calculateTextDimensions(text, config).height;
}
__name(calculateTextHeight, "calculateTextHeight");
function calculateTextWidth(text, config) {
  return calculateTextDimensions(text, config).width;
}
__name(calculateTextWidth, "calculateTextWidth");
var calculateTextDimensions = memoize(
  (text, config) => {
    const { fontSize = 12, fontFamily = "Arial", fontWeight = 400 } = config;
    if (!text) {
      return { width: 0, height: 0 };
    }
    const [, _fontSizePx] = parseFontSize(fontSize);
    const fontFamilies = ["sans-serif", fontFamily];
    const lines = text.split(common_default.lineBreakRegex);
    const dims = [];
    const body = select("body");
    if (!body.remove) {
      return { width: 0, height: 0, lineHeight: 0 };
    }
    const g = body.append("svg");
    for (const fontFamily2 of fontFamilies) {
      let cHeight = 0;
      const dim = { width: 0, height: 0, lineHeight: 0 };
      for (const line of lines) {
        const textObj = getTextObj();
        textObj.text = line || ZERO_WIDTH_SPACE;
        const textElem = drawSimpleText(g, textObj).style("font-size", _fontSizePx).style("font-weight", fontWeight).style("font-family", fontFamily2);
        const bBox = (textElem._groups || textElem)[0][0].getBBox();
        if (bBox.width === 0 && bBox.height === 0) {
          throw new Error("svg element not in render tree");
        }
        dim.width = Math.round(Math.max(dim.width, bBox.width));
        cHeight = Math.round(bBox.height);
        dim.height += cHeight;
        dim.lineHeight = Math.round(Math.max(dim.lineHeight, cHeight));
      }
      dims.push(dim);
    }
    g.remove();
    const index = isNaN(dims[1].height) || isNaN(dims[1].width) || isNaN(dims[1].lineHeight) || dims[0].height > dims[1].height && dims[0].width > dims[1].width && dims[0].lineHeight > dims[1].lineHeight ? 0 : 1;
    return dims[index];
  },
  (text, config) => `${text}${config.fontSize}${config.fontWeight}${config.fontFamily}`
);
var InitIDGenerator = class {
  constructor(deterministic = false, seed) {
    this.count = 0;
    this.count = seed ? seed.length : 0;
    this.next = deterministic ? () => this.count++ : () => Date.now();
  }
  static {
    __name(this, "InitIDGenerator");
  }
};
var decoder;
var entityDecode = /* @__PURE__ */ __name(function(html) {
  decoder = decoder || document.createElement("div");
  html = escape(html).replace(/%26/g, "&").replace(/%23/g, "#").replace(/%3B/g, ";");
  decoder.innerHTML = html;
  return unescape(decoder.textContent);
}, "entityDecode");
function isDetailedError(error) {
  return "str" in error;
}
__name(isDetailedError, "isDetailedError");
var insertTitle = /* @__PURE__ */ __name((parent, cssClass, titleTopMargin, title) => {
  if (!title) {
    return;
  }
  const bounds = parent.node()?.getBBox();
  if (!bounds) {
    return;
  }
  parent.append("text").text(title).attr("text-anchor", "middle").attr("x", bounds.x + bounds.width / 2).attr("y", -titleTopMargin).attr("class", cssClass);
}, "insertTitle");
var parseFontSize = /* @__PURE__ */ __name((fontSize) => {
  if (typeof fontSize === "number") {
    return [fontSize, fontSize + "px"];
  }
  const fontSizeNumber = parseInt(fontSize ?? "", 10);
  if (Number.isNaN(fontSizeNumber)) {
    return [void 0, void 0];
  } else if (fontSize === String(fontSizeNumber)) {
    return [fontSizeNumber, fontSize + "px"];
  } else {
    return [fontSizeNumber, fontSize];
  }
}, "parseFontSize");
function cleanAndMerge(defaultData, data) {
  return merge({}, defaultData, data);
}
__name(cleanAndMerge, "cleanAndMerge");
var utils_default = {
  assignWithDepth: assignWithDepth_default,
  wrapLabel,
  calculateTextHeight,
  calculateTextWidth,
  calculateTextDimensions,
  cleanAndMerge,
  detectInit,
  detectDirective,
  isSubstringInArray,
  interpolateToCurve,
  calcLabelPosition,
  calcCardinalityPosition,
  calcTerminalLabelPosition,
  formatUrl,
  getStylesFromArray,
  generateId,
  random,
  runFunc,
  entityDecode,
  insertTitle,
  isLabelCoordinateInPath,
  parseFontSize,
  InitIDGenerator
};
var encodeEntities = /* @__PURE__ */ __name(function(text) {
  let txt = text;
  txt = txt.replace(/style.*:\S*#.*;/g, function(s) {
    return s.substring(0, s.length - 1);
  });
  txt = txt.replace(/classDef.*:\S*#.*;/g, function(s) {
    return s.substring(0, s.length - 1);
  });
  txt = txt.replace(/#\w+;/g, function(s) {
    const innerTxt = s.substring(1, s.length - 1);
    const isInt = /^\+?\d+$/.test(innerTxt);
    if (isInt) {
      return "\uFB02\xB0\xB0" + innerTxt + "\xB6\xDF";
    } else {
      return "\uFB02\xB0" + innerTxt + "\xB6\xDF";
    }
  });
  return txt;
}, "encodeEntities");
var decodeEntities = /* @__PURE__ */ __name(function(text) {
  return text.replace(/ﬂ°°/g, "&#").replace(/ﬂ°/g, "&").replace(/¶ß/g, ";");
}, "decodeEntities");
var getEdgeId = /* @__PURE__ */ __name((from, to, {
  counter = 0,
  prefix,
  suffix
}, id) => {
  if (id) {
    return id;
  }
  return `${prefix ? `${prefix}_` : ""}${from}_${to}_${counter}${suffix ? `_${suffix}` : ""}`;
}, "getEdgeId");
function handleUndefinedAttr(attrValue) {
  return attrValue ?? null;
}
__name(handleUndefinedAttr, "handleUndefinedAttr");
function isLabelCoordinateInPath(point, dAttr) {
  const roundedX = Math.round(point.x);
  const roundedY = Math.round(point.y);
  const sanitizedD = dAttr.replace(
    /(\d+\.\d+)/g,
    (match) => Math.round(parseFloat(match)).toString()
  );
  return sanitizedD.includes(roundedX.toString()) || sanitizedD.includes(roundedY.toString());
}
__name(isLabelCoordinateInPath, "isLabelCoordinateInPath");

const defaultIconDimensions = Object.freeze(
  {
    left: 0,
    top: 0,
    width: 16,
    height: 16
  }
);
const defaultIconTransformations = Object.freeze({
  rotate: 0,
  vFlip: false,
  hFlip: false
});
const defaultIconProps = Object.freeze({
  ...defaultIconDimensions,
  ...defaultIconTransformations
});
const defaultExtendedIconProps = Object.freeze({
  ...defaultIconProps,
  body: "",
  hidden: false
});

const defaultIconSizeCustomisations = Object.freeze({
  width: null,
  height: null
});
const defaultIconCustomisations = Object.freeze({
  // Dimensions
  ...defaultIconSizeCustomisations,
  // Transformations
  ...defaultIconTransformations
});

const stringToIcon = (value, validate, allowSimpleName, provider = "") => {
  const colonSeparated = value.split(":");
  if (value.slice(0, 1) === "@") {
    if (colonSeparated.length < 2 || colonSeparated.length > 3) {
      return null;
    }
    provider = colonSeparated.shift().slice(1);
  }
  if (colonSeparated.length > 3 || !colonSeparated.length) {
    return null;
  }
  if (colonSeparated.length > 1) {
    const name2 = colonSeparated.pop();
    const prefix = colonSeparated.pop();
    const result = {
      // Allow provider without '@': "provider:prefix:name"
      provider: colonSeparated.length > 0 ? colonSeparated[0] : provider,
      prefix,
      name: name2
    };
    return !validateIconName(result) ? null : result;
  }
  const name = colonSeparated[0];
  const dashSeparated = name.split("-");
  if (dashSeparated.length > 1) {
    const result = {
      provider,
      prefix: dashSeparated.shift(),
      name: dashSeparated.join("-")
    };
    return !validateIconName(result) ? null : result;
  }
  if (allowSimpleName && provider === "") {
    const result = {
      provider,
      prefix: "",
      name
    };
    return !validateIconName(result, allowSimpleName) ? null : result;
  }
  return null;
};
const validateIconName = (icon, allowSimpleName) => {
  if (!icon) {
    return false;
  }
  return !!// Check prefix: cannot be empty, unless allowSimpleName is enabled
  // Check name: cannot be empty
  ((allowSimpleName && icon.prefix === "" || !!icon.prefix) && !!icon.name);
};

function mergeIconTransformations(obj1, obj2) {
  const result = {};
  if (!obj1.hFlip !== !obj2.hFlip) {
    result.hFlip = true;
  }
  if (!obj1.vFlip !== !obj2.vFlip) {
    result.vFlip = true;
  }
  const rotate = ((obj1.rotate || 0) + (obj2.rotate || 0)) % 4;
  if (rotate) {
    result.rotate = rotate;
  }
  return result;
}

function mergeIconData(parent, child) {
  const result = mergeIconTransformations(parent, child);
  for (const key in defaultExtendedIconProps) {
    if (key in defaultIconTransformations) {
      if (key in parent && !(key in result)) {
        result[key] = defaultIconTransformations[key];
      }
    } else if (key in child) {
      result[key] = child[key];
    } else if (key in parent) {
      result[key] = parent[key];
    }
  }
  return result;
}

function getIconsTree(data, names) {
  const icons = data.icons;
  const aliases = data.aliases || /* @__PURE__ */ Object.create(null);
  const resolved = /* @__PURE__ */ Object.create(null);
  function resolve(name) {
    if (icons[name]) {
      return resolved[name] = [];
    }
    if (!(name in resolved)) {
      resolved[name] = null;
      const parent = aliases[name] && aliases[name].parent;
      const value = parent && resolve(parent);
      if (value) {
        resolved[name] = [parent].concat(value);
      }
    }
    return resolved[name];
  }
  (names || Object.keys(icons).concat(Object.keys(aliases))).forEach(resolve);
  return resolved;
}

function internalGetIconData(data, name, tree) {
  const icons = data.icons;
  const aliases = data.aliases || /* @__PURE__ */ Object.create(null);
  let currentProps = {};
  function parse(name2) {
    currentProps = mergeIconData(
      icons[name2] || aliases[name2],
      currentProps
    );
  }
  parse(name);
  tree.forEach(parse);
  return mergeIconData(data, currentProps);
}
function getIconData(data, name) {
  if (data.icons[name]) {
    return internalGetIconData(data, name, []);
  }
  const tree = getIconsTree(data, [name])[name];
  return tree ? internalGetIconData(data, name, tree) : null;
}

const unitsSplit = /(-?[0-9.]*[0-9]+[0-9.]*)/g;
const unitsTest = /^-?[0-9.]*[0-9]+[0-9.]*$/g;
function calculateSize(size, ratio, precision) {
  if (ratio === 1) {
    return size;
  }
  precision = precision || 100;
  if (typeof size === "number") {
    return Math.ceil(size * ratio * precision) / precision;
  }
  if (typeof size !== "string") {
    return size;
  }
  const oldParts = size.split(unitsSplit);
  if (oldParts === null || !oldParts.length) {
    return size;
  }
  const newParts = [];
  let code = oldParts.shift();
  let isNumber = unitsTest.test(code);
  while (true) {
    if (isNumber) {
      const num = parseFloat(code);
      if (isNaN(num)) {
        newParts.push(code);
      } else {
        newParts.push(Math.ceil(num * ratio * precision) / precision);
      }
    } else {
      newParts.push(code);
    }
    code = oldParts.shift();
    if (code === void 0) {
      return newParts.join("");
    }
    isNumber = !isNumber;
  }
}

function splitSVGDefs(content, tag = "defs") {
  let defs = "";
  const index = content.indexOf("<" + tag);
  while (index >= 0) {
    const start = content.indexOf(">", index);
    const end = content.indexOf("</" + tag);
    if (start === -1 || end === -1) {
      break;
    }
    const endEnd = content.indexOf(">", end);
    if (endEnd === -1) {
      break;
    }
    defs += content.slice(start + 1, end).trim();
    content = content.slice(0, index).trim() + content.slice(endEnd + 1);
  }
  return {
    defs,
    content
  };
}
function mergeDefsAndContent(defs, content) {
  return defs ? "<defs>" + defs + "</defs>" + content : content;
}
function wrapSVGContent(body, start, end) {
  const split = splitSVGDefs(body);
  return mergeDefsAndContent(split.defs, start + split.content + end);
}

const isUnsetKeyword = (value) => value === "unset" || value === "undefined" || value === "none";
function iconToSVG(icon, customisations) {
  const fullIcon = {
    ...defaultIconProps,
    ...icon
  };
  const fullCustomisations = {
    ...defaultIconCustomisations,
    ...customisations
  };
  const box = {
    left: fullIcon.left,
    top: fullIcon.top,
    width: fullIcon.width,
    height: fullIcon.height
  };
  let body = fullIcon.body;
  [fullIcon, fullCustomisations].forEach((props) => {
    const transformations = [];
    const hFlip = props.hFlip;
    const vFlip = props.vFlip;
    let rotation = props.rotate;
    if (hFlip) {
      if (vFlip) {
        rotation += 2;
      } else {
        transformations.push(
          "translate(" + (box.width + box.left).toString() + " " + (0 - box.top).toString() + ")"
        );
        transformations.push("scale(-1 1)");
        box.top = box.left = 0;
      }
    } else if (vFlip) {
      transformations.push(
        "translate(" + (0 - box.left).toString() + " " + (box.height + box.top).toString() + ")"
      );
      transformations.push("scale(1 -1)");
      box.top = box.left = 0;
    }
    let tempValue;
    if (rotation < 0) {
      rotation -= Math.floor(rotation / 4) * 4;
    }
    rotation = rotation % 4;
    switch (rotation) {
      case 1:
        tempValue = box.height / 2 + box.top;
        transformations.unshift(
          "rotate(90 " + tempValue.toString() + " " + tempValue.toString() + ")"
        );
        break;
      case 2:
        transformations.unshift(
          "rotate(180 " + (box.width / 2 + box.left).toString() + " " + (box.height / 2 + box.top).toString() + ")"
        );
        break;
      case 3:
        tempValue = box.width / 2 + box.left;
        transformations.unshift(
          "rotate(-90 " + tempValue.toString() + " " + tempValue.toString() + ")"
        );
        break;
    }
    if (rotation % 2 === 1) {
      if (box.left !== box.top) {
        tempValue = box.left;
        box.left = box.top;
        box.top = tempValue;
      }
      if (box.width !== box.height) {
        tempValue = box.width;
        box.width = box.height;
        box.height = tempValue;
      }
    }
    if (transformations.length) {
      body = wrapSVGContent(
        body,
        '<g transform="' + transformations.join(" ") + '">',
        "</g>"
      );
    }
  });
  const customisationsWidth = fullCustomisations.width;
  const customisationsHeight = fullCustomisations.height;
  const boxWidth = box.width;
  const boxHeight = box.height;
  let width;
  let height;
  if (customisationsWidth === null) {
    height = customisationsHeight === null ? "1em" : customisationsHeight === "auto" ? boxHeight : customisationsHeight;
    width = calculateSize(height, boxWidth / boxHeight);
  } else {
    width = customisationsWidth === "auto" ? boxWidth : customisationsWidth;
    height = customisationsHeight === null ? calculateSize(width, boxHeight / boxWidth) : customisationsHeight === "auto" ? boxHeight : customisationsHeight;
  }
  const attributes = {};
  const setAttr = (prop, value) => {
    if (!isUnsetKeyword(value)) {
      attributes[prop] = value.toString();
    }
  };
  setAttr("width", width);
  setAttr("height", height);
  const viewBox = [box.left, box.top, boxWidth, boxHeight];
  attributes.viewBox = viewBox.join(" ");
  return {
    attributes,
    viewBox,
    body
  };
}

const regex = /\sid="(\S+)"/g;
const randomPrefix = "IconifyId" + Date.now().toString(16) + (Math.random() * 16777216 | 0).toString(16);
let counter = 0;
function replaceIDs(body, prefix = randomPrefix) {
  const ids = [];
  let match;
  while (match = regex.exec(body)) {
    ids.push(match[1]);
  }
  if (!ids.length) {
    return body;
  }
  const suffix = "suffix" + (Math.random() * 16777216 | Date.now()).toString(16);
  ids.forEach((id) => {
    const newID = typeof prefix === "function" ? prefix(id) : prefix + (counter++).toString();
    const escapedID = id.replace(/[.*+?^${}()|[\]\\]/g, "\\$&");
    body = body.replace(
      // Allowed characters before id: [#;"]
      // Allowed characters after id: [)"], .[a-z]
      new RegExp('([#;"])(' + escapedID + ')([")]|\\.[a-z])', "g"),
      "$1" + newID + suffix + "$3"
    );
  });
  body = body.replace(new RegExp(suffix, "g"), "");
  return body;
}

function iconToHTML(body, attributes) {
  let renderAttribsHTML = body.indexOf("xlink:") === -1 ? "" : ' xmlns:xlink="http://www.w3.org/1999/xlink"';
  for (const attr in attributes) {
    renderAttribsHTML += " " + attr + '="' + attributes[attr] + '"';
  }
  return '<svg xmlns="http://www.w3.org/2000/svg"' + renderAttribsHTML + ">" + body + "</svg>";
}

/**
 * marked v16.2.1 - a markdown parser
 * Copyright (c) 2011-2025, Christopher Jeffrey. (MIT Licensed)
 * https://github.com/markedjs/marked
 */

/**
 * DO NOT EDIT THIS FILE
 * The code in this file is generated from files in ./src/
 */

function L$1(){return {async:false,breaks:false,extensions:null,gfm:true,hooks:null,pedantic:false,renderer:null,silent:false,tokenizer:null,walkTokens:null}}var O$1=L$1();function H$1(l){O$1=l;}var E$1={exec:()=>null};function h$1(l,e=""){let t=typeof l=="string"?l:l.source,n={replace:(r,i)=>{let s=typeof i=="string"?i:i.source;return s=s.replace(m$1.caret,"$1"),t=t.replace(r,s),n},getRegex:()=>new RegExp(t,e)};return n}var m$1={codeRemoveIndent:/^(?: {1,4}| {0,3}\t)/gm,outputLinkReplace:/\\([\[\]])/g,indentCodeCompensation:/^(\s+)(?:```)/,beginningSpace:/^\s+/,endingHash:/#$/,startingSpaceChar:/^ /,endingSpaceChar:/ $/,nonSpaceChar:/[^ ]/,newLineCharGlobal:/\n/g,tabCharGlobal:/\t/g,multipleSpaceGlobal:/\s+/g,blankLine:/^[ \t]*$/,doubleBlankLine:/\n[ \t]*\n[ \t]*$/,blockquoteStart:/^ {0,3}>/,blockquoteSetextReplace:/\n {0,3}((?:=+|-+) *)(?=\n|$)/g,blockquoteSetextReplace2:/^ {0,3}>[ \t]?/gm,listReplaceTabs:/^\t+/,listReplaceNesting:/^ {1,4}(?=( {4})*[^ ])/g,listIsTask:/^\[[ xX]\] /,listReplaceTask:/^\[[ xX]\] +/,anyLine:/\n.*\n/,hrefBrackets:/^<(.*)>$/,tableDelimiter:/[:|]/,tableAlignChars:/^\||\| *$/g,tableRowBlankLine:/\n[ \t]*$/,tableAlignRight:/^ *-+: *$/,tableAlignCenter:/^ *:-+: *$/,tableAlignLeft:/^ *:-+ *$/,startATag:/^<a /i,endATag:/^<\/a>/i,startPreScriptTag:/^<(pre|code|kbd|script)(\s|>)/i,endPreScriptTag:/^<\/(pre|code|kbd|script)(\s|>)/i,startAngleBracket:/^</,endAngleBracket:/>$/,pedanticHrefTitle:/^([^'"]*[^\s])\s+(['"])(.*)\2/,unicodeAlphaNumeric:/[\p{L}\p{N}]/u,escapeTest:/[&<>"']/,escapeReplace:/[&<>"']/g,escapeTestNoEncode:/[<>"']|&(?!(#\d{1,7}|#[Xx][a-fA-F0-9]{1,6}|\w+);)/,escapeReplaceNoEncode:/[<>"']|&(?!(#\d{1,7}|#[Xx][a-fA-F0-9]{1,6}|\w+);)/g,unescapeTest:/&(#(?:\d+)|(?:#x[0-9A-Fa-f]+)|(?:\w+));?/ig,caret:/(^|[^\[])\^/g,percentDecode:/%25/g,findPipe:/\|/g,splitPipe:/ \|/,slashPipe:/\\\|/g,carriageReturn:/\r\n|\r/g,spaceLine:/^ +$/gm,notSpaceStart:/^\S*/,endingNewline:/\n$/,listItemRegex:l=>new RegExp(`^( {0,3}${l})((?:[	 ][^\\n]*)?(?:\\n|$))`),nextBulletRegex:l=>new RegExp(`^ {0,${Math.min(3,l-1)}}(?:[*+-]|\\d{1,9}[.)])((?:[ 	][^\\n]*)?(?:\\n|$))`),hrRegex:l=>new RegExp(`^ {0,${Math.min(3,l-1)}}((?:- *){3,}|(?:_ *){3,}|(?:\\* *){3,})(?:\\n+|$)`),fencesBeginRegex:l=>new RegExp(`^ {0,${Math.min(3,l-1)}}(?:\`\`\`|~~~)`),headingBeginRegex:l=>new RegExp(`^ {0,${Math.min(3,l-1)}}#`),htmlBeginRegex:l=>new RegExp(`^ {0,${Math.min(3,l-1)}}<(?:[a-z].*>|!--)`,"i")},xe=/^(?:[ \t]*(?:\n|$))+/,be=/^((?: {4}| {0,3}\t)[^\n]+(?:\n(?:[ \t]*(?:\n|$))*)?)+/,Re=/^ {0,3}(`{3,}(?=[^`\n]*(?:\n|$))|~{3,})([^\n]*)(?:\n|$)(?:|([\s\S]*?)(?:\n|$))(?: {0,3}\1[~`]* *(?=\n|$)|$)/,C$1=/^ {0,3}((?:-[\t ]*){3,}|(?:_[ \t]*){3,}|(?:\*[ \t]*){3,})(?:\n+|$)/,Oe=/^ {0,3}(#{1,6})(?=\s|$)(.*)(?:\n+|$)/,j$1=/(?:[*+-]|\d{1,9}[.)])/,se=/^(?!bull |blockCode|fences|blockquote|heading|html|table)((?:.|\n(?!\s*?\n|bull |blockCode|fences|blockquote|heading|html|table))+?)\n {0,3}(=+|-+) *(?:\n+|$)/,ie=h$1(se).replace(/bull/g,j$1).replace(/blockCode/g,/(?: {4}| {0,3}\t)/).replace(/fences/g,/ {0,3}(?:`{3,}|~{3,})/).replace(/blockquote/g,/ {0,3}>/).replace(/heading/g,/ {0,3}#{1,6}/).replace(/html/g,/ {0,3}<[^\n>]+>\n/).replace(/\|table/g,"").getRegex(),Te=h$1(se).replace(/bull/g,j$1).replace(/blockCode/g,/(?: {4}| {0,3}\t)/).replace(/fences/g,/ {0,3}(?:`{3,}|~{3,})/).replace(/blockquote/g,/ {0,3}>/).replace(/heading/g,/ {0,3}#{1,6}/).replace(/html/g,/ {0,3}<[^\n>]+>\n/).replace(/table/g,/ {0,3}\|?(?:[:\- ]*\|)+[\:\- ]*\n/).getRegex(),F$1=/^([^\n]+(?:\n(?!hr|heading|lheading|blockquote|fences|list|html|table| +\n)[^\n]+)*)/,we=/^[^\n]+/,Q$1=/(?!\s*\])(?:\\[\s\S]|[^\[\]\\])+/,ye=h$1(/^ {0,3}\[(label)\]: *(?:\n[ \t]*)?([^<\s][^\s]*|<.*?>)(?:(?: +(?:\n[ \t]*)?| *\n[ \t]*)(title))? *(?:\n+|$)/).replace("label",Q$1).replace("title",/(?:"(?:\\"?|[^"\\])*"|'[^'\n]*(?:\n[^'\n]+)*\n?'|\([^()]*\))/).getRegex(),Pe=h$1(/^( {0,3}bull)([ \t][^\n]+?)?(?:\n|$)/).replace(/bull/g,j$1).getRegex(),v$1="address|article|aside|base|basefont|blockquote|body|caption|center|col|colgroup|dd|details|dialog|dir|div|dl|dt|fieldset|figcaption|figure|footer|form|frame|frameset|h[1-6]|head|header|hr|html|iframe|legend|li|link|main|menu|menuitem|meta|nav|noframes|ol|optgroup|option|p|param|search|section|summary|table|tbody|td|tfoot|th|thead|title|tr|track|ul",U$1=/<!--(?:-?>|[\s\S]*?(?:-->|$))/,Se=h$1("^ {0,3}(?:<(script|pre|style|textarea)[\\s>][\\s\\S]*?(?:</\\1>[^\\n]*\\n+|$)|comment[^\\n]*(\\n+|$)|<\\?[\\s\\S]*?(?:\\?>\\n*|$)|<![A-Z][\\s\\S]*?(?:>\\n*|$)|<!\\[CDATA\\[[\\s\\S]*?(?:\\]\\]>\\n*|$)|</?(tag)(?: +|\\n|/?>)[\\s\\S]*?(?:(?:\\n[ 	]*)+\\n|$)|<(?!script|pre|style|textarea)([a-z][\\w-]*)(?:attribute)*? */?>(?=[ \\t]*(?:\\n|$))[\\s\\S]*?(?:(?:\\n[ 	]*)+\\n|$)|</(?!script|pre|style|textarea)[a-z][\\w-]*\\s*>(?=[ \\t]*(?:\\n|$))[\\s\\S]*?(?:(?:\\n[ 	]*)+\\n|$))","i").replace("comment",U$1).replace("tag",v$1).replace("attribute",/ +[a-zA-Z:_][\w.:-]*(?: *= *"[^"\n]*"| *= *'[^'\n]*'| *= *[^\s"'=<>`]+)?/).getRegex(),oe=h$1(F$1).replace("hr",C$1).replace("heading"," {0,3}#{1,6}(?:\\s|$)").replace("|lheading","").replace("|table","").replace("blockquote"," {0,3}>").replace("fences"," {0,3}(?:`{3,}(?=[^`\\n]*\\n)|~{3,})[^\\n]*\\n").replace("list"," {0,3}(?:[*+-]|1[.)]) ").replace("html","</?(?:tag)(?: +|\\n|/?>)|<(?:script|pre|style|textarea|!--)").replace("tag",v$1).getRegex(),$e=h$1(/^( {0,3}> ?(paragraph|[^\n]*)(?:\n|$))+/).replace("paragraph",oe).getRegex(),K$1={blockquote:$e,code:be,def:ye,fences:Re,heading:Oe,hr:C$1,html:Se,lheading:ie,list:Pe,newline:xe,paragraph:oe,table:E$1,text:we},re=h$1("^ *([^\\n ].*)\\n {0,3}((?:\\| *)?:?-+:? *(?:\\| *:?-+:? *)*(?:\\| *)?)(?:\\n((?:(?! *\\n|hr|heading|blockquote|code|fences|list|html).*(?:\\n|$))*)\\n*|$)").replace("hr",C$1).replace("heading"," {0,3}#{1,6}(?:\\s|$)").replace("blockquote"," {0,3}>").replace("code","(?: {4}| {0,3}	)[^\\n]").replace("fences"," {0,3}(?:`{3,}(?=[^`\\n]*\\n)|~{3,})[^\\n]*\\n").replace("list"," {0,3}(?:[*+-]|1[.)]) ").replace("html","</?(?:tag)(?: +|\\n|/?>)|<(?:script|pre|style|textarea|!--)").replace("tag",v$1).getRegex(),_e={...K$1,lheading:Te,table:re,paragraph:h$1(F$1).replace("hr",C$1).replace("heading"," {0,3}#{1,6}(?:\\s|$)").replace("|lheading","").replace("table",re).replace("blockquote"," {0,3}>").replace("fences"," {0,3}(?:`{3,}(?=[^`\\n]*\\n)|~{3,})[^\\n]*\\n").replace("list"," {0,3}(?:[*+-]|1[.)]) ").replace("html","</?(?:tag)(?: +|\\n|/?>)|<(?:script|pre|style|textarea|!--)").replace("tag",v$1).getRegex()},Le={...K$1,html:h$1(`^ *(?:comment *(?:\\n|\\s*$)|<(tag)[\\s\\S]+?</\\1> *(?:\\n{2,}|\\s*$)|<tag(?:"[^"]*"|'[^']*'|\\s[^'"/>\\s]*)*?/?> *(?:\\n{2,}|\\s*$))`).replace("comment",U$1).replace(/tag/g,"(?!(?:a|em|strong|small|s|cite|q|dfn|abbr|data|time|code|var|samp|kbd|sub|sup|i|b|u|mark|ruby|rt|rp|bdi|bdo|span|br|wbr|ins|del|img)\\b)\\w+(?!:|[^\\w\\s@]*@)\\b").getRegex(),def:/^ *\[([^\]]+)\]: *<?([^\s>]+)>?(?: +(["(][^\n]+[")]))? *(?:\n+|$)/,heading:/^(#{1,6})(.*)(?:\n+|$)/,fences:E$1,lheading:/^(.+?)\n {0,3}(=+|-+) *(?:\n+|$)/,paragraph:h$1(F$1).replace("hr",C$1).replace("heading",` *#{1,6} *[^
]`).replace("lheading",ie).replace("|table","").replace("blockquote"," {0,3}>").replace("|fences","").replace("|list","").replace("|html","").replace("|tag","").getRegex()},Me=/^\\([!"#$%&'()*+,\-./:;<=>?@\[\]\\^_`{|}~])/,ze=/^(`+)([^`]|[^`][\s\S]*?[^`])\1(?!`)/,ae=/^( {2,}|\\)\n(?!\s*$)/,Ae=/^(`+|[^`])(?:(?= {2,}\n)|[\s\S]*?(?:(?=[\\<!\[`*_]|\b_|$)|[^ ](?= {2,}\n)))/,D$1=/[\p{P}\p{S}]/u,W$1=/[\s\p{P}\p{S}]/u,le=/[^\s\p{P}\p{S}]/u,Ee=h$1(/^((?![*_])punctSpace)/,"u").replace(/punctSpace/g,W$1).getRegex(),ue=/(?!~)[\p{P}\p{S}]/u,Ce=/(?!~)[\s\p{P}\p{S}]/u,Ie=/(?:[^\s\p{P}\p{S}]|~)/u,Be=/\[[^\[\]]*?\]\((?:\\[\s\S]|[^\\\(\)]|\((?:\\[\s\S]|[^\\\(\)])*\))*\)|`[^`]*?`|<(?! )[^<>]*?>/g,pe=/^(?:\*+(?:((?!\*)punct)|[^\s*]))|^_+(?:((?!_)punct)|([^\s_]))/,qe=h$1(pe,"u").replace(/punct/g,D$1).getRegex(),ve=h$1(pe,"u").replace(/punct/g,ue).getRegex(),ce="^[^_*]*?__[^_*]*?\\*[^_*]*?(?=__)|[^*]+(?=[^*])|(?!\\*)punct(\\*+)(?=[\\s]|$)|notPunctSpace(\\*+)(?!\\*)(?=punctSpace|$)|(?!\\*)punctSpace(\\*+)(?=notPunctSpace)|[\\s](\\*+)(?!\\*)(?=punct)|(?!\\*)punct(\\*+)(?!\\*)(?=punct)|notPunctSpace(\\*+)(?=notPunctSpace)",De=h$1(ce,"gu").replace(/notPunctSpace/g,le).replace(/punctSpace/g,W$1).replace(/punct/g,D$1).getRegex(),Ze=h$1(ce,"gu").replace(/notPunctSpace/g,Ie).replace(/punctSpace/g,Ce).replace(/punct/g,ue).getRegex(),Ge=h$1("^[^_*]*?\\*\\*[^_*]*?_[^_*]*?(?=\\*\\*)|[^_]+(?=[^_])|(?!_)punct(_+)(?=[\\s]|$)|notPunctSpace(_+)(?!_)(?=punctSpace|$)|(?!_)punctSpace(_+)(?=notPunctSpace)|[\\s](_+)(?!_)(?=punct)|(?!_)punct(_+)(?!_)(?=punct)","gu").replace(/notPunctSpace/g,le).replace(/punctSpace/g,W$1).replace(/punct/g,D$1).getRegex(),He=h$1(/\\(punct)/,"gu").replace(/punct/g,D$1).getRegex(),Ne=h$1(/^<(scheme:[^\s\x00-\x1f<>]*|email)>/).replace("scheme",/[a-zA-Z][a-zA-Z0-9+.-]{1,31}/).replace("email",/[a-zA-Z0-9.!#$%&'*+/=?^_`{|}~-]+(@)[a-zA-Z0-9](?:[a-zA-Z0-9-]{0,61}[a-zA-Z0-9])?(?:\.[a-zA-Z0-9](?:[a-zA-Z0-9-]{0,61}[a-zA-Z0-9])?)+(?![-_])/).getRegex(),je=h$1(U$1).replace("(?:-->|$)","-->").getRegex(),Fe=h$1("^comment|^</[a-zA-Z][\\w:-]*\\s*>|^<[a-zA-Z][\\w-]*(?:attribute)*?\\s*/?>|^<\\?[\\s\\S]*?\\?>|^<![a-zA-Z]+\\s[\\s\\S]*?>|^<!\\[CDATA\\[[\\s\\S]*?\\]\\]>").replace("comment",je).replace("attribute",/\s+[a-zA-Z:_][\w.:-]*(?:\s*=\s*"[^"]*"|\s*=\s*'[^']*'|\s*=\s*[^\s"'=<>`]+)?/).getRegex(),q$1=/(?:\[(?:\\[\s\S]|[^\[\]\\])*\]|\\[\s\S]|`[^`]*`|[^\[\]\\`])*?/,Qe=h$1(/^!?\[(label)\]\(\s*(href)(?:(?:[ \t]*(?:\n[ \t]*)?)(title))?\s*\)/).replace("label",q$1).replace("href",/<(?:\\.|[^\n<>\\])+>|[^ \t\n\x00-\x1f]*/).replace("title",/"(?:\\"?|[^"\\])*"|'(?:\\'?|[^'\\])*'|\((?:\\\)?|[^)\\])*\)/).getRegex(),he=h$1(/^!?\[(label)\]\[(ref)\]/).replace("label",q$1).replace("ref",Q$1).getRegex(),de=h$1(/^!?\[(ref)\](?:\[\])?/).replace("ref",Q$1).getRegex(),Ue=h$1("reflink|nolink(?!\\()","g").replace("reflink",he).replace("nolink",de).getRegex(),X$1={_backpedal:E$1,anyPunctuation:He,autolink:Ne,blockSkip:Be,br:ae,code:ze,del:E$1,emStrongLDelim:qe,emStrongRDelimAst:De,emStrongRDelimUnd:Ge,escape:Me,link:Qe,nolink:de,punctuation:Ee,reflink:he,reflinkSearch:Ue,tag:Fe,text:Ae,url:E$1},Ke={...X$1,link:h$1(/^!?\[(label)\]\((.*?)\)/).replace("label",q$1).getRegex(),reflink:h$1(/^!?\[(label)\]\s*\[([^\]]*)\]/).replace("label",q$1).getRegex()},N$1={...X$1,emStrongRDelimAst:Ze,emStrongLDelim:ve,url:h$1(/^((?:ftp|https?):\/\/|www\.)(?:[a-zA-Z0-9\-]+\.?)+[^\s<]*|^email/,"i").replace("email",/[A-Za-z0-9._+-]+(@)[a-zA-Z0-9-_]+(?:\.[a-zA-Z0-9-_]*[a-zA-Z0-9])+(?![-_])/).getRegex(),_backpedal:/(?:[^?!.,:;*_'"~()&]+|\([^)]*\)|&(?![a-zA-Z0-9]+;$)|[?!.,:;*_'"~)]+(?!$))+/,del:/^(~~?)(?=[^\s~])((?:\\[\s\S]|[^\\])*?(?:\\[\s\S]|[^\s~\\]))\1(?=[^~]|$)/,text:/^([`~]+|[^`~])(?:(?= {2,}\n)|(?=[a-zA-Z0-9.!#$%&'*+\/=?_`{\|}~-]+@)|[\s\S]*?(?:(?=[\\<!\[`*~_]|\b_|https?:\/\/|ftp:\/\/|www\.|$)|[^ ](?= {2,}\n)|[^a-zA-Z0-9.!#$%&'*+\/=?_`{\|}~-](?=[a-zA-Z0-9.!#$%&'*+\/=?_`{\|}~-]+@)))/},We={...N$1,br:h$1(ae).replace("{2,}","*").getRegex(),text:h$1(N$1.text).replace("\\b_","\\b_| {2,}\\n").replace(/\{2,\}/g,"*").getRegex()},I$1={normal:K$1,gfm:_e,pedantic:Le},M$1={normal:X$1,gfm:N$1,breaks:We,pedantic:Ke};var Xe={"&":"&amp;","<":"&lt;",">":"&gt;",'"':"&quot;","'":"&#39;"},ke=l=>Xe[l];function w$1(l,e){if(e){if(m$1.escapeTest.test(l))return l.replace(m$1.escapeReplace,ke)}else if(m$1.escapeTestNoEncode.test(l))return l.replace(m$1.escapeReplaceNoEncode,ke);return l}function J$1(l){try{l=encodeURI(l).replace(m$1.percentDecode,"%");}catch{return null}return l}function V$1(l,e){let t=l.replace(m$1.findPipe,(i,s,o)=>{let a=false,u=s;for(;--u>=0&&o[u]==="\\";)a=!a;return a?"|":" |"}),n=t.split(m$1.splitPipe),r=0;if(n[0].trim()||n.shift(),n.length>0&&!n.at(-1)?.trim()&&n.pop(),e)if(n.length>e)n.splice(e);else for(;n.length<e;)n.push("");for(;r<n.length;r++)n[r]=n[r].trim().replace(m$1.slashPipe,"|");return n}function z$1(l,e,t){let n=l.length;if(n===0)return "";let r=0;for(;r<n;){let i=l.charAt(n-r-1);if(i===e&&true)r++;else break}return l.slice(0,n-r)}function ge(l,e){if(l.indexOf(e[1])===-1)return  -1;let t=0;for(let n=0;n<l.length;n++)if(l[n]==="\\")n++;else if(l[n]===e[0])t++;else if(l[n]===e[1]&&(t--,t<0))return n;return t>0?-2:-1}function fe(l,e,t,n,r){let i=e.href,s=e.title||null,o=l[1].replace(r.other.outputLinkReplace,"$1");n.state.inLink=true;let a={type:l[0].charAt(0)==="!"?"image":"link",raw:t,href:i,title:s,text:o,tokens:n.inlineTokens(o)};return n.state.inLink=false,a}function Je(l,e,t){let n=l.match(t.other.indentCodeCompensation);if(n===null)return e;let r=n[1];return e.split(`
`).map(i=>{let s=i.match(t.other.beginningSpace);if(s===null)return i;let[o]=s;return o.length>=r.length?i.slice(r.length):i}).join(`
`)}var y$1=class y{options;rules;lexer;constructor(e){this.options=e||O$1;}space(e){let t=this.rules.block.newline.exec(e);if(t&&t[0].length>0)return {type:"space",raw:t[0]}}code(e){let t=this.rules.block.code.exec(e);if(t){let n=t[0].replace(this.rules.other.codeRemoveIndent,"");return {type:"code",raw:t[0],codeBlockStyle:"indented",text:this.options.pedantic?n:z$1(n,`
`)}}}fences(e){let t=this.rules.block.fences.exec(e);if(t){let n=t[0],r=Je(n,t[3]||"",this.rules);return {type:"code",raw:n,lang:t[2]?t[2].trim().replace(this.rules.inline.anyPunctuation,"$1"):t[2],text:r}}}heading(e){let t=this.rules.block.heading.exec(e);if(t){let n=t[2].trim();if(this.rules.other.endingHash.test(n)){let r=z$1(n,"#");(this.options.pedantic||!r||this.rules.other.endingSpaceChar.test(r))&&(n=r.trim());}return {type:"heading",raw:t[0],depth:t[1].length,text:n,tokens:this.lexer.inline(n)}}}hr(e){let t=this.rules.block.hr.exec(e);if(t)return {type:"hr",raw:z$1(t[0],`
`)}}blockquote(e){let t=this.rules.block.blockquote.exec(e);if(t){let n=z$1(t[0],`
`).split(`
`),r="",i="",s=[];for(;n.length>0;){let o=false,a=[],u;for(u=0;u<n.length;u++)if(this.rules.other.blockquoteStart.test(n[u]))a.push(n[u]),o=true;else if(!o)a.push(n[u]);else break;n=n.slice(u);let p=a.join(`
`),c=p.replace(this.rules.other.blockquoteSetextReplace,`
    $1`).replace(this.rules.other.blockquoteSetextReplace2,"");r=r?`${r}
${p}`:p,i=i?`${i}
${c}`:c;let f=this.lexer.state.top;if(this.lexer.state.top=true,this.lexer.blockTokens(c,s,true),this.lexer.state.top=f,n.length===0)break;let k=s.at(-1);if(k?.type==="code")break;if(k?.type==="blockquote"){let x=k,g=x.raw+`
`+n.join(`
`),T=this.blockquote(g);s[s.length-1]=T,r=r.substring(0,r.length-x.raw.length)+T.raw,i=i.substring(0,i.length-x.text.length)+T.text;break}else if(k?.type==="list"){let x=k,g=x.raw+`
`+n.join(`
`),T=this.list(g);s[s.length-1]=T,r=r.substring(0,r.length-k.raw.length)+T.raw,i=i.substring(0,i.length-x.raw.length)+T.raw,n=g.substring(s.at(-1).raw.length).split(`
`);continue}}return {type:"blockquote",raw:r,tokens:s,text:i}}}list(e){let t=this.rules.block.list.exec(e);if(t){let n=t[1].trim(),r=n.length>1,i={type:"list",raw:"",ordered:r,start:r?+n.slice(0,-1):"",loose:false,items:[]};n=r?`\\d{1,9}\\${n.slice(-1)}`:`\\${n}`,this.options.pedantic&&(n=r?n:"[*+-]");let s=this.rules.other.listItemRegex(n),o=false;for(;e;){let u=false,p="",c="";if(!(t=s.exec(e))||this.rules.block.hr.test(e))break;p=t[0],e=e.substring(p.length);let f=t[2].split(`
`,1)[0].replace(this.rules.other.listReplaceTabs,Z=>" ".repeat(3*Z.length)),k=e.split(`
`,1)[0],x=!f.trim(),g=0;if(this.options.pedantic?(g=2,c=f.trimStart()):x?g=t[1].length+1:(g=t[2].search(this.rules.other.nonSpaceChar),g=g>4?1:g,c=f.slice(g),g+=t[1].length),x&&this.rules.other.blankLine.test(k)&&(p+=k+`
`,e=e.substring(k.length+1),u=true),!u){let Z=this.rules.other.nextBulletRegex(g),ee=this.rules.other.hrRegex(g),te=this.rules.other.fencesBeginRegex(g),ne=this.rules.other.headingBeginRegex(g),me=this.rules.other.htmlBeginRegex(g);for(;e;){let G=e.split(`
`,1)[0],A;if(k=G,this.options.pedantic?(k=k.replace(this.rules.other.listReplaceNesting,"  "),A=k):A=k.replace(this.rules.other.tabCharGlobal,"    "),te.test(k)||ne.test(k)||me.test(k)||Z.test(k)||ee.test(k))break;if(A.search(this.rules.other.nonSpaceChar)>=g||!k.trim())c+=`
`+A.slice(g);else {if(x||f.replace(this.rules.other.tabCharGlobal,"    ").search(this.rules.other.nonSpaceChar)>=4||te.test(f)||ne.test(f)||ee.test(f))break;c+=`
`+k;}!x&&!k.trim()&&(x=true),p+=G+`
`,e=e.substring(G.length+1),f=A.slice(g);}}i.loose||(o?i.loose=true:this.rules.other.doubleBlankLine.test(p)&&(o=true));let T=null,Y;this.options.gfm&&(T=this.rules.other.listIsTask.exec(c),T&&(Y=T[0]!=="[ ] ",c=c.replace(this.rules.other.listReplaceTask,""))),i.items.push({type:"list_item",raw:p,task:!!T,checked:Y,loose:false,text:c,tokens:[]}),i.raw+=p;}let a=i.items.at(-1);if(a)a.raw=a.raw.trimEnd(),a.text=a.text.trimEnd();else return;i.raw=i.raw.trimEnd();for(let u=0;u<i.items.length;u++)if(this.lexer.state.top=false,i.items[u].tokens=this.lexer.blockTokens(i.items[u].text,[]),!i.loose){let p=i.items[u].tokens.filter(f=>f.type==="space"),c=p.length>0&&p.some(f=>this.rules.other.anyLine.test(f.raw));i.loose=c;}if(i.loose)for(let u=0;u<i.items.length;u++)i.items[u].loose=true;return i}}html(e){let t=this.rules.block.html.exec(e);if(t)return {type:"html",block:true,raw:t[0],pre:t[1]==="pre"||t[1]==="script"||t[1]==="style",text:t[0]}}def(e){let t=this.rules.block.def.exec(e);if(t){let n=t[1].toLowerCase().replace(this.rules.other.multipleSpaceGlobal," "),r=t[2]?t[2].replace(this.rules.other.hrefBrackets,"$1").replace(this.rules.inline.anyPunctuation,"$1"):"",i=t[3]?t[3].substring(1,t[3].length-1).replace(this.rules.inline.anyPunctuation,"$1"):t[3];return {type:"def",tag:n,raw:t[0],href:r,title:i}}}table(e){let t=this.rules.block.table.exec(e);if(!t||!this.rules.other.tableDelimiter.test(t[2]))return;let n=V$1(t[1]),r=t[2].replace(this.rules.other.tableAlignChars,"").split("|"),i=t[3]?.trim()?t[3].replace(this.rules.other.tableRowBlankLine,"").split(`
`):[],s={type:"table",raw:t[0],header:[],align:[],rows:[]};if(n.length===r.length){for(let o of r)this.rules.other.tableAlignRight.test(o)?s.align.push("right"):this.rules.other.tableAlignCenter.test(o)?s.align.push("center"):this.rules.other.tableAlignLeft.test(o)?s.align.push("left"):s.align.push(null);for(let o=0;o<n.length;o++)s.header.push({text:n[o],tokens:this.lexer.inline(n[o]),header:true,align:s.align[o]});for(let o of i)s.rows.push(V$1(o,s.header.length).map((a,u)=>({text:a,tokens:this.lexer.inline(a),header:false,align:s.align[u]})));return s}}lheading(e){let t=this.rules.block.lheading.exec(e);if(t)return {type:"heading",raw:t[0],depth:t[2].charAt(0)==="="?1:2,text:t[1],tokens:this.lexer.inline(t[1])}}paragraph(e){let t=this.rules.block.paragraph.exec(e);if(t){let n=t[1].charAt(t[1].length-1)===`
`?t[1].slice(0,-1):t[1];return {type:"paragraph",raw:t[0],text:n,tokens:this.lexer.inline(n)}}}text(e){let t=this.rules.block.text.exec(e);if(t)return {type:"text",raw:t[0],text:t[0],tokens:this.lexer.inline(t[0])}}escape(e){let t=this.rules.inline.escape.exec(e);if(t)return {type:"escape",raw:t[0],text:t[1]}}tag(e){let t=this.rules.inline.tag.exec(e);if(t)return !this.lexer.state.inLink&&this.rules.other.startATag.test(t[0])?this.lexer.state.inLink=true:this.lexer.state.inLink&&this.rules.other.endATag.test(t[0])&&(this.lexer.state.inLink=false),!this.lexer.state.inRawBlock&&this.rules.other.startPreScriptTag.test(t[0])?this.lexer.state.inRawBlock=true:this.lexer.state.inRawBlock&&this.rules.other.endPreScriptTag.test(t[0])&&(this.lexer.state.inRawBlock=false),{type:"html",raw:t[0],inLink:this.lexer.state.inLink,inRawBlock:this.lexer.state.inRawBlock,block:false,text:t[0]}}link(e){let t=this.rules.inline.link.exec(e);if(t){let n=t[2].trim();if(!this.options.pedantic&&this.rules.other.startAngleBracket.test(n)){if(!this.rules.other.endAngleBracket.test(n))return;let s=z$1(n.slice(0,-1),"\\");if((n.length-s.length)%2===0)return}else {let s=ge(t[2],"()");if(s===-2)return;if(s>-1){let a=(t[0].indexOf("!")===0?5:4)+t[1].length+s;t[2]=t[2].substring(0,s),t[0]=t[0].substring(0,a).trim(),t[3]="";}}let r=t[2],i="";if(this.options.pedantic){let s=this.rules.other.pedanticHrefTitle.exec(r);s&&(r=s[1],i=s[3]);}else i=t[3]?t[3].slice(1,-1):"";return r=r.trim(),this.rules.other.startAngleBracket.test(r)&&(this.options.pedantic&&!this.rules.other.endAngleBracket.test(n)?r=r.slice(1):r=r.slice(1,-1)),fe(t,{href:r&&r.replace(this.rules.inline.anyPunctuation,"$1"),title:i&&i.replace(this.rules.inline.anyPunctuation,"$1")},t[0],this.lexer,this.rules)}}reflink(e,t){let n;if((n=this.rules.inline.reflink.exec(e))||(n=this.rules.inline.nolink.exec(e))){let r=(n[2]||n[1]).replace(this.rules.other.multipleSpaceGlobal," "),i=t[r.toLowerCase()];if(!i){let s=n[0].charAt(0);return {type:"text",raw:s,text:s}}return fe(n,i,n[0],this.lexer,this.rules)}}emStrong(e,t,n=""){let r=this.rules.inline.emStrongLDelim.exec(e);if(!r||r[3]&&n.match(this.rules.other.unicodeAlphaNumeric))return;if(!(r[1]||r[2]||"")||!n||this.rules.inline.punctuation.exec(n)){let s=[...r[0]].length-1,o,a,u=s,p=0,c=r[0][0]==="*"?this.rules.inline.emStrongRDelimAst:this.rules.inline.emStrongRDelimUnd;for(c.lastIndex=0,t=t.slice(-1*e.length+s);(r=c.exec(t))!=null;){if(o=r[1]||r[2]||r[3]||r[4]||r[5]||r[6],!o)continue;if(a=[...o].length,r[3]||r[4]){u+=a;continue}else if((r[5]||r[6])&&s%3&&!((s+a)%3)){p+=a;continue}if(u-=a,u>0)continue;a=Math.min(a,a+u+p);let f=[...r[0]][0].length,k=e.slice(0,s+r.index+f+a);if(Math.min(s,a)%2){let g=k.slice(1,-1);return {type:"em",raw:k,text:g,tokens:this.lexer.inlineTokens(g)}}let x=k.slice(2,-2);return {type:"strong",raw:k,text:x,tokens:this.lexer.inlineTokens(x)}}}}codespan(e){let t=this.rules.inline.code.exec(e);if(t){let n=t[2].replace(this.rules.other.newLineCharGlobal," "),r=this.rules.other.nonSpaceChar.test(n),i=this.rules.other.startingSpaceChar.test(n)&&this.rules.other.endingSpaceChar.test(n);return r&&i&&(n=n.substring(1,n.length-1)),{type:"codespan",raw:t[0],text:n}}}br(e){let t=this.rules.inline.br.exec(e);if(t)return {type:"br",raw:t[0]}}del(e){let t=this.rules.inline.del.exec(e);if(t)return {type:"del",raw:t[0],text:t[2],tokens:this.lexer.inlineTokens(t[2])}}autolink(e){let t=this.rules.inline.autolink.exec(e);if(t){let n,r;return t[2]==="@"?(n=t[1],r="mailto:"+n):(n=t[1],r=n),{type:"link",raw:t[0],text:n,href:r,tokens:[{type:"text",raw:n,text:n}]}}}url(e){let t;if(t=this.rules.inline.url.exec(e)){let n,r;if(t[2]==="@")n=t[0],r="mailto:"+n;else {let i;do i=t[0],t[0]=this.rules.inline._backpedal.exec(t[0])?.[0]??"";while(i!==t[0]);n=t[0],t[1]==="www."?r="http://"+t[0]:r=t[0];}return {type:"link",raw:t[0],text:n,href:r,tokens:[{type:"text",raw:n,text:n}]}}}inlineText(e){let t=this.rules.inline.text.exec(e);if(t){let n=this.lexer.state.inRawBlock;return {type:"text",raw:t[0],text:t[0],escaped:n}}}};var b$1=class l{tokens;options;state;tokenizer;inlineQueue;constructor(e){this.tokens=[],this.tokens.links=Object.create(null),this.options=e||O$1,this.options.tokenizer=this.options.tokenizer||new y$1,this.tokenizer=this.options.tokenizer,this.tokenizer.options=this.options,this.tokenizer.lexer=this,this.inlineQueue=[],this.state={inLink:false,inRawBlock:false,top:true};let t={other:m$1,block:I$1.normal,inline:M$1.normal};this.options.pedantic?(t.block=I$1.pedantic,t.inline=M$1.pedantic):this.options.gfm&&(t.block=I$1.gfm,this.options.breaks?t.inline=M$1.breaks:t.inline=M$1.gfm),this.tokenizer.rules=t;}static get rules(){return {block:I$1,inline:M$1}}static lex(e,t){return new l(t).lex(e)}static lexInline(e,t){return new l(t).inlineTokens(e)}lex(e){e=e.replace(m$1.carriageReturn,`
`),this.blockTokens(e,this.tokens);for(let t=0;t<this.inlineQueue.length;t++){let n=this.inlineQueue[t];this.inlineTokens(n.src,n.tokens);}return this.inlineQueue=[],this.tokens}blockTokens(e,t=[],n=false){for(this.options.pedantic&&(e=e.replace(m$1.tabCharGlobal,"    ").replace(m$1.spaceLine,""));e;){let r;if(this.options.extensions?.block?.some(s=>(r=s.call({lexer:this},e,t))?(e=e.substring(r.raw.length),t.push(r),true):false))continue;if(r=this.tokenizer.space(e)){e=e.substring(r.raw.length);let s=t.at(-1);r.raw.length===1&&s!==void 0?s.raw+=`
`:t.push(r);continue}if(r=this.tokenizer.code(e)){e=e.substring(r.raw.length);let s=t.at(-1);s?.type==="paragraph"||s?.type==="text"?(s.raw+=(s.raw.endsWith(`
`)?"":`
`)+r.raw,s.text+=`
`+r.text,this.inlineQueue.at(-1).src=s.text):t.push(r);continue}if(r=this.tokenizer.fences(e)){e=e.substring(r.raw.length),t.push(r);continue}if(r=this.tokenizer.heading(e)){e=e.substring(r.raw.length),t.push(r);continue}if(r=this.tokenizer.hr(e)){e=e.substring(r.raw.length),t.push(r);continue}if(r=this.tokenizer.blockquote(e)){e=e.substring(r.raw.length),t.push(r);continue}if(r=this.tokenizer.list(e)){e=e.substring(r.raw.length),t.push(r);continue}if(r=this.tokenizer.html(e)){e=e.substring(r.raw.length),t.push(r);continue}if(r=this.tokenizer.def(e)){e=e.substring(r.raw.length);let s=t.at(-1);s?.type==="paragraph"||s?.type==="text"?(s.raw+=(s.raw.endsWith(`
`)?"":`
`)+r.raw,s.text+=`
`+r.raw,this.inlineQueue.at(-1).src=s.text):this.tokens.links[r.tag]||(this.tokens.links[r.tag]={href:r.href,title:r.title},t.push(r));continue}if(r=this.tokenizer.table(e)){e=e.substring(r.raw.length),t.push(r);continue}if(r=this.tokenizer.lheading(e)){e=e.substring(r.raw.length),t.push(r);continue}let i=e;if(this.options.extensions?.startBlock){let s=1/0,o=e.slice(1),a;this.options.extensions.startBlock.forEach(u=>{a=u.call({lexer:this},o),typeof a=="number"&&a>=0&&(s=Math.min(s,a));}),s<1/0&&s>=0&&(i=e.substring(0,s+1));}if(this.state.top&&(r=this.tokenizer.paragraph(i))){let s=t.at(-1);n&&s?.type==="paragraph"?(s.raw+=(s.raw.endsWith(`
`)?"":`
`)+r.raw,s.text+=`
`+r.text,this.inlineQueue.pop(),this.inlineQueue.at(-1).src=s.text):t.push(r),n=i.length!==e.length,e=e.substring(r.raw.length);continue}if(r=this.tokenizer.text(e)){e=e.substring(r.raw.length);let s=t.at(-1);s?.type==="text"?(s.raw+=(s.raw.endsWith(`
`)?"":`
`)+r.raw,s.text+=`
`+r.text,this.inlineQueue.pop(),this.inlineQueue.at(-1).src=s.text):t.push(r);continue}if(e){let s="Infinite loop on byte: "+e.charCodeAt(0);if(this.options.silent){console.error(s);break}else throw new Error(s)}}return this.state.top=true,t}inline(e,t=[]){return this.inlineQueue.push({src:e,tokens:t}),t}inlineTokens(e,t=[]){let n=e,r=null;if(this.tokens.links){let o=Object.keys(this.tokens.links);if(o.length>0)for(;(r=this.tokenizer.rules.inline.reflinkSearch.exec(n))!=null;)o.includes(r[0].slice(r[0].lastIndexOf("[")+1,-1))&&(n=n.slice(0,r.index)+"["+"a".repeat(r[0].length-2)+"]"+n.slice(this.tokenizer.rules.inline.reflinkSearch.lastIndex));}for(;(r=this.tokenizer.rules.inline.anyPunctuation.exec(n))!=null;)n=n.slice(0,r.index)+"++"+n.slice(this.tokenizer.rules.inline.anyPunctuation.lastIndex);for(;(r=this.tokenizer.rules.inline.blockSkip.exec(n))!=null;)n=n.slice(0,r.index)+"["+"a".repeat(r[0].length-2)+"]"+n.slice(this.tokenizer.rules.inline.blockSkip.lastIndex);let i=false,s="";for(;e;){i||(s=""),i=false;let o;if(this.options.extensions?.inline?.some(u=>(o=u.call({lexer:this},e,t))?(e=e.substring(o.raw.length),t.push(o),true):false))continue;if(o=this.tokenizer.escape(e)){e=e.substring(o.raw.length),t.push(o);continue}if(o=this.tokenizer.tag(e)){e=e.substring(o.raw.length),t.push(o);continue}if(o=this.tokenizer.link(e)){e=e.substring(o.raw.length),t.push(o);continue}if(o=this.tokenizer.reflink(e,this.tokens.links)){e=e.substring(o.raw.length);let u=t.at(-1);o.type==="text"&&u?.type==="text"?(u.raw+=o.raw,u.text+=o.text):t.push(o);continue}if(o=this.tokenizer.emStrong(e,n,s)){e=e.substring(o.raw.length),t.push(o);continue}if(o=this.tokenizer.codespan(e)){e=e.substring(o.raw.length),t.push(o);continue}if(o=this.tokenizer.br(e)){e=e.substring(o.raw.length),t.push(o);continue}if(o=this.tokenizer.del(e)){e=e.substring(o.raw.length),t.push(o);continue}if(o=this.tokenizer.autolink(e)){e=e.substring(o.raw.length),t.push(o);continue}if(!this.state.inLink&&(o=this.tokenizer.url(e))){e=e.substring(o.raw.length),t.push(o);continue}let a=e;if(this.options.extensions?.startInline){let u=1/0,p=e.slice(1),c;this.options.extensions.startInline.forEach(f=>{c=f.call({lexer:this},p),typeof c=="number"&&c>=0&&(u=Math.min(u,c));}),u<1/0&&u>=0&&(a=e.substring(0,u+1));}if(o=this.tokenizer.inlineText(a)){e=e.substring(o.raw.length),o.raw.slice(-1)!=="_"&&(s=o.raw.slice(-1)),i=true;let u=t.at(-1);u?.type==="text"?(u.raw+=o.raw,u.text+=o.text):t.push(o);continue}if(e){let u="Infinite loop on byte: "+e.charCodeAt(0);if(this.options.silent){console.error(u);break}else throw new Error(u)}}return t}};var P$1=class P{options;parser;constructor(e){this.options=e||O$1;}space(e){return ""}code({text:e,lang:t,escaped:n}){let r=(t||"").match(m$1.notSpaceStart)?.[0],i=e.replace(m$1.endingNewline,"")+`
`;return r?'<pre><code class="language-'+w$1(r)+'">'+(n?i:w$1(i,true))+`</code></pre>
`:"<pre><code>"+(n?i:w$1(i,true))+`</code></pre>
`}blockquote({tokens:e}){return `<blockquote>
${this.parser.parse(e)}</blockquote>
`}html({text:e}){return e}def(e){return ""}heading({tokens:e,depth:t}){return `<h${t}>${this.parser.parseInline(e)}</h${t}>
`}hr(e){return `<hr>
`}list(e){let t=e.ordered,n=e.start,r="";for(let o=0;o<e.items.length;o++){let a=e.items[o];r+=this.listitem(a);}let i=t?"ol":"ul",s=t&&n!==1?' start="'+n+'"':"";return "<"+i+s+`>
`+r+"</"+i+`>
`}listitem(e){let t="";if(e.task){let n=this.checkbox({checked:!!e.checked});e.loose?e.tokens[0]?.type==="paragraph"?(e.tokens[0].text=n+" "+e.tokens[0].text,e.tokens[0].tokens&&e.tokens[0].tokens.length>0&&e.tokens[0].tokens[0].type==="text"&&(e.tokens[0].tokens[0].text=n+" "+w$1(e.tokens[0].tokens[0].text),e.tokens[0].tokens[0].escaped=true)):e.tokens.unshift({type:"text",raw:n+" ",text:n+" ",escaped:true}):t+=n+" ";}return t+=this.parser.parse(e.tokens,!!e.loose),`<li>${t}</li>
`}checkbox({checked:e}){return "<input "+(e?'checked="" ':"")+'disabled="" type="checkbox">'}paragraph({tokens:e}){return `<p>${this.parser.parseInline(e)}</p>
`}table(e){let t="",n="";for(let i=0;i<e.header.length;i++)n+=this.tablecell(e.header[i]);t+=this.tablerow({text:n});let r="";for(let i=0;i<e.rows.length;i++){let s=e.rows[i];n="";for(let o=0;o<s.length;o++)n+=this.tablecell(s[o]);r+=this.tablerow({text:n});}return r&&(r=`<tbody>${r}</tbody>`),`<table>
<thead>
`+t+`</thead>
`+r+`</table>
`}tablerow({text:e}){return `<tr>
${e}</tr>
`}tablecell(e){let t=this.parser.parseInline(e.tokens),n=e.header?"th":"td";return (e.align?`<${n} align="${e.align}">`:`<${n}>`)+t+`</${n}>
`}strong({tokens:e}){return `<strong>${this.parser.parseInline(e)}</strong>`}em({tokens:e}){return `<em>${this.parser.parseInline(e)}</em>`}codespan({text:e}){return `<code>${w$1(e,true)}</code>`}br(e){return "<br>"}del({tokens:e}){return `<del>${this.parser.parseInline(e)}</del>`}link({href:e,title:t,tokens:n}){let r=this.parser.parseInline(n),i=J$1(e);if(i===null)return r;e=i;let s='<a href="'+e+'"';return t&&(s+=' title="'+w$1(t)+'"'),s+=">"+r+"</a>",s}image({href:e,title:t,text:n,tokens:r}){r&&(n=this.parser.parseInline(r,this.parser.textRenderer));let i=J$1(e);if(i===null)return w$1(n);e=i;let s=`<img src="${e}" alt="${n}"`;return t&&(s+=` title="${w$1(t)}"`),s+=">",s}text(e){return "tokens"in e&&e.tokens?this.parser.parseInline(e.tokens):"escaped"in e&&e.escaped?e.text:w$1(e.text)}};var S$1=class S{strong({text:e}){return e}em({text:e}){return e}codespan({text:e}){return e}del({text:e}){return e}html({text:e}){return e}text({text:e}){return e}link({text:e}){return ""+e}image({text:e}){return ""+e}br(){return ""}};var R$1=class l{options;renderer;textRenderer;constructor(e){this.options=e||O$1,this.options.renderer=this.options.renderer||new P$1,this.renderer=this.options.renderer,this.renderer.options=this.options,this.renderer.parser=this,this.textRenderer=new S$1;}static parse(e,t){return new l(t).parse(e)}static parseInline(e,t){return new l(t).parseInline(e)}parse(e,t=true){let n="";for(let r=0;r<e.length;r++){let i=e[r];if(this.options.extensions?.renderers?.[i.type]){let o=i,a=this.options.extensions.renderers[o.type].call({parser:this},o);if(a!==false||!["space","hr","heading","code","table","blockquote","list","html","def","paragraph","text"].includes(o.type)){n+=a||"";continue}}let s=i;switch(s.type){case "space":{n+=this.renderer.space(s);continue}case "hr":{n+=this.renderer.hr(s);continue}case "heading":{n+=this.renderer.heading(s);continue}case "code":{n+=this.renderer.code(s);continue}case "table":{n+=this.renderer.table(s);continue}case "blockquote":{n+=this.renderer.blockquote(s);continue}case "list":{n+=this.renderer.list(s);continue}case "html":{n+=this.renderer.html(s);continue}case "def":{n+=this.renderer.def(s);continue}case "paragraph":{n+=this.renderer.paragraph(s);continue}case "text":{let o=s,a=this.renderer.text(o);for(;r+1<e.length&&e[r+1].type==="text";)o=e[++r],a+=`
`+this.renderer.text(o);t?n+=this.renderer.paragraph({type:"paragraph",raw:a,text:a,tokens:[{type:"text",raw:a,text:a,escaped:true}]}):n+=a;continue}default:{let o='Token with "'+s.type+'" type was not found.';if(this.options.silent)return console.error(o),"";throw new Error(o)}}}return n}parseInline(e,t=this.renderer){let n="";for(let r=0;r<e.length;r++){let i=e[r];if(this.options.extensions?.renderers?.[i.type]){let o=this.options.extensions.renderers[i.type].call({parser:this},i);if(o!==false||!["escape","html","link","image","strong","em","codespan","br","del","text"].includes(i.type)){n+=o||"";continue}}let s=i;switch(s.type){case "escape":{n+=t.text(s);break}case "html":{n+=t.html(s);break}case "link":{n+=t.link(s);break}case "image":{n+=t.image(s);break}case "strong":{n+=t.strong(s);break}case "em":{n+=t.em(s);break}case "codespan":{n+=t.codespan(s);break}case "br":{n+=t.br(s);break}case "del":{n+=t.del(s);break}case "text":{n+=t.text(s);break}default:{let o='Token with "'+s.type+'" type was not found.';if(this.options.silent)return console.error(o),"";throw new Error(o)}}}return n}};var $$1=class ${options;block;constructor(e){this.options=e||O$1;}static passThroughHooks=new Set(["preprocess","postprocess","processAllTokens"]);preprocess(e){return e}postprocess(e){return e}processAllTokens(e){return e}provideLexer(){return this.block?b$1.lex:b$1.lexInline}provideParser(){return this.block?R$1.parse:R$1.parseInline}};var B$1=class B{defaults=L$1();options=this.setOptions;parse=this.parseMarkdown(true);parseInline=this.parseMarkdown(false);Parser=R$1;Renderer=P$1;TextRenderer=S$1;Lexer=b$1;Tokenizer=y$1;Hooks=$$1;constructor(...e){this.use(...e);}walkTokens(e,t){let n=[];for(let r of e)switch(n=n.concat(t.call(this,r)),r.type){case "table":{let i=r;for(let s of i.header)n=n.concat(this.walkTokens(s.tokens,t));for(let s of i.rows)for(let o of s)n=n.concat(this.walkTokens(o.tokens,t));break}case "list":{let i=r;n=n.concat(this.walkTokens(i.items,t));break}default:{let i=r;this.defaults.extensions?.childTokens?.[i.type]?this.defaults.extensions.childTokens[i.type].forEach(s=>{let o=i[s].flat(1/0);n=n.concat(this.walkTokens(o,t));}):i.tokens&&(n=n.concat(this.walkTokens(i.tokens,t)));}}return n}use(...e){let t=this.defaults.extensions||{renderers:{},childTokens:{}};return e.forEach(n=>{let r={...n};if(r.async=this.defaults.async||r.async||false,n.extensions&&(n.extensions.forEach(i=>{if(!i.name)throw new Error("extension name required");if("renderer"in i){let s=t.renderers[i.name];s?t.renderers[i.name]=function(...o){let a=i.renderer.apply(this,o);return a===false&&(a=s.apply(this,o)),a}:t.renderers[i.name]=i.renderer;}if("tokenizer"in i){if(!i.level||i.level!=="block"&&i.level!=="inline")throw new Error("extension level must be 'block' or 'inline'");let s=t[i.level];s?s.unshift(i.tokenizer):t[i.level]=[i.tokenizer],i.start&&(i.level==="block"?t.startBlock?t.startBlock.push(i.start):t.startBlock=[i.start]:i.level==="inline"&&(t.startInline?t.startInline.push(i.start):t.startInline=[i.start]));}"childTokens"in i&&i.childTokens&&(t.childTokens[i.name]=i.childTokens);}),r.extensions=t),n.renderer){let i=this.defaults.renderer||new P$1(this.defaults);for(let s in n.renderer){if(!(s in i))throw new Error(`renderer '${s}' does not exist`);if(["options","parser"].includes(s))continue;let o=s,a=n.renderer[o],u=i[o];i[o]=(...p)=>{let c=a.apply(i,p);return c===false&&(c=u.apply(i,p)),c||""};}r.renderer=i;}if(n.tokenizer){let i=this.defaults.tokenizer||new y$1(this.defaults);for(let s in n.tokenizer){if(!(s in i))throw new Error(`tokenizer '${s}' does not exist`);if(["options","rules","lexer"].includes(s))continue;let o=s,a=n.tokenizer[o],u=i[o];i[o]=(...p)=>{let c=a.apply(i,p);return c===false&&(c=u.apply(i,p)),c};}r.tokenizer=i;}if(n.hooks){let i=this.defaults.hooks||new $$1;for(let s in n.hooks){if(!(s in i))throw new Error(`hook '${s}' does not exist`);if(["options","block"].includes(s))continue;let o=s,a=n.hooks[o],u=i[o];$$1.passThroughHooks.has(s)?i[o]=p=>{if(this.defaults.async)return Promise.resolve(a.call(i,p)).then(f=>u.call(i,f));let c=a.call(i,p);return u.call(i,c)}:i[o]=(...p)=>{let c=a.apply(i,p);return c===false&&(c=u.apply(i,p)),c};}r.hooks=i;}if(n.walkTokens){let i=this.defaults.walkTokens,s=n.walkTokens;r.walkTokens=function(o){let a=[];return a.push(s.call(this,o)),i&&(a=a.concat(i.call(this,o))),a};}this.defaults={...this.defaults,...r};}),this}setOptions(e){return this.defaults={...this.defaults,...e},this}lexer(e,t){return b$1.lex(e,t??this.defaults)}parser(e,t){return R$1.parse(e,t??this.defaults)}parseMarkdown(e){return (n,r)=>{let i={...r},s={...this.defaults,...i},o=this.onError(!!s.silent,!!s.async);if(this.defaults.async===true&&i.async===false)return o(new Error("marked(): The async option was set to true by an extension. Remove async: false from the parse options object to return a Promise."));if(typeof n>"u"||n===null)return o(new Error("marked(): input parameter is undefined or null"));if(typeof n!="string")return o(new Error("marked(): input parameter is of type "+Object.prototype.toString.call(n)+", string expected"));s.hooks&&(s.hooks.options=s,s.hooks.block=e);let a=s.hooks?s.hooks.provideLexer():e?b$1.lex:b$1.lexInline,u=s.hooks?s.hooks.provideParser():e?R$1.parse:R$1.parseInline;if(s.async)return Promise.resolve(s.hooks?s.hooks.preprocess(n):n).then(p=>a(p,s)).then(p=>s.hooks?s.hooks.processAllTokens(p):p).then(p=>s.walkTokens?Promise.all(this.walkTokens(p,s.walkTokens)).then(()=>p):p).then(p=>u(p,s)).then(p=>s.hooks?s.hooks.postprocess(p):p).catch(o);try{s.hooks&&(n=s.hooks.preprocess(n));let p=a(n,s);s.hooks&&(p=s.hooks.processAllTokens(p)),s.walkTokens&&this.walkTokens(p,s.walkTokens);let c=u(p,s);return s.hooks&&(c=s.hooks.postprocess(c)),c}catch(p){return o(p)}}}onError(e,t){return n=>{if(n.message+=`
Please report this to https://github.com/markedjs/marked.`,e){let r="<p>An error occurred:</p><pre>"+w$1(n.message+"",true)+"</pre>";return t?Promise.resolve(r):r}if(t)return Promise.reject(n);throw n}}};var _$1=new B$1;function d$1(l,e){return _$1.parse(l,e)}d$1.options=d$1.setOptions=function(l){return _$1.setOptions(l),d$1.defaults=_$1.defaults,H$1(d$1.defaults),d$1};d$1.getDefaults=L$1;d$1.defaults=O$1;d$1.use=function(...l){return _$1.use(...l),d$1.defaults=_$1.defaults,H$1(d$1.defaults),d$1};d$1.walkTokens=function(l,e){return _$1.walkTokens(l,e)};d$1.parseInline=_$1.parseInline;d$1.Parser=R$1;d$1.parser=R$1.parse;d$1.Renderer=P$1;d$1.TextRenderer=S$1;d$1.Lexer=b$1;d$1.lexer=b$1.lex;d$1.Tokenizer=y$1;d$1.Hooks=$$1;d$1.parse=d$1;d$1.options;d$1.setOptions;d$1.use;d$1.walkTokens;d$1.parseInline;R$1.parse;b$1.lex;

function dedent(templ) {
    var values = [];
    for (var _i = 1; _i < arguments.length; _i++) {
        values[_i - 1] = arguments[_i];
    }
    var strings = Array.from(typeof templ === 'string' ? [templ] : templ);
    strings[strings.length - 1] = strings[strings.length - 1].replace(/\r?\n([\t ]*)$/, '');
    var indentLengths = strings.reduce(function (arr, str) {
        var matches = str.match(/\n([\t ]+|(?!\s).)/g);
        if (matches) {
            return arr.concat(matches.map(function (match) { var _a, _b; return (_b = (_a = match.match(/[\t ]/g)) === null || _a === void 0 ? void 0 : _a.length) !== null && _b !== void 0 ? _b : 0; }));
        }
        return arr;
    }, []);
    if (indentLengths.length) {
        var pattern_1 = new RegExp("\n[\t ]{" + Math.min.apply(Math, indentLengths) + "}", 'g');
        strings = strings.map(function (str) { return str.replace(pattern_1, '\n'); });
    }
    strings[0] = strings[0].replace(/^\r?\n/, '');
    var string = strings[0];
    values.forEach(function (value, i) {
        var endentations = string.match(/(?:^|\n)( *)$/);
        var endentation = endentations ? endentations[1] : '';
        var indentedValue = value;
        if (typeof value === 'string' && value.includes('\n')) {
            indentedValue = String(value)
                .split('\n')
                .map(function (str, i) {
                return i === 0 ? str : "" + endentation + str;
            })
                .join('\n');
        }
        string += indentedValue + strings[i + 1];
    });
    return string;
}

var unknownIcon = {
  body: '<g><rect width="80" height="80" style="fill: #087ebf; stroke-width: 0px;"/><text transform="translate(21.16 64.67)" style="fill: #fff; font-family: ArialMT, Arial; font-size: 67.75px;"><tspan x="0" y="0">?</tspan></text></g>',
  height: 80,
  width: 80
};
var iconsStore = /* @__PURE__ */ new Map();
var loaderStore = /* @__PURE__ */ new Map();
var registerIconPacks = /* @__PURE__ */ __name((iconLoaders) => {
  for (const iconLoader of iconLoaders) {
    if (!iconLoader.name) {
      throw new Error(
        'Invalid icon loader. Must have a "name" property with non-empty string value.'
      );
    }
    log.debug("Registering icon pack:", iconLoader.name);
    if ("loader" in iconLoader) {
      loaderStore.set(iconLoader.name, iconLoader.loader);
    } else if ("icons" in iconLoader) {
      iconsStore.set(iconLoader.name, iconLoader.icons);
    } else {
      log.error("Invalid icon loader:", iconLoader);
      throw new Error('Invalid icon loader. Must have either "icons" or "loader" property.');
    }
  }
}, "registerIconPacks");
var getRegisteredIconData = /* @__PURE__ */ __name(async (iconName, fallbackPrefix) => {
  const data = stringToIcon(iconName, true, fallbackPrefix !== void 0);
  if (!data) {
    throw new Error(`Invalid icon name: ${iconName}`);
  }
  const prefix = data.prefix || fallbackPrefix;
  if (!prefix) {
    throw new Error(`Icon name must contain a prefix: ${iconName}`);
  }
  let icons = iconsStore.get(prefix);
  if (!icons) {
    const loader = loaderStore.get(prefix);
    if (!loader) {
      throw new Error(`Icon set not found: ${data.prefix}`);
    }
    try {
      const loaded = await loader();
      icons = { ...loaded, prefix };
      iconsStore.set(prefix, icons);
    } catch (e) {
      log.error(e);
      throw new Error(`Failed to load icon set: ${data.prefix}`);
    }
  }
  const iconData = getIconData(icons, data.name);
  if (!iconData) {
    throw new Error(`Icon not found: ${iconName}`);
  }
  return iconData;
}, "getRegisteredIconData");
var isIconAvailable = /* @__PURE__ */ __name(async (iconName) => {
  try {
    await getRegisteredIconData(iconName);
    return true;
  } catch {
    return false;
  }
}, "isIconAvailable");
var getIconSVG = /* @__PURE__ */ __name(async (iconName, customisations, extraAttributes) => {
  let iconData;
  try {
    iconData = await getRegisteredIconData(iconName, customisations?.fallbackPrefix);
  } catch (e) {
    log.error(e);
    iconData = unknownIcon;
  }
  const renderData = iconToSVG(iconData, customisations);
  const svg = iconToHTML(replaceIDs(renderData.body), {
    ...renderData.attributes,
    ...extraAttributes
  });
  return sanitizeText(svg, getConfig());
}, "getIconSVG");
function preprocessMarkdown(markdown, { markdownAutoWrap }) {
  const withoutBR = markdown.replace(/<br\/>/g, "\n");
  const withoutMultipleNewlines = withoutBR.replace(/\n{2,}/g, "\n");
  const withoutExtraSpaces = dedent(withoutMultipleNewlines);
  if (markdownAutoWrap === false) {
    return withoutExtraSpaces.replace(/ /g, "&nbsp;");
  }
  return withoutExtraSpaces;
}
__name(preprocessMarkdown, "preprocessMarkdown");
function markdownToLines(markdown, config = {}) {
  const preprocessedMarkdown = preprocessMarkdown(markdown, config);
  const nodes = d$1.lexer(preprocessedMarkdown);
  const lines = [[]];
  let currentLine = 0;
  function processNode(node, parentType = "normal") {
    if (node.type === "text") {
      const textLines = node.text.split("\n");
      textLines.forEach((textLine, index) => {
        if (index !== 0) {
          currentLine++;
          lines.push([]);
        }
        textLine.split(" ").forEach((word) => {
          word = word.replace(/&#39;/g, `'`);
          if (word) {
            lines[currentLine].push({ content: word, type: parentType });
          }
        });
      });
    } else if (node.type === "strong" || node.type === "em") {
      node.tokens.forEach((contentNode) => {
        processNode(contentNode, node.type);
      });
    } else if (node.type === "html") {
      lines[currentLine].push({ content: node.text, type: "normal" });
    }
  }
  __name(processNode, "processNode");
  nodes.forEach((treeNode) => {
    if (treeNode.type === "paragraph") {
      treeNode.tokens?.forEach((contentNode) => {
        processNode(contentNode);
      });
    } else if (treeNode.type === "html") {
      lines[currentLine].push({ content: treeNode.text, type: "normal" });
    } else {
      lines[currentLine].push({ content: treeNode.raw, type: "normal" });
    }
  });
  return lines;
}
__name(markdownToLines, "markdownToLines");
function markdownToHTML(markdown, { markdownAutoWrap } = {}) {
  const nodes = d$1.lexer(markdown);
  function output(node) {
    if (node.type === "text") {
      if (markdownAutoWrap === false) {
        return node.text.replace(/\n */g, "<br/>").replace(/ /g, "&nbsp;");
      }
      return node.text.replace(/\n */g, "<br/>");
    } else if (node.type === "strong") {
      return `<strong>${node.tokens?.map(output).join("")}</strong>`;
    } else if (node.type === "em") {
      return `<em>${node.tokens?.map(output).join("")}</em>`;
    } else if (node.type === "paragraph") {
      return `<p>${node.tokens?.map(output).join("")}</p>`;
    } else if (node.type === "space") {
      return "";
    } else if (node.type === "html") {
      return `${node.text}`;
    } else if (node.type === "escape") {
      return node.text;
    }
    log.warn(`Unsupported markdown: ${node.type}`);
    return node.raw;
  }
  __name(output, "output");
  return nodes.map(output).join("");
}
__name(markdownToHTML, "markdownToHTML");

// src/rendering-util/splitText.ts
function splitTextToChars(text) {
  if (Intl.Segmenter) {
    return [...new Intl.Segmenter().segment(text)].map((s) => s.segment);
  }
  return [...text];
}
__name(splitTextToChars, "splitTextToChars");
function splitWordToFitWidth(checkFit, word) {
  const characters = splitTextToChars(word.content);
  return splitWordToFitWidthRecursion(checkFit, [], characters, word.type);
}
__name(splitWordToFitWidth, "splitWordToFitWidth");
function splitWordToFitWidthRecursion(checkFit, usedChars, remainingChars, type) {
  if (remainingChars.length === 0) {
    return [
      { content: usedChars.join(""), type },
      { content: "", type }
    ];
  }
  const [nextChar, ...rest] = remainingChars;
  const newWord = [...usedChars, nextChar];
  if (checkFit([{ content: newWord.join(""), type }])) {
    return splitWordToFitWidthRecursion(checkFit, newWord, rest, type);
  }
  if (usedChars.length === 0 && nextChar) {
    usedChars.push(nextChar);
    remainingChars.shift();
  }
  return [
    { content: usedChars.join(""), type },
    { content: remainingChars.join(""), type }
  ];
}
__name(splitWordToFitWidthRecursion, "splitWordToFitWidthRecursion");
function splitLineToFitWidth(line, checkFit) {
  if (line.some(({ content }) => content.includes("\n"))) {
    throw new Error("splitLineToFitWidth does not support newlines in the line");
  }
  return splitLineToFitWidthRecursion(line, checkFit);
}
__name(splitLineToFitWidth, "splitLineToFitWidth");
function splitLineToFitWidthRecursion(words, checkFit, lines = [], newLine = []) {
  if (words.length === 0) {
    if (newLine.length > 0) {
      lines.push(newLine);
    }
    return lines.length > 0 ? lines : [];
  }
  let joiner = "";
  if (words[0].content === " ") {
    joiner = " ";
    words.shift();
  }
  const nextWord = words.shift() ?? { content: " ", type: "normal" };
  const lineWithNextWord = [...newLine];
  if (joiner !== "") {
    lineWithNextWord.push({ content: joiner, type: "normal" });
  }
  lineWithNextWord.push(nextWord);
  if (checkFit(lineWithNextWord)) {
    return splitLineToFitWidthRecursion(words, checkFit, lines, lineWithNextWord);
  }
  if (newLine.length > 0) {
    lines.push(newLine);
    words.unshift(nextWord);
  } else if (nextWord.content) {
    const [line, rest] = splitWordToFitWidth(checkFit, nextWord);
    lines.push([line]);
    if (rest.content) {
      words.unshift(rest);
    }
  }
  return splitLineToFitWidthRecursion(words, checkFit, lines);
}
__name(splitLineToFitWidthRecursion, "splitLineToFitWidthRecursion");

// src/rendering-util/createText.ts
function applyStyle$1(dom, styleFn) {
  if (styleFn) {
    dom.attr("style", styleFn);
  }
}
__name(applyStyle$1, "applyStyle");
async function addHtmlSpan(element, node, width, classes, addBackground = false, config = getConfig()) {
  const fo = element.append("foreignObject");
  fo.attr("width", `${10 * width}px`);
  fo.attr("height", `${10 * width}px`);
  const div = fo.append("xhtml:div");
  const sanitizedLabel = hasKatex(node.label) ? await renderKatexSanitized(node.label.replace(common_default.lineBreakRegex, "\n"), config) : sanitizeText(node.label, config);
  const labelClass = node.isNode ? "nodeLabel" : "edgeLabel";
  const span = div.append("span");
  span.html(sanitizedLabel);
  applyStyle$1(span, node.labelStyle);
  span.attr("class", `${labelClass} ${classes}`);
  applyStyle$1(div, node.labelStyle);
  div.style("display", "table-cell");
  div.style("white-space", "nowrap");
  div.style("line-height", "1.5");
  div.style("max-width", width + "px");
  div.style("text-align", "center");
  div.attr("xmlns", "http://www.w3.org/1999/xhtml");
  if (addBackground) {
    div.attr("class", "labelBkg");
  }
  let bbox = div.node().getBoundingClientRect();
  if (bbox.width === width) {
    div.style("display", "table");
    div.style("white-space", "break-spaces");
    div.style("width", width + "px");
    bbox = div.node().getBoundingClientRect();
  }
  return fo.node();
}
__name(addHtmlSpan, "addHtmlSpan");
function createTspan(textElement, lineIndex, lineHeight) {
  return textElement.append("tspan").attr("class", "text-outer-tspan").attr("x", 0).attr("y", lineIndex * lineHeight - 0.1 + "em").attr("dy", lineHeight + "em");
}
__name(createTspan, "createTspan");
function computeWidthOfText(parentNode, lineHeight, line) {
  const testElement = parentNode.append("text");
  const testSpan = createTspan(testElement, 1, lineHeight);
  updateTextContentAndStyles(testSpan, line);
  const textLength = testSpan.node().getComputedTextLength();
  testElement.remove();
  return textLength;
}
__name(computeWidthOfText, "computeWidthOfText");
function computeDimensionOfText(parentNode, lineHeight, text) {
  const testElement = parentNode.append("text");
  const testSpan = createTspan(testElement, 1, lineHeight);
  updateTextContentAndStyles(testSpan, [{ content: text, type: "normal" }]);
  const textDimension = testSpan.node()?.getBoundingClientRect();
  if (textDimension) {
    testElement.remove();
  }
  return textDimension;
}
__name(computeDimensionOfText, "computeDimensionOfText");
function createFormattedText(width, g, structuredText, addBackground = false) {
  const lineHeight = 1.1;
  const labelGroup = g.append("g");
  const bkg = labelGroup.insert("rect").attr("class", "background").attr("style", "stroke: none");
  const textElement = labelGroup.append("text").attr("y", "-10.1");
  let lineIndex = 0;
  for (const line of structuredText) {
    const checkWidth = /* @__PURE__ */ __name((line2) => computeWidthOfText(labelGroup, lineHeight, line2) <= width, "checkWidth");
    const linesUnderWidth = checkWidth(line) ? [line] : splitLineToFitWidth(line, checkWidth);
    for (const preparedLine of linesUnderWidth) {
      const tspan = createTspan(textElement, lineIndex, lineHeight);
      updateTextContentAndStyles(tspan, preparedLine);
      lineIndex++;
    }
  }
  if (addBackground) {
    const bbox = textElement.node().getBBox();
    const padding = 2;
    bkg.attr("x", bbox.x - padding).attr("y", bbox.y - padding).attr("width", bbox.width + 2 * padding).attr("height", bbox.height + 2 * padding);
    return labelGroup.node();
  } else {
    return textElement.node();
  }
}
__name(createFormattedText, "createFormattedText");
function updateTextContentAndStyles(tspan, wrappedLine) {
  tspan.text("");
  wrappedLine.forEach((word, index) => {
    const innerTspan = tspan.append("tspan").attr("font-style", word.type === "em" ? "italic" : "normal").attr("class", "text-inner-tspan").attr("font-weight", word.type === "strong" ? "bold" : "normal");
    if (index === 0) {
      innerTspan.text(word.content);
    } else {
      innerTspan.text(" " + word.content);
    }
  });
}
__name(updateTextContentAndStyles, "updateTextContentAndStyles");
async function replaceIconSubstring(text, config = {}) {
  const pendingReplacements = [];
  text.replace(/(fa[bklrs]?):fa-([\w-]+)/g, (fullMatch, prefix, iconName) => {
    pendingReplacements.push(
      (async () => {
        const registeredIconName = `${prefix}:${iconName}`;
        if (await isIconAvailable(registeredIconName)) {
          return await getIconSVG(registeredIconName, void 0, { class: "label-icon" });
        } else {
          return `<i class='${sanitizeText(fullMatch, config).replace(":", " ")}'></i>`;
        }
      })()
    );
    return fullMatch;
  });
  const replacements = await Promise.all(pendingReplacements);
  return text.replace(/(fa[bklrs]?):fa-([\w-]+)/g, () => replacements.shift() ?? "");
}
__name(replaceIconSubstring, "replaceIconSubstring");
var createText = /* @__PURE__ */ __name(async (el, text = "", {
  style = "",
  isTitle = false,
  classes = "",
  useHtmlLabels = true,
  isNode = true,
  width = 200,
  addSvgBackground = false
} = {}, config) => {
  log.debug(
    "XYZ createText",
    text,
    style,
    isTitle,
    classes,
    useHtmlLabels,
    isNode,
    "addSvgBackground: ",
    addSvgBackground
  );
  if (useHtmlLabels) {
    const htmlText = markdownToHTML(text, config);
    const decodedReplacedText = await replaceIconSubstring(decodeEntities(htmlText), config);
    const inputForKatex = text.replace(/\\\\/g, "\\");
    const node = {
      isNode,
      label: hasKatex(text) ? inputForKatex : decodedReplacedText,
      labelStyle: style.replace("fill:", "color:")
    };
    const vertexNode = await addHtmlSpan(el, node, width, classes, addSvgBackground, config);
    return vertexNode;
  } else {
    const sanitizeBR = text.replace(/<br\s*\/?>/g, "<br/>");
    const structuredText = markdownToLines(sanitizeBR.replace("<br>", "<br/>"), config);
    const svgLabel = createFormattedText(
      width,
      el,
      structuredText,
      text ? addSvgBackground : false
    );
    if (isNode) {
      if (/stroke:/.exec(style)) {
        style = style.replace("stroke:", "lineColor:");
      }
      const nodeLabelTextStyle = style.replace(/stroke:[^;]+;?/g, "").replace(/stroke-width:[^;]+;?/g, "").replace(/fill:[^;]+;?/g, "").replace(/color:/g, "fill:");
      select(svgLabel).attr("style", nodeLabelTextStyle);
    } else {
      const edgeLabelRectStyle = style.replace(/stroke:[^;]+;?/g, "").replace(/stroke-width:[^;]+;?/g, "").replace(/fill:[^;]+;?/g, "").replace(/background:/g, "fill:");
      select(svgLabel).select("rect").attr("style", edgeLabelRectStyle.replace(/background:/g, "fill:"));
      const edgeLabelTextStyle = style.replace(/stroke:[^;]+;?/g, "").replace(/stroke-width:[^;]+;?/g, "").replace(/fill:[^;]+;?/g, "").replace(/color:/g, "fill:");
      select(svgLabel).select("text").attr("style", edgeLabelTextStyle);
    }
    return svgLabel;
  }
}, "createText");

function t(t,e,s){if(t&&t.length){const[n,o]=e,a=Math.PI/180*s,h=Math.cos(a),r=Math.sin(a);for(const e of t){const[t,s]=e;e[0]=(t-n)*h-(s-o)*r+n,e[1]=(t-n)*r+(s-o)*h+o;}}}function e(t,e){return t[0]===e[0]&&t[1]===e[1]}function s(s,n,o,a=1){const h=o,r=Math.max(n,.1),i=s[0]&&s[0][0]&&"number"==typeof s[0][0]?[s]:s,c=[0,0];if(h)for(const e of i)t(e,c,h);const l=function(t,s,n){const o=[];for(const s of t){const t=[...s];e(t[0],t[t.length-1])||t.push([t[0][0],t[0][1]]),t.length>2&&o.push(t);}const a=[];s=Math.max(s,.1);const h=[];for(const t of o)for(let e=0;e<t.length-1;e++){const s=t[e],n=t[e+1];if(s[1]!==n[1]){const t=Math.min(s[1],n[1]);h.push({ymin:t,ymax:Math.max(s[1],n[1]),x:t===s[1]?s[0]:n[0],islope:(n[0]-s[0])/(n[1]-s[1])});}}if(h.sort(((t,e)=>t.ymin<e.ymin?-1:t.ymin>e.ymin?1:t.x<e.x?-1:t.x>e.x?1:t.ymax===e.ymax?0:(t.ymax-e.ymax)/Math.abs(t.ymax-e.ymax))),!h.length)return a;let r=[],i=h[0].ymin,c=0;for(;r.length||h.length;){if(h.length){let t=-1;for(let e=0;e<h.length&&!(h[e].ymin>i);e++)t=e;h.splice(0,t+1).forEach((t=>{r.push({s:i,edge:t});}));}if(r=r.filter((t=>!(t.edge.ymax<=i))),r.sort(((t,e)=>t.edge.x===e.edge.x?0:(t.edge.x-e.edge.x)/Math.abs(t.edge.x-e.edge.x))),(1!==n||c%s==0)&&r.length>1)for(let t=0;t<r.length;t+=2){const e=t+1;if(e>=r.length)break;const s=r[t].edge,n=r[e].edge;a.push([[Math.round(s.x),i],[Math.round(n.x),i]]);}i+=n,r.forEach((t=>{t.edge.x=t.edge.x+n*t.edge.islope;})),c++;}return a}(i,r,a);if(h){for(const e of i)t(e,c,-h);!function(e,s,n){const o=[];e.forEach((t=>o.push(...t))),t(o,s,n);}(l,c,-h);}return l}function n(t,e){var n;const o=e.hachureAngle+90;let a=e.hachureGap;a<0&&(a=4*e.strokeWidth),a=Math.round(Math.max(a,.1));let h=1;return e.roughness>=1&&((null===(n=e.randomizer)||void 0===n?void 0:n.next())||Math.random())>.7&&(h=a),s(t,a,o,h||1)}class o{constructor(t){this.helper=t;}fillPolygons(t,e){return this._fillPolygons(t,e)}_fillPolygons(t,e){const s=n(t,e);return {type:"fillSketch",ops:this.renderLines(s,e)}}renderLines(t,e){const s=[];for(const n of t)s.push(...this.helper.doubleLineOps(n[0][0],n[0][1],n[1][0],n[1][1],e));return s}}function a(t){const e=t[0],s=t[1];return Math.sqrt(Math.pow(e[0]-s[0],2)+Math.pow(e[1]-s[1],2))}class h extends o{fillPolygons(t,e){let s=e.hachureGap;s<0&&(s=4*e.strokeWidth),s=Math.max(s,.1);const o=n(t,Object.assign({},e,{hachureGap:s})),h=Math.PI/180*e.hachureAngle,r=[],i=.5*s*Math.cos(h),c=.5*s*Math.sin(h);for(const[t,e]of o)a([t,e])&&r.push([[t[0]-i,t[1]+c],[...e]],[[t[0]+i,t[1]-c],[...e]]);return {type:"fillSketch",ops:this.renderLines(r,e)}}}class r extends o{fillPolygons(t,e){const s=this._fillPolygons(t,e),n=Object.assign({},e,{hachureAngle:e.hachureAngle+90}),o=this._fillPolygons(t,n);return s.ops=s.ops.concat(o.ops),s}}class i{constructor(t){this.helper=t;}fillPolygons(t,e){const s=n(t,e=Object.assign({},e,{hachureAngle:0}));return this.dotsOnLines(s,e)}dotsOnLines(t,e){const s=[];let n=e.hachureGap;n<0&&(n=4*e.strokeWidth),n=Math.max(n,.1);let o=e.fillWeight;o<0&&(o=e.strokeWidth/2);const h=n/4;for(const r of t){const t=a(r),i=t/n,c=Math.ceil(i)-1,l=t-c*n,u=(r[0][0]+r[1][0])/2-n/4,p=Math.min(r[0][1],r[1][1]);for(let t=0;t<c;t++){const a=p+l+t*n,r=u-h+2*Math.random()*h,i=a-h+2*Math.random()*h,c=this.helper.ellipse(r,i,o,o,e);s.push(...c.ops);}}return {type:"fillSketch",ops:s}}}class c{constructor(t){this.helper=t;}fillPolygons(t,e){const s=n(t,e);return {type:"fillSketch",ops:this.dashedLine(s,e)}}dashedLine(t,e){const s=e.dashOffset<0?e.hachureGap<0?4*e.strokeWidth:e.hachureGap:e.dashOffset,n=e.dashGap<0?e.hachureGap<0?4*e.strokeWidth:e.hachureGap:e.dashGap,o=[];return t.forEach((t=>{const h=a(t),r=Math.floor(h/(s+n)),i=(h+n-r*(s+n))/2;let c=t[0],l=t[1];c[0]>l[0]&&(c=t[1],l=t[0]);const u=Math.atan((l[1]-c[1])/(l[0]-c[0]));for(let t=0;t<r;t++){const a=t*(s+n),h=a+s,r=[c[0]+a*Math.cos(u)+i*Math.cos(u),c[1]+a*Math.sin(u)+i*Math.sin(u)],l=[c[0]+h*Math.cos(u)+i*Math.cos(u),c[1]+h*Math.sin(u)+i*Math.sin(u)];o.push(...this.helper.doubleLineOps(r[0],r[1],l[0],l[1],e));}})),o}}class l{constructor(t){this.helper=t;}fillPolygons(t,e){const s=e.hachureGap<0?4*e.strokeWidth:e.hachureGap,o=e.zigzagOffset<0?s:e.zigzagOffset,a=n(t,e=Object.assign({},e,{hachureGap:s+o}));return {type:"fillSketch",ops:this.zigzagLines(a,o,e)}}zigzagLines(t,e,s){const n=[];return t.forEach((t=>{const o=a(t),h=Math.round(o/(2*e));let r=t[0],i=t[1];r[0]>i[0]&&(r=t[1],i=t[0]);const c=Math.atan((i[1]-r[1])/(i[0]-r[0]));for(let t=0;t<h;t++){const o=2*t*e,a=2*(t+1)*e,h=Math.sqrt(2*Math.pow(e,2)),i=[r[0]+o*Math.cos(c),r[1]+o*Math.sin(c)],l=[r[0]+a*Math.cos(c),r[1]+a*Math.sin(c)],u=[i[0]+h*Math.cos(c+Math.PI/4),i[1]+h*Math.sin(c+Math.PI/4)];n.push(...this.helper.doubleLineOps(i[0],i[1],u[0],u[1],s),...this.helper.doubleLineOps(u[0],u[1],l[0],l[1],s));}})),n}}const u={};class p{constructor(t){this.seed=t;}next(){return this.seed?(2**31-1&(this.seed=Math.imul(48271,this.seed)))/2**31:Math.random()}}const f=0,d=1,g=2,M={A:7,a:7,C:6,c:6,H:1,h:1,L:2,l:2,M:2,m:2,Q:4,q:4,S:4,s:4,T:2,t:2,V:1,v:1,Z:0,z:0};function k(t,e){return t.type===e}function b(t){const e=[],s=function(t){const e=new Array;for(;""!==t;)if(t.match(/^([ \t\r\n,]+)/))t=t.substr(RegExp.$1.length);else if(t.match(/^([aAcChHlLmMqQsStTvVzZ])/))e[e.length]={type:f,text:RegExp.$1},t=t.substr(RegExp.$1.length);else {if(!t.match(/^(([-+]?[0-9]+(\.[0-9]*)?|[-+]?\.[0-9]+)([eE][-+]?[0-9]+)?)/))return [];e[e.length]={type:d,text:`${parseFloat(RegExp.$1)}`},t=t.substr(RegExp.$1.length);}return e[e.length]={type:g,text:""},e}(t);let n="BOD",o=0,a=s[o];for(;!k(a,g);){let h=0;const r=[];if("BOD"===n){if("M"!==a.text&&"m"!==a.text)return b("M0,0"+t);o++,h=M[a.text],n=a.text;}else k(a,d)?h=M[n]:(o++,h=M[a.text],n=a.text);if(!(o+h<s.length))throw new Error("Path data ended short");for(let t=o;t<o+h;t++){const e=s[t];if(!k(e,d))throw new Error("Param not a number: "+n+","+e.text);r[r.length]=+e.text;}if("number"!=typeof M[n])throw new Error("Bad segment: "+n);{const t={key:n,data:r};e.push(t),o+=h,a=s[o],"M"===n&&(n="L"),"m"===n&&(n="l");}}return e}function y(t){let e=0,s=0,n=0,o=0;const a=[];for(const{key:h,data:r}of t)switch(h){case "M":a.push({key:"M",data:[...r]}),[e,s]=r,[n,o]=r;break;case "m":e+=r[0],s+=r[1],a.push({key:"M",data:[e,s]}),n=e,o=s;break;case "L":a.push({key:"L",data:[...r]}),[e,s]=r;break;case "l":e+=r[0],s+=r[1],a.push({key:"L",data:[e,s]});break;case "C":a.push({key:"C",data:[...r]}),e=r[4],s=r[5];break;case "c":{const t=r.map(((t,n)=>n%2?t+s:t+e));a.push({key:"C",data:t}),e=t[4],s=t[5];break}case "Q":a.push({key:"Q",data:[...r]}),e=r[2],s=r[3];break;case "q":{const t=r.map(((t,n)=>n%2?t+s:t+e));a.push({key:"Q",data:t}),e=t[2],s=t[3];break}case "A":a.push({key:"A",data:[...r]}),e=r[5],s=r[6];break;case "a":e+=r[5],s+=r[6],a.push({key:"A",data:[r[0],r[1],r[2],r[3],r[4],e,s]});break;case "H":a.push({key:"H",data:[...r]}),e=r[0];break;case "h":e+=r[0],a.push({key:"H",data:[e]});break;case "V":a.push({key:"V",data:[...r]}),s=r[0];break;case "v":s+=r[0],a.push({key:"V",data:[s]});break;case "S":a.push({key:"S",data:[...r]}),e=r[2],s=r[3];break;case "s":{const t=r.map(((t,n)=>n%2?t+s:t+e));a.push({key:"S",data:t}),e=t[2],s=t[3];break}case "T":a.push({key:"T",data:[...r]}),e=r[0],s=r[1];break;case "t":e+=r[0],s+=r[1],a.push({key:"T",data:[e,s]});break;case "Z":case "z":a.push({key:"Z",data:[]}),e=n,s=o;}return a}function m(t){const e=[];let s="",n=0,o=0,a=0,h=0,r=0,i=0;for(const{key:c,data:l}of t){switch(c){case "M":e.push({key:"M",data:[...l]}),[n,o]=l,[a,h]=l;break;case "C":e.push({key:"C",data:[...l]}),n=l[4],o=l[5],r=l[2],i=l[3];break;case "L":e.push({key:"L",data:[...l]}),[n,o]=l;break;case "H":n=l[0],e.push({key:"L",data:[n,o]});break;case "V":o=l[0],e.push({key:"L",data:[n,o]});break;case "S":{let t=0,a=0;"C"===s||"S"===s?(t=n+(n-r),a=o+(o-i)):(t=n,a=o),e.push({key:"C",data:[t,a,...l]}),r=l[0],i=l[1],n=l[2],o=l[3];break}case "T":{const[t,a]=l;let h=0,c=0;"Q"===s||"T"===s?(h=n+(n-r),c=o+(o-i)):(h=n,c=o);const u=n+2*(h-n)/3,p=o+2*(c-o)/3,f=t+2*(h-t)/3,d=a+2*(c-a)/3;e.push({key:"C",data:[u,p,f,d,t,a]}),r=h,i=c,n=t,o=a;break}case "Q":{const[t,s,a,h]=l,c=n+2*(t-n)/3,u=o+2*(s-o)/3,p=a+2*(t-a)/3,f=h+2*(s-h)/3;e.push({key:"C",data:[c,u,p,f,a,h]}),r=t,i=s,n=a,o=h;break}case "A":{const t=Math.abs(l[0]),s=Math.abs(l[1]),a=l[2],h=l[3],r=l[4],i=l[5],c=l[6];if(0===t||0===s)e.push({key:"C",data:[n,o,i,c,i,c]}),n=i,o=c;else if(n!==i||o!==c){x(n,o,i,c,t,s,a,h,r).forEach((function(t){e.push({key:"C",data:t});})),n=i,o=c;}break}case "Z":e.push({key:"Z",data:[]}),n=a,o=h;}s=c;}return e}function w(t,e,s){return [t*Math.cos(s)-e*Math.sin(s),t*Math.sin(s)+e*Math.cos(s)]}function x(t,e,s,n,o,a,h,r,i,c){const l=(u=h,Math.PI*u/180);var u;let p=[],f=0,d=0,g=0,M=0;if(c)[f,d,g,M]=c;else {[t,e]=w(t,e,-l),[s,n]=w(s,n,-l);const h=(t-s)/2,c=(e-n)/2;let u=h*h/(o*o)+c*c/(a*a);u>1&&(u=Math.sqrt(u),o*=u,a*=u);const p=o*o,k=a*a,b=p*k-p*c*c-k*h*h,y=p*c*c+k*h*h,m=(r===i?-1:1)*Math.sqrt(Math.abs(b/y));g=m*o*c/a+(t+s)/2,M=m*-a*h/o+(e+n)/2,f=Math.asin(parseFloat(((e-M)/a).toFixed(9))),d=Math.asin(parseFloat(((n-M)/a).toFixed(9))),t<g&&(f=Math.PI-f),s<g&&(d=Math.PI-d),f<0&&(f=2*Math.PI+f),d<0&&(d=2*Math.PI+d),i&&f>d&&(f-=2*Math.PI),!i&&d>f&&(d-=2*Math.PI);}let k=d-f;if(Math.abs(k)>120*Math.PI/180){const t=d,e=s,r=n;d=i&&d>f?f+120*Math.PI/180*1:f+120*Math.PI/180*-1,p=x(s=g+o*Math.cos(d),n=M+a*Math.sin(d),e,r,o,a,h,0,i,[d,t,g,M]);}k=d-f;const b=Math.cos(f),y=Math.sin(f),m=Math.cos(d),P=Math.sin(d),v=Math.tan(k/4),S=4/3*o*v,O=4/3*a*v,L=[t,e],T=[t+S*y,e-O*b],D=[s+S*P,n-O*m],A=[s,n];if(T[0]=2*L[0]-T[0],T[1]=2*L[1]-T[1],c)return [T,D,A].concat(p);{p=[T,D,A].concat(p);const t=[];for(let e=0;e<p.length;e+=3){const s=w(p[e][0],p[e][1],l),n=w(p[e+1][0],p[e+1][1],l),o=w(p[e+2][0],p[e+2][1],l);t.push([s[0],s[1],n[0],n[1],o[0],o[1]]);}return t}}const P={randOffset:function(t,e){return G(t,e)},randOffsetWithRange:function(t,e,s){return E(t,e,s)},ellipse:function(t,e,s,n,o){const a=T(s,n,o);return D(t,e,o,a).opset},doubleLineOps:function(t,e,s,n,o){return $(t,e,s,n,o,true)}};function v(t,e,s,n,o){return {type:"path",ops:$(t,e,s,n,o)}}function S(t,e,s){const n=(t||[]).length;if(n>2){const o=[];for(let e=0;e<n-1;e++)o.push(...$(t[e][0],t[e][1],t[e+1][0],t[e+1][1],s));return e&&o.push(...$(t[n-1][0],t[n-1][1],t[0][0],t[0][1],s)),{type:"path",ops:o}}return 2===n?v(t[0][0],t[0][1],t[1][0],t[1][1],s):{type:"path",ops:[]}}function O(t,e,s,n,o){return function(t,e){return S(t,true,e)}([[t,e],[t+s,e],[t+s,e+n],[t,e+n]],o)}function L(t,e){if(t.length){const s="number"==typeof t[0][0]?[t]:t,n=j(s[0],1*(1+.2*e.roughness),e),o=e.disableMultiStroke?[]:j(s[0],1.5*(1+.22*e.roughness),z(e));for(let t=1;t<s.length;t++){const a=s[t];if(a.length){const t=j(a,1*(1+.2*e.roughness),e),s=e.disableMultiStroke?[]:j(a,1.5*(1+.22*e.roughness),z(e));for(const e of t)"move"!==e.op&&n.push(e);for(const t of s)"move"!==t.op&&o.push(t);}}return {type:"path",ops:n.concat(o)}}return {type:"path",ops:[]}}function T(t,e,s){const n=Math.sqrt(2*Math.PI*Math.sqrt((Math.pow(t/2,2)+Math.pow(e/2,2))/2)),o=Math.ceil(Math.max(s.curveStepCount,s.curveStepCount/Math.sqrt(200)*n)),a=2*Math.PI/o;let h=Math.abs(t/2),r=Math.abs(e/2);const i=1-s.curveFitting;return h+=G(h*i,s),r+=G(r*i,s),{increment:a,rx:h,ry:r}}function D(t,e,s,n){const[o,a]=F(n.increment,t,e,n.rx,n.ry,1,n.increment*E(.1,E(.4,1,s),s),s);let h=q(o,null,s);if(!s.disableMultiStroke&&0!==s.roughness){const[o]=F(n.increment,t,e,n.rx,n.ry,1.5,0,s),a=q(o,null,s);h=h.concat(a);}return {estimatedPoints:a,opset:{type:"path",ops:h}}}function A(t,e,s,n,o,a,h,r,i){const c=t,l=e;let u=Math.abs(s/2),p=Math.abs(n/2);u+=G(.01*u,i),p+=G(.01*p,i);let f=o,d=a;for(;f<0;)f+=2*Math.PI,d+=2*Math.PI;d-f>2*Math.PI&&(f=0,d=2*Math.PI);const g=2*Math.PI/i.curveStepCount,M=Math.min(g/2,(d-f)/2),k=V(M,c,l,u,p,f,d,1,i);if(!i.disableMultiStroke){const t=V(M,c,l,u,p,f,d,1.5,i);k.push(...t);}return h&&(r?k.push(...$(c,l,c+u*Math.cos(f),l+p*Math.sin(f),i),...$(c,l,c+u*Math.cos(d),l+p*Math.sin(d),i)):k.push({op:"lineTo",data:[c,l]},{op:"lineTo",data:[c+u*Math.cos(f),l+p*Math.sin(f)]})),{type:"path",ops:k}}function _(t,e){const s=m(y(b(t))),n=[];let o=[0,0],a=[0,0];for(const{key:t,data:h}of s)switch(t){case "M":a=[h[0],h[1]],o=[h[0],h[1]];break;case "L":n.push(...$(a[0],a[1],h[0],h[1],e)),a=[h[0],h[1]];break;case "C":{const[t,s,o,r,i,c]=h;n.push(...Z(t,s,o,r,i,c,a,e)),a=[i,c];break}case "Z":n.push(...$(a[0],a[1],o[0],o[1],e)),a=[o[0],o[1]];}return {type:"path",ops:n}}function I(t,e){const s=[];for(const n of t)if(n.length){const t=e.maxRandomnessOffset||0,o=n.length;if(o>2){s.push({op:"move",data:[n[0][0]+G(t,e),n[0][1]+G(t,e)]});for(let a=1;a<o;a++)s.push({op:"lineTo",data:[n[a][0]+G(t,e),n[a][1]+G(t,e)]});}}return {type:"fillPath",ops:s}}function C(t,e){return function(t,e){let s=t.fillStyle||"hachure";if(!u[s])switch(s){case "zigzag":u[s]||(u[s]=new h(e));break;case "cross-hatch":u[s]||(u[s]=new r(e));break;case "dots":u[s]||(u[s]=new i(e));break;case "dashed":u[s]||(u[s]=new c(e));break;case "zigzag-line":u[s]||(u[s]=new l(e));break;default:s="hachure",u[s]||(u[s]=new o(e));}return u[s]}(e,P).fillPolygons(t,e)}function z(t){const e=Object.assign({},t);return e.randomizer=void 0,t.seed&&(e.seed=t.seed+1),e}function W(t){return t.randomizer||(t.randomizer=new p(t.seed||0)),t.randomizer.next()}function E(t,e,s,n=1){return s.roughness*n*(W(s)*(e-t)+t)}function G(t,e,s=1){return E(-t,t,e,s)}function $(t,e,s,n,o,a=false){const h=a?o.disableMultiStrokeFill:o.disableMultiStroke,r=R(t,e,s,n,o,true,false);if(h)return r;const i=R(t,e,s,n,o,true,true);return r.concat(i)}function R(t,e,s,n,o,a,h){const r=Math.pow(t-s,2)+Math.pow(e-n,2),i=Math.sqrt(r);let c=1;c=i<200?1:i>500?.4:-16668e-7*i+1.233334;let l=o.maxRandomnessOffset||0;l*l*100>r&&(l=i/10);const u=l/2,p=.2+.2*W(o);let f=o.bowing*o.maxRandomnessOffset*(n-e)/200,d=o.bowing*o.maxRandomnessOffset*(t-s)/200;f=G(f,o,c),d=G(d,o,c);const g=[],M=()=>G(u,o,c),k=()=>G(l,o,c),b=o.preserveVertices;return (h?g.push({op:"move",data:[t+(b?0:M()),e+(b?0:M())]}):g.push({op:"move",data:[t+(b?0:G(l,o,c)),e+(b?0:G(l,o,c))]})),h?g.push({op:"bcurveTo",data:[f+t+(s-t)*p+M(),d+e+(n-e)*p+M(),f+t+2*(s-t)*p+M(),d+e+2*(n-e)*p+M(),s+(b?0:M()),n+(b?0:M())]}):g.push({op:"bcurveTo",data:[f+t+(s-t)*p+k(),d+e+(n-e)*p+k(),f+t+2*(s-t)*p+k(),d+e+2*(n-e)*p+k(),s+(b?0:k()),n+(b?0:k())]}),g}function j(t,e,s){if(!t.length)return [];const n=[];n.push([t[0][0]+G(e,s),t[0][1]+G(e,s)]),n.push([t[0][0]+G(e,s),t[0][1]+G(e,s)]);for(let o=1;o<t.length;o++)n.push([t[o][0]+G(e,s),t[o][1]+G(e,s)]),o===t.length-1&&n.push([t[o][0]+G(e,s),t[o][1]+G(e,s)]);return q(n,null,s)}function q(t,e,s){const n=t.length,o=[];if(n>3){const a=[],h=1-s.curveTightness;o.push({op:"move",data:[t[1][0],t[1][1]]});for(let e=1;e+2<n;e++){const s=t[e];a[0]=[s[0],s[1]],a[1]=[s[0]+(h*t[e+1][0]-h*t[e-1][0])/6,s[1]+(h*t[e+1][1]-h*t[e-1][1])/6],a[2]=[t[e+1][0]+(h*t[e][0]-h*t[e+2][0])/6,t[e+1][1]+(h*t[e][1]-h*t[e+2][1])/6],a[3]=[t[e+1][0],t[e+1][1]],o.push({op:"bcurveTo",data:[a[1][0],a[1][1],a[2][0],a[2][1],a[3][0],a[3][1]]});}}else 3===n?(o.push({op:"move",data:[t[1][0],t[1][1]]}),o.push({op:"bcurveTo",data:[t[1][0],t[1][1],t[2][0],t[2][1],t[2][0],t[2][1]]})):2===n&&o.push(...R(t[0][0],t[0][1],t[1][0],t[1][1],s,true,true));return o}function F(t,e,s,n,o,a,h,r){const i=[],c=[];if(0===r.roughness){t/=4,c.push([e+n*Math.cos(-t),s+o*Math.sin(-t)]);for(let a=0;a<=2*Math.PI;a+=t){const t=[e+n*Math.cos(a),s+o*Math.sin(a)];i.push(t),c.push(t);}c.push([e+n*Math.cos(0),s+o*Math.sin(0)]),c.push([e+n*Math.cos(t),s+o*Math.sin(t)]);}else {const l=G(.5,r)-Math.PI/2;c.push([G(a,r)+e+.9*n*Math.cos(l-t),G(a,r)+s+.9*o*Math.sin(l-t)]);const u=2*Math.PI+l-.01;for(let h=l;h<u;h+=t){const t=[G(a,r)+e+n*Math.cos(h),G(a,r)+s+o*Math.sin(h)];i.push(t),c.push(t);}c.push([G(a,r)+e+n*Math.cos(l+2*Math.PI+.5*h),G(a,r)+s+o*Math.sin(l+2*Math.PI+.5*h)]),c.push([G(a,r)+e+.98*n*Math.cos(l+h),G(a,r)+s+.98*o*Math.sin(l+h)]),c.push([G(a,r)+e+.9*n*Math.cos(l+.5*h),G(a,r)+s+.9*o*Math.sin(l+.5*h)]);}return [c,i]}function V(t,e,s,n,o,a,h,r,i){const c=a+G(.1,i),l=[];l.push([G(r,i)+e+.9*n*Math.cos(c-t),G(r,i)+s+.9*o*Math.sin(c-t)]);for(let a=c;a<=h;a+=t)l.push([G(r,i)+e+n*Math.cos(a),G(r,i)+s+o*Math.sin(a)]);return l.push([e+n*Math.cos(h),s+o*Math.sin(h)]),l.push([e+n*Math.cos(h),s+o*Math.sin(h)]),q(l,null,i)}function Z(t,e,s,n,o,a,h,r){const i=[],c=[r.maxRandomnessOffset||1,(r.maxRandomnessOffset||1)+.3];let l=[0,0];const u=r.disableMultiStroke?1:2,p=r.preserveVertices;for(let f=0;f<u;f++)0===f?i.push({op:"move",data:[h[0],h[1]]}):i.push({op:"move",data:[h[0]+(p?0:G(c[0],r)),h[1]+(p?0:G(c[0],r))]}),l=p?[o,a]:[o+G(c[f],r),a+G(c[f],r)],i.push({op:"bcurveTo",data:[t+G(c[f],r),e+G(c[f],r),s+G(c[f],r),n+G(c[f],r),l[0],l[1]]});return i}function Q(t){return [...t]}function H(t,e=0){const s=t.length;if(s<3)throw new Error("A curve must have at least three points.");const n=[];if(3===s)n.push(Q(t[0]),Q(t[1]),Q(t[2]),Q(t[2]));else {const s=[];s.push(t[0],t[0]);for(let e=1;e<t.length;e++)s.push(t[e]),e===t.length-1&&s.push(t[e]);const o=[],a=1-e;n.push(Q(s[0]));for(let t=1;t+2<s.length;t++){const e=s[t];o[0]=[e[0],e[1]],o[1]=[e[0]+(a*s[t+1][0]-a*s[t-1][0])/6,e[1]+(a*s[t+1][1]-a*s[t-1][1])/6],o[2]=[s[t+1][0]+(a*s[t][0]-a*s[t+2][0])/6,s[t+1][1]+(a*s[t][1]-a*s[t+2][1])/6],o[3]=[s[t+1][0],s[t+1][1]],n.push(o[1],o[2],o[3]);}}return n}function N(t,e){return Math.pow(t[0]-e[0],2)+Math.pow(t[1]-e[1],2)}function B(t,e,s){const n=N(e,s);if(0===n)return N(t,e);let o=((t[0]-e[0])*(s[0]-e[0])+(t[1]-e[1])*(s[1]-e[1]))/n;return o=Math.max(0,Math.min(1,o)),N(t,J(e,s,o))}function J(t,e,s){return [t[0]+(e[0]-t[0])*s,t[1]+(e[1]-t[1])*s]}function K(t,e,s,n){const o=n||[];if(function(t,e){const s=t[e+0],n=t[e+1],o=t[e+2],a=t[e+3];let h=3*n[0]-2*s[0]-a[0];h*=h;let r=3*n[1]-2*s[1]-a[1];r*=r;let i=3*o[0]-2*a[0]-s[0];i*=i;let c=3*o[1]-2*a[1]-s[1];return c*=c,h<i&&(h=i),r<c&&(r=c),h+r}(t,e)<s){const s=t[e+0];if(o.length){(a=o[o.length-1],h=s,Math.sqrt(N(a,h)))>1&&o.push(s);}else o.push(s);o.push(t[e+3]);}else {const n=.5,a=t[e+0],h=t[e+1],r=t[e+2],i=t[e+3],c=J(a,h,n),l=J(h,r,n),u=J(r,i,n),p=J(c,l,n),f=J(l,u,n),d=J(p,f,n);K([a,c,p,d],0,s,o),K([d,f,u,i],0,s,o);}var a,h;return o}function U(t,e){return X(t,0,t.length,e)}function X(t,e,s,n,o){const a=o||[],h=t[e],r=t[s-1];let i=0,c=1;for(let n=e+1;n<s-1;++n){const e=B(t[n],h,r);e>i&&(i=e,c=n);}return Math.sqrt(i)>n?(X(t,e,c+1,n,a),X(t,c,s,n,a)):(a.length||a.push(h),a.push(r)),a}function Y(t,e=.15,s){const n=[],o=(t.length-1)/3;for(let s=0;s<o;s++){K(t,3*s,e,n);}return s&&s>0?X(n,0,n.length,s):n}const tt="none";class et{constructor(t){this.defaultOptions={maxRandomnessOffset:2,roughness:1,bowing:1,stroke:"#000",strokeWidth:1,curveTightness:0,curveFitting:.95,curveStepCount:9,fillStyle:"hachure",fillWeight:-1,hachureAngle:-41,hachureGap:-1,dashOffset:-1,dashGap:-1,zigzagOffset:-1,seed:0,disableMultiStroke:false,disableMultiStrokeFill:false,preserveVertices:false,fillShapeRoughnessGain:.8},this.config=t||{},this.config.options&&(this.defaultOptions=this._o(this.config.options));}static newSeed(){return Math.floor(Math.random()*2**31)}_o(t){return t?Object.assign({},this.defaultOptions,t):this.defaultOptions}_d(t,e,s){return {shape:t,sets:e||[],options:s||this.defaultOptions}}line(t,e,s,n,o){const a=this._o(o);return this._d("line",[v(t,e,s,n,a)],a)}rectangle(t,e,s,n,o){const a=this._o(o),h=[],r=O(t,e,s,n,a);if(a.fill){const o=[[t,e],[t+s,e],[t+s,e+n],[t,e+n]];"solid"===a.fillStyle?h.push(I([o],a)):h.push(C([o],a));}return a.stroke!==tt&&h.push(r),this._d("rectangle",h,a)}ellipse(t,e,s,n,o){const a=this._o(o),h=[],r=T(s,n,a),i=D(t,e,a,r);if(a.fill)if("solid"===a.fillStyle){const s=D(t,e,a,r).opset;s.type="fillPath",h.push(s);}else h.push(C([i.estimatedPoints],a));return a.stroke!==tt&&h.push(i.opset),this._d("ellipse",h,a)}circle(t,e,s,n){const o=this.ellipse(t,e,s,s,n);return o.shape="circle",o}linearPath(t,e){const s=this._o(e);return this._d("linearPath",[S(t,false,s)],s)}arc(t,e,s,n,o,a,h=false,r){const i=this._o(r),c=[],l=A(t,e,s,n,o,a,h,true,i);if(h&&i.fill)if("solid"===i.fillStyle){const h=Object.assign({},i);h.disableMultiStroke=true;const r=A(t,e,s,n,o,a,true,false,h);r.type="fillPath",c.push(r);}else c.push(function(t,e,s,n,o,a,h){const r=t,i=e;let c=Math.abs(s/2),l=Math.abs(n/2);c+=G(.01*c,h),l+=G(.01*l,h);let u=o,p=a;for(;u<0;)u+=2*Math.PI,p+=2*Math.PI;p-u>2*Math.PI&&(u=0,p=2*Math.PI);const f=(p-u)/h.curveStepCount,d=[];for(let t=u;t<=p;t+=f)d.push([r+c*Math.cos(t),i+l*Math.sin(t)]);return d.push([r+c*Math.cos(p),i+l*Math.sin(p)]),d.push([r,i]),C([d],h)}(t,e,s,n,o,a,i));return i.stroke!==tt&&c.push(l),this._d("arc",c,i)}curve(t,e){const s=this._o(e),n=[],o=L(t,s);if(s.fill&&s.fill!==tt)if("solid"===s.fillStyle){const e=L(t,Object.assign(Object.assign({},s),{disableMultiStroke:true,roughness:s.roughness?s.roughness+s.fillShapeRoughnessGain:0}));n.push({type:"fillPath",ops:this._mergedShape(e.ops)});}else {const e=[],o=t;if(o.length){const t="number"==typeof o[0][0]?[o]:o;for(const n of t)n.length<3?e.push(...n):3===n.length?e.push(...Y(H([n[0],n[0],n[1],n[2]]),10,(1+s.roughness)/2)):e.push(...Y(H(n),10,(1+s.roughness)/2));}e.length&&n.push(C([e],s));}return s.stroke!==tt&&n.push(o),this._d("curve",n,s)}polygon(t,e){const s=this._o(e),n=[],o=S(t,true,s);return s.fill&&("solid"===s.fillStyle?n.push(I([t],s)):n.push(C([t],s))),s.stroke!==tt&&n.push(o),this._d("polygon",n,s)}path(t,e){const s=this._o(e),n=[];if(!t)return this._d("path",n,s);t=(t||"").replace(/\n/g," ").replace(/(-\s)/g,"-").replace("/(ss)/g"," ");const o=s.fill&&"transparent"!==s.fill&&s.fill!==tt,a=s.stroke!==tt,h=!!(s.simplification&&s.simplification<1),r=function(t,e,s){const n=m(y(b(t))),o=[];let a=[],h=[0,0],r=[];const i=()=>{r.length>=4&&a.push(...Y(r,e)),r=[];},c=()=>{i(),a.length&&(o.push(a),a=[]);};for(const{key:t,data:e}of n)switch(t){case "M":c(),h=[e[0],e[1]],a.push(h);break;case "L":i(),a.push([e[0],e[1]]);break;case "C":if(!r.length){const t=a.length?a[a.length-1]:h;r.push([t[0],t[1]]);}r.push([e[0],e[1]]),r.push([e[2],e[3]]),r.push([e[4],e[5]]);break;case "Z":i(),a.push([h[0],h[1]]);}if(c(),!s)return o;const l=[];for(const t of o){const e=U(t,s);e.length&&l.push(e);}return l}(t,1,h?4-4*(s.simplification||1):(1+s.roughness)/2),i=_(t,s);if(o)if("solid"===s.fillStyle)if(1===r.length){const e=_(t,Object.assign(Object.assign({},s),{disableMultiStroke:true,roughness:s.roughness?s.roughness+s.fillShapeRoughnessGain:0}));n.push({type:"fillPath",ops:this._mergedShape(e.ops)});}else n.push(I(r,s));else n.push(C(r,s));return a&&(h?r.forEach((t=>{n.push(S(t,false,s));})):n.push(i)),this._d("path",n,s)}opsToPath(t,e){let s="";for(const n of t.ops){const t="number"==typeof e&&e>=0?n.data.map((t=>+t.toFixed(e))):n.data;switch(n.op){case "move":s+=`M${t[0]} ${t[1]} `;break;case "bcurveTo":s+=`C${t[0]} ${t[1]}, ${t[2]} ${t[3]}, ${t[4]} ${t[5]} `;break;case "lineTo":s+=`L${t[0]} ${t[1]} `;}}return s.trim()}toPaths(t){const e=t.sets||[],s=t.options||this.defaultOptions,n=[];for(const t of e){let e=null;switch(t.type){case "path":e={d:this.opsToPath(t),stroke:s.stroke,strokeWidth:s.strokeWidth,fill:tt};break;case "fillPath":e={d:this.opsToPath(t),stroke:tt,strokeWidth:0,fill:s.fill||tt};break;case "fillSketch":e=this.fillSketch(t,s);}e&&n.push(e);}return n}fillSketch(t,e){let s=e.fillWeight;return s<0&&(s=e.strokeWidth/2),{d:this.opsToPath(t),stroke:e.fill||tt,strokeWidth:s,fill:tt}}_mergedShape(t){return t.filter(((t,e)=>0===e||"move"!==t.op))}}class st{constructor(t,e){this.canvas=t,this.ctx=this.canvas.getContext("2d"),this.gen=new et(e);}draw(t){const e=t.sets||[],s=t.options||this.getDefaultOptions(),n=this.ctx,o=t.options.fixedDecimalPlaceDigits;for(const a of e)switch(a.type){case "path":n.save(),n.strokeStyle="none"===s.stroke?"transparent":s.stroke,n.lineWidth=s.strokeWidth,s.strokeLineDash&&n.setLineDash(s.strokeLineDash),s.strokeLineDashOffset&&(n.lineDashOffset=s.strokeLineDashOffset),this._drawToContext(n,a,o),n.restore();break;case "fillPath":{n.save(),n.fillStyle=s.fill||"";const e="curve"===t.shape||"polygon"===t.shape||"path"===t.shape?"evenodd":"nonzero";this._drawToContext(n,a,o,e),n.restore();break}case "fillSketch":this.fillSketch(n,a,s);}}fillSketch(t,e,s){let n=s.fillWeight;n<0&&(n=s.strokeWidth/2),t.save(),s.fillLineDash&&t.setLineDash(s.fillLineDash),s.fillLineDashOffset&&(t.lineDashOffset=s.fillLineDashOffset),t.strokeStyle=s.fill||"",t.lineWidth=n,this._drawToContext(t,e,s.fixedDecimalPlaceDigits),t.restore();}_drawToContext(t,e,s,n="nonzero"){t.beginPath();for(const n of e.ops){const e="number"==typeof s&&s>=0?n.data.map((t=>+t.toFixed(s))):n.data;switch(n.op){case "move":t.moveTo(e[0],e[1]);break;case "bcurveTo":t.bezierCurveTo(e[0],e[1],e[2],e[3],e[4],e[5]);break;case "lineTo":t.lineTo(e[0],e[1]);}}"fillPath"===e.type?t.fill(n):t.stroke();}get generator(){return this.gen}getDefaultOptions(){return this.gen.defaultOptions}line(t,e,s,n,o){const a=this.gen.line(t,e,s,n,o);return this.draw(a),a}rectangle(t,e,s,n,o){const a=this.gen.rectangle(t,e,s,n,o);return this.draw(a),a}ellipse(t,e,s,n,o){const a=this.gen.ellipse(t,e,s,n,o);return this.draw(a),a}circle(t,e,s,n){const o=this.gen.circle(t,e,s,n);return this.draw(o),o}linearPath(t,e){const s=this.gen.linearPath(t,e);return this.draw(s),s}polygon(t,e){const s=this.gen.polygon(t,e);return this.draw(s),s}arc(t,e,s,n,o,a,h=false,r){const i=this.gen.arc(t,e,s,n,o,a,h,r);return this.draw(i),i}curve(t,e){const s=this.gen.curve(t,e);return this.draw(s),s}path(t,e){const s=this.gen.path(t,e);return this.draw(s),s}}const nt="http://www.w3.org/2000/svg";class ot{constructor(t,e){this.svg=t,this.gen=new et(e);}draw(t){const e=t.sets||[],s=t.options||this.getDefaultOptions(),n=this.svg.ownerDocument||window.document,o=n.createElementNS(nt,"g"),a=t.options.fixedDecimalPlaceDigits;for(const h of e){let e=null;switch(h.type){case "path":e=n.createElementNS(nt,"path"),e.setAttribute("d",this.opsToPath(h,a)),e.setAttribute("stroke",s.stroke),e.setAttribute("stroke-width",s.strokeWidth+""),e.setAttribute("fill","none"),s.strokeLineDash&&e.setAttribute("stroke-dasharray",s.strokeLineDash.join(" ").trim()),s.strokeLineDashOffset&&e.setAttribute("stroke-dashoffset",`${s.strokeLineDashOffset}`);break;case "fillPath":e=n.createElementNS(nt,"path"),e.setAttribute("d",this.opsToPath(h,a)),e.setAttribute("stroke","none"),e.setAttribute("stroke-width","0"),e.setAttribute("fill",s.fill||""),"curve"!==t.shape&&"polygon"!==t.shape||e.setAttribute("fill-rule","evenodd");break;case "fillSketch":e=this.fillSketch(n,h,s);}e&&o.appendChild(e);}return o}fillSketch(t,e,s){let n=s.fillWeight;n<0&&(n=s.strokeWidth/2);const o=t.createElementNS(nt,"path");return o.setAttribute("d",this.opsToPath(e,s.fixedDecimalPlaceDigits)),o.setAttribute("stroke",s.fill||""),o.setAttribute("stroke-width",n+""),o.setAttribute("fill","none"),s.fillLineDash&&o.setAttribute("stroke-dasharray",s.fillLineDash.join(" ").trim()),s.fillLineDashOffset&&o.setAttribute("stroke-dashoffset",`${s.fillLineDashOffset}`),o}get generator(){return this.gen}getDefaultOptions(){return this.gen.defaultOptions}opsToPath(t,e){return this.gen.opsToPath(t,e)}line(t,e,s,n,o){const a=this.gen.line(t,e,s,n,o);return this.draw(a)}rectangle(t,e,s,n,o){const a=this.gen.rectangle(t,e,s,n,o);return this.draw(a)}ellipse(t,e,s,n,o){const a=this.gen.ellipse(t,e,s,n,o);return this.draw(a)}circle(t,e,s,n){const o=this.gen.circle(t,e,s,n);return this.draw(o)}linearPath(t,e){const s=this.gen.linearPath(t,e);return this.draw(s)}polygon(t,e){const s=this.gen.polygon(t,e);return this.draw(s)}arc(t,e,s,n,o,a,h=false,r){const i=this.gen.arc(t,e,s,n,o,a,h,r);return this.draw(i)}curve(t,e){const s=this.gen.curve(t,e);return this.draw(s)}path(t,e){const s=this.gen.path(t,e);return this.draw(s)}}var at={canvas:(t,e)=>new st(t,e),svg:(t,e)=>new ot(t,e),generator:t=>new et(t),newSeed:()=>et.newSeed()};

var labelHelper = /* @__PURE__ */ __name(async (parent, node, _classes) => {
  let cssClasses;
  const useHtmlLabels = node.useHtmlLabels || evaluate(getConfig2()?.htmlLabels);
  if (!_classes) {
    cssClasses = "node default";
  } else {
    cssClasses = _classes;
  }
  const shapeSvg = parent.insert("g").attr("class", cssClasses).attr("id", node.domId || node.id);
  const labelEl = shapeSvg.insert("g").attr("class", "label").attr("style", handleUndefinedAttr(node.labelStyle));
  let label;
  if (node.label === void 0) {
    label = "";
  } else {
    label = typeof node.label === "string" ? node.label : node.label[0];
  }
  const text2 = await createText(labelEl, sanitizeText(decodeEntities(label), getConfig2()), {
    useHtmlLabels,
    width: node.width || getConfig2().flowchart?.wrappingWidth,
    // @ts-expect-error -- This is currently not used. Should this be `classes` instead?
    cssClasses: "markdown-node-label",
    style: node.labelStyle,
    addSvgBackground: !!node.icon || !!node.img
  });
  let bbox = text2.getBBox();
  const halfPadding = (node?.padding ?? 0) / 2;
  if (useHtmlLabels) {
    const div = text2.children[0];
    const dv = select(text2);
    const images = div.getElementsByTagName("img");
    if (images) {
      const noImgText = label.replace(/<img[^>]*>/g, "").trim() === "";
      await Promise.all(
        [...images].map(
          (img) => new Promise((res) => {
            function setupImage() {
              img.style.display = "flex";
              img.style.flexDirection = "column";
              if (noImgText) {
                const bodyFontSize = getConfig2().fontSize ? getConfig2().fontSize : window.getComputedStyle(document.body).fontSize;
                const enlargingFactor = 5;
                const [parsedBodyFontSize = defaultConfig_default.fontSize] = parseFontSize(bodyFontSize);
                const width = parsedBodyFontSize * enlargingFactor + "px";
                img.style.minWidth = width;
                img.style.maxWidth = width;
              } else {
                img.style.width = "100%";
              }
              res(img);
            }
            __name(setupImage, "setupImage");
            setTimeout(() => {
              if (img.complete) {
                setupImage();
              }
            });
            img.addEventListener("error", setupImage);
            img.addEventListener("load", setupImage);
          })
        )
      );
    }
    bbox = div.getBoundingClientRect();
    dv.attr("width", bbox.width);
    dv.attr("height", bbox.height);
  }
  if (useHtmlLabels) {
    labelEl.attr("transform", "translate(" + -bbox.width / 2 + ", " + -bbox.height / 2 + ")");
  } else {
    labelEl.attr("transform", "translate(0, " + -bbox.height / 2 + ")");
  }
  if (node.centerLabel) {
    labelEl.attr("transform", "translate(" + -bbox.width / 2 + ", " + -bbox.height / 2 + ")");
  }
  labelEl.insert("rect", ":first-child");
  return { shapeSvg, bbox, halfPadding, label: labelEl };
}, "labelHelper");
var insertLabel = /* @__PURE__ */ __name(async (parent, label, options) => {
  const useHtmlLabels = options.useHtmlLabels || evaluate(getConfig2()?.flowchart?.htmlLabels);
  const labelEl = parent.insert("g").attr("class", "label").attr("style", options.labelStyle || "");
  const text2 = await createText(labelEl, sanitizeText(decodeEntities(label), getConfig2()), {
    useHtmlLabels,
    width: options.width || getConfig2()?.flowchart?.wrappingWidth,
    style: options.labelStyle,
    addSvgBackground: !!options.icon || !!options.img
  });
  let bbox = text2.getBBox();
  const halfPadding = options.padding / 2;
  if (evaluate(getConfig2()?.flowchart?.htmlLabels)) {
    const div = text2.children[0];
    const dv = select(text2);
    bbox = div.getBoundingClientRect();
    dv.attr("width", bbox.width);
    dv.attr("height", bbox.height);
  }
  if (useHtmlLabels) {
    labelEl.attr("transform", "translate(" + -bbox.width / 2 + ", " + -bbox.height / 2 + ")");
  } else {
    labelEl.attr("transform", "translate(0, " + -bbox.height / 2 + ")");
  }
  if (options.centerLabel) {
    labelEl.attr("transform", "translate(" + -bbox.width / 2 + ", " + -bbox.height / 2 + ")");
  }
  labelEl.insert("rect", ":first-child");
  return { shapeSvg: parent, bbox, halfPadding, label: labelEl };
}, "insertLabel");
var updateNodeBounds = /* @__PURE__ */ __name((node, element) => {
  const bbox = element.node().getBBox();
  node.width = bbox.width;
  node.height = bbox.height;
}, "updateNodeBounds");
var getNodeClasses = /* @__PURE__ */ __name((node, extra) => (node.look === "handDrawn" ? "rough-node" : "node") + " " + node.cssClasses + " " + (extra || ""), "getNodeClasses");
function createPathFromPoints(points) {
  const pointStrings = points.map((p, i) => `${i === 0 ? "M" : "L"}${p.x},${p.y}`);
  pointStrings.push("Z");
  return pointStrings.join(" ");
}
__name(createPathFromPoints, "createPathFromPoints");
function generateFullSineWavePoints(x1, y1, x2, y2, amplitude, numCycles) {
  const points = [];
  const steps = 50;
  const deltaX = x2 - x1;
  const deltaY = y2 - y1;
  const cycleLength = deltaX / numCycles;
  const frequency = 2 * Math.PI / cycleLength;
  const midY = y1 + deltaY / 2;
  for (let i = 0; i <= steps; i++) {
    const t = i / steps;
    const x = x1 + t * deltaX;
    const y = midY + amplitude * Math.sin(frequency * (x - x1));
    points.push({ x, y });
  }
  return points;
}
__name(generateFullSineWavePoints, "generateFullSineWavePoints");
function generateCirclePoints(centerX, centerY, radius, numPoints, startAngle, endAngle) {
  const points = [];
  const startAngleRad = startAngle * Math.PI / 180;
  const endAngleRad = endAngle * Math.PI / 180;
  const angleRange = endAngleRad - startAngleRad;
  const angleStep = angleRange / (numPoints - 1);
  for (let i = 0; i < numPoints; i++) {
    const angle = startAngleRad + i * angleStep;
    const x = centerX + radius * Math.cos(angle);
    const y = centerY + radius * Math.sin(angle);
    points.push({ x: -x, y: -y });
  }
  return points;
}
__name(generateCirclePoints, "generateCirclePoints");

// src/rendering-util/rendering-elements/intersect/intersect-rect.js
var intersectRect = /* @__PURE__ */ __name((node, point) => {
  var x = node.x;
  var y = node.y;
  var dx = point.x - x;
  var dy = point.y - y;
  var w = node.width / 2;
  var h = node.height / 2;
  var sx, sy;
  if (Math.abs(dy) * w > Math.abs(dx) * h) {
    if (dy < 0) {
      h = -h;
    }
    sx = dy === 0 ? 0 : h * dx / dy;
    sy = h;
  } else {
    if (dx < 0) {
      w = -w;
    }
    sx = w;
    sy = dx === 0 ? 0 : w * dy / dx;
  }
  return { x: x + sx, y: y + sy };
}, "intersectRect");
var intersect_rect_default = intersectRect;
function applyStyle(dom, styleFn) {
  if (styleFn) {
    dom.attr("style", styleFn);
  }
}
__name(applyStyle, "applyStyle");
async function addHtmlLabel(node) {
  const fo = select(document.createElementNS("http://www.w3.org/2000/svg", "foreignObject"));
  const div = fo.append("xhtml:div");
  const config = getConfig2();
  let label = node.label;
  if (node.label && hasKatex(node.label)) {
    label = await renderKatexSanitized(node.label.replace(common_default.lineBreakRegex, "\n"), config);
  }
  const labelClass = node.isNode ? "nodeLabel" : "edgeLabel";
  const labelSpan = '<span class="' + labelClass + '" ' + (node.labelStyle ? 'style="' + node.labelStyle + '"' : "") + // codeql [js/html-constructed-from-input] : false positive
  ">" + label + "</span>";
  div.html(sanitizeText(labelSpan, config));
  applyStyle(div, node.labelStyle);
  div.style("display", "inline-block");
  div.style("padding-right", "1px");
  div.style("white-space", "nowrap");
  div.attr("xmlns", "http://www.w3.org/1999/xhtml");
  return fo.node();
}
__name(addHtmlLabel, "addHtmlLabel");
var createLabel = /* @__PURE__ */ __name(async (_vertexText, style, isTitle, isNode) => {
  let vertexText = _vertexText || "";
  if (typeof vertexText === "object") {
    vertexText = vertexText[0];
  }
  if (evaluate(getConfig2().flowchart.htmlLabels)) {
    vertexText = vertexText.replace(/\\n|\n/g, "<br />");
    log.info("vertexText" + vertexText);
    const node = {
      isNode,
      label: decodeEntities(vertexText).replace(
        /fa[blrs]?:fa-[\w-]+/g,
        (s) => `<i class='${s.replace(":", " ")}'></i>`
      ),
      labelStyle: style ? style.replace("fill:", "color:") : style
    };
    let vertexNode = await addHtmlLabel(node);
    return vertexNode;
  } else {
    const svgLabel = document.createElementNS("http://www.w3.org/2000/svg", "text");
    svgLabel.setAttribute("style", style.replace("color:", "fill:"));
    let rows = [];
    if (typeof vertexText === "string") {
      rows = vertexText.split(/\\n|\n|<br\s*\/?>/gi);
    } else if (Array.isArray(vertexText)) {
      rows = vertexText;
    } else {
      rows = [];
    }
    for (const row of rows) {
      const tspan = document.createElementNS("http://www.w3.org/2000/svg", "tspan");
      tspan.setAttributeNS("http://www.w3.org/XML/1998/namespace", "xml:space", "preserve");
      tspan.setAttribute("dy", "1em");
      tspan.setAttribute("x", "0");
      if (isTitle) {
        tspan.setAttribute("class", "title-row");
      } else {
        tspan.setAttribute("class", "row");
      }
      tspan.textContent = row.trim();
      svgLabel.appendChild(tspan);
    }
    return svgLabel;
  }
}, "createLabel");
var createLabel_default = createLabel;

// src/rendering-util/rendering-elements/shapes/roundedRectPath.ts
var createRoundedRectPathD = /* @__PURE__ */ __name((x, y, totalWidth, totalHeight, radius) => [
  "M",
  x + radius,
  y,
  // Move to the first point
  "H",
  x + totalWidth - radius,
  // Draw horizontal line to the beginning of the right corner
  "A",
  radius,
  radius,
  0,
  0,
  1,
  x + totalWidth,
  y + radius,
  // Draw arc to the right top corner
  "V",
  y + totalHeight - radius,
  // Draw vertical line down to the beginning of the right bottom corner
  "A",
  radius,
  radius,
  0,
  0,
  1,
  x + totalWidth - radius,
  y + totalHeight,
  // Draw arc to the right bottom corner
  "H",
  x + radius,
  // Draw horizontal line to the beginning of the left bottom corner
  "A",
  radius,
  radius,
  0,
  0,
  1,
  x,
  y + totalHeight - radius,
  // Draw arc to the left bottom corner
  "V",
  y + radius,
  // Draw vertical line up to the beginning of the left top corner
  "A",
  radius,
  radius,
  0,
  0,
  1,
  x + radius,
  y,
  // Draw arc to the left top corner
  "Z"
  // Close the path
].join(" "), "createRoundedRectPathD");

// src/rendering-util/rendering-elements/clusters.js
var rect = /* @__PURE__ */ __name(async (parent, node) => {
  log.info("Creating subgraph rect for ", node.id, node);
  const siteConfig = getConfig2();
  const { themeVariables, handDrawnSeed } = siteConfig;
  const { clusterBkg, clusterBorder } = themeVariables;
  const { labelStyles, nodeStyles, borderStyles, backgroundStyles } = styles2String(node);
  const shapeSvg = parent.insert("g").attr("class", "cluster " + node.cssClasses).attr("id", node.id).attr("data-look", node.look);
  const useHtmlLabels = evaluate(siteConfig.flowchart.htmlLabels);
  const labelEl = shapeSvg.insert("g").attr("class", "cluster-label ");
  const text2 = await createText(labelEl, node.label, {
    style: node.labelStyle,
    useHtmlLabels,
    isNode: true
  });
  let bbox = text2.getBBox();
  if (evaluate(siteConfig.flowchart.htmlLabels)) {
    const div = text2.children[0];
    const dv = select(text2);
    bbox = div.getBoundingClientRect();
    dv.attr("width", bbox.width);
    dv.attr("height", bbox.height);
  }
  const width = node.width <= bbox.width + node.padding ? bbox.width + node.padding : node.width;
  if (node.width <= bbox.width + node.padding) {
    node.diff = (width - node.width) / 2 - node.padding;
  } else {
    node.diff = -node.padding;
  }
  const height = node.height;
  const x = node.x - width / 2;
  const y = node.y - height / 2;
  log.trace("Data ", node, JSON.stringify(node));
  let rect2;
  if (node.look === "handDrawn") {
    const rc = at.svg(shapeSvg);
    const options = userNodeOverrides(node, {
      roughness: 0.7,
      fill: clusterBkg,
      // fill: 'red',
      stroke: clusterBorder,
      fillWeight: 3,
      seed: handDrawnSeed
    });
    const roughNode = rc.path(createRoundedRectPathD(x, y, width, height, 0), options);
    rect2 = shapeSvg.insert(() => {
      log.debug("Rough node insert CXC", roughNode);
      return roughNode;
    }, ":first-child");
    rect2.select("path:nth-child(2)").attr("style", borderStyles.join(";"));
    rect2.select("path").attr("style", backgroundStyles.join(";").replace("fill", "stroke"));
  } else {
    rect2 = shapeSvg.insert("rect", ":first-child");
    rect2.attr("style", nodeStyles).attr("rx", node.rx).attr("ry", node.ry).attr("x", x).attr("y", y).attr("width", width).attr("height", height);
  }
  const { subGraphTitleTopMargin } = getSubGraphTitleMargins(siteConfig);
  labelEl.attr(
    "transform",
    // This puts the label on top of the box instead of inside it
    `translate(${node.x - bbox.width / 2}, ${node.y - node.height / 2 + subGraphTitleTopMargin})`
  );
  if (labelStyles) {
    const span = labelEl.select("span");
    if (span) {
      span.attr("style", labelStyles);
    }
  }
  const rectBox = rect2.node().getBBox();
  node.offsetX = 0;
  node.width = rectBox.width;
  node.height = rectBox.height;
  node.offsetY = bbox.height - node.padding / 2;
  node.intersect = function(point) {
    return intersect_rect_default(node, point);
  };
  return { cluster: shapeSvg, labelBBox: bbox };
}, "rect");
var noteGroup = /* @__PURE__ */ __name((parent, node) => {
  const shapeSvg = parent.insert("g").attr("class", "note-cluster").attr("id", node.id);
  const rect2 = shapeSvg.insert("rect", ":first-child");
  const padding = 0 * node.padding;
  const halfPadding = padding / 2;
  rect2.attr("rx", node.rx).attr("ry", node.ry).attr("x", node.x - node.width / 2 - halfPadding).attr("y", node.y - node.height / 2 - halfPadding).attr("width", node.width + padding).attr("height", node.height + padding).attr("fill", "none");
  const rectBox = rect2.node().getBBox();
  node.width = rectBox.width;
  node.height = rectBox.height;
  node.intersect = function(point) {
    return intersect_rect_default(node, point);
  };
  return { cluster: shapeSvg, labelBBox: { width: 0, height: 0 } };
}, "noteGroup");
var roundedWithTitle = /* @__PURE__ */ __name(async (parent, node) => {
  const siteConfig = getConfig2();
  const { themeVariables, handDrawnSeed } = siteConfig;
  const { altBackground, compositeBackground, compositeTitleBackground, nodeBorder } = themeVariables;
  const shapeSvg = parent.insert("g").attr("class", node.cssClasses).attr("id", node.id).attr("data-id", node.id).attr("data-look", node.look);
  const outerRectG = shapeSvg.insert("g", ":first-child");
  const label = shapeSvg.insert("g").attr("class", "cluster-label");
  let innerRect = shapeSvg.append("rect");
  const text2 = label.node().appendChild(await createLabel_default(node.label, node.labelStyle, void 0, true));
  let bbox = text2.getBBox();
  if (evaluate(siteConfig.flowchart.htmlLabels)) {
    const div = text2.children[0];
    const dv = select(text2);
    bbox = div.getBoundingClientRect();
    dv.attr("width", bbox.width);
    dv.attr("height", bbox.height);
  }
  const padding = 0 * node.padding;
  const halfPadding = padding / 2;
  const width = (node.width <= bbox.width + node.padding ? bbox.width + node.padding : node.width) + padding;
  if (node.width <= bbox.width + node.padding) {
    node.diff = (width - node.width) / 2 - node.padding;
  } else {
    node.diff = -node.padding;
  }
  const height = node.height + padding;
  const innerHeight = node.height + padding - bbox.height - 6;
  const x = node.x - width / 2;
  const y = node.y - height / 2;
  node.width = width;
  const innerY = node.y - node.height / 2 - halfPadding + bbox.height + 2;
  let rect2;
  if (node.look === "handDrawn") {
    const isAlt = node.cssClasses.includes("statediagram-cluster-alt");
    const rc = at.svg(shapeSvg);
    const roughOuterNode = node.rx || node.ry ? rc.path(createRoundedRectPathD(x, y, width, height, 10), {
      roughness: 0.7,
      fill: compositeTitleBackground,
      fillStyle: "solid",
      stroke: nodeBorder,
      seed: handDrawnSeed
    }) : rc.rectangle(x, y, width, height, { seed: handDrawnSeed });
    rect2 = shapeSvg.insert(() => roughOuterNode, ":first-child");
    const roughInnerNode = rc.rectangle(x, innerY, width, innerHeight, {
      fill: isAlt ? altBackground : compositeBackground,
      fillStyle: isAlt ? "hachure" : "solid",
      stroke: nodeBorder,
      seed: handDrawnSeed
    });
    rect2 = shapeSvg.insert(() => roughOuterNode, ":first-child");
    innerRect = shapeSvg.insert(() => roughInnerNode);
  } else {
    rect2 = outerRectG.insert("rect", ":first-child");
    const outerRectClass = "outer";
    rect2.attr("class", outerRectClass).attr("x", x).attr("y", y).attr("width", width).attr("height", height).attr("data-look", node.look);
    innerRect.attr("class", "inner").attr("x", x).attr("y", innerY).attr("width", width).attr("height", innerHeight);
  }
  label.attr(
    "transform",
    `translate(${node.x - bbox.width / 2}, ${y + 1 - (evaluate(siteConfig.flowchart.htmlLabels) ? 0 : 3)})`
  );
  const rectBox = rect2.node().getBBox();
  node.height = rectBox.height;
  node.offsetX = 0;
  node.offsetY = bbox.height - node.padding / 2;
  node.labelBBox = bbox;
  node.intersect = function(point) {
    return intersect_rect_default(node, point);
  };
  return { cluster: shapeSvg, labelBBox: bbox };
}, "roundedWithTitle");
var kanbanSection = /* @__PURE__ */ __name(async (parent, node) => {
  log.info("Creating subgraph rect for ", node.id, node);
  const siteConfig = getConfig2();
  const { themeVariables, handDrawnSeed } = siteConfig;
  const { clusterBkg, clusterBorder } = themeVariables;
  const { labelStyles, nodeStyles, borderStyles, backgroundStyles } = styles2String(node);
  const shapeSvg = parent.insert("g").attr("class", "cluster " + node.cssClasses).attr("id", node.id).attr("data-look", node.look);
  const useHtmlLabels = evaluate(siteConfig.flowchart.htmlLabels);
  const labelEl = shapeSvg.insert("g").attr("class", "cluster-label ");
  const text2 = await createText(labelEl, node.label, {
    style: node.labelStyle,
    useHtmlLabels,
    isNode: true,
    width: node.width
  });
  let bbox = text2.getBBox();
  if (evaluate(siteConfig.flowchart.htmlLabels)) {
    const div = text2.children[0];
    const dv = select(text2);
    bbox = div.getBoundingClientRect();
    dv.attr("width", bbox.width);
    dv.attr("height", bbox.height);
  }
  const width = node.width <= bbox.width + node.padding ? bbox.width + node.padding : node.width;
  if (node.width <= bbox.width + node.padding) {
    node.diff = (width - node.width) / 2 - node.padding;
  } else {
    node.diff = -node.padding;
  }
  const height = node.height;
  const x = node.x - width / 2;
  const y = node.y - height / 2;
  log.trace("Data ", node, JSON.stringify(node));
  let rect2;
  if (node.look === "handDrawn") {
    const rc = at.svg(shapeSvg);
    const options = userNodeOverrides(node, {
      roughness: 0.7,
      fill: clusterBkg,
      // fill: 'red',
      stroke: clusterBorder,
      fillWeight: 4,
      seed: handDrawnSeed
    });
    const roughNode = rc.path(createRoundedRectPathD(x, y, width, height, node.rx), options);
    rect2 = shapeSvg.insert(() => {
      log.debug("Rough node insert CXC", roughNode);
      return roughNode;
    }, ":first-child");
    rect2.select("path:nth-child(2)").attr("style", borderStyles.join(";"));
    rect2.select("path").attr("style", backgroundStyles.join(";").replace("fill", "stroke"));
  } else {
    rect2 = shapeSvg.insert("rect", ":first-child");
    rect2.attr("style", nodeStyles).attr("rx", node.rx).attr("ry", node.ry).attr("x", x).attr("y", y).attr("width", width).attr("height", height);
  }
  const { subGraphTitleTopMargin } = getSubGraphTitleMargins(siteConfig);
  labelEl.attr(
    "transform",
    // This puts the label on top of the box instead of inside it
    `translate(${node.x - bbox.width / 2}, ${node.y - node.height / 2 + subGraphTitleTopMargin})`
  );
  if (labelStyles) {
    const span = labelEl.select("span");
    if (span) {
      span.attr("style", labelStyles);
    }
  }
  const rectBox = rect2.node().getBBox();
  node.offsetX = 0;
  node.width = rectBox.width;
  node.height = rectBox.height;
  node.offsetY = bbox.height - node.padding / 2;
  node.intersect = function(point) {
    return intersect_rect_default(node, point);
  };
  return { cluster: shapeSvg, labelBBox: bbox };
}, "kanbanSection");
var divider = /* @__PURE__ */ __name((parent, node) => {
  const siteConfig = getConfig2();
  const { themeVariables, handDrawnSeed } = siteConfig;
  const { nodeBorder } = themeVariables;
  const shapeSvg = parent.insert("g").attr("class", node.cssClasses).attr("id", node.id).attr("data-look", node.look);
  const outerRectG = shapeSvg.insert("g", ":first-child");
  const padding = 0 * node.padding;
  const width = node.width + padding;
  node.diff = -node.padding;
  const height = node.height + padding;
  const x = node.x - width / 2;
  const y = node.y - height / 2;
  node.width = width;
  let rect2;
  if (node.look === "handDrawn") {
    const rc = at.svg(shapeSvg);
    const roughOuterNode = rc.rectangle(x, y, width, height, {
      fill: "lightgrey",
      roughness: 0.5,
      strokeLineDash: [5],
      stroke: nodeBorder,
      seed: handDrawnSeed
    });
    rect2 = shapeSvg.insert(() => roughOuterNode, ":first-child");
  } else {
    rect2 = outerRectG.insert("rect", ":first-child");
    const outerRectClass = "divider";
    rect2.attr("class", outerRectClass).attr("x", x).attr("y", y).attr("width", width).attr("height", height).attr("data-look", node.look);
  }
  const rectBox = rect2.node().getBBox();
  node.height = rectBox.height;
  node.offsetX = 0;
  node.offsetY = 0;
  node.intersect = function(point) {
    return intersect_rect_default(node, point);
  };
  return { cluster: shapeSvg, labelBBox: {} };
}, "divider");
var squareRect = rect;
var shapes = {
  rect,
  squareRect,
  roundedWithTitle,
  noteGroup,
  divider,
  kanbanSection
};
var clusterElems = /* @__PURE__ */ new Map();
var insertCluster = /* @__PURE__ */ __name(async (elem, node) => {
  const shape = node.shape || "rect";
  const cluster = await shapes[shape](elem, node);
  clusterElems.set(node.id, cluster);
  return cluster;
}, "insertCluster");
var clear$1 = /* @__PURE__ */ __name(() => {
  clusterElems = /* @__PURE__ */ new Map();
}, "clear");

// src/rendering-util/rendering-elements/intersect/intersect-node.js
function intersectNode(node, point) {
  return node.intersect(point);
}
__name(intersectNode, "intersectNode");
var intersect_node_default = intersectNode;

// src/rendering-util/rendering-elements/intersect/intersect-ellipse.js
function intersectEllipse(node, rx, ry, point) {
  var cx = node.x;
  var cy = node.y;
  var px = cx - point.x;
  var py = cy - point.y;
  var det = Math.sqrt(rx * rx * py * py + ry * ry * px * px);
  var dx = Math.abs(rx * ry * px / det);
  if (point.x < cx) {
    dx = -dx;
  }
  var dy = Math.abs(rx * ry * py / det);
  if (point.y < cy) {
    dy = -dy;
  }
  return { x: cx + dx, y: cy + dy };
}
__name(intersectEllipse, "intersectEllipse");
var intersect_ellipse_default = intersectEllipse;

// src/rendering-util/rendering-elements/intersect/intersect-circle.js
function intersectCircle(node, rx, point) {
  return intersect_ellipse_default(node, rx, rx, point);
}
__name(intersectCircle, "intersectCircle");
var intersect_circle_default = intersectCircle;

// src/rendering-util/rendering-elements/intersect/intersect-line.js
function intersectLine(p1, p2, q1, q2) {
  var a1, a2, b1, b2, c1, c2;
  var r1, r2, r3, r4;
  var denom, offset, num;
  var x, y;
  a1 = p2.y - p1.y;
  b1 = p1.x - p2.x;
  c1 = p2.x * p1.y - p1.x * p2.y;
  r3 = a1 * q1.x + b1 * q1.y + c1;
  r4 = a1 * q2.x + b1 * q2.y + c1;
  if (r3 !== 0 && r4 !== 0 && sameSign(r3, r4)) {
    return;
  }
  a2 = q2.y - q1.y;
  b2 = q1.x - q2.x;
  c2 = q2.x * q1.y - q1.x * q2.y;
  r1 = a2 * p1.x + b2 * p1.y + c2;
  r2 = a2 * p2.x + b2 * p2.y + c2;
  if (r1 !== 0 && r2 !== 0 && sameSign(r1, r2)) {
    return;
  }
  denom = a1 * b2 - a2 * b1;
  if (denom === 0) {
    return;
  }
  offset = Math.abs(denom / 2);
  num = b1 * c2 - b2 * c1;
  x = num < 0 ? (num - offset) / denom : (num + offset) / denom;
  num = a2 * c1 - a1 * c2;
  y = num < 0 ? (num - offset) / denom : (num + offset) / denom;
  return { x, y };
}
__name(intersectLine, "intersectLine");
function sameSign(r1, r2) {
  return r1 * r2 > 0;
}
__name(sameSign, "sameSign");
var intersect_line_default = intersectLine;

// src/rendering-util/rendering-elements/intersect/intersect-polygon.js
function intersectPolygon(node, polyPoints, point) {
  let x1 = node.x;
  let y1 = node.y;
  let intersections = [];
  let minX = Number.POSITIVE_INFINITY;
  let minY = Number.POSITIVE_INFINITY;
  if (typeof polyPoints.forEach === "function") {
    polyPoints.forEach(function(entry) {
      minX = Math.min(minX, entry.x);
      minY = Math.min(minY, entry.y);
    });
  } else {
    minX = Math.min(minX, polyPoints.x);
    minY = Math.min(minY, polyPoints.y);
  }
  let left = x1 - node.width / 2 - minX;
  let top = y1 - node.height / 2 - minY;
  for (let i = 0; i < polyPoints.length; i++) {
    let p1 = polyPoints[i];
    let p2 = polyPoints[i < polyPoints.length - 1 ? i + 1 : 0];
    let intersect = intersect_line_default(
      node,
      point,
      { x: left + p1.x, y: top + p1.y },
      { x: left + p2.x, y: top + p2.y }
    );
    if (intersect) {
      intersections.push(intersect);
    }
  }
  if (!intersections.length) {
    return node;
  }
  if (intersections.length > 1) {
    intersections.sort(function(p, q) {
      let pdx = p.x - point.x;
      let pdy = p.y - point.y;
      let distp = Math.sqrt(pdx * pdx + pdy * pdy);
      let qdx = q.x - point.x;
      let qdy = q.y - point.y;
      let distq = Math.sqrt(qdx * qdx + qdy * qdy);
      return distp < distq ? -1 : distp === distq ? 0 : 1;
    });
  }
  return intersections[0];
}
__name(intersectPolygon, "intersectPolygon");
var intersect_polygon_default = intersectPolygon;

// src/rendering-util/rendering-elements/intersect/index.js
var intersect_default = {
  node: intersect_node_default,
  circle: intersect_circle_default,
  ellipse: intersect_ellipse_default,
  polygon: intersect_polygon_default,
  rect: intersect_rect_default
};
function anchor(parent, node) {
  const { labelStyles } = styles2String(node);
  node.labelStyle = labelStyles;
  const classes = getNodeClasses(node);
  let cssClasses = classes;
  if (!classes) {
    cssClasses = "anchor";
  }
  const shapeSvg = parent.insert("g").attr("class", cssClasses).attr("id", node.domId || node.id);
  const radius = 1;
  const { cssStyles } = node;
  const rc = at.svg(shapeSvg);
  const options = userNodeOverrides(node, { fill: "black", stroke: "none", fillStyle: "solid" });
  if (node.look !== "handDrawn") {
    options.roughness = 0;
  }
  const roughNode = rc.circle(0, 0, radius * 2, options);
  const circleElem = shapeSvg.insert(() => roughNode, ":first-child");
  circleElem.attr("class", "anchor").attr("style", handleUndefinedAttr(cssStyles));
  updateNodeBounds(node, circleElem);
  node.intersect = function(point) {
    log.info("Circle intersect", node, radius, point);
    return intersect_default.circle(node, radius, point);
  };
  return shapeSvg;
}
__name(anchor, "anchor");
function generateArcPoints(x1, y1, x2, y2, rx, ry, clockwise) {
  const numPoints = 20;
  const midX = (x1 + x2) / 2;
  const midY = (y1 + y2) / 2;
  const angle = Math.atan2(y2 - y1, x2 - x1);
  const dx = (x2 - x1) / 2;
  const dy = (y2 - y1) / 2;
  const transformedX = dx / rx;
  const transformedY = dy / ry;
  const distance = Math.sqrt(transformedX ** 2 + transformedY ** 2);
  if (distance > 1) {
    throw new Error("The given radii are too small to create an arc between the points.");
  }
  const scaledCenterDistance = Math.sqrt(1 - distance ** 2);
  const centerX = midX + scaledCenterDistance * ry * Math.sin(angle) * (clockwise ? -1 : 1);
  const centerY = midY - scaledCenterDistance * rx * Math.cos(angle) * (clockwise ? -1 : 1);
  const startAngle = Math.atan2((y1 - centerY) / ry, (x1 - centerX) / rx);
  const endAngle = Math.atan2((y2 - centerY) / ry, (x2 - centerX) / rx);
  let angleRange = endAngle - startAngle;
  if (clockwise && angleRange < 0) {
    angleRange += 2 * Math.PI;
  }
  if (!clockwise && angleRange > 0) {
    angleRange -= 2 * Math.PI;
  }
  const points = [];
  for (let i = 0; i < numPoints; i++) {
    const t = i / (numPoints - 1);
    const angle2 = startAngle + t * angleRange;
    const x = centerX + rx * Math.cos(angle2);
    const y = centerY + ry * Math.sin(angle2);
    points.push({ x, y });
  }
  return points;
}
__name(generateArcPoints, "generateArcPoints");
async function bowTieRect(parent, node) {
  const { labelStyles, nodeStyles } = styles2String(node);
  node.labelStyle = labelStyles;
  const { shapeSvg, bbox } = await labelHelper(parent, node, getNodeClasses(node));
  const w = bbox.width + node.padding + 20;
  const h = bbox.height + node.padding;
  const ry = h / 2;
  const rx = ry / (2.5 + h / 50);
  const { cssStyles } = node;
  const points = [
    { x: w / 2, y: -h / 2 },
    { x: -w / 2, y: -h / 2 },
    ...generateArcPoints(-w / 2, -h / 2, -w / 2, h / 2, rx, ry, false),
    { x: w / 2, y: h / 2 },
    ...generateArcPoints(w / 2, h / 2, w / 2, -h / 2, rx, ry, true)
  ];
  const rc = at.svg(shapeSvg);
  const options = userNodeOverrides(node, {});
  if (node.look !== "handDrawn") {
    options.roughness = 0;
    options.fillStyle = "solid";
  }
  const bowTieRectPath = createPathFromPoints(points);
  const bowTieRectShapePath = rc.path(bowTieRectPath, options);
  const bowTieRectShape = shapeSvg.insert(() => bowTieRectShapePath, ":first-child");
  bowTieRectShape.attr("class", "basic label-container");
  if (cssStyles && node.look !== "handDrawn") {
    bowTieRectShape.selectAll("path").attr("style", cssStyles);
  }
  if (nodeStyles && node.look !== "handDrawn") {
    bowTieRectShape.selectAll("path").attr("style", nodeStyles);
  }
  bowTieRectShape.attr("transform", `translate(${rx / 2}, 0)`);
  updateNodeBounds(node, bowTieRectShape);
  node.intersect = function(point) {
    const pos = intersect_default.polygon(node, points, point);
    return pos;
  };
  return shapeSvg;
}
__name(bowTieRect, "bowTieRect");

// src/rendering-util/rendering-elements/shapes/insertPolygonShape.ts
function insertPolygonShape(parent, w, h, points) {
  return parent.insert("polygon", ":first-child").attr(
    "points",
    points.map(function(d) {
      return d.x + "," + d.y;
    }).join(" ")
  ).attr("class", "label-container").attr("transform", "translate(" + -w / 2 + "," + h / 2 + ")");
}
__name(insertPolygonShape, "insertPolygonShape");

// src/rendering-util/rendering-elements/shapes/card.ts
async function card(parent, node) {
  const { labelStyles, nodeStyles } = styles2String(node);
  node.labelStyle = labelStyles;
  const { shapeSvg, bbox } = await labelHelper(parent, node, getNodeClasses(node));
  const h = bbox.height + node.padding;
  const padding = 12;
  const w = bbox.width + node.padding + padding;
  const left = 0;
  const right = w;
  const top = -h;
  const bottom = 0;
  const points = [
    { x: left + padding, y: top },
    { x: right, y: top },
    { x: right, y: bottom },
    { x: left, y: bottom },
    { x: left, y: top + padding },
    { x: left + padding, y: top }
  ];
  let polygon;
  const { cssStyles } = node;
  if (node.look === "handDrawn") {
    const rc = at.svg(shapeSvg);
    const options = userNodeOverrides(node, {});
    const pathData = createPathFromPoints(points);
    const roughNode = rc.path(pathData, options);
    polygon = shapeSvg.insert(() => roughNode, ":first-child").attr("transform", `translate(${-w / 2}, ${h / 2})`);
    if (cssStyles) {
      polygon.attr("style", cssStyles);
    }
  } else {
    polygon = insertPolygonShape(shapeSvg, w, h, points);
  }
  if (nodeStyles) {
    polygon.attr("style", nodeStyles);
  }
  updateNodeBounds(node, polygon);
  node.intersect = function(point) {
    return intersect_default.polygon(node, points, point);
  };
  return shapeSvg;
}
__name(card, "card");
function choice(parent, node) {
  const { nodeStyles } = styles2String(node);
  node.label = "";
  const shapeSvg = parent.insert("g").attr("class", getNodeClasses(node)).attr("id", node.domId ?? node.id);
  const { cssStyles } = node;
  const s = Math.max(28, node.width ?? 0);
  const points = [
    { x: 0, y: s / 2 },
    { x: s / 2, y: 0 },
    { x: 0, y: -s / 2 },
    { x: -s / 2, y: 0 }
  ];
  const rc = at.svg(shapeSvg);
  const options = userNodeOverrides(node, {});
  if (node.look !== "handDrawn") {
    options.roughness = 0;
    options.fillStyle = "solid";
  }
  const choicePath = createPathFromPoints(points);
  const roughNode = rc.path(choicePath, options);
  const choiceShape = shapeSvg.insert(() => roughNode, ":first-child");
  if (cssStyles && node.look !== "handDrawn") {
    choiceShape.selectAll("path").attr("style", cssStyles);
  }
  if (nodeStyles && node.look !== "handDrawn") {
    choiceShape.selectAll("path").attr("style", nodeStyles);
  }
  node.width = 28;
  node.height = 28;
  node.intersect = function(point) {
    return intersect_default.polygon(node, points, point);
  };
  return shapeSvg;
}
__name(choice, "choice");
async function circle$1(parent, node) {
  const { labelStyles, nodeStyles } = styles2String(node);
  node.labelStyle = labelStyles;
  const { shapeSvg, bbox, halfPadding } = await labelHelper(parent, node, getNodeClasses(node));
  const radius = bbox.width / 2 + halfPadding;
  let circleElem;
  const { cssStyles } = node;
  if (node.look === "handDrawn") {
    const rc = at.svg(shapeSvg);
    const options = userNodeOverrides(node, {});
    const roughNode = rc.circle(0, 0, radius * 2, options);
    circleElem = shapeSvg.insert(() => roughNode, ":first-child");
    circleElem.attr("class", "basic label-container").attr("style", handleUndefinedAttr(cssStyles));
  } else {
    circleElem = shapeSvg.insert("circle", ":first-child").attr("class", "basic label-container").attr("style", nodeStyles).attr("r", radius).attr("cx", 0).attr("cy", 0);
  }
  updateNodeBounds(node, circleElem);
  node.intersect = function(point) {
    log.info("Circle intersect", node, radius, point);
    return intersect_default.circle(node, radius, point);
  };
  return shapeSvg;
}
__name(circle$1, "circle");
function createLine(r) {
  const xAxis45 = Math.cos(Math.PI / 4);
  const yAxis45 = Math.sin(Math.PI / 4);
  const lineLength = r * 2;
  const pointQ1 = { x: lineLength / 2 * xAxis45, y: lineLength / 2 * yAxis45 };
  const pointQ2 = { x: -(lineLength / 2) * xAxis45, y: lineLength / 2 * yAxis45 };
  const pointQ3 = { x: -(lineLength / 2) * xAxis45, y: -(lineLength / 2) * yAxis45 };
  const pointQ4 = { x: lineLength / 2 * xAxis45, y: -(lineLength / 2) * yAxis45 };
  return `M ${pointQ2.x},${pointQ2.y} L ${pointQ4.x},${pointQ4.y}
                   M ${pointQ1.x},${pointQ1.y} L ${pointQ3.x},${pointQ3.y}`;
}
__name(createLine, "createLine");
function crossedCircle(parent, node) {
  const { labelStyles, nodeStyles } = styles2String(node);
  node.labelStyle = labelStyles;
  node.label = "";
  const shapeSvg = parent.insert("g").attr("class", getNodeClasses(node)).attr("id", node.domId ?? node.id);
  const radius = Math.max(30, node?.width ?? 0);
  const { cssStyles } = node;
  const rc = at.svg(shapeSvg);
  const options = userNodeOverrides(node, {});
  if (node.look !== "handDrawn") {
    options.roughness = 0;
    options.fillStyle = "solid";
  }
  const circleNode = rc.circle(0, 0, radius * 2, options);
  const linePath = createLine(radius);
  const lineNode = rc.path(linePath, options);
  const crossedCircle2 = shapeSvg.insert(() => circleNode, ":first-child");
  crossedCircle2.insert(() => lineNode);
  if (cssStyles && node.look !== "handDrawn") {
    crossedCircle2.selectAll("path").attr("style", cssStyles);
  }
  if (nodeStyles && node.look !== "handDrawn") {
    crossedCircle2.selectAll("path").attr("style", nodeStyles);
  }
  updateNodeBounds(node, crossedCircle2);
  node.intersect = function(point) {
    log.info("crossedCircle intersect", node, { radius, point });
    const pos = intersect_default.circle(node, radius, point);
    return pos;
  };
  return shapeSvg;
}
__name(crossedCircle, "crossedCircle");
function generateCirclePoints2(centerX, centerY, radius, numPoints = 100, startAngle = 0, endAngle = 180) {
  const points = [];
  const startAngleRad = startAngle * Math.PI / 180;
  const endAngleRad = endAngle * Math.PI / 180;
  const angleRange = endAngleRad - startAngleRad;
  const angleStep = angleRange / (numPoints - 1);
  for (let i = 0; i < numPoints; i++) {
    const angle = startAngleRad + i * angleStep;
    const x = centerX + radius * Math.cos(angle);
    const y = centerY + radius * Math.sin(angle);
    points.push({ x: -x, y: -y });
  }
  return points;
}
__name(generateCirclePoints2, "generateCirclePoints");
async function curlyBraceLeft(parent, node) {
  const { labelStyles, nodeStyles } = styles2String(node);
  node.labelStyle = labelStyles;
  const { shapeSvg, bbox, label } = await labelHelper(parent, node, getNodeClasses(node));
  const w = bbox.width + (node.padding ?? 0);
  const h = bbox.height + (node.padding ?? 0);
  const radius = Math.max(5, h * 0.1);
  const { cssStyles } = node;
  const points = [
    ...generateCirclePoints2(w / 2, -h / 2, radius, 30, -90, 0),
    { x: -w / 2 - radius, y: radius },
    ...generateCirclePoints2(w / 2 + radius * 2, -radius, radius, 20, -180, -270),
    ...generateCirclePoints2(w / 2 + radius * 2, radius, radius, 20, -90, -180),
    { x: -w / 2 - radius, y: -h / 2 },
    ...generateCirclePoints2(w / 2, h / 2, radius, 20, 0, 90)
  ];
  const rectPoints = [
    { x: w / 2, y: -h / 2 - radius },
    { x: -w / 2, y: -h / 2 - radius },
    ...generateCirclePoints2(w / 2, -h / 2, radius, 20, -90, 0),
    { x: -w / 2 - radius, y: -radius },
    ...generateCirclePoints2(w / 2 + w * 0.1, -radius, radius, 20, -180, -270),
    ...generateCirclePoints2(w / 2 + w * 0.1, radius, radius, 20, -90, -180),
    { x: -w / 2 - radius, y: h / 2 },
    ...generateCirclePoints2(w / 2, h / 2, radius, 20, 0, 90),
    { x: -w / 2, y: h / 2 + radius },
    { x: w / 2, y: h / 2 + radius }
  ];
  const rc = at.svg(shapeSvg);
  const options = userNodeOverrides(node, { fill: "none" });
  if (node.look !== "handDrawn") {
    options.roughness = 0;
    options.fillStyle = "solid";
  }
  const curlyBraceLeftPath = createPathFromPoints(points);
  const newCurlyBracePath = curlyBraceLeftPath.replace("Z", "");
  const curlyBraceLeftNode = rc.path(newCurlyBracePath, options);
  const rectPath = createPathFromPoints(rectPoints);
  const rectShape = rc.path(rectPath, { ...options });
  const curlyBraceLeftShape = shapeSvg.insert("g", ":first-child");
  curlyBraceLeftShape.insert(() => rectShape, ":first-child").attr("stroke-opacity", 0);
  curlyBraceLeftShape.insert(() => curlyBraceLeftNode, ":first-child");
  curlyBraceLeftShape.attr("class", "text");
  if (cssStyles && node.look !== "handDrawn") {
    curlyBraceLeftShape.selectAll("path").attr("style", cssStyles);
  }
  if (nodeStyles && node.look !== "handDrawn") {
    curlyBraceLeftShape.selectAll("path").attr("style", nodeStyles);
  }
  curlyBraceLeftShape.attr("transform", `translate(${radius}, 0)`);
  label.attr(
    "transform",
    `translate(${-w / 2 + radius - (bbox.x - (bbox.left ?? 0))},${-h / 2 + (node.padding ?? 0) / 2 - (bbox.y - (bbox.top ?? 0))})`
  );
  updateNodeBounds(node, curlyBraceLeftShape);
  node.intersect = function(point) {
    const pos = intersect_default.polygon(node, rectPoints, point);
    return pos;
  };
  return shapeSvg;
}
__name(curlyBraceLeft, "curlyBraceLeft");
function generateCirclePoints3(centerX, centerY, radius, numPoints = 100, startAngle = 0, endAngle = 180) {
  const points = [];
  const startAngleRad = startAngle * Math.PI / 180;
  const endAngleRad = endAngle * Math.PI / 180;
  const angleRange = endAngleRad - startAngleRad;
  const angleStep = angleRange / (numPoints - 1);
  for (let i = 0; i < numPoints; i++) {
    const angle = startAngleRad + i * angleStep;
    const x = centerX + radius * Math.cos(angle);
    const y = centerY + radius * Math.sin(angle);
    points.push({ x, y });
  }
  return points;
}
__name(generateCirclePoints3, "generateCirclePoints");
async function curlyBraceRight(parent, node) {
  const { labelStyles, nodeStyles } = styles2String(node);
  node.labelStyle = labelStyles;
  const { shapeSvg, bbox, label } = await labelHelper(parent, node, getNodeClasses(node));
  const w = bbox.width + (node.padding ?? 0);
  const h = bbox.height + (node.padding ?? 0);
  const radius = Math.max(5, h * 0.1);
  const { cssStyles } = node;
  const points = [
    ...generateCirclePoints3(w / 2, -h / 2, radius, 20, -90, 0),
    { x: w / 2 + radius, y: -radius },
    ...generateCirclePoints3(w / 2 + radius * 2, -radius, radius, 20, -180, -270),
    ...generateCirclePoints3(w / 2 + radius * 2, radius, radius, 20, -90, -180),
    { x: w / 2 + radius, y: h / 2 },
    ...generateCirclePoints3(w / 2, h / 2, radius, 20, 0, 90)
  ];
  const rectPoints = [
    { x: -w / 2, y: -h / 2 - radius },
    { x: w / 2, y: -h / 2 - radius },
    ...generateCirclePoints3(w / 2, -h / 2, radius, 20, -90, 0),
    { x: w / 2 + radius, y: -radius },
    ...generateCirclePoints3(w / 2 + radius * 2, -radius, radius, 20, -180, -270),
    ...generateCirclePoints3(w / 2 + radius * 2, radius, radius, 20, -90, -180),
    { x: w / 2 + radius, y: h / 2 },
    ...generateCirclePoints3(w / 2, h / 2, radius, 20, 0, 90),
    { x: w / 2, y: h / 2 + radius },
    { x: -w / 2, y: h / 2 + radius }
  ];
  const rc = at.svg(shapeSvg);
  const options = userNodeOverrides(node, { fill: "none" });
  if (node.look !== "handDrawn") {
    options.roughness = 0;
    options.fillStyle = "solid";
  }
  const curlyBraceRightPath = createPathFromPoints(points);
  const newCurlyBracePath = curlyBraceRightPath.replace("Z", "");
  const curlyBraceRightNode = rc.path(newCurlyBracePath, options);
  const rectPath = createPathFromPoints(rectPoints);
  const rectShape = rc.path(rectPath, { ...options });
  const curlyBraceRightShape = shapeSvg.insert("g", ":first-child");
  curlyBraceRightShape.insert(() => rectShape, ":first-child").attr("stroke-opacity", 0);
  curlyBraceRightShape.insert(() => curlyBraceRightNode, ":first-child");
  curlyBraceRightShape.attr("class", "text");
  if (cssStyles && node.look !== "handDrawn") {
    curlyBraceRightShape.selectAll("path").attr("style", cssStyles);
  }
  if (nodeStyles && node.look !== "handDrawn") {
    curlyBraceRightShape.selectAll("path").attr("style", nodeStyles);
  }
  curlyBraceRightShape.attr("transform", `translate(${-radius}, 0)`);
  label.attr(
    "transform",
    `translate(${-w / 2 + (node.padding ?? 0) / 2 - (bbox.x - (bbox.left ?? 0))},${-h / 2 + (node.padding ?? 0) / 2 - (bbox.y - (bbox.top ?? 0))})`
  );
  updateNodeBounds(node, curlyBraceRightShape);
  node.intersect = function(point) {
    const pos = intersect_default.polygon(node, rectPoints, point);
    return pos;
  };
  return shapeSvg;
}
__name(curlyBraceRight, "curlyBraceRight");
function generateCirclePoints4(centerX, centerY, radius, numPoints = 100, startAngle = 0, endAngle = 180) {
  const points = [];
  const startAngleRad = startAngle * Math.PI / 180;
  const endAngleRad = endAngle * Math.PI / 180;
  const angleRange = endAngleRad - startAngleRad;
  const angleStep = angleRange / (numPoints - 1);
  for (let i = 0; i < numPoints; i++) {
    const angle = startAngleRad + i * angleStep;
    const x = centerX + radius * Math.cos(angle);
    const y = centerY + radius * Math.sin(angle);
    points.push({ x: -x, y: -y });
  }
  return points;
}
__name(generateCirclePoints4, "generateCirclePoints");
async function curlyBraces(parent, node) {
  const { labelStyles, nodeStyles } = styles2String(node);
  node.labelStyle = labelStyles;
  const { shapeSvg, bbox, label } = await labelHelper(parent, node, getNodeClasses(node));
  const w = bbox.width + (node.padding ?? 0);
  const h = bbox.height + (node.padding ?? 0);
  const radius = Math.max(5, h * 0.1);
  const { cssStyles } = node;
  const leftCurlyBracePoints = [
    ...generateCirclePoints4(w / 2, -h / 2, radius, 30, -90, 0),
    { x: -w / 2 - radius, y: radius },
    ...generateCirclePoints4(w / 2 + radius * 2, -radius, radius, 20, -180, -270),
    ...generateCirclePoints4(w / 2 + radius * 2, radius, radius, 20, -90, -180),
    { x: -w / 2 - radius, y: -h / 2 },
    ...generateCirclePoints4(w / 2, h / 2, radius, 20, 0, 90)
  ];
  const rightCurlyBracePoints = [
    ...generateCirclePoints4(-w / 2 + radius + radius / 2, -h / 2, radius, 20, -90, -180),
    { x: w / 2 - radius / 2, y: radius },
    ...generateCirclePoints4(-w / 2 - radius / 2, -radius, radius, 20, 0, 90),
    ...generateCirclePoints4(-w / 2 - radius / 2, radius, radius, 20, -90, 0),
    { x: w / 2 - radius / 2, y: -radius },
    ...generateCirclePoints4(-w / 2 + radius + radius / 2, h / 2, radius, 30, -180, -270)
  ];
  const rectPoints = [
    { x: w / 2, y: -h / 2 - radius },
    { x: -w / 2, y: -h / 2 - radius },
    ...generateCirclePoints4(w / 2, -h / 2, radius, 20, -90, 0),
    { x: -w / 2 - radius, y: -radius },
    ...generateCirclePoints4(w / 2 + radius * 2, -radius, radius, 20, -180, -270),
    ...generateCirclePoints4(w / 2 + radius * 2, radius, radius, 20, -90, -180),
    { x: -w / 2 - radius, y: h / 2 },
    ...generateCirclePoints4(w / 2, h / 2, radius, 20, 0, 90),
    { x: -w / 2, y: h / 2 + radius },
    { x: w / 2 - radius - radius / 2, y: h / 2 + radius },
    ...generateCirclePoints4(-w / 2 + radius + radius / 2, -h / 2, radius, 20, -90, -180),
    { x: w / 2 - radius / 2, y: radius },
    ...generateCirclePoints4(-w / 2 - radius / 2, -radius, radius, 20, 0, 90),
    ...generateCirclePoints4(-w / 2 - radius / 2, radius, radius, 20, -90, 0),
    { x: w / 2 - radius / 2, y: -radius },
    ...generateCirclePoints4(-w / 2 + radius + radius / 2, h / 2, radius, 30, -180, -270)
  ];
  const rc = at.svg(shapeSvg);
  const options = userNodeOverrides(node, { fill: "none" });
  if (node.look !== "handDrawn") {
    options.roughness = 0;
    options.fillStyle = "solid";
  }
  const leftCurlyBracePath = createPathFromPoints(leftCurlyBracePoints);
  const newLeftCurlyBracePath = leftCurlyBracePath.replace("Z", "");
  const leftCurlyBraceNode = rc.path(newLeftCurlyBracePath, options);
  const rightCurlyBracePath = createPathFromPoints(rightCurlyBracePoints);
  const newRightCurlyBracePath = rightCurlyBracePath.replace("Z", "");
  const rightCurlyBraceNode = rc.path(newRightCurlyBracePath, options);
  const rectPath = createPathFromPoints(rectPoints);
  const rectShape = rc.path(rectPath, { ...options });
  const curlyBracesShape = shapeSvg.insert("g", ":first-child");
  curlyBracesShape.insert(() => rectShape, ":first-child").attr("stroke-opacity", 0);
  curlyBracesShape.insert(() => leftCurlyBraceNode, ":first-child");
  curlyBracesShape.insert(() => rightCurlyBraceNode, ":first-child");
  curlyBracesShape.attr("class", "text");
  if (cssStyles && node.look !== "handDrawn") {
    curlyBracesShape.selectAll("path").attr("style", cssStyles);
  }
  if (nodeStyles && node.look !== "handDrawn") {
    curlyBracesShape.selectAll("path").attr("style", nodeStyles);
  }
  curlyBracesShape.attr("transform", `translate(${radius - radius / 4}, 0)`);
  label.attr(
    "transform",
    `translate(${-w / 2 + (node.padding ?? 0) / 2 - (bbox.x - (bbox.left ?? 0))},${-h / 2 + (node.padding ?? 0) / 2 - (bbox.y - (bbox.top ?? 0))})`
  );
  updateNodeBounds(node, curlyBracesShape);
  node.intersect = function(point) {
    const pos = intersect_default.polygon(node, rectPoints, point);
    return pos;
  };
  return shapeSvg;
}
__name(curlyBraces, "curlyBraces");
async function curvedTrapezoid(parent, node) {
  const { labelStyles, nodeStyles } = styles2String(node);
  node.labelStyle = labelStyles;
  const { shapeSvg, bbox } = await labelHelper(parent, node, getNodeClasses(node));
  const minWidth = 80, minHeight = 20;
  const w = Math.max(minWidth, (bbox.width + (node.padding ?? 0) * 2) * 1.25, node?.width ?? 0);
  const h = Math.max(minHeight, bbox.height + (node.padding ?? 0) * 2, node?.height ?? 0);
  const radius = h / 2;
  const { cssStyles } = node;
  const rc = at.svg(shapeSvg);
  const options = userNodeOverrides(node, {});
  if (node.look !== "handDrawn") {
    options.roughness = 0;
    options.fillStyle = "solid";
  }
  const totalWidth = w, totalHeight = h;
  const rw = totalWidth - radius;
  const tw = totalHeight / 4;
  const points = [
    { x: rw, y: 0 },
    { x: tw, y: 0 },
    { x: 0, y: totalHeight / 2 },
    { x: tw, y: totalHeight },
    { x: rw, y: totalHeight },
    ...generateCirclePoints(-rw, -totalHeight / 2, radius, 50, 270, 90)
  ];
  const pathData = createPathFromPoints(points);
  const shapeNode = rc.path(pathData, options);
  const polygon = shapeSvg.insert(() => shapeNode, ":first-child");
  polygon.attr("class", "basic label-container");
  if (cssStyles && node.look !== "handDrawn") {
    polygon.selectChildren("path").attr("style", cssStyles);
  }
  if (nodeStyles && node.look !== "handDrawn") {
    polygon.selectChildren("path").attr("style", nodeStyles);
  }
  polygon.attr("transform", `translate(${-w / 2}, ${-h / 2})`);
  updateNodeBounds(node, polygon);
  node.intersect = function(point) {
    const pos = intersect_default.polygon(node, points, point);
    return pos;
  };
  return shapeSvg;
}
__name(curvedTrapezoid, "curvedTrapezoid");
var createCylinderPathD = /* @__PURE__ */ __name((x, y, width, height, rx, ry) => {
  return [
    `M${x},${y + ry}`,
    `a${rx},${ry} 0,0,0 ${width},0`,
    `a${rx},${ry} 0,0,0 ${-width},0`,
    `l0,${height}`,
    `a${rx},${ry} 0,0,0 ${width},0`,
    `l0,${-height}`
  ].join(" ");
}, "createCylinderPathD");
var createOuterCylinderPathD = /* @__PURE__ */ __name((x, y, width, height, rx, ry) => {
  return [
    `M${x},${y + ry}`,
    `M${x + width},${y + ry}`,
    `a${rx},${ry} 0,0,0 ${-width},0`,
    `l0,${height}`,
    `a${rx},${ry} 0,0,0 ${width},0`,
    `l0,${-height}`
  ].join(" ");
}, "createOuterCylinderPathD");
var createInnerCylinderPathD = /* @__PURE__ */ __name((x, y, width, height, rx, ry) => {
  return [`M${x - width / 2},${-height / 2}`, `a${rx},${ry} 0,0,0 ${width},0`].join(" ");
}, "createInnerCylinderPathD");
async function cylinder(parent, node) {
  const { labelStyles, nodeStyles } = styles2String(node);
  node.labelStyle = labelStyles;
  const { shapeSvg, bbox, label } = await labelHelper(parent, node, getNodeClasses(node));
  const w = Math.max(bbox.width + node.padding, node.width ?? 0);
  const rx = w / 2;
  const ry = rx / (2.5 + w / 50);
  const h = Math.max(bbox.height + ry + node.padding, node.height ?? 0);
  let cylinder2;
  const { cssStyles } = node;
  if (node.look === "handDrawn") {
    const rc = at.svg(shapeSvg);
    const outerPathData = createOuterCylinderPathD(0, 0, w, h, rx, ry);
    const innerPathData = createInnerCylinderPathD(0, ry, w, h, rx, ry);
    const outerNode = rc.path(outerPathData, userNodeOverrides(node, {}));
    const innerLine = rc.path(innerPathData, userNodeOverrides(node, { fill: "none" }));
    cylinder2 = shapeSvg.insert(() => innerLine, ":first-child");
    cylinder2 = shapeSvg.insert(() => outerNode, ":first-child");
    cylinder2.attr("class", "basic label-container");
    if (cssStyles) {
      cylinder2.attr("style", cssStyles);
    }
  } else {
    const pathData = createCylinderPathD(0, 0, w, h, rx, ry);
    cylinder2 = shapeSvg.insert("path", ":first-child").attr("d", pathData).attr("class", "basic label-container").attr("style", handleUndefinedAttr(cssStyles)).attr("style", nodeStyles);
  }
  cylinder2.attr("label-offset-y", ry);
  cylinder2.attr("transform", `translate(${-w / 2}, ${-(h / 2 + ry)})`);
  updateNodeBounds(node, cylinder2);
  label.attr(
    "transform",
    `translate(${-(bbox.width / 2) - (bbox.x - (bbox.left ?? 0))}, ${-(bbox.height / 2) + (node.padding ?? 0) / 1.5 - (bbox.y - (bbox.top ?? 0))})`
  );
  node.intersect = function(point) {
    const pos = intersect_default.rect(node, point);
    const x = pos.x - (node.x ?? 0);
    if (rx != 0 && (Math.abs(x) < (node.width ?? 0) / 2 || Math.abs(x) == (node.width ?? 0) / 2 && Math.abs(pos.y - (node.y ?? 0)) > (node.height ?? 0) / 2 - ry)) {
      let y = ry * ry * (1 - x * x / (rx * rx));
      if (y > 0) {
        y = Math.sqrt(y);
      }
      y = ry - y;
      if (point.y - (node.y ?? 0) > 0) {
        y = -y;
      }
      pos.y += y;
    }
    return pos;
  };
  return shapeSvg;
}
__name(cylinder, "cylinder");
async function dividedRectangle(parent, node) {
  const { labelStyles, nodeStyles } = styles2String(node);
  node.labelStyle = labelStyles;
  const { shapeSvg, bbox, label } = await labelHelper(parent, node, getNodeClasses(node));
  const w = bbox.width + node.padding;
  const h = bbox.height + node.padding;
  const rectOffset = h * 0.2;
  const x = -w / 2;
  const y = -h / 2 - rectOffset / 2;
  const { cssStyles } = node;
  const rc = at.svg(shapeSvg);
  const options = userNodeOverrides(node, {});
  if (node.look !== "handDrawn") {
    options.roughness = 0;
    options.fillStyle = "solid";
  }
  const pts = [
    { x, y: y + rectOffset },
    { x: -x, y: y + rectOffset },
    { x: -x, y: -y },
    { x, y: -y },
    { x, y },
    { x: -x, y },
    { x: -x, y: y + rectOffset }
  ];
  const poly = rc.polygon(
    pts.map((p) => [p.x, p.y]),
    options
  );
  const polygon = shapeSvg.insert(() => poly, ":first-child");
  polygon.attr("class", "basic label-container");
  if (cssStyles && node.look !== "handDrawn") {
    polygon.selectAll("path").attr("style", cssStyles);
  }
  if (nodeStyles && node.look !== "handDrawn") {
    polygon.selectAll("path").attr("style", nodeStyles);
  }
  label.attr(
    "transform",
    `translate(${x + (node.padding ?? 0) / 2 - (bbox.x - (bbox.left ?? 0))}, ${y + rectOffset + (node.padding ?? 0) / 2 - (bbox.y - (bbox.top ?? 0))})`
  );
  updateNodeBounds(node, polygon);
  node.intersect = function(point) {
    const pos = intersect_default.rect(node, point);
    return pos;
  };
  return shapeSvg;
}
__name(dividedRectangle, "dividedRectangle");
async function doublecircle(parent, node) {
  const { labelStyles, nodeStyles } = styles2String(node);
  node.labelStyle = labelStyles;
  const { shapeSvg, bbox, halfPadding } = await labelHelper(parent, node, getNodeClasses(node));
  const gap = 5;
  const outerRadius = bbox.width / 2 + halfPadding + gap;
  const innerRadius = bbox.width / 2 + halfPadding;
  let circleGroup;
  const { cssStyles } = node;
  if (node.look === "handDrawn") {
    const rc = at.svg(shapeSvg);
    const outerOptions = userNodeOverrides(node, { roughness: 0.2, strokeWidth: 2.5 });
    const innerOptions = userNodeOverrides(node, { roughness: 0.2, strokeWidth: 1.5 });
    const outerRoughNode = rc.circle(0, 0, outerRadius * 2, outerOptions);
    const innerRoughNode = rc.circle(0, 0, innerRadius * 2, innerOptions);
    circleGroup = shapeSvg.insert("g", ":first-child");
    circleGroup.attr("class", handleUndefinedAttr(node.cssClasses)).attr("style", handleUndefinedAttr(cssStyles));
    circleGroup.node()?.appendChild(outerRoughNode);
    circleGroup.node()?.appendChild(innerRoughNode);
  } else {
    circleGroup = shapeSvg.insert("g", ":first-child");
    const outerCircle = circleGroup.insert("circle", ":first-child");
    const innerCircle = circleGroup.insert("circle");
    circleGroup.attr("class", "basic label-container").attr("style", nodeStyles);
    outerCircle.attr("class", "outer-circle").attr("style", nodeStyles).attr("r", outerRadius).attr("cx", 0).attr("cy", 0);
    innerCircle.attr("class", "inner-circle").attr("style", nodeStyles).attr("r", innerRadius).attr("cx", 0).attr("cy", 0);
  }
  updateNodeBounds(node, circleGroup);
  node.intersect = function(point) {
    log.info("DoubleCircle intersect", node, outerRadius, point);
    return intersect_default.circle(node, outerRadius, point);
  };
  return shapeSvg;
}
__name(doublecircle, "doublecircle");
function filledCircle(parent, node, { config: { themeVariables } }) {
  const { labelStyles, nodeStyles } = styles2String(node);
  node.label = "";
  node.labelStyle = labelStyles;
  const shapeSvg = parent.insert("g").attr("class", getNodeClasses(node)).attr("id", node.domId ?? node.id);
  const radius = 7;
  const { cssStyles } = node;
  const rc = at.svg(shapeSvg);
  const { nodeBorder } = themeVariables;
  const options = userNodeOverrides(node, { fillStyle: "solid" });
  if (node.look !== "handDrawn") {
    options.roughness = 0;
  }
  const circleNode = rc.circle(0, 0, radius * 2, options);
  const filledCircle2 = shapeSvg.insert(() => circleNode, ":first-child");
  filledCircle2.selectAll("path").attr("style", `fill: ${nodeBorder} !important;`);
  if (cssStyles && cssStyles.length > 0 && node.look !== "handDrawn") {
    filledCircle2.selectAll("path").attr("style", cssStyles);
  }
  if (nodeStyles && node.look !== "handDrawn") {
    filledCircle2.selectAll("path").attr("style", nodeStyles);
  }
  updateNodeBounds(node, filledCircle2);
  node.intersect = function(point) {
    log.info("filledCircle intersect", node, { radius, point });
    const pos = intersect_default.circle(node, radius, point);
    return pos;
  };
  return shapeSvg;
}
__name(filledCircle, "filledCircle");
async function flippedTriangle(parent, node) {
  const { labelStyles, nodeStyles } = styles2String(node);
  node.labelStyle = labelStyles;
  const { shapeSvg, bbox, label } = await labelHelper(parent, node, getNodeClasses(node));
  const w = bbox.width + (node.padding ?? 0);
  const h = w + bbox.height;
  const tw = w + bbox.height;
  const points = [
    { x: 0, y: -h },
    { x: tw, y: -h },
    { x: tw / 2, y: 0 }
  ];
  const { cssStyles } = node;
  const rc = at.svg(shapeSvg);
  const options = userNodeOverrides(node, {});
  if (node.look !== "handDrawn") {
    options.roughness = 0;
    options.fillStyle = "solid";
  }
  const pathData = createPathFromPoints(points);
  const roughNode = rc.path(pathData, options);
  const flippedTriangle2 = shapeSvg.insert(() => roughNode, ":first-child").attr("transform", `translate(${-h / 2}, ${h / 2})`);
  if (cssStyles && node.look !== "handDrawn") {
    flippedTriangle2.selectChildren("path").attr("style", cssStyles);
  }
  if (nodeStyles && node.look !== "handDrawn") {
    flippedTriangle2.selectChildren("path").attr("style", nodeStyles);
  }
  node.width = w;
  node.height = h;
  updateNodeBounds(node, flippedTriangle2);
  label.attr(
    "transform",
    `translate(${-bbox.width / 2 - (bbox.x - (bbox.left ?? 0))}, ${-h / 2 + (node.padding ?? 0) / 2 + (bbox.y - (bbox.top ?? 0))})`
  );
  node.intersect = function(point) {
    log.info("Triangle intersect", node, points, point);
    return intersect_default.polygon(node, points, point);
  };
  return shapeSvg;
}
__name(flippedTriangle, "flippedTriangle");
function forkJoin(parent, node, { dir, config: { state: state2, themeVariables } }) {
  const { nodeStyles } = styles2String(node);
  node.label = "";
  const shapeSvg = parent.insert("g").attr("class", getNodeClasses(node)).attr("id", node.domId ?? node.id);
  const { cssStyles } = node;
  let width = Math.max(70, node?.width ?? 0);
  let height = Math.max(10, node?.height ?? 0);
  if (dir === "LR") {
    width = Math.max(10, node?.width ?? 0);
    height = Math.max(70, node?.height ?? 0);
  }
  const x = -1 * width / 2;
  const y = -1 * height / 2;
  const rc = at.svg(shapeSvg);
  const options = userNodeOverrides(node, {
    stroke: themeVariables.lineColor,
    fill: themeVariables.lineColor
  });
  if (node.look !== "handDrawn") {
    options.roughness = 0;
    options.fillStyle = "solid";
  }
  const roughNode = rc.rectangle(x, y, width, height, options);
  const shape = shapeSvg.insert(() => roughNode, ":first-child");
  if (cssStyles && node.look !== "handDrawn") {
    shape.selectAll("path").attr("style", cssStyles);
  }
  if (nodeStyles && node.look !== "handDrawn") {
    shape.selectAll("path").attr("style", nodeStyles);
  }
  updateNodeBounds(node, shape);
  const padding = state2?.padding ?? 0;
  if (node.width && node.height) {
    node.width += padding / 2 || 0;
    node.height += padding / 2 || 0;
  }
  node.intersect = function(point) {
    return intersect_default.rect(node, point);
  };
  return shapeSvg;
}
__name(forkJoin, "forkJoin");
async function halfRoundedRectangle(parent, node) {
  const { labelStyles, nodeStyles } = styles2String(node);
  node.labelStyle = labelStyles;
  const minWidth = 80, minHeight = 50;
  const { shapeSvg, bbox } = await labelHelper(parent, node, getNodeClasses(node));
  const w = Math.max(minWidth, bbox.width + (node.padding ?? 0) * 2, node?.width ?? 0);
  const h = Math.max(minHeight, bbox.height + (node.padding ?? 0) * 2, node?.height ?? 0);
  const radius = h / 2;
  const { cssStyles } = node;
  const rc = at.svg(shapeSvg);
  const options = userNodeOverrides(node, {});
  if (node.look !== "handDrawn") {
    options.roughness = 0;
    options.fillStyle = "solid";
  }
  const points = [
    { x: -w / 2, y: -h / 2 },
    { x: w / 2 - radius, y: -h / 2 },
    ...generateCirclePoints(-w / 2 + radius, 0, radius, 50, 90, 270),
    { x: w / 2 - radius, y: h / 2 },
    { x: -w / 2, y: h / 2 }
  ];
  const pathData = createPathFromPoints(points);
  const shapeNode = rc.path(pathData, options);
  const polygon = shapeSvg.insert(() => shapeNode, ":first-child");
  polygon.attr("class", "basic label-container");
  if (cssStyles && node.look !== "handDrawn") {
    polygon.selectChildren("path").attr("style", cssStyles);
  }
  if (nodeStyles && node.look !== "handDrawn") {
    polygon.selectChildren("path").attr("style", nodeStyles);
  }
  updateNodeBounds(node, polygon);
  node.intersect = function(point) {
    log.info("Pill intersect", node, { radius, point });
    const pos = intersect_default.polygon(node, points, point);
    return pos;
  };
  return shapeSvg;
}
__name(halfRoundedRectangle, "halfRoundedRectangle");
async function hexagon(parent, node) {
  const { labelStyles, nodeStyles } = styles2String(node);
  node.labelStyle = labelStyles;
  const { shapeSvg, bbox } = await labelHelper(parent, node, getNodeClasses(node));
  const h = bbox.height + (node.padding ?? 0);
  const w = bbox.width + (node.padding ?? 0) * 2.5;
  const { cssStyles } = node;
  const rc = at.svg(shapeSvg);
  const options = userNodeOverrides(node, {});
  if (node.look !== "handDrawn") {
    options.roughness = 0;
    options.fillStyle = "solid";
  }
  let halfWidth = w / 2;
  const m = halfWidth / 6;
  halfWidth = halfWidth + m;
  const halfHeight = h / 2;
  const fixedLength = halfHeight / 2;
  const deducedWidth = halfWidth - fixedLength;
  const points = [
    { x: -deducedWidth, y: -halfHeight },
    { x: 0, y: -halfHeight },
    { x: deducedWidth, y: -halfHeight },
    { x: halfWidth, y: 0 },
    { x: deducedWidth, y: halfHeight },
    { x: 0, y: halfHeight },
    { x: -deducedWidth, y: halfHeight },
    { x: -halfWidth, y: 0 }
  ];
  const pathData = createPathFromPoints(points);
  const shapeNode = rc.path(pathData, options);
  const polygon = shapeSvg.insert(() => shapeNode, ":first-child");
  polygon.attr("class", "basic label-container");
  if (cssStyles && node.look !== "handDrawn") {
    polygon.selectChildren("path").attr("style", cssStyles);
  }
  if (nodeStyles && node.look !== "handDrawn") {
    polygon.selectChildren("path").attr("style", nodeStyles);
  }
  node.width = w;
  node.height = h;
  updateNodeBounds(node, polygon);
  node.intersect = function(point) {
    return intersect_default.polygon(node, points, point);
  };
  return shapeSvg;
}
__name(hexagon, "hexagon");
async function hourglass(parent, node) {
  const { labelStyles, nodeStyles } = styles2String(node);
  node.label = "";
  node.labelStyle = labelStyles;
  const { shapeSvg } = await labelHelper(parent, node, getNodeClasses(node));
  const w = Math.max(30, node?.width ?? 0);
  const h = Math.max(30, node?.height ?? 0);
  const { cssStyles } = node;
  const rc = at.svg(shapeSvg);
  const options = userNodeOverrides(node, {});
  if (node.look !== "handDrawn") {
    options.roughness = 0;
    options.fillStyle = "solid";
  }
  const points = [
    { x: 0, y: 0 },
    { x: w, y: 0 },
    { x: 0, y: h },
    { x: w, y: h }
  ];
  const pathData = createPathFromPoints(points);
  const shapeNode = rc.path(pathData, options);
  const polygon = shapeSvg.insert(() => shapeNode, ":first-child");
  polygon.attr("class", "basic label-container");
  if (cssStyles && node.look !== "handDrawn") {
    polygon.selectChildren("path").attr("style", cssStyles);
  }
  if (nodeStyles && node.look !== "handDrawn") {
    polygon.selectChildren("path").attr("style", nodeStyles);
  }
  polygon.attr("transform", `translate(${-w / 2}, ${-h / 2})`);
  updateNodeBounds(node, polygon);
  node.intersect = function(point) {
    log.info("Pill intersect", node, { points });
    const pos = intersect_default.polygon(node, points, point);
    return pos;
  };
  return shapeSvg;
}
__name(hourglass, "hourglass");
async function icon(parent, node, { config: { themeVariables, flowchart } }) {
  const { labelStyles } = styles2String(node);
  node.labelStyle = labelStyles;
  const assetHeight = node.assetHeight ?? 48;
  const assetWidth = node.assetWidth ?? 48;
  const iconSize = Math.max(assetHeight, assetWidth);
  const defaultWidth = flowchart?.wrappingWidth;
  node.width = Math.max(iconSize, defaultWidth ?? 0);
  const { shapeSvg, bbox, label } = await labelHelper(parent, node, "icon-shape default");
  const topLabel = node.pos === "t";
  const height = iconSize;
  const width = iconSize;
  const { nodeBorder } = themeVariables;
  const { stylesMap } = compileStyles(node);
  const x = -width / 2;
  const y = -height / 2;
  const labelPadding = node.label ? 8 : 0;
  const rc = at.svg(shapeSvg);
  const options = userNodeOverrides(node, { stroke: "none", fill: "none" });
  if (node.look !== "handDrawn") {
    options.roughness = 0;
    options.fillStyle = "solid";
  }
  const iconNode = rc.rectangle(x, y, width, height, options);
  const outerWidth = Math.max(width, bbox.width);
  const outerHeight = height + bbox.height + labelPadding;
  const outerNode = rc.rectangle(-outerWidth / 2, -outerHeight / 2, outerWidth, outerHeight, {
    ...options,
    fill: "transparent",
    stroke: "none"
  });
  const iconShape = shapeSvg.insert(() => iconNode, ":first-child");
  const outerShape = shapeSvg.insert(() => outerNode);
  if (node.icon) {
    const iconElem = shapeSvg.append("g");
    iconElem.html(
      `<g>${await getIconSVG(node.icon, {
        height: iconSize,
        width: iconSize,
        fallbackPrefix: ""
      })}</g>`
    );
    const iconBBox = iconElem.node().getBBox();
    const iconWidth = iconBBox.width;
    const iconHeight = iconBBox.height;
    const iconX = iconBBox.x;
    const iconY = iconBBox.y;
    iconElem.attr(
      "transform",
      `translate(${-iconWidth / 2 - iconX},${topLabel ? bbox.height / 2 + labelPadding / 2 - iconHeight / 2 - iconY : -bbox.height / 2 - labelPadding / 2 - iconHeight / 2 - iconY})`
    );
    iconElem.attr("style", `color: ${stylesMap.get("stroke") ?? nodeBorder};`);
  }
  label.attr(
    "transform",
    `translate(${-bbox.width / 2 - (bbox.x - (bbox.left ?? 0))},${topLabel ? -outerHeight / 2 : outerHeight / 2 - bbox.height})`
  );
  iconShape.attr(
    "transform",
    `translate(${0},${topLabel ? bbox.height / 2 + labelPadding / 2 : -bbox.height / 2 - labelPadding / 2})`
  );
  updateNodeBounds(node, outerShape);
  node.intersect = function(point) {
    log.info("iconSquare intersect", node, point);
    if (!node.label) {
      return intersect_default.rect(node, point);
    }
    const dx = node.x ?? 0;
    const dy = node.y ?? 0;
    const nodeHeight = node.height ?? 0;
    let points = [];
    if (topLabel) {
      points = [
        { x: dx - bbox.width / 2, y: dy - nodeHeight / 2 },
        { x: dx + bbox.width / 2, y: dy - nodeHeight / 2 },
        { x: dx + bbox.width / 2, y: dy - nodeHeight / 2 + bbox.height + labelPadding },
        { x: dx + width / 2, y: dy - nodeHeight / 2 + bbox.height + labelPadding },
        { x: dx + width / 2, y: dy + nodeHeight / 2 },
        { x: dx - width / 2, y: dy + nodeHeight / 2 },
        { x: dx - width / 2, y: dy - nodeHeight / 2 + bbox.height + labelPadding },
        { x: dx - bbox.width / 2, y: dy - nodeHeight / 2 + bbox.height + labelPadding }
      ];
    } else {
      points = [
        { x: dx - width / 2, y: dy - nodeHeight / 2 },
        { x: dx + width / 2, y: dy - nodeHeight / 2 },
        { x: dx + width / 2, y: dy - nodeHeight / 2 + height },
        { x: dx + bbox.width / 2, y: dy - nodeHeight / 2 + height },
        { x: dx + bbox.width / 2 / 2, y: dy + nodeHeight / 2 },
        { x: dx - bbox.width / 2, y: dy + nodeHeight / 2 },
        { x: dx - bbox.width / 2, y: dy - nodeHeight / 2 + height },
        { x: dx - width / 2, y: dy - nodeHeight / 2 + height }
      ];
    }
    const pos = intersect_default.polygon(node, points, point);
    return pos;
  };
  return shapeSvg;
}
__name(icon, "icon");
async function iconCircle(parent, node, { config: { themeVariables, flowchart } }) {
  const { labelStyles } = styles2String(node);
  node.labelStyle = labelStyles;
  const assetHeight = node.assetHeight ?? 48;
  const assetWidth = node.assetWidth ?? 48;
  const iconSize = Math.max(assetHeight, assetWidth);
  const defaultWidth = flowchart?.wrappingWidth;
  node.width = Math.max(iconSize, defaultWidth ?? 0);
  const { shapeSvg, bbox, label } = await labelHelper(parent, node, "icon-shape default");
  const padding = 20;
  const labelPadding = node.label ? 8 : 0;
  const topLabel = node.pos === "t";
  const { nodeBorder, mainBkg } = themeVariables;
  const { stylesMap } = compileStyles(node);
  const rc = at.svg(shapeSvg);
  const options = userNodeOverrides(node, {});
  if (node.look !== "handDrawn") {
    options.roughness = 0;
    options.fillStyle = "solid";
  }
  const fill = stylesMap.get("fill");
  options.stroke = fill ?? mainBkg;
  const iconElem = shapeSvg.append("g");
  if (node.icon) {
    iconElem.html(
      `<g>${await getIconSVG(node.icon, {
        height: iconSize,
        width: iconSize,
        fallbackPrefix: ""
      })}</g>`
    );
  }
  const iconBBox = iconElem.node().getBBox();
  const iconWidth = iconBBox.width;
  const iconHeight = iconBBox.height;
  const iconX = iconBBox.x;
  const iconY = iconBBox.y;
  const diameter = Math.max(iconWidth, iconHeight) * Math.SQRT2 + padding * 2;
  const iconNode = rc.circle(0, 0, diameter, options);
  const outerWidth = Math.max(diameter, bbox.width);
  const outerHeight = diameter + bbox.height + labelPadding;
  const outerNode = rc.rectangle(-outerWidth / 2, -outerHeight / 2, outerWidth, outerHeight, {
    ...options,
    fill: "transparent",
    stroke: "none"
  });
  const iconShape = shapeSvg.insert(() => iconNode, ":first-child");
  const outerShape = shapeSvg.insert(() => outerNode);
  iconElem.attr(
    "transform",
    `translate(${-iconWidth / 2 - iconX},${topLabel ? bbox.height / 2 + labelPadding / 2 - iconHeight / 2 - iconY : -bbox.height / 2 - labelPadding / 2 - iconHeight / 2 - iconY})`
  );
  iconElem.attr("style", `color: ${stylesMap.get("stroke") ?? nodeBorder};`);
  label.attr(
    "transform",
    `translate(${-bbox.width / 2 - (bbox.x - (bbox.left ?? 0))},${topLabel ? -outerHeight / 2 : outerHeight / 2 - bbox.height})`
  );
  iconShape.attr(
    "transform",
    `translate(${0},${topLabel ? bbox.height / 2 + labelPadding / 2 : -bbox.height / 2 - labelPadding / 2})`
  );
  updateNodeBounds(node, outerShape);
  node.intersect = function(point) {
    log.info("iconSquare intersect", node, point);
    const pos = intersect_default.rect(node, point);
    return pos;
  };
  return shapeSvg;
}
__name(iconCircle, "iconCircle");
async function iconRounded(parent, node, { config: { themeVariables, flowchart } }) {
  const { labelStyles } = styles2String(node);
  node.labelStyle = labelStyles;
  const assetHeight = node.assetHeight ?? 48;
  const assetWidth = node.assetWidth ?? 48;
  const iconSize = Math.max(assetHeight, assetWidth);
  const defaultWidth = flowchart?.wrappingWidth;
  node.width = Math.max(iconSize, defaultWidth ?? 0);
  const { shapeSvg, bbox, halfPadding, label } = await labelHelper(
    parent,
    node,
    "icon-shape default"
  );
  const topLabel = node.pos === "t";
  const height = iconSize + halfPadding * 2;
  const width = iconSize + halfPadding * 2;
  const { nodeBorder, mainBkg } = themeVariables;
  const { stylesMap } = compileStyles(node);
  const x = -width / 2;
  const y = -height / 2;
  const labelPadding = node.label ? 8 : 0;
  const rc = at.svg(shapeSvg);
  const options = userNodeOverrides(node, {});
  if (node.look !== "handDrawn") {
    options.roughness = 0;
    options.fillStyle = "solid";
  }
  const fill = stylesMap.get("fill");
  options.stroke = fill ?? mainBkg;
  const iconNode = rc.path(createRoundedRectPathD(x, y, width, height, 5), options);
  const outerWidth = Math.max(width, bbox.width);
  const outerHeight = height + bbox.height + labelPadding;
  const outerNode = rc.rectangle(-outerWidth / 2, -outerHeight / 2, outerWidth, outerHeight, {
    ...options,
    fill: "transparent",
    stroke: "none"
  });
  const iconShape = shapeSvg.insert(() => iconNode, ":first-child").attr("class", "icon-shape2");
  const outerShape = shapeSvg.insert(() => outerNode);
  if (node.icon) {
    const iconElem = shapeSvg.append("g");
    iconElem.html(
      `<g>${await getIconSVG(node.icon, {
        height: iconSize,
        width: iconSize,
        fallbackPrefix: ""
      })}</g>`
    );
    const iconBBox = iconElem.node().getBBox();
    const iconWidth = iconBBox.width;
    const iconHeight = iconBBox.height;
    const iconX = iconBBox.x;
    const iconY = iconBBox.y;
    iconElem.attr(
      "transform",
      `translate(${-iconWidth / 2 - iconX},${topLabel ? bbox.height / 2 + labelPadding / 2 - iconHeight / 2 - iconY : -bbox.height / 2 - labelPadding / 2 - iconHeight / 2 - iconY})`
    );
    iconElem.attr("style", `color: ${stylesMap.get("stroke") ?? nodeBorder};`);
  }
  label.attr(
    "transform",
    `translate(${-bbox.width / 2 - (bbox.x - (bbox.left ?? 0))},${topLabel ? -outerHeight / 2 : outerHeight / 2 - bbox.height})`
  );
  iconShape.attr(
    "transform",
    `translate(${0},${topLabel ? bbox.height / 2 + labelPadding / 2 : -bbox.height / 2 - labelPadding / 2})`
  );
  updateNodeBounds(node, outerShape);
  node.intersect = function(point) {
    log.info("iconSquare intersect", node, point);
    if (!node.label) {
      return intersect_default.rect(node, point);
    }
    const dx = node.x ?? 0;
    const dy = node.y ?? 0;
    const nodeHeight = node.height ?? 0;
    let points = [];
    if (topLabel) {
      points = [
        { x: dx - bbox.width / 2, y: dy - nodeHeight / 2 },
        { x: dx + bbox.width / 2, y: dy - nodeHeight / 2 },
        { x: dx + bbox.width / 2, y: dy - nodeHeight / 2 + bbox.height + labelPadding },
        { x: dx + width / 2, y: dy - nodeHeight / 2 + bbox.height + labelPadding },
        { x: dx + width / 2, y: dy + nodeHeight / 2 },
        { x: dx - width / 2, y: dy + nodeHeight / 2 },
        { x: dx - width / 2, y: dy - nodeHeight / 2 + bbox.height + labelPadding },
        { x: dx - bbox.width / 2, y: dy - nodeHeight / 2 + bbox.height + labelPadding }
      ];
    } else {
      points = [
        { x: dx - width / 2, y: dy - nodeHeight / 2 },
        { x: dx + width / 2, y: dy - nodeHeight / 2 },
        { x: dx + width / 2, y: dy - nodeHeight / 2 + height },
        { x: dx + bbox.width / 2, y: dy - nodeHeight / 2 + height },
        { x: dx + bbox.width / 2 / 2, y: dy + nodeHeight / 2 },
        { x: dx - bbox.width / 2, y: dy + nodeHeight / 2 },
        { x: dx - bbox.width / 2, y: dy - nodeHeight / 2 + height },
        { x: dx - width / 2, y: dy - nodeHeight / 2 + height }
      ];
    }
    const pos = intersect_default.polygon(node, points, point);
    return pos;
  };
  return shapeSvg;
}
__name(iconRounded, "iconRounded");
async function iconSquare(parent, node, { config: { themeVariables, flowchart } }) {
  const { labelStyles } = styles2String(node);
  node.labelStyle = labelStyles;
  const assetHeight = node.assetHeight ?? 48;
  const assetWidth = node.assetWidth ?? 48;
  const iconSize = Math.max(assetHeight, assetWidth);
  const defaultWidth = flowchart?.wrappingWidth;
  node.width = Math.max(iconSize, defaultWidth ?? 0);
  const { shapeSvg, bbox, halfPadding, label } = await labelHelper(
    parent,
    node,
    "icon-shape default"
  );
  const topLabel = node.pos === "t";
  const height = iconSize + halfPadding * 2;
  const width = iconSize + halfPadding * 2;
  const { nodeBorder, mainBkg } = themeVariables;
  const { stylesMap } = compileStyles(node);
  const x = -width / 2;
  const y = -height / 2;
  const labelPadding = node.label ? 8 : 0;
  const rc = at.svg(shapeSvg);
  const options = userNodeOverrides(node, {});
  if (node.look !== "handDrawn") {
    options.roughness = 0;
    options.fillStyle = "solid";
  }
  const fill = stylesMap.get("fill");
  options.stroke = fill ?? mainBkg;
  const iconNode = rc.path(createRoundedRectPathD(x, y, width, height, 0.1), options);
  const outerWidth = Math.max(width, bbox.width);
  const outerHeight = height + bbox.height + labelPadding;
  const outerNode = rc.rectangle(-outerWidth / 2, -outerHeight / 2, outerWidth, outerHeight, {
    ...options,
    fill: "transparent",
    stroke: "none"
  });
  const iconShape = shapeSvg.insert(() => iconNode, ":first-child");
  const outerShape = shapeSvg.insert(() => outerNode);
  if (node.icon) {
    const iconElem = shapeSvg.append("g");
    iconElem.html(
      `<g>${await getIconSVG(node.icon, {
        height: iconSize,
        width: iconSize,
        fallbackPrefix: ""
      })}</g>`
    );
    const iconBBox = iconElem.node().getBBox();
    const iconWidth = iconBBox.width;
    const iconHeight = iconBBox.height;
    const iconX = iconBBox.x;
    const iconY = iconBBox.y;
    iconElem.attr(
      "transform",
      `translate(${-iconWidth / 2 - iconX},${topLabel ? bbox.height / 2 + labelPadding / 2 - iconHeight / 2 - iconY : -bbox.height / 2 - labelPadding / 2 - iconHeight / 2 - iconY})`
    );
    iconElem.attr("style", `color: ${stylesMap.get("stroke") ?? nodeBorder};`);
  }
  label.attr(
    "transform",
    `translate(${-bbox.width / 2 - (bbox.x - (bbox.left ?? 0))},${topLabel ? -outerHeight / 2 : outerHeight / 2 - bbox.height})`
  );
  iconShape.attr(
    "transform",
    `translate(${0},${topLabel ? bbox.height / 2 + labelPadding / 2 : -bbox.height / 2 - labelPadding / 2})`
  );
  updateNodeBounds(node, outerShape);
  node.intersect = function(point) {
    log.info("iconSquare intersect", node, point);
    if (!node.label) {
      return intersect_default.rect(node, point);
    }
    const dx = node.x ?? 0;
    const dy = node.y ?? 0;
    const nodeHeight = node.height ?? 0;
    let points = [];
    if (topLabel) {
      points = [
        { x: dx - bbox.width / 2, y: dy - nodeHeight / 2 },
        { x: dx + bbox.width / 2, y: dy - nodeHeight / 2 },
        { x: dx + bbox.width / 2, y: dy - nodeHeight / 2 + bbox.height + labelPadding },
        { x: dx + width / 2, y: dy - nodeHeight / 2 + bbox.height + labelPadding },
        { x: dx + width / 2, y: dy + nodeHeight / 2 },
        { x: dx - width / 2, y: dy + nodeHeight / 2 },
        { x: dx - width / 2, y: dy - nodeHeight / 2 + bbox.height + labelPadding },
        { x: dx - bbox.width / 2, y: dy - nodeHeight / 2 + bbox.height + labelPadding }
      ];
    } else {
      points = [
        { x: dx - width / 2, y: dy - nodeHeight / 2 },
        { x: dx + width / 2, y: dy - nodeHeight / 2 },
        { x: dx + width / 2, y: dy - nodeHeight / 2 + height },
        { x: dx + bbox.width / 2, y: dy - nodeHeight / 2 + height },
        { x: dx + bbox.width / 2 / 2, y: dy + nodeHeight / 2 },
        { x: dx - bbox.width / 2, y: dy + nodeHeight / 2 },
        { x: dx - bbox.width / 2, y: dy - nodeHeight / 2 + height },
        { x: dx - width / 2, y: dy - nodeHeight / 2 + height }
      ];
    }
    const pos = intersect_default.polygon(node, points, point);
    return pos;
  };
  return shapeSvg;
}
__name(iconSquare, "iconSquare");
async function imageSquare(parent, node, { config: { flowchart } }) {
  const img = new Image();
  img.src = node?.img ?? "";
  await img.decode();
  const imageNaturalWidth = Number(img.naturalWidth.toString().replace("px", ""));
  const imageNaturalHeight = Number(img.naturalHeight.toString().replace("px", ""));
  node.imageAspectRatio = imageNaturalWidth / imageNaturalHeight;
  const { labelStyles } = styles2String(node);
  node.labelStyle = labelStyles;
  const defaultWidth = flowchart?.wrappingWidth;
  node.defaultWidth = flowchart?.wrappingWidth;
  const imageRawWidth = Math.max(
    node.label ? defaultWidth ?? 0 : 0,
    node?.assetWidth ?? imageNaturalWidth
  );
  const imageWidth = node.constraint === "on" ? node?.assetHeight ? node.assetHeight * node.imageAspectRatio : imageRawWidth : imageRawWidth;
  const imageHeight = node.constraint === "on" ? imageWidth / node.imageAspectRatio : node?.assetHeight ?? imageNaturalHeight;
  node.width = Math.max(imageWidth, defaultWidth ?? 0);
  const { shapeSvg, bbox, label } = await labelHelper(parent, node, "image-shape default");
  const topLabel = node.pos === "t";
  const x = -imageWidth / 2;
  const y = -imageHeight / 2;
  const labelPadding = node.label ? 8 : 0;
  const rc = at.svg(shapeSvg);
  const options = userNodeOverrides(node, {});
  if (node.look !== "handDrawn") {
    options.roughness = 0;
    options.fillStyle = "solid";
  }
  const imageNode = rc.rectangle(x, y, imageWidth, imageHeight, options);
  const outerWidth = Math.max(imageWidth, bbox.width);
  const outerHeight = imageHeight + bbox.height + labelPadding;
  const outerNode = rc.rectangle(-outerWidth / 2, -outerHeight / 2, outerWidth, outerHeight, {
    ...options,
    fill: "none",
    stroke: "none"
  });
  const iconShape = shapeSvg.insert(() => imageNode, ":first-child");
  const outerShape = shapeSvg.insert(() => outerNode);
  if (node.img) {
    const image = shapeSvg.append("image");
    image.attr("href", node.img);
    image.attr("width", imageWidth);
    image.attr("height", imageHeight);
    image.attr("preserveAspectRatio", "none");
    image.attr(
      "transform",
      `translate(${-imageWidth / 2},${topLabel ? outerHeight / 2 - imageHeight : -outerHeight / 2})`
    );
  }
  label.attr(
    "transform",
    `translate(${-bbox.width / 2 - (bbox.x - (bbox.left ?? 0))},${topLabel ? -imageHeight / 2 - bbox.height / 2 - labelPadding / 2 : imageHeight / 2 - bbox.height / 2 + labelPadding / 2})`
  );
  iconShape.attr(
    "transform",
    `translate(${0},${topLabel ? bbox.height / 2 + labelPadding / 2 : -bbox.height / 2 - labelPadding / 2})`
  );
  updateNodeBounds(node, outerShape);
  node.intersect = function(point) {
    log.info("iconSquare intersect", node, point);
    if (!node.label) {
      return intersect_default.rect(node, point);
    }
    const dx = node.x ?? 0;
    const dy = node.y ?? 0;
    const nodeHeight = node.height ?? 0;
    let points = [];
    if (topLabel) {
      points = [
        { x: dx - bbox.width / 2, y: dy - nodeHeight / 2 },
        { x: dx + bbox.width / 2, y: dy - nodeHeight / 2 },
        { x: dx + bbox.width / 2, y: dy - nodeHeight / 2 + bbox.height + labelPadding },
        { x: dx + imageWidth / 2, y: dy - nodeHeight / 2 + bbox.height + labelPadding },
        { x: dx + imageWidth / 2, y: dy + nodeHeight / 2 },
        { x: dx - imageWidth / 2, y: dy + nodeHeight / 2 },
        { x: dx - imageWidth / 2, y: dy - nodeHeight / 2 + bbox.height + labelPadding },
        { x: dx - bbox.width / 2, y: dy - nodeHeight / 2 + bbox.height + labelPadding }
      ];
    } else {
      points = [
        { x: dx - imageWidth / 2, y: dy - nodeHeight / 2 },
        { x: dx + imageWidth / 2, y: dy - nodeHeight / 2 },
        { x: dx + imageWidth / 2, y: dy - nodeHeight / 2 + imageHeight },
        { x: dx + bbox.width / 2, y: dy - nodeHeight / 2 + imageHeight },
        { x: dx + bbox.width / 2 / 2, y: dy + nodeHeight / 2 },
        { x: dx - bbox.width / 2, y: dy + nodeHeight / 2 },
        { x: dx - bbox.width / 2, y: dy - nodeHeight / 2 + imageHeight },
        { x: dx - imageWidth / 2, y: dy - nodeHeight / 2 + imageHeight }
      ];
    }
    const pos = intersect_default.polygon(node, points, point);
    return pos;
  };
  return shapeSvg;
}
__name(imageSquare, "imageSquare");
async function inv_trapezoid(parent, node) {
  const { labelStyles, nodeStyles } = styles2String(node);
  node.labelStyle = labelStyles;
  const { shapeSvg, bbox } = await labelHelper(parent, node, getNodeClasses(node));
  const w = Math.max(bbox.width + (node.padding ?? 0) * 2, node?.width ?? 0);
  const h = Math.max(bbox.height + (node.padding ?? 0) * 2, node?.height ?? 0);
  const points = [
    { x: 0, y: 0 },
    { x: w, y: 0 },
    { x: w + 3 * h / 6, y: -h },
    { x: -3 * h / 6, y: -h }
  ];
  let polygon;
  const { cssStyles } = node;
  if (node.look === "handDrawn") {
    const rc = at.svg(shapeSvg);
    const options = userNodeOverrides(node, {});
    const pathData = createPathFromPoints(points);
    const roughNode = rc.path(pathData, options);
    polygon = shapeSvg.insert(() => roughNode, ":first-child").attr("transform", `translate(${-w / 2}, ${h / 2})`);
    if (cssStyles) {
      polygon.attr("style", cssStyles);
    }
  } else {
    polygon = insertPolygonShape(shapeSvg, w, h, points);
  }
  if (nodeStyles) {
    polygon.attr("style", nodeStyles);
  }
  node.width = w;
  node.height = h;
  updateNodeBounds(node, polygon);
  node.intersect = function(point) {
    return intersect_default.polygon(node, points, point);
  };
  return shapeSvg;
}
__name(inv_trapezoid, "inv_trapezoid");
async function drawRect(parent, node, options) {
  const { labelStyles, nodeStyles } = styles2String(node);
  node.labelStyle = labelStyles;
  const { shapeSvg, bbox } = await labelHelper(parent, node, getNodeClasses(node));
  const totalWidth = Math.max(bbox.width + options.labelPaddingX * 2, node?.width || 0);
  const totalHeight = Math.max(bbox.height + options.labelPaddingY * 2, node?.height || 0);
  const x = -totalWidth / 2;
  const y = -totalHeight / 2;
  let rect2;
  let { rx, ry } = node;
  const { cssStyles } = node;
  if (options?.rx && options.ry) {
    rx = options.rx;
    ry = options.ry;
  }
  if (node.look === "handDrawn") {
    const rc = at.svg(shapeSvg);
    const options2 = userNodeOverrides(node, {});
    const roughNode = rx || ry ? rc.path(createRoundedRectPathD(x, y, totalWidth, totalHeight, rx || 0), options2) : rc.rectangle(x, y, totalWidth, totalHeight, options2);
    rect2 = shapeSvg.insert(() => roughNode, ":first-child");
    rect2.attr("class", "basic label-container").attr("style", handleUndefinedAttr(cssStyles));
  } else {
    rect2 = shapeSvg.insert("rect", ":first-child");
    rect2.attr("class", "basic label-container").attr("style", nodeStyles).attr("rx", handleUndefinedAttr(rx)).attr("ry", handleUndefinedAttr(ry)).attr("x", x).attr("y", y).attr("width", totalWidth).attr("height", totalHeight);
  }
  updateNodeBounds(node, rect2);
  node.intersect = function(point) {
    return intersect_default.rect(node, point);
  };
  return shapeSvg;
}
__name(drawRect, "drawRect");

// src/rendering-util/rendering-elements/shapes/labelRect.ts
async function labelRect(parent, node) {
  const { shapeSvg, bbox, label } = await labelHelper(parent, node, "label");
  const rect2 = shapeSvg.insert("rect", ":first-child");
  const totalWidth = 0.1;
  const totalHeight = 0.1;
  rect2.attr("width", totalWidth).attr("height", totalHeight);
  shapeSvg.attr("class", "label edgeLabel");
  label.attr(
    "transform",
    `translate(${-(bbox.width / 2) - (bbox.x - (bbox.left ?? 0))}, ${-(bbox.height / 2) - (bbox.y - (bbox.top ?? 0))})`
  );
  updateNodeBounds(node, rect2);
  node.intersect = function(point) {
    return intersect_default.rect(node, point);
  };
  return shapeSvg;
}
__name(labelRect, "labelRect");
async function lean_left(parent, node) {
  const { labelStyles, nodeStyles } = styles2String(node);
  node.labelStyle = labelStyles;
  const { shapeSvg, bbox } = await labelHelper(parent, node, getNodeClasses(node));
  const w = Math.max(bbox.width + (node.padding ?? 0), node?.width ?? 0);
  const h = Math.max(bbox.height + (node.padding ?? 0), node?.height ?? 0);
  const points = [
    { x: 0, y: 0 },
    { x: w + 3 * h / 6, y: 0 },
    { x: w, y: -h },
    { x: -(3 * h) / 6, y: -h }
  ];
  let polygon;
  const { cssStyles } = node;
  if (node.look === "handDrawn") {
    const rc = at.svg(shapeSvg);
    const options = userNodeOverrides(node, {});
    const pathData = createPathFromPoints(points);
    const roughNode = rc.path(pathData, options);
    polygon = shapeSvg.insert(() => roughNode, ":first-child").attr("transform", `translate(${-w / 2}, ${h / 2})`);
    if (cssStyles) {
      polygon.attr("style", cssStyles);
    }
  } else {
    polygon = insertPolygonShape(shapeSvg, w, h, points);
  }
  if (nodeStyles) {
    polygon.attr("style", nodeStyles);
  }
  node.width = w;
  node.height = h;
  updateNodeBounds(node, polygon);
  node.intersect = function(point) {
    return intersect_default.polygon(node, points, point);
  };
  return shapeSvg;
}
__name(lean_left, "lean_left");
async function lean_right(parent, node) {
  const { labelStyles, nodeStyles } = styles2String(node);
  node.labelStyle = labelStyles;
  const { shapeSvg, bbox } = await labelHelper(parent, node, getNodeClasses(node));
  const w = Math.max(bbox.width + (node.padding ?? 0), node?.width ?? 0);
  const h = Math.max(bbox.height + (node.padding ?? 0), node?.height ?? 0);
  const points = [
    { x: -3 * h / 6, y: 0 },
    { x: w, y: 0 },
    { x: w + 3 * h / 6, y: -h },
    { x: 0, y: -h }
  ];
  let polygon;
  const { cssStyles } = node;
  if (node.look === "handDrawn") {
    const rc = at.svg(shapeSvg);
    const options = userNodeOverrides(node, {});
    const pathData = createPathFromPoints(points);
    const roughNode = rc.path(pathData, options);
    polygon = shapeSvg.insert(() => roughNode, ":first-child").attr("transform", `translate(${-w / 2}, ${h / 2})`);
    if (cssStyles) {
      polygon.attr("style", cssStyles);
    }
  } else {
    polygon = insertPolygonShape(shapeSvg, w, h, points);
  }
  if (nodeStyles) {
    polygon.attr("style", nodeStyles);
  }
  node.width = w;
  node.height = h;
  updateNodeBounds(node, polygon);
  node.intersect = function(point) {
    return intersect_default.polygon(node, points, point);
  };
  return shapeSvg;
}
__name(lean_right, "lean_right");
function lightningBolt(parent, node) {
  const { labelStyles, nodeStyles } = styles2String(node);
  node.label = "";
  node.labelStyle = labelStyles;
  const shapeSvg = parent.insert("g").attr("class", getNodeClasses(node)).attr("id", node.domId ?? node.id);
  const { cssStyles } = node;
  const width = Math.max(35, node?.width ?? 0);
  const height = Math.max(35, node?.height ?? 0);
  const gap = 7;
  const points = [
    { x: width, y: 0 },
    { x: 0, y: height + gap / 2 },
    { x: width - 2 * gap, y: height + gap / 2 },
    { x: 0, y: 2 * height },
    { x: width, y: height - gap / 2 },
    { x: 2 * gap, y: height - gap / 2 }
  ];
  const rc = at.svg(shapeSvg);
  const options = userNodeOverrides(node, {});
  if (node.look !== "handDrawn") {
    options.roughness = 0;
    options.fillStyle = "solid";
  }
  const linePath = createPathFromPoints(points);
  const lineNode = rc.path(linePath, options);
  const lightningBolt2 = shapeSvg.insert(() => lineNode, ":first-child");
  if (cssStyles && node.look !== "handDrawn") {
    lightningBolt2.selectAll("path").attr("style", cssStyles);
  }
  if (nodeStyles && node.look !== "handDrawn") {
    lightningBolt2.selectAll("path").attr("style", nodeStyles);
  }
  lightningBolt2.attr("transform", `translate(-${width / 2},${-height})`);
  updateNodeBounds(node, lightningBolt2);
  node.intersect = function(point) {
    log.info("lightningBolt intersect", node, point);
    const pos = intersect_default.polygon(node, points, point);
    return pos;
  };
  return shapeSvg;
}
__name(lightningBolt, "lightningBolt");
var createCylinderPathD2 = /* @__PURE__ */ __name((x, y, width, height, rx, ry, outerOffset) => {
  return [
    `M${x},${y + ry}`,
    `a${rx},${ry} 0,0,0 ${width},0`,
    `a${rx},${ry} 0,0,0 ${-width},0`,
    `l0,${height}`,
    `a${rx},${ry} 0,0,0 ${width},0`,
    `l0,${-height}`,
    `M${x},${y + ry + outerOffset}`,
    `a${rx},${ry} 0,0,0 ${width},0`
  ].join(" ");
}, "createCylinderPathD");
var createOuterCylinderPathD2 = /* @__PURE__ */ __name((x, y, width, height, rx, ry, outerOffset) => {
  return [
    `M${x},${y + ry}`,
    `M${x + width},${y + ry}`,
    `a${rx},${ry} 0,0,0 ${-width},0`,
    `l0,${height}`,
    `a${rx},${ry} 0,0,0 ${width},0`,
    `l0,${-height}`,
    `M${x},${y + ry + outerOffset}`,
    `a${rx},${ry} 0,0,0 ${width},0`
  ].join(" ");
}, "createOuterCylinderPathD");
var createInnerCylinderPathD2 = /* @__PURE__ */ __name((x, y, width, height, rx, ry) => {
  return [`M${x - width / 2},${-height / 2}`, `a${rx},${ry} 0,0,0 ${width},0`].join(" ");
}, "createInnerCylinderPathD");
async function linedCylinder(parent, node) {
  const { labelStyles, nodeStyles } = styles2String(node);
  node.labelStyle = labelStyles;
  const { shapeSvg, bbox, label } = await labelHelper(parent, node, getNodeClasses(node));
  const w = Math.max(bbox.width + (node.padding ?? 0), node.width ?? 0);
  const rx = w / 2;
  const ry = rx / (2.5 + w / 50);
  const h = Math.max(bbox.height + ry + (node.padding ?? 0), node.height ?? 0);
  const outerOffset = h * 0.1;
  let cylinder2;
  const { cssStyles } = node;
  if (node.look === "handDrawn") {
    const rc = at.svg(shapeSvg);
    const outerPathData = createOuterCylinderPathD2(0, 0, w, h, rx, ry, outerOffset);
    const innerPathData = createInnerCylinderPathD2(0, ry, w, h, rx, ry);
    const options = userNodeOverrides(node, {});
    const outerNode = rc.path(outerPathData, options);
    const innerLine = rc.path(innerPathData, options);
    const innerLineEl = shapeSvg.insert(() => innerLine, ":first-child");
    innerLineEl.attr("class", "line");
    cylinder2 = shapeSvg.insert(() => outerNode, ":first-child");
    cylinder2.attr("class", "basic label-container");
    if (cssStyles) {
      cylinder2.attr("style", cssStyles);
    }
  } else {
    const pathData = createCylinderPathD2(0, 0, w, h, rx, ry, outerOffset);
    cylinder2 = shapeSvg.insert("path", ":first-child").attr("d", pathData).attr("class", "basic label-container").attr("style", handleUndefinedAttr(cssStyles)).attr("style", nodeStyles);
  }
  cylinder2.attr("label-offset-y", ry);
  cylinder2.attr("transform", `translate(${-w / 2}, ${-(h / 2 + ry)})`);
  updateNodeBounds(node, cylinder2);
  label.attr(
    "transform",
    `translate(${-(bbox.width / 2) - (bbox.x - (bbox.left ?? 0))}, ${-(bbox.height / 2) + ry - (bbox.y - (bbox.top ?? 0))})`
  );
  node.intersect = function(point) {
    const pos = intersect_default.rect(node, point);
    const x = pos.x - (node.x ?? 0);
    if (rx != 0 && (Math.abs(x) < (node.width ?? 0) / 2 || Math.abs(x) == (node.width ?? 0) / 2 && Math.abs(pos.y - (node.y ?? 0)) > (node.height ?? 0) / 2 - ry)) {
      let y = ry * ry * (1 - x * x / (rx * rx));
      if (y > 0) {
        y = Math.sqrt(y);
      }
      y = ry - y;
      if (point.y - (node.y ?? 0) > 0) {
        y = -y;
      }
      pos.y += y;
    }
    return pos;
  };
  return shapeSvg;
}
__name(linedCylinder, "linedCylinder");
async function linedWaveEdgedRect(parent, node) {
  const { labelStyles, nodeStyles } = styles2String(node);
  node.labelStyle = labelStyles;
  const { shapeSvg, bbox, label } = await labelHelper(parent, node, getNodeClasses(node));
  const w = Math.max(bbox.width + (node.padding ?? 0) * 2, node?.width ?? 0);
  const h = Math.max(bbox.height + (node.padding ?? 0) * 2, node?.height ?? 0);
  const waveAmplitude = h / 4;
  const finalH = h + waveAmplitude;
  const { cssStyles } = node;
  const rc = at.svg(shapeSvg);
  const options = userNodeOverrides(node, {});
  if (node.look !== "handDrawn") {
    options.roughness = 0;
    options.fillStyle = "solid";
  }
  const points = [
    { x: -w / 2 - w / 2 * 0.1, y: -finalH / 2 },
    { x: -w / 2 - w / 2 * 0.1, y: finalH / 2 },
    ...generateFullSineWavePoints(
      -w / 2 - w / 2 * 0.1,
      finalH / 2,
      w / 2 + w / 2 * 0.1,
      finalH / 2,
      waveAmplitude,
      0.8
    ),
    { x: w / 2 + w / 2 * 0.1, y: -finalH / 2 },
    { x: -w / 2 - w / 2 * 0.1, y: -finalH / 2 },
    { x: -w / 2, y: -finalH / 2 },
    { x: -w / 2, y: finalH / 2 * 1.1 },
    { x: -w / 2, y: -finalH / 2 }
  ];
  const poly = rc.polygon(
    points.map((p) => [p.x, p.y]),
    options
  );
  const waveEdgeRect = shapeSvg.insert(() => poly, ":first-child");
  waveEdgeRect.attr("class", "basic label-container");
  if (cssStyles && node.look !== "handDrawn") {
    waveEdgeRect.selectAll("path").attr("style", cssStyles);
  }
  if (nodeStyles && node.look !== "handDrawn") {
    waveEdgeRect.selectAll("path").attr("style", nodeStyles);
  }
  waveEdgeRect.attr("transform", `translate(0,${-waveAmplitude / 2})`);
  label.attr(
    "transform",
    `translate(${-w / 2 + (node.padding ?? 0) + w / 2 * 0.1 / 2 - (bbox.x - (bbox.left ?? 0))},${-h / 2 + (node.padding ?? 0) - waveAmplitude / 2 - (bbox.y - (bbox.top ?? 0))})`
  );
  updateNodeBounds(node, waveEdgeRect);
  node.intersect = function(point) {
    const pos = intersect_default.polygon(node, points, point);
    return pos;
  };
  return shapeSvg;
}
__name(linedWaveEdgedRect, "linedWaveEdgedRect");
async function multiRect(parent, node) {
  const { labelStyles, nodeStyles } = styles2String(node);
  node.labelStyle = labelStyles;
  const { shapeSvg, bbox, label } = await labelHelper(parent, node, getNodeClasses(node));
  const w = Math.max(bbox.width + (node.padding ?? 0) * 2, node?.width ?? 0);
  const h = Math.max(bbox.height + (node.padding ?? 0) * 2, node?.height ?? 0);
  const rectOffset = 5;
  const x = -w / 2;
  const y = -h / 2;
  const { cssStyles } = node;
  const rc = at.svg(shapeSvg);
  const options = userNodeOverrides(node, {});
  const outerPathPoints = [
    { x: x - rectOffset, y: y + rectOffset },
    { x: x - rectOffset, y: y + h + rectOffset },
    { x: x + w - rectOffset, y: y + h + rectOffset },
    { x: x + w - rectOffset, y: y + h },
    { x: x + w, y: y + h },
    { x: x + w, y: y + h - rectOffset },
    { x: x + w + rectOffset, y: y + h - rectOffset },
    { x: x + w + rectOffset, y: y - rectOffset },
    { x: x + rectOffset, y: y - rectOffset },
    { x: x + rectOffset, y },
    { x, y },
    { x, y: y + rectOffset }
  ];
  const innerPathPoints = [
    { x, y: y + rectOffset },
    { x: x + w - rectOffset, y: y + rectOffset },
    { x: x + w - rectOffset, y: y + h },
    { x: x + w, y: y + h },
    { x: x + w, y },
    { x, y }
  ];
  if (node.look !== "handDrawn") {
    options.roughness = 0;
    options.fillStyle = "solid";
  }
  const outerPath = createPathFromPoints(outerPathPoints);
  const outerNode = rc.path(outerPath, options);
  const innerPath = createPathFromPoints(innerPathPoints);
  const innerNode = rc.path(innerPath, { ...options, fill: "none" });
  const multiRect2 = shapeSvg.insert(() => innerNode, ":first-child");
  multiRect2.insert(() => outerNode, ":first-child");
  multiRect2.attr("class", "basic label-container");
  if (cssStyles && node.look !== "handDrawn") {
    multiRect2.selectAll("path").attr("style", cssStyles);
  }
  if (nodeStyles && node.look !== "handDrawn") {
    multiRect2.selectAll("path").attr("style", nodeStyles);
  }
  label.attr(
    "transform",
    `translate(${-(bbox.width / 2) - rectOffset - (bbox.x - (bbox.left ?? 0))}, ${-(bbox.height / 2) + rectOffset - (bbox.y - (bbox.top ?? 0))})`
  );
  updateNodeBounds(node, multiRect2);
  node.intersect = function(point) {
    const pos = intersect_default.polygon(node, outerPathPoints, point);
    return pos;
  };
  return shapeSvg;
}
__name(multiRect, "multiRect");
async function multiWaveEdgedRectangle(parent, node) {
  const { labelStyles, nodeStyles } = styles2String(node);
  node.labelStyle = labelStyles;
  const { shapeSvg, bbox, label } = await labelHelper(parent, node, getNodeClasses(node));
  const w = Math.max(bbox.width + (node.padding ?? 0) * 2, node?.width ?? 0);
  const h = Math.max(bbox.height + (node.padding ?? 0) * 2, node?.height ?? 0);
  const waveAmplitude = h / 4;
  const finalH = h + waveAmplitude;
  const x = -w / 2;
  const y = -finalH / 2;
  const rectOffset = 5;
  const { cssStyles } = node;
  const wavePoints = generateFullSineWavePoints(
    x - rectOffset,
    y + finalH + rectOffset,
    x + w - rectOffset,
    y + finalH + rectOffset,
    waveAmplitude,
    0.8
  );
  const lastWavePoint = wavePoints?.[wavePoints.length - 1];
  const outerPathPoints = [
    { x: x - rectOffset, y: y + rectOffset },
    { x: x - rectOffset, y: y + finalH + rectOffset },
    ...wavePoints,
    { x: x + w - rectOffset, y: lastWavePoint.y - rectOffset },
    { x: x + w, y: lastWavePoint.y - rectOffset },
    { x: x + w, y: lastWavePoint.y - 2 * rectOffset },
    { x: x + w + rectOffset, y: lastWavePoint.y - 2 * rectOffset },
    { x: x + w + rectOffset, y: y - rectOffset },
    { x: x + rectOffset, y: y - rectOffset },
    { x: x + rectOffset, y },
    { x, y },
    { x, y: y + rectOffset }
  ];
  const innerPathPoints = [
    { x, y: y + rectOffset },
    { x: x + w - rectOffset, y: y + rectOffset },
    { x: x + w - rectOffset, y: lastWavePoint.y - rectOffset },
    { x: x + w, y: lastWavePoint.y - rectOffset },
    { x: x + w, y },
    { x, y }
  ];
  const rc = at.svg(shapeSvg);
  const options = userNodeOverrides(node, {});
  if (node.look !== "handDrawn") {
    options.roughness = 0;
    options.fillStyle = "solid";
  }
  const outerPath = createPathFromPoints(outerPathPoints);
  const outerNode = rc.path(outerPath, options);
  const innerPath = createPathFromPoints(innerPathPoints);
  const innerNode = rc.path(innerPath, options);
  const shape = shapeSvg.insert(() => outerNode, ":first-child");
  shape.insert(() => innerNode);
  shape.attr("class", "basic label-container");
  if (cssStyles && node.look !== "handDrawn") {
    shape.selectAll("path").attr("style", cssStyles);
  }
  if (nodeStyles && node.look !== "handDrawn") {
    shape.selectAll("path").attr("style", nodeStyles);
  }
  shape.attr("transform", `translate(0,${-waveAmplitude / 2})`);
  label.attr(
    "transform",
    `translate(${-(bbox.width / 2) - rectOffset - (bbox.x - (bbox.left ?? 0))}, ${-(bbox.height / 2) + rectOffset - waveAmplitude / 2 - (bbox.y - (bbox.top ?? 0))})`
  );
  updateNodeBounds(node, shape);
  node.intersect = function(point) {
    const pos = intersect_default.polygon(node, outerPathPoints, point);
    return pos;
  };
  return shapeSvg;
}
__name(multiWaveEdgedRectangle, "multiWaveEdgedRectangle");
async function note(parent, node, { config: { themeVariables } }) {
  const { labelStyles, nodeStyles } = styles2String(node);
  node.labelStyle = labelStyles;
  const useHtmlLabels = node.useHtmlLabels || getConfig().flowchart?.htmlLabels !== false;
  if (!useHtmlLabels) {
    node.centerLabel = true;
  }
  const { shapeSvg, bbox, label } = await labelHelper(parent, node, getNodeClasses(node));
  const totalWidth = Math.max(bbox.width + (node.padding ?? 0) * 2, node?.width ?? 0);
  const totalHeight = Math.max(bbox.height + (node.padding ?? 0) * 2, node?.height ?? 0);
  const x = -totalWidth / 2;
  const y = -totalHeight / 2;
  const { cssStyles } = node;
  const rc = at.svg(shapeSvg);
  const options = userNodeOverrides(node, {
    fill: themeVariables.noteBkgColor,
    stroke: themeVariables.noteBorderColor
  });
  if (node.look !== "handDrawn") {
    options.roughness = 0;
    options.fillStyle = "solid";
  }
  const noteShapeNode = rc.rectangle(x, y, totalWidth, totalHeight, options);
  const rect2 = shapeSvg.insert(() => noteShapeNode, ":first-child");
  rect2.attr("class", "basic label-container");
  if (cssStyles && node.look !== "handDrawn") {
    rect2.selectAll("path").attr("style", cssStyles);
  }
  if (nodeStyles && node.look !== "handDrawn") {
    rect2.selectAll("path").attr("style", nodeStyles);
  }
  label.attr(
    "transform",
    `translate(${-bbox.width / 2 - (bbox.x - (bbox.left ?? 0))}, ${-(bbox.height / 2) - (bbox.y - (bbox.top ?? 0))})`
  );
  updateNodeBounds(node, rect2);
  node.intersect = function(point) {
    return intersect_default.rect(node, point);
  };
  return shapeSvg;
}
__name(note, "note");
var createDecisionBoxPathD = /* @__PURE__ */ __name((x, y, size) => {
  return [
    `M${x + size / 2},${y}`,
    `L${x + size},${y - size / 2}`,
    `L${x + size / 2},${y - size}`,
    `L${x},${y - size / 2}`,
    "Z"
  ].join(" ");
}, "createDecisionBoxPathD");
async function question(parent, node) {
  const { labelStyles, nodeStyles } = styles2String(node);
  node.labelStyle = labelStyles;
  const { shapeSvg, bbox } = await labelHelper(parent, node, getNodeClasses(node));
  const w = bbox.width + node.padding;
  const h = bbox.height + node.padding;
  const s = w + h;
  const adjustment = 0.5;
  const points = [
    { x: s / 2, y: 0 },
    { x: s, y: -s / 2 },
    { x: s / 2, y: -s },
    { x: 0, y: -s / 2 }
  ];
  let polygon;
  const { cssStyles } = node;
  if (node.look === "handDrawn") {
    const rc = at.svg(shapeSvg);
    const options = userNodeOverrides(node, {});
    const pathData = createDecisionBoxPathD(0, 0, s);
    const roughNode = rc.path(pathData, options);
    polygon = shapeSvg.insert(() => roughNode, ":first-child").attr("transform", `translate(${-s / 2 + adjustment}, ${s / 2})`);
    if (cssStyles) {
      polygon.attr("style", cssStyles);
    }
  } else {
    polygon = insertPolygonShape(shapeSvg, s, s, points);
    polygon.attr("transform", `translate(${-s / 2 + adjustment}, ${s / 2})`);
  }
  if (nodeStyles) {
    polygon.attr("style", nodeStyles);
  }
  updateNodeBounds(node, polygon);
  node.intersect = function(point) {
    log.debug(
      "APA12 Intersect called SPLIT\npoint:",
      point,
      "\nnode:\n",
      node,
      "\nres:",
      intersect_default.polygon(node, points, point)
    );
    return intersect_default.polygon(node, points, point);
  };
  return shapeSvg;
}
__name(question, "question");
async function rect_left_inv_arrow(parent, node) {
  const { labelStyles, nodeStyles } = styles2String(node);
  node.labelStyle = labelStyles;
  const { shapeSvg, bbox, label } = await labelHelper(parent, node, getNodeClasses(node));
  const w = Math.max(bbox.width + (node.padding ?? 0), node?.width ?? 0);
  const h = Math.max(bbox.height + (node.padding ?? 0), node?.height ?? 0);
  const x = -w / 2;
  const y = -h / 2;
  const notch = y / 2;
  const points = [
    { x: x + notch, y },
    { x, y: 0 },
    { x: x + notch, y: -y },
    { x: -x, y: -y },
    { x: -x, y }
  ];
  const { cssStyles } = node;
  const rc = at.svg(shapeSvg);
  const options = userNodeOverrides(node, {});
  if (node.look !== "handDrawn") {
    options.roughness = 0;
    options.fillStyle = "solid";
  }
  const pathData = createPathFromPoints(points);
  const roughNode = rc.path(pathData, options);
  const polygon = shapeSvg.insert(() => roughNode, ":first-child");
  polygon.attr("class", "basic label-container");
  if (cssStyles && node.look !== "handDrawn") {
    polygon.selectAll("path").attr("style", cssStyles);
  }
  if (nodeStyles && node.look !== "handDrawn") {
    polygon.selectAll("path").attr("style", nodeStyles);
  }
  polygon.attr("transform", `translate(${-notch / 2},0)`);
  label.attr(
    "transform",
    `translate(${-notch / 2 - bbox.width / 2 - (bbox.x - (bbox.left ?? 0))}, ${-(bbox.height / 2) - (bbox.y - (bbox.top ?? 0))})`
  );
  updateNodeBounds(node, polygon);
  node.intersect = function(point) {
    return intersect_default.polygon(node, points, point);
  };
  return shapeSvg;
}
__name(rect_left_inv_arrow, "rect_left_inv_arrow");
async function rectWithTitle(parent, node) {
  const { labelStyles, nodeStyles } = styles2String(node);
  node.labelStyle = labelStyles;
  let classes;
  if (!node.cssClasses) {
    classes = "node default";
  } else {
    classes = "node " + node.cssClasses;
  }
  const shapeSvg = parent.insert("g").attr("class", classes).attr("id", node.domId || node.id);
  const g = shapeSvg.insert("g");
  const label = shapeSvg.insert("g").attr("class", "label").attr("style", nodeStyles);
  const description = node.description;
  const title = node.label;
  const text2 = label.node().appendChild(await createLabel_default(title, node.labelStyle, true, true));
  let bbox = { width: 0, height: 0 };
  if (evaluate(getConfig2()?.flowchart?.htmlLabels)) {
    const div2 = text2.children[0];
    const dv2 = select(text2);
    bbox = div2.getBoundingClientRect();
    dv2.attr("width", bbox.width);
    dv2.attr("height", bbox.height);
  }
  log.info("Text 2", description);
  const textRows = description || [];
  const titleBox = text2.getBBox();
  const descr = label.node().appendChild(
    await createLabel_default(
      textRows.join ? textRows.join("<br/>") : textRows,
      node.labelStyle,
      true,
      true
    )
  );
  const div = descr.children[0];
  const dv = select(descr);
  bbox = div.getBoundingClientRect();
  dv.attr("width", bbox.width);
  dv.attr("height", bbox.height);
  const halfPadding = (node.padding || 0) / 2;
  select(descr).attr(
    "transform",
    "translate( " + (bbox.width > titleBox.width ? 0 : (titleBox.width - bbox.width) / 2) + ", " + (titleBox.height + halfPadding + 5) + ")"
  );
  select(text2).attr(
    "transform",
    "translate( " + (bbox.width < titleBox.width ? 0 : -(titleBox.width - bbox.width) / 2) + ", 0)"
  );
  bbox = label.node().getBBox();
  label.attr(
    "transform",
    "translate(" + -bbox.width / 2 + ", " + (-bbox.height / 2 - halfPadding + 3) + ")"
  );
  const totalWidth = bbox.width + (node.padding || 0);
  const totalHeight = bbox.height + (node.padding || 0);
  const x = -bbox.width / 2 - halfPadding;
  const y = -bbox.height / 2 - halfPadding;
  let rect2;
  let innerLine;
  if (node.look === "handDrawn") {
    const rc = at.svg(shapeSvg);
    const options = userNodeOverrides(node, {});
    const roughNode = rc.path(
      createRoundedRectPathD(x, y, totalWidth, totalHeight, node.rx || 0),
      options
    );
    const roughLine = rc.line(
      -bbox.width / 2 - halfPadding,
      -bbox.height / 2 - halfPadding + titleBox.height + halfPadding,
      bbox.width / 2 + halfPadding,
      -bbox.height / 2 - halfPadding + titleBox.height + halfPadding,
      options
    );
    innerLine = shapeSvg.insert(() => {
      log.debug("Rough node insert CXC", roughNode);
      return roughLine;
    }, ":first-child");
    rect2 = shapeSvg.insert(() => {
      log.debug("Rough node insert CXC", roughNode);
      return roughNode;
    }, ":first-child");
  } else {
    rect2 = g.insert("rect", ":first-child");
    innerLine = g.insert("line");
    rect2.attr("class", "outer title-state").attr("style", nodeStyles).attr("x", -bbox.width / 2 - halfPadding).attr("y", -bbox.height / 2 - halfPadding).attr("width", bbox.width + (node.padding || 0)).attr("height", bbox.height + (node.padding || 0));
    innerLine.attr("class", "divider").attr("x1", -bbox.width / 2 - halfPadding).attr("x2", bbox.width / 2 + halfPadding).attr("y1", -bbox.height / 2 - halfPadding + titleBox.height + halfPadding).attr("y2", -bbox.height / 2 - halfPadding + titleBox.height + halfPadding);
  }
  updateNodeBounds(node, rect2);
  node.intersect = function(point) {
    return intersect_default.rect(node, point);
  };
  return shapeSvg;
}
__name(rectWithTitle, "rectWithTitle");
function generateArcPoints2(x1, y1, x2, y2, rx, ry, clockwise) {
  const numPoints = 20;
  const midX = (x1 + x2) / 2;
  const midY = (y1 + y2) / 2;
  const angle = Math.atan2(y2 - y1, x2 - x1);
  const dx = (x2 - x1) / 2;
  const dy = (y2 - y1) / 2;
  const transformedX = dx / rx;
  const transformedY = dy / ry;
  const distance = Math.sqrt(transformedX ** 2 + transformedY ** 2);
  if (distance > 1) {
    throw new Error("The given radii are too small to create an arc between the points.");
  }
  const scaledCenterDistance = Math.sqrt(1 - distance ** 2);
  const centerX = midX + scaledCenterDistance * ry * Math.sin(angle) * (clockwise ? -1 : 1);
  const centerY = midY - scaledCenterDistance * rx * Math.cos(angle) * (clockwise ? -1 : 1);
  const startAngle = Math.atan2((y1 - centerY) / ry, (x1 - centerX) / rx);
  const endAngle = Math.atan2((y2 - centerY) / ry, (x2 - centerX) / rx);
  let angleRange = endAngle - startAngle;
  if (clockwise && angleRange < 0) {
    angleRange += 2 * Math.PI;
  }
  if (!clockwise && angleRange > 0) {
    angleRange -= 2 * Math.PI;
  }
  const points = [];
  for (let i = 0; i < numPoints; i++) {
    const t = i / (numPoints - 1);
    const angle2 = startAngle + t * angleRange;
    const x = centerX + rx * Math.cos(angle2);
    const y = centerY + ry * Math.sin(angle2);
    points.push({ x, y });
  }
  return points;
}
__name(generateArcPoints2, "generateArcPoints");
async function roundedRect(parent, node) {
  const { labelStyles, nodeStyles } = styles2String(node);
  node.labelStyle = labelStyles;
  const { shapeSvg, bbox } = await labelHelper(parent, node, getNodeClasses(node));
  const labelPaddingX = node?.padding ?? 0;
  const labelPaddingY = node?.padding ?? 0;
  const w = (node?.width ? node?.width : bbox.width) + labelPaddingX * 2;
  const h = (node?.height ? node?.height : bbox.height) + labelPaddingY * 2;
  const radius = 5;
  const taper = 5;
  const { cssStyles } = node;
  const rc = at.svg(shapeSvg);
  const options = userNodeOverrides(node, {});
  if (node.look !== "handDrawn") {
    options.roughness = 0;
    options.fillStyle = "solid";
  }
  const points = [
    // Top edge (left to right)
    { x: -w / 2 + taper, y: -h / 2 },
    // Top-left corner start (1)
    { x: w / 2 - taper, y: -h / 2 },
    // Top-right corner start (2)
    ...generateArcPoints2(w / 2 - taper, -h / 2, w / 2, -h / 2 + taper, radius, radius, true),
    // Top-left arc (2 to 3)
    // Right edge (top to bottom)
    { x: w / 2, y: -h / 2 + taper },
    // Top-right taper point (3)
    { x: w / 2, y: h / 2 - taper },
    // Bottom-right taper point (4)
    ...generateArcPoints2(w / 2, h / 2 - taper, w / 2 - taper, h / 2, radius, radius, true),
    // Top-left arc (4 to 5)
    // Bottom edge (right to left)
    { x: w / 2 - taper, y: h / 2 },
    // Bottom-right corner start (5)
    { x: -w / 2 + taper, y: h / 2 },
    // Bottom-left corner start (6)
    ...generateArcPoints2(-w / 2 + taper, h / 2, -w / 2, h / 2 - taper, radius, radius, true),
    // Top-left arc (4 to 5)
    // Left edge (bottom to top)
    { x: -w / 2, y: h / 2 - taper },
    // Bottom-left taper point (7)
    { x: -w / 2, y: -h / 2 + taper },
    // Top-left taper point (8)
    ...generateArcPoints2(-w / 2, -h / 2 + taper, -w / 2 + taper, -h / 2, radius, radius, true)
    // Top-left arc (4 to 5)
  ];
  const pathData = createPathFromPoints(points);
  const shapeNode = rc.path(pathData, options);
  const polygon = shapeSvg.insert(() => shapeNode, ":first-child");
  polygon.attr("class", "basic label-container outer-path");
  if (cssStyles && node.look !== "handDrawn") {
    polygon.selectChildren("path").attr("style", cssStyles);
  }
  if (nodeStyles && node.look !== "handDrawn") {
    polygon.selectChildren("path").attr("style", nodeStyles);
  }
  updateNodeBounds(node, polygon);
  node.intersect = function(point) {
    const pos = intersect_default.polygon(node, points, point);
    return pos;
  };
  return shapeSvg;
}
__name(roundedRect, "roundedRect");
async function shadedProcess(parent, node) {
  const { labelStyles, nodeStyles } = styles2String(node);
  node.labelStyle = labelStyles;
  const { shapeSvg, bbox, label } = await labelHelper(parent, node, getNodeClasses(node));
  const halfPadding = node?.padding ?? 0;
  const w = Math.max(bbox.width + (node.padding ?? 0) * 2, node?.width ?? 0);
  const h = Math.max(bbox.height + (node.padding ?? 0) * 2, node?.height ?? 0);
  const x = -bbox.width / 2 - halfPadding;
  const y = -bbox.height / 2 - halfPadding;
  const { cssStyles } = node;
  const rc = at.svg(shapeSvg);
  const options = userNodeOverrides(node, {});
  if (node.look !== "handDrawn") {
    options.roughness = 0;
    options.fillStyle = "solid";
  }
  const points = [
    { x, y },
    { x: x + w + 8, y },
    { x: x + w + 8, y: y + h },
    { x: x - 8, y: y + h },
    { x: x - 8, y },
    { x, y },
    { x, y: y + h }
  ];
  const roughNode = rc.polygon(
    points.map((p) => [p.x, p.y]),
    options
  );
  const rect2 = shapeSvg.insert(() => roughNode, ":first-child");
  rect2.attr("class", "basic label-container").attr("style", handleUndefinedAttr(cssStyles));
  if (nodeStyles && node.look !== "handDrawn") {
    rect2.selectAll("path").attr("style", nodeStyles);
  }
  if (cssStyles && node.look !== "handDrawn") {
    rect2.selectAll("path").attr("style", nodeStyles);
  }
  label.attr(
    "transform",
    `translate(${-w / 2 + 4 + (node.padding ?? 0) - (bbox.x - (bbox.left ?? 0))},${-h / 2 + (node.padding ?? 0) - (bbox.y - (bbox.top ?? 0))})`
  );
  updateNodeBounds(node, rect2);
  node.intersect = function(point) {
    return intersect_default.rect(node, point);
  };
  return shapeSvg;
}
__name(shadedProcess, "shadedProcess");
async function slopedRect(parent, node) {
  const { labelStyles, nodeStyles } = styles2String(node);
  node.labelStyle = labelStyles;
  const { shapeSvg, bbox, label } = await labelHelper(parent, node, getNodeClasses(node));
  const w = Math.max(bbox.width + (node.padding ?? 0) * 2, node?.width ?? 0);
  const h = Math.max(bbox.height + (node.padding ?? 0) * 2, node?.height ?? 0);
  const x = -w / 2;
  const y = -h / 2;
  const { cssStyles } = node;
  const rc = at.svg(shapeSvg);
  const options = userNodeOverrides(node, {});
  if (node.look !== "handDrawn") {
    options.roughness = 0;
    options.fillStyle = "solid";
  }
  const points = [
    { x, y },
    { x, y: y + h },
    { x: x + w, y: y + h },
    { x: x + w, y: y - h / 2 }
  ];
  const pathData = createPathFromPoints(points);
  const shapeNode = rc.path(pathData, options);
  const polygon = shapeSvg.insert(() => shapeNode, ":first-child");
  polygon.attr("class", "basic label-container");
  if (cssStyles && node.look !== "handDrawn") {
    polygon.selectChildren("path").attr("style", cssStyles);
  }
  if (nodeStyles && node.look !== "handDrawn") {
    polygon.selectChildren("path").attr("style", nodeStyles);
  }
  polygon.attr("transform", `translate(0, ${h / 4})`);
  label.attr(
    "transform",
    `translate(${-w / 2 + (node.padding ?? 0) - (bbox.x - (bbox.left ?? 0))}, ${-h / 4 + (node.padding ?? 0) - (bbox.y - (bbox.top ?? 0))})`
  );
  updateNodeBounds(node, polygon);
  node.intersect = function(point) {
    const pos = intersect_default.polygon(node, points, point);
    return pos;
  };
  return shapeSvg;
}
__name(slopedRect, "slopedRect");

// src/rendering-util/rendering-elements/shapes/squareRect.ts
async function squareRect2(parent, node) {
  const options = {
    rx: 0,
    ry: 0,
    labelPaddingX: (node?.padding || 0) * 2,
    labelPaddingY: (node?.padding || 0) * 1
  };
  return drawRect(parent, node, options);
}
__name(squareRect2, "squareRect");
async function stadium(parent, node) {
  const { labelStyles, nodeStyles } = styles2String(node);
  node.labelStyle = labelStyles;
  const { shapeSvg, bbox } = await labelHelper(parent, node, getNodeClasses(node));
  const h = bbox.height + node.padding;
  const w = bbox.width + h / 4 + node.padding;
  const radius = h / 2;
  const { cssStyles } = node;
  const rc = at.svg(shapeSvg);
  const options = userNodeOverrides(node, {});
  if (node.look !== "handDrawn") {
    options.roughness = 0;
    options.fillStyle = "solid";
  }
  const points = [
    { x: -w / 2 + radius, y: -h / 2 },
    { x: w / 2 - radius, y: -h / 2 },
    ...generateCirclePoints(-w / 2 + radius, 0, radius, 50, 90, 270),
    { x: w / 2 - radius, y: h / 2 },
    ...generateCirclePoints(w / 2 - radius, 0, radius, 50, 270, 450)
  ];
  const pathData = createPathFromPoints(points);
  const shapeNode = rc.path(pathData, options);
  const polygon = shapeSvg.insert(() => shapeNode, ":first-child");
  polygon.attr("class", "basic label-container outer-path");
  if (cssStyles && node.look !== "handDrawn") {
    polygon.selectChildren("path").attr("style", cssStyles);
  }
  if (nodeStyles && node.look !== "handDrawn") {
    polygon.selectChildren("path").attr("style", nodeStyles);
  }
  updateNodeBounds(node, polygon);
  node.intersect = function(point) {
    const pos = intersect_default.polygon(node, points, point);
    return pos;
  };
  return shapeSvg;
}
__name(stadium, "stadium");

// src/rendering-util/rendering-elements/shapes/state.ts
async function state(parent, node) {
  const options = {
    rx: 5,
    ry: 5};
  return drawRect(parent, node, options);
}
__name(state, "state");
function stateEnd(parent, node, { config: { themeVariables } }) {
  const { labelStyles, nodeStyles } = styles2String(node);
  node.labelStyle = labelStyles;
  const { cssStyles } = node;
  const { lineColor, stateBorder, nodeBorder } = themeVariables;
  const shapeSvg = parent.insert("g").attr("class", "node default").attr("id", node.domId || node.id);
  const rc = at.svg(shapeSvg);
  const options = userNodeOverrides(node, {});
  if (node.look !== "handDrawn") {
    options.roughness = 0;
    options.fillStyle = "solid";
  }
  const roughNode = rc.circle(0, 0, 14, {
    ...options,
    stroke: lineColor,
    strokeWidth: 2
  });
  const innerFill = stateBorder ?? nodeBorder;
  const roughInnerNode = rc.circle(0, 0, 5, {
    ...options,
    fill: innerFill,
    stroke: innerFill,
    strokeWidth: 2,
    fillStyle: "solid"
  });
  const circle2 = shapeSvg.insert(() => roughNode, ":first-child");
  circle2.insert(() => roughInnerNode);
  if (cssStyles) {
    circle2.selectAll("path").attr("style", cssStyles);
  }
  if (nodeStyles) {
    circle2.selectAll("path").attr("style", nodeStyles);
  }
  updateNodeBounds(node, circle2);
  node.intersect = function(point) {
    return intersect_default.circle(node, 7, point);
  };
  return shapeSvg;
}
__name(stateEnd, "stateEnd");
function stateStart(parent, node, { config: { themeVariables } }) {
  const { lineColor } = themeVariables;
  const shapeSvg = parent.insert("g").attr("class", "node default").attr("id", node.domId || node.id);
  let circle2;
  if (node.look === "handDrawn") {
    const rc = at.svg(shapeSvg);
    const roughNode = rc.circle(0, 0, 14, solidStateFill(lineColor));
    circle2 = shapeSvg.insert(() => roughNode);
    circle2.attr("class", "state-start").attr("r", 7).attr("width", 14).attr("height", 14);
  } else {
    circle2 = shapeSvg.insert("circle", ":first-child");
    circle2.attr("class", "state-start").attr("r", 7).attr("width", 14).attr("height", 14);
  }
  updateNodeBounds(node, circle2);
  node.intersect = function(point) {
    return intersect_default.circle(node, 7, point);
  };
  return shapeSvg;
}
__name(stateStart, "stateStart");
async function subroutine(parent, node) {
  const { labelStyles, nodeStyles } = styles2String(node);
  node.labelStyle = labelStyles;
  const { shapeSvg, bbox } = await labelHelper(parent, node, getNodeClasses(node));
  const halfPadding = (node?.padding || 0) / 2;
  const w = bbox.width + node.padding;
  const h = bbox.height + node.padding;
  const x = -bbox.width / 2 - halfPadding;
  const y = -bbox.height / 2 - halfPadding;
  const points = [
    { x: 0, y: 0 },
    { x: w, y: 0 },
    { x: w, y: -h },
    { x: 0, y: -h },
    { x: 0, y: 0 },
    { x: -8, y: 0 },
    { x: w + 8, y: 0 },
    { x: w + 8, y: -h },
    { x: -8, y: -h },
    { x: -8, y: 0 }
  ];
  if (node.look === "handDrawn") {
    const rc = at.svg(shapeSvg);
    const options = userNodeOverrides(node, {});
    const roughNode = rc.rectangle(x - 8, y, w + 16, h, options);
    const l1 = rc.line(x, y, x, y + h, options);
    const l2 = rc.line(x + w, y, x + w, y + h, options);
    shapeSvg.insert(() => l1, ":first-child");
    shapeSvg.insert(() => l2, ":first-child");
    const rect2 = shapeSvg.insert(() => roughNode, ":first-child");
    const { cssStyles } = node;
    rect2.attr("class", "basic label-container").attr("style", handleUndefinedAttr(cssStyles));
    updateNodeBounds(node, rect2);
  } else {
    const el = insertPolygonShape(shapeSvg, w, h, points);
    if (nodeStyles) {
      el.attr("style", nodeStyles);
    }
    updateNodeBounds(node, el);
  }
  node.intersect = function(point) {
    return intersect_default.polygon(node, points, point);
  };
  return shapeSvg;
}
__name(subroutine, "subroutine");
async function taggedRect(parent, node) {
  const { labelStyles, nodeStyles } = styles2String(node);
  node.labelStyle = labelStyles;
  const { shapeSvg, bbox } = await labelHelper(parent, node, getNodeClasses(node));
  const w = Math.max(bbox.width + (node.padding ?? 0) * 2, node?.width ?? 0);
  const h = Math.max(bbox.height + (node.padding ?? 0) * 2, node?.height ?? 0);
  const x = -w / 2;
  const y = -h / 2;
  const tagWidth = 0.2 * h;
  const tagHeight = 0.2 * h;
  const { cssStyles } = node;
  const rc = at.svg(shapeSvg);
  const options = userNodeOverrides(node, {});
  const rectPoints = [
    { x: x - tagWidth / 2, y },
    { x: x + w + tagWidth / 2, y },
    { x: x + w + tagWidth / 2, y: y + h },
    { x: x - tagWidth / 2, y: y + h }
  ];
  const tagPoints = [
    { x: x + w - tagWidth / 2, y: y + h },
    { x: x + w + tagWidth / 2, y: y + h },
    { x: x + w + tagWidth / 2, y: y + h - tagHeight }
  ];
  if (node.look !== "handDrawn") {
    options.roughness = 0;
    options.fillStyle = "solid";
  }
  const rectPath = createPathFromPoints(rectPoints);
  const rectNode = rc.path(rectPath, options);
  const tagPath = createPathFromPoints(tagPoints);
  const tagNode = rc.path(tagPath, { ...options, fillStyle: "solid" });
  const taggedRect2 = shapeSvg.insert(() => tagNode, ":first-child");
  taggedRect2.insert(() => rectNode, ":first-child");
  taggedRect2.attr("class", "basic label-container");
  if (cssStyles && node.look !== "handDrawn") {
    taggedRect2.selectAll("path").attr("style", cssStyles);
  }
  if (nodeStyles && node.look !== "handDrawn") {
    taggedRect2.selectAll("path").attr("style", nodeStyles);
  }
  updateNodeBounds(node, taggedRect2);
  node.intersect = function(point) {
    const pos = intersect_default.polygon(node, rectPoints, point);
    return pos;
  };
  return shapeSvg;
}
__name(taggedRect, "taggedRect");
async function taggedWaveEdgedRectangle(parent, node) {
  const { labelStyles, nodeStyles } = styles2String(node);
  node.labelStyle = labelStyles;
  const { shapeSvg, bbox, label } = await labelHelper(parent, node, getNodeClasses(node));
  const w = Math.max(bbox.width + (node.padding ?? 0) * 2, node?.width ?? 0);
  const h = Math.max(bbox.height + (node.padding ?? 0) * 2, node?.height ?? 0);
  const waveAmplitude = h / 4;
  const tagWidth = 0.2 * w;
  const tagHeight = 0.2 * h;
  const finalH = h + waveAmplitude;
  const { cssStyles } = node;
  const rc = at.svg(shapeSvg);
  const options = userNodeOverrides(node, {});
  if (node.look !== "handDrawn") {
    options.roughness = 0;
    options.fillStyle = "solid";
  }
  const points = [
    { x: -w / 2 - w / 2 * 0.1, y: finalH / 2 },
    ...generateFullSineWavePoints(
      -w / 2 - w / 2 * 0.1,
      finalH / 2,
      w / 2 + w / 2 * 0.1,
      finalH / 2,
      waveAmplitude,
      0.8
    ),
    { x: w / 2 + w / 2 * 0.1, y: -finalH / 2 },
    { x: -w / 2 - w / 2 * 0.1, y: -finalH / 2 }
  ];
  const x = -w / 2 + w / 2 * 0.1;
  const y = -finalH / 2 - tagHeight * 0.4;
  const tagPoints = [
    { x: x + w - tagWidth, y: (y + h) * 1.4 },
    { x: x + w, y: y + h - tagHeight },
    { x: x + w, y: (y + h) * 0.9 },
    ...generateFullSineWavePoints(
      x + w,
      (y + h) * 1.3,
      x + w - tagWidth,
      (y + h) * 1.5,
      -h * 0.03,
      0.5
    )
  ];
  const waveEdgeRectPath = createPathFromPoints(points);
  const waveEdgeRectNode = rc.path(waveEdgeRectPath, options);
  const taggedWaveEdgeRectPath = createPathFromPoints(tagPoints);
  const taggedWaveEdgeRectNode = rc.path(taggedWaveEdgeRectPath, {
    ...options,
    fillStyle: "solid"
  });
  const waveEdgeRect = shapeSvg.insert(() => taggedWaveEdgeRectNode, ":first-child");
  waveEdgeRect.insert(() => waveEdgeRectNode, ":first-child");
  waveEdgeRect.attr("class", "basic label-container");
  if (cssStyles && node.look !== "handDrawn") {
    waveEdgeRect.selectAll("path").attr("style", cssStyles);
  }
  if (nodeStyles && node.look !== "handDrawn") {
    waveEdgeRect.selectAll("path").attr("style", nodeStyles);
  }
  waveEdgeRect.attr("transform", `translate(0,${-waveAmplitude / 2})`);
  label.attr(
    "transform",
    `translate(${-w / 2 + (node.padding ?? 0) - (bbox.x - (bbox.left ?? 0))},${-h / 2 + (node.padding ?? 0) - waveAmplitude / 2 - (bbox.y - (bbox.top ?? 0))})`
  );
  updateNodeBounds(node, waveEdgeRect);
  node.intersect = function(point) {
    const pos = intersect_default.polygon(node, points, point);
    return pos;
  };
  return shapeSvg;
}
__name(taggedWaveEdgedRectangle, "taggedWaveEdgedRectangle");

// src/rendering-util/rendering-elements/shapes/text.ts
async function text(parent, node) {
  const { labelStyles, nodeStyles } = styles2String(node);
  node.labelStyle = labelStyles;
  const { shapeSvg, bbox } = await labelHelper(parent, node, getNodeClasses(node));
  const totalWidth = Math.max(bbox.width + node.padding, node?.width || 0);
  const totalHeight = Math.max(bbox.height + node.padding, node?.height || 0);
  const x = -totalWidth / 2;
  const y = -totalHeight / 2;
  const rect2 = shapeSvg.insert("rect", ":first-child");
  rect2.attr("class", "text").attr("style", nodeStyles).attr("rx", 0).attr("ry", 0).attr("x", x).attr("y", y).attr("width", totalWidth).attr("height", totalHeight);
  updateNodeBounds(node, rect2);
  node.intersect = function(point) {
    return intersect_default.rect(node, point);
  };
  return shapeSvg;
}
__name(text, "text");
var createCylinderPathD3 = /* @__PURE__ */ __name((x, y, width, height, rx, ry) => {
  return `M${x},${y}
    a${rx},${ry} 0,0,1 ${0},${-height}
    l${width},${0}
    a${rx},${ry} 0,0,1 ${0},${height}
    M${width},${-height}
    a${rx},${ry} 0,0,0 ${0},${height}
    l${-width},${0}`;
}, "createCylinderPathD");
var createOuterCylinderPathD3 = /* @__PURE__ */ __name((x, y, width, height, rx, ry) => {
  return [
    `M${x},${y}`,
    `M${x + width},${y}`,
    `a${rx},${ry} 0,0,0 ${0},${-height}`,
    `l${-width},0`,
    `a${rx},${ry} 0,0,0 ${0},${height}`,
    `l${width},0`
  ].join(" ");
}, "createOuterCylinderPathD");
var createInnerCylinderPathD3 = /* @__PURE__ */ __name((x, y, width, height, rx, ry) => {
  return [`M${x + width / 2},${-height / 2}`, `a${rx},${ry} 0,0,0 0,${height}`].join(" ");
}, "createInnerCylinderPathD");
async function tiltedCylinder(parent, node) {
  const { labelStyles, nodeStyles } = styles2String(node);
  node.labelStyle = labelStyles;
  const { shapeSvg, bbox, label, halfPadding } = await labelHelper(
    parent,
    node,
    getNodeClasses(node)
  );
  const labelPadding = node.look === "neo" ? halfPadding * 2 : halfPadding;
  const h = bbox.height + labelPadding;
  const ry = h / 2;
  const rx = ry / (2.5 + h / 50);
  const w = bbox.width + rx + labelPadding;
  const { cssStyles } = node;
  let cylinder2;
  if (node.look === "handDrawn") {
    const rc = at.svg(shapeSvg);
    const outerPathData = createOuterCylinderPathD3(0, 0, w, h, rx, ry);
    const innerPathData = createInnerCylinderPathD3(0, 0, w, h, rx, ry);
    const outerNode = rc.path(outerPathData, userNodeOverrides(node, {}));
    const innerLine = rc.path(innerPathData, userNodeOverrides(node, { fill: "none" }));
    cylinder2 = shapeSvg.insert(() => innerLine, ":first-child");
    cylinder2 = shapeSvg.insert(() => outerNode, ":first-child");
    cylinder2.attr("class", "basic label-container");
    if (cssStyles) {
      cylinder2.attr("style", cssStyles);
    }
  } else {
    const pathData = createCylinderPathD3(0, 0, w, h, rx, ry);
    cylinder2 = shapeSvg.insert("path", ":first-child").attr("d", pathData).attr("class", "basic label-container").attr("style", handleUndefinedAttr(cssStyles)).attr("style", nodeStyles);
    cylinder2.attr("class", "basic label-container");
    if (cssStyles) {
      cylinder2.selectAll("path").attr("style", cssStyles);
    }
    if (nodeStyles) {
      cylinder2.selectAll("path").attr("style", nodeStyles);
    }
  }
  cylinder2.attr("label-offset-x", rx);
  cylinder2.attr("transform", `translate(${-w / 2}, ${h / 2} )`);
  label.attr(
    "transform",
    `translate(${-(bbox.width / 2) - rx - (bbox.x - (bbox.left ?? 0))}, ${-(bbox.height / 2) - (bbox.y - (bbox.top ?? 0))})`
  );
  updateNodeBounds(node, cylinder2);
  node.intersect = function(point) {
    const pos = intersect_default.rect(node, point);
    const y = pos.y - (node.y ?? 0);
    if (ry != 0 && (Math.abs(y) < (node.height ?? 0) / 2 || Math.abs(y) == (node.height ?? 0) / 2 && Math.abs(pos.x - (node.x ?? 0)) > (node.width ?? 0) / 2 - rx)) {
      let x = rx * rx * (1 - y * y / (ry * ry));
      if (x != 0) {
        x = Math.sqrt(Math.abs(x));
      }
      x = rx - x;
      if (point.x - (node.x ?? 0) > 0) {
        x = -x;
      }
      pos.x += x;
    }
    return pos;
  };
  return shapeSvg;
}
__name(tiltedCylinder, "tiltedCylinder");
async function trapezoid(parent, node) {
  const { labelStyles, nodeStyles } = styles2String(node);
  node.labelStyle = labelStyles;
  const { shapeSvg, bbox } = await labelHelper(parent, node, getNodeClasses(node));
  const w = bbox.width + node.padding;
  const h = bbox.height + node.padding;
  const points = [
    { x: -3 * h / 6, y: 0 },
    { x: w + 3 * h / 6, y: 0 },
    { x: w, y: -h },
    { x: 0, y: -h }
  ];
  let polygon;
  const { cssStyles } = node;
  if (node.look === "handDrawn") {
    const rc = at.svg(shapeSvg);
    const options = userNodeOverrides(node, {});
    const pathData = createPathFromPoints(points);
    const roughNode = rc.path(pathData, options);
    polygon = shapeSvg.insert(() => roughNode, ":first-child").attr("transform", `translate(${-w / 2}, ${h / 2})`);
    if (cssStyles) {
      polygon.attr("style", cssStyles);
    }
  } else {
    polygon = insertPolygonShape(shapeSvg, w, h, points);
  }
  if (nodeStyles) {
    polygon.attr("style", nodeStyles);
  }
  node.width = w;
  node.height = h;
  updateNodeBounds(node, polygon);
  node.intersect = function(point) {
    return intersect_default.polygon(node, points, point);
  };
  return shapeSvg;
}
__name(trapezoid, "trapezoid");
async function trapezoidalPentagon(parent, node) {
  const { labelStyles, nodeStyles } = styles2String(node);
  node.labelStyle = labelStyles;
  const { shapeSvg, bbox } = await labelHelper(parent, node, getNodeClasses(node));
  const minWidth = 60, minHeight = 20;
  const w = Math.max(minWidth, bbox.width + (node.padding ?? 0) * 2, node?.width ?? 0);
  const h = Math.max(minHeight, bbox.height + (node.padding ?? 0) * 2, node?.height ?? 0);
  const { cssStyles } = node;
  const rc = at.svg(shapeSvg);
  const options = userNodeOverrides(node, {});
  if (node.look !== "handDrawn") {
    options.roughness = 0;
    options.fillStyle = "solid";
  }
  const points = [
    { x: -w / 2 * 0.8, y: -h / 2 },
    { x: w / 2 * 0.8, y: -h / 2 },
    { x: w / 2, y: -h / 2 * 0.6 },
    { x: w / 2, y: h / 2 },
    { x: -w / 2, y: h / 2 },
    { x: -w / 2, y: -h / 2 * 0.6 }
  ];
  const pathData = createPathFromPoints(points);
  const shapeNode = rc.path(pathData, options);
  const polygon = shapeSvg.insert(() => shapeNode, ":first-child");
  polygon.attr("class", "basic label-container");
  if (cssStyles && node.look !== "handDrawn") {
    polygon.selectChildren("path").attr("style", cssStyles);
  }
  if (nodeStyles && node.look !== "handDrawn") {
    polygon.selectChildren("path").attr("style", nodeStyles);
  }
  updateNodeBounds(node, polygon);
  node.intersect = function(point) {
    const pos = intersect_default.polygon(node, points, point);
    return pos;
  };
  return shapeSvg;
}
__name(trapezoidalPentagon, "trapezoidalPentagon");
async function triangle(parent, node) {
  const { labelStyles, nodeStyles } = styles2String(node);
  node.labelStyle = labelStyles;
  const { shapeSvg, bbox, label } = await labelHelper(parent, node, getNodeClasses(node));
  const useHtmlLabels = evaluate(getConfig2().flowchart?.htmlLabels);
  const w = bbox.width + (node.padding ?? 0);
  const h = w + bbox.height;
  const tw = w + bbox.height;
  const points = [
    { x: 0, y: 0 },
    { x: tw, y: 0 },
    { x: tw / 2, y: -h }
  ];
  const { cssStyles } = node;
  const rc = at.svg(shapeSvg);
  const options = userNodeOverrides(node, {});
  if (node.look !== "handDrawn") {
    options.roughness = 0;
    options.fillStyle = "solid";
  }
  const pathData = createPathFromPoints(points);
  const roughNode = rc.path(pathData, options);
  const polygon = shapeSvg.insert(() => roughNode, ":first-child").attr("transform", `translate(${-h / 2}, ${h / 2})`);
  if (cssStyles && node.look !== "handDrawn") {
    polygon.selectChildren("path").attr("style", cssStyles);
  }
  if (nodeStyles && node.look !== "handDrawn") {
    polygon.selectChildren("path").attr("style", nodeStyles);
  }
  node.width = w;
  node.height = h;
  updateNodeBounds(node, polygon);
  label.attr(
    "transform",
    `translate(${-bbox.width / 2 - (bbox.x - (bbox.left ?? 0))}, ${h / 2 - (bbox.height + (node.padding ?? 0) / (useHtmlLabels ? 2 : 1) - (bbox.y - (bbox.top ?? 0)))})`
  );
  node.intersect = function(point) {
    log.info("Triangle intersect", node, points, point);
    return intersect_default.polygon(node, points, point);
  };
  return shapeSvg;
}
__name(triangle, "triangle");
async function waveEdgedRectangle(parent, node) {
  const { labelStyles, nodeStyles } = styles2String(node);
  node.labelStyle = labelStyles;
  const { shapeSvg, bbox, label } = await labelHelper(parent, node, getNodeClasses(node));
  const w = Math.max(bbox.width + (node.padding ?? 0) * 2, node?.width ?? 0);
  const h = Math.max(bbox.height + (node.padding ?? 0) * 2, node?.height ?? 0);
  const waveAmplitude = h / 8;
  const finalH = h + waveAmplitude;
  const { cssStyles } = node;
  const minWidth = 70;
  const widthDif = minWidth - w;
  const extraW = widthDif > 0 ? widthDif / 2 : 0;
  const rc = at.svg(shapeSvg);
  const options = userNodeOverrides(node, {});
  if (node.look !== "handDrawn") {
    options.roughness = 0;
    options.fillStyle = "solid";
  }
  const points = [
    { x: -w / 2 - extraW, y: finalH / 2 },
    ...generateFullSineWavePoints(
      -w / 2 - extraW,
      finalH / 2,
      w / 2 + extraW,
      finalH / 2,
      waveAmplitude,
      0.8
    ),
    { x: w / 2 + extraW, y: -finalH / 2 },
    { x: -w / 2 - extraW, y: -finalH / 2 }
  ];
  const waveEdgeRectPath = createPathFromPoints(points);
  const waveEdgeRectNode = rc.path(waveEdgeRectPath, options);
  const waveEdgeRect = shapeSvg.insert(() => waveEdgeRectNode, ":first-child");
  waveEdgeRect.attr("class", "basic label-container");
  if (cssStyles && node.look !== "handDrawn") {
    waveEdgeRect.selectAll("path").attr("style", cssStyles);
  }
  if (nodeStyles && node.look !== "handDrawn") {
    waveEdgeRect.selectAll("path").attr("style", nodeStyles);
  }
  waveEdgeRect.attr("transform", `translate(0,${-waveAmplitude / 2})`);
  label.attr(
    "transform",
    `translate(${-w / 2 + (node.padding ?? 0) - (bbox.x - (bbox.left ?? 0))},${-h / 2 + (node.padding ?? 0) - waveAmplitude - (bbox.y - (bbox.top ?? 0))})`
  );
  updateNodeBounds(node, waveEdgeRect);
  node.intersect = function(point) {
    const pos = intersect_default.polygon(node, points, point);
    return pos;
  };
  return shapeSvg;
}
__name(waveEdgedRectangle, "waveEdgedRectangle");
async function waveRectangle(parent, node) {
  const { labelStyles, nodeStyles } = styles2String(node);
  node.labelStyle = labelStyles;
  const { shapeSvg, bbox } = await labelHelper(parent, node, getNodeClasses(node));
  const minWidth = 100;
  const minHeight = 50;
  const baseWidth = Math.max(bbox.width + (node.padding ?? 0) * 2, node?.width ?? 0);
  const baseHeight = Math.max(bbox.height + (node.padding ?? 0) * 2, node?.height ?? 0);
  const aspectRatio = baseWidth / baseHeight;
  let w = baseWidth;
  let h = baseHeight;
  if (w > h * aspectRatio) {
    h = w / aspectRatio;
  } else {
    w = h * aspectRatio;
  }
  w = Math.max(w, minWidth);
  h = Math.max(h, minHeight);
  const waveAmplitude = Math.min(h * 0.2, h / 4);
  const finalH = h + waveAmplitude * 2;
  const { cssStyles } = node;
  const rc = at.svg(shapeSvg);
  const options = userNodeOverrides(node, {});
  if (node.look !== "handDrawn") {
    options.roughness = 0;
    options.fillStyle = "solid";
  }
  const points = [
    { x: -w / 2, y: finalH / 2 },
    ...generateFullSineWavePoints(-w / 2, finalH / 2, w / 2, finalH / 2, waveAmplitude, 1),
    { x: w / 2, y: -finalH / 2 },
    ...generateFullSineWavePoints(w / 2, -finalH / 2, -w / 2, -finalH / 2, waveAmplitude, -1)
  ];
  const waveRectPath = createPathFromPoints(points);
  const waveRectNode = rc.path(waveRectPath, options);
  const waveRect = shapeSvg.insert(() => waveRectNode, ":first-child");
  waveRect.attr("class", "basic label-container");
  if (cssStyles && node.look !== "handDrawn") {
    waveRect.selectAll("path").attr("style", cssStyles);
  }
  if (nodeStyles && node.look !== "handDrawn") {
    waveRect.selectAll("path").attr("style", nodeStyles);
  }
  updateNodeBounds(node, waveRect);
  node.intersect = function(point) {
    const pos = intersect_default.polygon(node, points, point);
    return pos;
  };
  return shapeSvg;
}
__name(waveRectangle, "waveRectangle");
async function windowPane(parent, node) {
  const { labelStyles, nodeStyles } = styles2String(node);
  node.labelStyle = labelStyles;
  const { shapeSvg, bbox, label } = await labelHelper(parent, node, getNodeClasses(node));
  const w = Math.max(bbox.width + (node.padding ?? 0) * 2, node?.width ?? 0);
  const h = Math.max(bbox.height + (node.padding ?? 0) * 2, node?.height ?? 0);
  const rectOffset = 5;
  const x = -w / 2;
  const y = -h / 2;
  const { cssStyles } = node;
  const rc = at.svg(shapeSvg);
  const options = userNodeOverrides(node, {});
  const outerPathPoints = [
    { x: x - rectOffset, y: y - rectOffset },
    { x: x - rectOffset, y: y + h },
    { x: x + w, y: y + h },
    { x: x + w, y: y - rectOffset }
  ];
  const path = `M${x - rectOffset},${y - rectOffset} L${x + w},${y - rectOffset} L${x + w},${y + h} L${x - rectOffset},${y + h} L${x - rectOffset},${y - rectOffset}
                M${x - rectOffset},${y} L${x + w},${y}
                M${x},${y - rectOffset} L${x},${y + h}`;
  if (node.look !== "handDrawn") {
    options.roughness = 0;
    options.fillStyle = "solid";
  }
  const no = rc.path(path, options);
  const windowPane2 = shapeSvg.insert(() => no, ":first-child");
  windowPane2.attr("transform", `translate(${rectOffset / 2}, ${rectOffset / 2})`);
  windowPane2.attr("class", "basic label-container");
  if (cssStyles && node.look !== "handDrawn") {
    windowPane2.selectAll("path").attr("style", cssStyles);
  }
  if (nodeStyles && node.look !== "handDrawn") {
    windowPane2.selectAll("path").attr("style", nodeStyles);
  }
  label.attr(
    "transform",
    `translate(${-(bbox.width / 2) + rectOffset / 2 - (bbox.x - (bbox.left ?? 0))}, ${-(bbox.height / 2) + rectOffset / 2 - (bbox.y - (bbox.top ?? 0))})`
  );
  updateNodeBounds(node, windowPane2);
  node.intersect = function(point) {
    const pos = intersect_default.polygon(node, outerPathPoints, point);
    return pos;
  };
  return shapeSvg;
}
__name(windowPane, "windowPane");
async function erBox(parent, node) {
  const entityNode = node;
  if (entityNode.alias) {
    node.label = entityNode.alias;
  }
  if (node.look === "handDrawn") {
    const { themeVariables: themeVariables2 } = getConfig();
    const { background } = themeVariables2;
    const backgroundNode = {
      ...node,
      id: node.id + "-background",
      look: "default",
      cssStyles: ["stroke: none", `fill: ${background}`]
    };
    await erBox(parent, backgroundNode);
  }
  const config = getConfig();
  node.useHtmlLabels = config.htmlLabels;
  let PADDING = config.er?.diagramPadding ?? 10;
  let TEXT_PADDING = config.er?.entityPadding ?? 6;
  const { cssStyles } = node;
  const { labelStyles, nodeStyles } = styles2String(node);
  if (entityNode.attributes.length === 0 && node.label) {
    const options2 = {
      rx: 0,
      ry: 0,
      labelPaddingX: PADDING,
      labelPaddingY: PADDING * 1.5};
    if (calculateTextWidth(node.label, config) + options2.labelPaddingX * 2 < config.er.minEntityWidth) {
      node.width = config.er.minEntityWidth;
    }
    const shapeSvg2 = await drawRect(parent, node, options2);
    if (!evaluate(config.htmlLabels)) {
      const textElement = shapeSvg2.select("text");
      const bbox = textElement.node()?.getBBox();
      textElement.attr("transform", `translate(${-bbox.width / 2}, 0)`);
    }
    return shapeSvg2;
  }
  if (!config.htmlLabels) {
    PADDING *= 1.25;
    TEXT_PADDING *= 1.25;
  }
  let cssClasses = getNodeClasses(node);
  if (!cssClasses) {
    cssClasses = "node default";
  }
  const shapeSvg = parent.insert("g").attr("class", cssClasses).attr("id", node.domId || node.id);
  const nameBBox = await addText(shapeSvg, node.label ?? "", config, 0, 0, ["name"], labelStyles);
  nameBBox.height += TEXT_PADDING;
  let yOffset = 0;
  const yOffsets = [];
  const rows = [];
  let maxTypeWidth = 0;
  let maxNameWidth = 0;
  let maxKeysWidth = 0;
  let maxCommentWidth = 0;
  let keysPresent = true;
  let commentPresent = true;
  for (const attribute of entityNode.attributes) {
    const typeBBox = await addText(
      shapeSvg,
      attribute.type,
      config,
      0,
      yOffset,
      ["attribute-type"],
      labelStyles
    );
    maxTypeWidth = Math.max(maxTypeWidth, typeBBox.width + PADDING);
    const nameBBox2 = await addText(
      shapeSvg,
      attribute.name,
      config,
      0,
      yOffset,
      ["attribute-name"],
      labelStyles
    );
    maxNameWidth = Math.max(maxNameWidth, nameBBox2.width + PADDING);
    const keysBBox = await addText(
      shapeSvg,
      attribute.keys.join(),
      config,
      0,
      yOffset,
      ["attribute-keys"],
      labelStyles
    );
    maxKeysWidth = Math.max(maxKeysWidth, keysBBox.width + PADDING);
    const commentBBox = await addText(
      shapeSvg,
      attribute.comment,
      config,
      0,
      yOffset,
      ["attribute-comment"],
      labelStyles
    );
    maxCommentWidth = Math.max(maxCommentWidth, commentBBox.width + PADDING);
    const rowHeight = Math.max(typeBBox.height, nameBBox2.height, keysBBox.height, commentBBox.height) + TEXT_PADDING;
    rows.push({ yOffset, rowHeight });
    yOffset += rowHeight;
  }
  let totalWidthSections = 4;
  if (maxKeysWidth <= PADDING) {
    keysPresent = false;
    maxKeysWidth = 0;
    totalWidthSections--;
  }
  if (maxCommentWidth <= PADDING) {
    commentPresent = false;
    maxCommentWidth = 0;
    totalWidthSections--;
  }
  const shapeBBox = shapeSvg.node().getBBox();
  if (nameBBox.width + PADDING * 2 - (maxTypeWidth + maxNameWidth + maxKeysWidth + maxCommentWidth) > 0) {
    const difference = nameBBox.width + PADDING * 2 - (maxTypeWidth + maxNameWidth + maxKeysWidth + maxCommentWidth);
    maxTypeWidth += difference / totalWidthSections;
    maxNameWidth += difference / totalWidthSections;
    if (maxKeysWidth > 0) {
      maxKeysWidth += difference / totalWidthSections;
    }
    if (maxCommentWidth > 0) {
      maxCommentWidth += difference / totalWidthSections;
    }
  }
  const maxWidth = maxTypeWidth + maxNameWidth + maxKeysWidth + maxCommentWidth;
  const rc = at.svg(shapeSvg);
  const options = userNodeOverrides(node, {});
  if (node.look !== "handDrawn") {
    options.roughness = 0;
    options.fillStyle = "solid";
  }
  let totalShapeBBoxHeight = 0;
  if (rows.length > 0) {
    totalShapeBBoxHeight = rows.reduce((sum, row) => sum + (row?.rowHeight ?? 0), 0);
  }
  const w = Math.max(shapeBBox.width + PADDING * 2, node?.width || 0, maxWidth);
  const h = Math.max((totalShapeBBoxHeight ?? 0) + nameBBox.height, node?.height || 0);
  const x = -w / 2;
  const y = -h / 2;
  shapeSvg.selectAll("g:not(:first-child)").each((_, i, nodes) => {
    const text2 = select(nodes[i]);
    const transform = text2.attr("transform");
    let translateX = 0;
    let translateY = 0;
    if (transform) {
      const regex = RegExp(/translate\(([^,]+),([^)]+)\)/);
      const translate = regex.exec(transform);
      if (translate) {
        translateX = parseFloat(translate[1]);
        translateY = parseFloat(translate[2]);
        if (text2.attr("class").includes("attribute-name")) {
          translateX += maxTypeWidth;
        } else if (text2.attr("class").includes("attribute-keys")) {
          translateX += maxTypeWidth + maxNameWidth;
        } else if (text2.attr("class").includes("attribute-comment")) {
          translateX += maxTypeWidth + maxNameWidth + maxKeysWidth;
        }
      }
    }
    text2.attr(
      "transform",
      `translate(${x + PADDING / 2 + translateX}, ${translateY + y + nameBBox.height + TEXT_PADDING / 2})`
    );
  });
  shapeSvg.select(".name").attr("transform", "translate(" + -nameBBox.width / 2 + ", " + (y + TEXT_PADDING / 2) + ")");
  const roughRect = rc.rectangle(x, y, w, h, options);
  const rect2 = shapeSvg.insert(() => roughRect, ":first-child").attr("style", cssStyles.join(""));
  const { themeVariables } = getConfig();
  const { rowEven, rowOdd, nodeBorder } = themeVariables;
  yOffsets.push(0);
  for (const [i, row] of rows.entries()) {
    const contentRowIndex = i + 1;
    const isEven = contentRowIndex % 2 === 0 && row.yOffset !== 0;
    const roughRect2 = rc.rectangle(x, nameBBox.height + y + row?.yOffset, w, row?.rowHeight, {
      ...options,
      fill: isEven ? rowEven : rowOdd,
      stroke: nodeBorder
    });
    shapeSvg.insert(() => roughRect2, "g.label").attr("style", cssStyles.join("")).attr("class", `row-rect-${isEven ? "even" : "odd"}`);
  }
  let roughLine = rc.line(x, nameBBox.height + y, w + x, nameBBox.height + y, options);
  shapeSvg.insert(() => roughLine).attr("class", "divider");
  roughLine = rc.line(maxTypeWidth + x, nameBBox.height + y, maxTypeWidth + x, h + y, options);
  shapeSvg.insert(() => roughLine).attr("class", "divider");
  if (keysPresent) {
    roughLine = rc.line(
      maxTypeWidth + maxNameWidth + x,
      nameBBox.height + y,
      maxTypeWidth + maxNameWidth + x,
      h + y,
      options
    );
    shapeSvg.insert(() => roughLine).attr("class", "divider");
  }
  if (commentPresent) {
    roughLine = rc.line(
      maxTypeWidth + maxNameWidth + maxKeysWidth + x,
      nameBBox.height + y,
      maxTypeWidth + maxNameWidth + maxKeysWidth + x,
      h + y,
      options
    );
    shapeSvg.insert(() => roughLine).attr("class", "divider");
  }
  for (const yOffset2 of yOffsets) {
    roughLine = rc.line(
      x,
      nameBBox.height + y + yOffset2,
      w + x,
      nameBBox.height + y + yOffset2,
      options
    );
    shapeSvg.insert(() => roughLine).attr("class", "divider");
  }
  updateNodeBounds(node, rect2);
  if (nodeStyles && node.look !== "handDrawn") {
    const allStyle = nodeStyles.split(";");
    const strokeStyles = allStyle?.filter((e) => {
      return e.includes("stroke");
    })?.map((s) => `${s}`).join("; ");
    shapeSvg.selectAll("path").attr("style", strokeStyles ?? "");
    shapeSvg.selectAll(".row-rect-even path").attr("style", nodeStyles);
  }
  node.intersect = function(point) {
    return intersect_default.rect(node, point);
  };
  return shapeSvg;
}
__name(erBox, "erBox");
async function addText(shapeSvg, labelText, config, translateX = 0, translateY = 0, classes = [], style = "") {
  const label = shapeSvg.insert("g").attr("class", `label ${classes.join(" ")}`).attr("transform", `translate(${translateX}, ${translateY})`).attr("style", style);
  if (labelText !== parseGenericTypes(labelText)) {
    labelText = parseGenericTypes(labelText);
    labelText = labelText.replaceAll("<", "&lt;").replaceAll(">", "&gt;");
  }
  const text2 = label.node().appendChild(
    await createText(
      label,
      labelText,
      {
        width: calculateTextWidth(labelText, config) + 100,
        style,
        useHtmlLabels: config.htmlLabels
      },
      config
    )
  );
  if (labelText.includes("&lt;") || labelText.includes("&gt;")) {
    let child = text2.children[0];
    child.textContent = child.textContent.replaceAll("&lt;", "<").replaceAll("&gt;", ">");
    while (child.childNodes[0]) {
      child = child.childNodes[0];
      child.textContent = child.textContent.replaceAll("&lt;", "<").replaceAll("&gt;", ">");
    }
  }
  let bbox = text2.getBBox();
  if (evaluate(config.htmlLabels)) {
    const div = text2.children[0];
    div.style.textAlign = "start";
    const dv = select(text2);
    bbox = div.getBoundingClientRect();
    dv.attr("width", bbox.width);
    dv.attr("height", bbox.height);
  }
  return bbox;
}
__name(addText, "addText");
async function textHelper(parent, node, config, useHtmlLabels, GAP = config.class.padding ?? 12) {
  const TEXT_PADDING = !useHtmlLabels ? 3 : 0;
  const shapeSvg = parent.insert("g").attr("class", getNodeClasses(node)).attr("id", node.domId || node.id);
  let annotationGroup = null;
  let labelGroup = null;
  let membersGroup = null;
  let methodsGroup = null;
  let annotationGroupHeight = 0;
  let labelGroupHeight = 0;
  let membersGroupHeight = 0;
  annotationGroup = shapeSvg.insert("g").attr("class", "annotation-group text");
  if (node.annotations.length > 0) {
    const annotation = node.annotations[0];
    await addText2(annotationGroup, { text: `\xAB${annotation}\xBB` }, 0);
    const annotationGroupBBox = annotationGroup.node().getBBox();
    annotationGroupHeight = annotationGroupBBox.height;
  }
  labelGroup = shapeSvg.insert("g").attr("class", "label-group text");
  await addText2(labelGroup, node, 0, ["font-weight: bolder"]);
  const labelGroupBBox = labelGroup.node().getBBox();
  labelGroupHeight = labelGroupBBox.height;
  membersGroup = shapeSvg.insert("g").attr("class", "members-group text");
  let yOffset = 0;
  for (const member of node.members) {
    const height = await addText2(membersGroup, member, yOffset, [member.parseClassifier()]);
    yOffset += height + TEXT_PADDING;
  }
  membersGroupHeight = membersGroup.node().getBBox().height;
  if (membersGroupHeight <= 0) {
    membersGroupHeight = GAP / 2;
  }
  methodsGroup = shapeSvg.insert("g").attr("class", "methods-group text");
  let methodsYOffset = 0;
  for (const method of node.methods) {
    const height = await addText2(methodsGroup, method, methodsYOffset, [method.parseClassifier()]);
    methodsYOffset += height + TEXT_PADDING;
  }
  let bbox = shapeSvg.node().getBBox();
  if (annotationGroup !== null) {
    const annotationGroupBBox = annotationGroup.node().getBBox();
    annotationGroup.attr("transform", `translate(${-annotationGroupBBox.width / 2})`);
  }
  labelGroup.attr("transform", `translate(${-labelGroupBBox.width / 2}, ${annotationGroupHeight})`);
  bbox = shapeSvg.node().getBBox();
  membersGroup.attr(
    "transform",
    `translate(${0}, ${annotationGroupHeight + labelGroupHeight + GAP * 2})`
  );
  bbox = shapeSvg.node().getBBox();
  methodsGroup.attr(
    "transform",
    `translate(${0}, ${annotationGroupHeight + labelGroupHeight + (membersGroupHeight ? membersGroupHeight + GAP * 4 : GAP * 2)})`
  );
  bbox = shapeSvg.node().getBBox();
  return { shapeSvg, bbox };
}
__name(textHelper, "textHelper");
async function addText2(parentGroup, node, yOffset, styles = []) {
  const textEl = parentGroup.insert("g").attr("class", "label").attr("style", styles.join("; "));
  const config = getConfig();
  let useHtmlLabels = "useHtmlLabels" in node ? node.useHtmlLabels : evaluate(config.htmlLabels) ?? true;
  let textContent = "";
  if ("text" in node) {
    textContent = node.text;
  } else {
    textContent = node.label;
  }
  if (!useHtmlLabels && textContent.startsWith("\\")) {
    textContent = textContent.substring(1);
  }
  if (hasKatex(textContent)) {
    useHtmlLabels = true;
  }
  const text2 = await createText(
    textEl,
    sanitizeText3(decodeEntities(textContent)),
    {
      width: calculateTextWidth(textContent, config) + 50,
      // Add room for error when splitting text into multiple lines
      classes: "markdown-node-label",
      useHtmlLabels
    },
    config
  );
  let bbox;
  let numberOfLines = 1;
  if (!useHtmlLabels) {
    if (styles.includes("font-weight: bolder")) {
      select(text2).selectAll("tspan").attr("font-weight", "");
    }
    numberOfLines = text2.children.length;
    const textChild = text2.children[0];
    if (text2.textContent === "" || text2.textContent.includes("&gt")) {
      textChild.textContent = textContent[0] + textContent.substring(1).replaceAll("&gt;", ">").replaceAll("&lt;", "<").trim();
      const preserveSpace = textContent[1] === " ";
      if (preserveSpace) {
        textChild.textContent = textChild.textContent[0] + " " + textChild.textContent.substring(1);
      }
    }
    if (textChild.textContent === "undefined") {
      textChild.textContent = "";
    }
    bbox = text2.getBBox();
  } else {
    const div = text2.children[0];
    const dv = select(text2);
    numberOfLines = div.innerHTML.split("<br>").length;
    if (div.innerHTML.includes("</math>")) {
      numberOfLines += div.innerHTML.split("<mrow>").length - 1;
    }
    const images = div.getElementsByTagName("img");
    if (images) {
      const noImgText = textContent.replace(/<img[^>]*>/g, "").trim() === "";
      await Promise.all(
        [...images].map(
          (img) => new Promise((res) => {
            function setupImage() {
              img.style.display = "flex";
              img.style.flexDirection = "column";
              if (noImgText) {
                const bodyFontSize = config.fontSize?.toString() ?? window.getComputedStyle(document.body).fontSize;
                const enlargingFactor = 5;
                const width = parseInt(bodyFontSize, 10) * enlargingFactor + "px";
                img.style.minWidth = width;
                img.style.maxWidth = width;
              } else {
                img.style.width = "100%";
              }
              res(img);
            }
            __name(setupImage, "setupImage");
            setTimeout(() => {
              if (img.complete) {
                setupImage();
              }
            });
            img.addEventListener("error", setupImage);
            img.addEventListener("load", setupImage);
          })
        )
      );
    }
    bbox = div.getBoundingClientRect();
    dv.attr("width", bbox.width);
    dv.attr("height", bbox.height);
  }
  textEl.attr("transform", "translate(0," + (-bbox.height / (2 * numberOfLines) + yOffset) + ")");
  return bbox.height;
}
__name(addText2, "addText");

// src/rendering-util/rendering-elements/shapes/classBox.ts
async function classBox(parent, node) {
  const config = getConfig2();
  const PADDING = config.class.padding ?? 12;
  const GAP = PADDING;
  const useHtmlLabels = node.useHtmlLabels ?? evaluate(config.htmlLabels) ?? true;
  const classNode = node;
  classNode.annotations = classNode.annotations ?? [];
  classNode.members = classNode.members ?? [];
  classNode.methods = classNode.methods ?? [];
  const { shapeSvg, bbox } = await textHelper(parent, node, config, useHtmlLabels, GAP);
  const { labelStyles, nodeStyles } = styles2String(node);
  node.labelStyle = labelStyles;
  node.cssStyles = classNode.styles || "";
  const styles = classNode.styles?.join(";") || nodeStyles || "";
  if (!node.cssStyles) {
    node.cssStyles = styles.replaceAll("!important", "").split(";");
  }
  const renderExtraBox = classNode.members.length === 0 && classNode.methods.length === 0 && !config.class?.hideEmptyMembersBox;
  const rc = at.svg(shapeSvg);
  const options = userNodeOverrides(node, {});
  if (node.look !== "handDrawn") {
    options.roughness = 0;
    options.fillStyle = "solid";
  }
  const w = bbox.width;
  let h = bbox.height;
  if (classNode.members.length === 0 && classNode.methods.length === 0) {
    h += GAP;
  } else if (classNode.members.length > 0 && classNode.methods.length === 0) {
    h += GAP * 2;
  }
  const x = -w / 2;
  const y = -h / 2;
  const roughRect = rc.rectangle(
    x - PADDING,
    y - PADDING - (renderExtraBox ? PADDING : classNode.members.length === 0 && classNode.methods.length === 0 ? -PADDING / 2 : 0),
    w + 2 * PADDING,
    h + 2 * PADDING + (renderExtraBox ? PADDING * 2 : classNode.members.length === 0 && classNode.methods.length === 0 ? -PADDING : 0),
    options
  );
  const rect2 = shapeSvg.insert(() => roughRect, ":first-child");
  rect2.attr("class", "basic label-container");
  const rectBBox = rect2.node().getBBox();
  shapeSvg.selectAll(".text").each((_, i, nodes) => {
    const text2 = select(nodes[i]);
    const transform = text2.attr("transform");
    let translateY = 0;
    if (transform) {
      const regex = RegExp(/translate\(([^,]+),([^)]+)\)/);
      const translate = regex.exec(transform);
      if (translate) {
        translateY = parseFloat(translate[2]);
      }
    }
    let newTranslateY = translateY + y + PADDING - (renderExtraBox ? PADDING : classNode.members.length === 0 && classNode.methods.length === 0 ? -PADDING / 2 : 0);
    if (!useHtmlLabels) {
      newTranslateY -= 4;
    }
    let newTranslateX = x;
    if (text2.attr("class").includes("label-group") || text2.attr("class").includes("annotation-group")) {
      newTranslateX = -text2.node()?.getBBox().width / 2 || 0;
      shapeSvg.selectAll("text").each(function(_2, i2, nodes2) {
        if (window.getComputedStyle(nodes2[i2]).textAnchor === "middle") {
          newTranslateX = 0;
        }
      });
    }
    text2.attr("transform", `translate(${newTranslateX}, ${newTranslateY})`);
  });
  const annotationGroupHeight = shapeSvg.select(".annotation-group").node().getBBox().height - (renderExtraBox ? PADDING / 2 : 0) || 0;
  const labelGroupHeight = shapeSvg.select(".label-group").node().getBBox().height - (renderExtraBox ? PADDING / 2 : 0) || 0;
  const membersGroupHeight = shapeSvg.select(".members-group").node().getBBox().height - (renderExtraBox ? PADDING / 2 : 0) || 0;
  if (classNode.members.length > 0 || classNode.methods.length > 0 || renderExtraBox) {
    const roughLine = rc.line(
      rectBBox.x,
      annotationGroupHeight + labelGroupHeight + y + PADDING,
      rectBBox.x + rectBBox.width,
      annotationGroupHeight + labelGroupHeight + y + PADDING,
      options
    );
    const line = shapeSvg.insert(() => roughLine);
    line.attr("class", "divider").attr("style", styles);
  }
  if (renderExtraBox || classNode.members.length > 0 || classNode.methods.length > 0) {
    const roughLine = rc.line(
      rectBBox.x,
      annotationGroupHeight + labelGroupHeight + membersGroupHeight + y + GAP * 2 + PADDING,
      rectBBox.x + rectBBox.width,
      annotationGroupHeight + labelGroupHeight + membersGroupHeight + y + PADDING + GAP * 2,
      options
    );
    const line = shapeSvg.insert(() => roughLine);
    line.attr("class", "divider").attr("style", styles);
  }
  if (classNode.look !== "handDrawn") {
    shapeSvg.selectAll("path").attr("style", styles);
  }
  rect2.select(":nth-child(2)").attr("style", styles);
  shapeSvg.selectAll(".divider").select("path").attr("style", styles);
  if (node.labelStyle) {
    shapeSvg.selectAll("span").attr("style", node.labelStyle);
  } else {
    shapeSvg.selectAll("span").attr("style", styles);
  }
  if (!useHtmlLabels) {
    const colorRegex = RegExp(/color\s*:\s*([^;]*)/);
    const match = colorRegex.exec(styles);
    if (match) {
      const colorStyle = match[0].replace("color", "fill");
      shapeSvg.selectAll("tspan").attr("style", colorStyle);
    } else if (labelStyles) {
      const match2 = colorRegex.exec(labelStyles);
      if (match2) {
        const colorStyle = match2[0].replace("color", "fill");
        shapeSvg.selectAll("tspan").attr("style", colorStyle);
      }
    }
  }
  updateNodeBounds(node, rect2);
  node.intersect = function(point) {
    return intersect_default.rect(node, point);
  };
  return shapeSvg;
}
__name(classBox, "classBox");
async function requirementBox(parent, node) {
  const { labelStyles, nodeStyles } = styles2String(node);
  node.labelStyle = labelStyles;
  const requirementNode = node;
  const elementNode = node;
  const padding = 20;
  const gap = 20;
  const isRequirementNode = "verifyMethod" in node;
  const classes = getNodeClasses(node);
  const shapeSvg = parent.insert("g").attr("class", classes).attr("id", node.domId ?? node.id);
  let typeHeight;
  if (isRequirementNode) {
    typeHeight = await addText3(
      shapeSvg,
      `&lt;&lt;${requirementNode.type}&gt;&gt;`,
      0,
      node.labelStyle
    );
  } else {
    typeHeight = await addText3(shapeSvg, "&lt;&lt;Element&gt;&gt;", 0, node.labelStyle);
  }
  let accumulativeHeight = typeHeight;
  const nameHeight = await addText3(
    shapeSvg,
    requirementNode.name,
    accumulativeHeight,
    node.labelStyle + "; font-weight: bold;"
  );
  accumulativeHeight += nameHeight + gap;
  if (isRequirementNode) {
    const idHeight = await addText3(
      shapeSvg,
      `${requirementNode.requirementId ? `ID: ${requirementNode.requirementId}` : ""}`,
      accumulativeHeight,
      node.labelStyle
    );
    accumulativeHeight += idHeight;
    const textHeight = await addText3(
      shapeSvg,
      `${requirementNode.text ? `Text: ${requirementNode.text}` : ""}`,
      accumulativeHeight,
      node.labelStyle
    );
    accumulativeHeight += textHeight;
    const riskHeight = await addText3(
      shapeSvg,
      `${requirementNode.risk ? `Risk: ${requirementNode.risk}` : ""}`,
      accumulativeHeight,
      node.labelStyle
    );
    accumulativeHeight += riskHeight;
    await addText3(
      shapeSvg,
      `${requirementNode.verifyMethod ? `Verification: ${requirementNode.verifyMethod}` : ""}`,
      accumulativeHeight,
      node.labelStyle
    );
  } else {
    const typeHeight2 = await addText3(
      shapeSvg,
      `${elementNode.type ? `Type: ${elementNode.type}` : ""}`,
      accumulativeHeight,
      node.labelStyle
    );
    accumulativeHeight += typeHeight2;
    await addText3(
      shapeSvg,
      `${elementNode.docRef ? `Doc Ref: ${elementNode.docRef}` : ""}`,
      accumulativeHeight,
      node.labelStyle
    );
  }
  const totalWidth = (shapeSvg.node()?.getBBox().width ?? 200) + padding;
  const totalHeight = (shapeSvg.node()?.getBBox().height ?? 200) + padding;
  const x = -totalWidth / 2;
  const y = -totalHeight / 2;
  const rc = at.svg(shapeSvg);
  const options = userNodeOverrides(node, {});
  if (node.look !== "handDrawn") {
    options.roughness = 0;
    options.fillStyle = "solid";
  }
  const roughRect = rc.rectangle(x, y, totalWidth, totalHeight, options);
  const rect2 = shapeSvg.insert(() => roughRect, ":first-child");
  rect2.attr("class", "basic label-container").attr("style", nodeStyles);
  shapeSvg.selectAll(".label").each((_, i, nodes) => {
    const text2 = select(nodes[i]);
    const transform = text2.attr("transform");
    let translateX = 0;
    let translateY = 0;
    if (transform) {
      const regex = RegExp(/translate\(([^,]+),([^)]+)\)/);
      const translate = regex.exec(transform);
      if (translate) {
        translateX = parseFloat(translate[1]);
        translateY = parseFloat(translate[2]);
      }
    }
    const newTranslateY = translateY - totalHeight / 2;
    let newTranslateX = x + padding / 2;
    if (i === 0 || i === 1) {
      newTranslateX = translateX;
    }
    text2.attr("transform", `translate(${newTranslateX}, ${newTranslateY + padding})`);
  });
  if (accumulativeHeight > typeHeight + nameHeight + gap) {
    const roughLine = rc.line(
      x,
      y + typeHeight + nameHeight + gap,
      x + totalWidth,
      y + typeHeight + nameHeight + gap,
      options
    );
    const dividerLine = shapeSvg.insert(() => roughLine);
    dividerLine.attr("style", nodeStyles);
  }
  updateNodeBounds(node, rect2);
  node.intersect = function(point) {
    return intersect_default.rect(node, point);
  };
  return shapeSvg;
}
__name(requirementBox, "requirementBox");
async function addText3(parentGroup, inputText, yOffset, style = "") {
  if (inputText === "") {
    return 0;
  }
  const textEl = parentGroup.insert("g").attr("class", "label").attr("style", style);
  const config = getConfig2();
  const useHtmlLabels = config.htmlLabels ?? true;
  const text2 = await createText(
    textEl,
    sanitizeText3(decodeEntities(inputText)),
    {
      width: calculateTextWidth(inputText, config) + 50,
      // Add room for error when splitting text into multiple lines
      classes: "markdown-node-label",
      useHtmlLabels,
      style
    },
    config
  );
  let bbox;
  if (!useHtmlLabels) {
    const textChild = text2.children[0];
    for (const child of textChild.children) {
      child.textContent = child.textContent.replaceAll("&gt;", ">").replaceAll("&lt;", "<");
      if (style) {
        child.setAttribute("style", style);
      }
    }
    bbox = text2.getBBox();
    bbox.height += 6;
  } else {
    const div = text2.children[0];
    const dv = select(text2);
    bbox = div.getBoundingClientRect();
    dv.attr("width", bbox.width);
    dv.attr("height", bbox.height);
  }
  textEl.attr("transform", `translate(${-bbox.width / 2},${-bbox.height / 2 + yOffset})`);
  return bbox.height;
}
__name(addText3, "addText");
var colorFromPriority = /* @__PURE__ */ __name((priority) => {
  switch (priority) {
    case "Very High":
      return "red";
    case "High":
      return "orange";
    case "Medium":
      return null;
    // no stroke
    case "Low":
      return "blue";
    case "Very Low":
      return "lightblue";
  }
}, "colorFromPriority");
async function kanbanItem(parent, kanbanNode, { config }) {
  const { labelStyles, nodeStyles } = styles2String(kanbanNode);
  kanbanNode.labelStyle = labelStyles || "";
  const labelPaddingX = 10;
  const orgWidth = kanbanNode.width;
  kanbanNode.width = (kanbanNode.width ?? 200) - 10;
  const {
    shapeSvg,
    bbox,
    label: labelElTitle
  } = await labelHelper(parent, kanbanNode, getNodeClasses(kanbanNode));
  const padding = kanbanNode.padding || 10;
  let ticketUrl = "";
  let link;
  if ("ticket" in kanbanNode && kanbanNode.ticket && config?.kanban?.ticketBaseUrl) {
    ticketUrl = config?.kanban?.ticketBaseUrl.replace("#TICKET#", kanbanNode.ticket);
    link = shapeSvg.insert("svg:a", ":first-child").attr("class", "kanban-ticket-link").attr("xlink:href", ticketUrl).attr("target", "_blank");
  }
  const options = {
    useHtmlLabels: kanbanNode.useHtmlLabels,
    labelStyle: kanbanNode.labelStyle || "",
    width: kanbanNode.width,
    img: kanbanNode.img,
    padding: kanbanNode.padding || 8,
    centerLabel: false
  };
  let labelEl, bbox2;
  if (link) {
    ({ label: labelEl, bbox: bbox2 } = await insertLabel(
      link,
      "ticket" in kanbanNode && kanbanNode.ticket || "",
      options
    ));
  } else {
    ({ label: labelEl, bbox: bbox2 } = await insertLabel(
      shapeSvg,
      "ticket" in kanbanNode && kanbanNode.ticket || "",
      options
    ));
  }
  const { label: labelElAssigned, bbox: bboxAssigned } = await insertLabel(
    shapeSvg,
    "assigned" in kanbanNode && kanbanNode.assigned || "",
    options
  );
  kanbanNode.width = orgWidth;
  const labelPaddingY = 10;
  const totalWidth = kanbanNode?.width || 0;
  const heightAdj = Math.max(bbox2.height, bboxAssigned.height) / 2;
  const totalHeight = Math.max(bbox.height + labelPaddingY * 2, kanbanNode?.height || 0) + heightAdj;
  const x = -totalWidth / 2;
  const y = -totalHeight / 2;
  labelElTitle.attr(
    "transform",
    "translate(" + (padding - totalWidth / 2) + ", " + (-heightAdj - bbox.height / 2) + ")"
  );
  labelEl.attr(
    "transform",
    "translate(" + (padding - totalWidth / 2) + ", " + (-heightAdj + bbox.height / 2) + ")"
  );
  labelElAssigned.attr(
    "transform",
    "translate(" + (padding + totalWidth / 2 - bboxAssigned.width - 2 * labelPaddingX) + ", " + (-heightAdj + bbox.height / 2) + ")"
  );
  let rect2;
  const { rx, ry } = kanbanNode;
  const { cssStyles } = kanbanNode;
  if (kanbanNode.look === "handDrawn") {
    const rc = at.svg(shapeSvg);
    const options2 = userNodeOverrides(kanbanNode, {});
    const roughNode = rx || ry ? rc.path(createRoundedRectPathD(x, y, totalWidth, totalHeight, rx || 0), options2) : rc.rectangle(x, y, totalWidth, totalHeight, options2);
    rect2 = shapeSvg.insert(() => roughNode, ":first-child");
    rect2.attr("class", "basic label-container").attr("style", cssStyles ? cssStyles : null);
  } else {
    rect2 = shapeSvg.insert("rect", ":first-child");
    rect2.attr("class", "basic label-container __APA__").attr("style", nodeStyles).attr("rx", rx ?? 5).attr("ry", ry ?? 5).attr("x", x).attr("y", y).attr("width", totalWidth).attr("height", totalHeight);
    const priority = "priority" in kanbanNode && kanbanNode.priority;
    if (priority) {
      const line = shapeSvg.append("line");
      const lineX = x + 2;
      const y1 = y + Math.floor((rx ?? 0) / 2);
      const y2 = y + totalHeight - Math.floor((rx ?? 0) / 2);
      line.attr("x1", lineX).attr("y1", y1).attr("x2", lineX).attr("y2", y2).attr("stroke-width", "4").attr("stroke", colorFromPriority(priority));
    }
  }
  updateNodeBounds(kanbanNode, rect2);
  kanbanNode.height = totalHeight;
  kanbanNode.intersect = function(point) {
    return intersect_default.rect(kanbanNode, point);
  };
  return shapeSvg;
}
__name(kanbanItem, "kanbanItem");

// src/rendering-util/rendering-elements/shapes.ts
var shapesDefs = [
  {
    semanticName: "Process",
    name: "Rectangle",
    shortName: "rect",
    description: "Standard process shape",
    aliases: ["proc", "process", "rectangle"],
    internalAliases: ["squareRect"],
    handler: squareRect2
  },
  {
    semanticName: "Event",
    name: "Rounded Rectangle",
    shortName: "rounded",
    description: "Represents an event",
    aliases: ["event"],
    internalAliases: ["roundedRect"],
    handler: roundedRect
  },
  {
    semanticName: "Terminal Point",
    name: "Stadium",
    shortName: "stadium",
    description: "Terminal point",
    aliases: ["terminal", "pill"],
    handler: stadium
  },
  {
    semanticName: "Subprocess",
    name: "Framed Rectangle",
    shortName: "fr-rect",
    description: "Subprocess",
    aliases: ["subprocess", "subproc", "framed-rectangle", "subroutine"],
    handler: subroutine
  },
  {
    semanticName: "Database",
    name: "Cylinder",
    shortName: "cyl",
    description: "Database storage",
    aliases: ["db", "database", "cylinder"],
    handler: cylinder
  },
  {
    semanticName: "Start",
    name: "Circle",
    shortName: "circle",
    description: "Starting point",
    aliases: ["circ"],
    handler: circle$1
  },
  {
    semanticName: "Decision",
    name: "Diamond",
    shortName: "diam",
    description: "Decision-making step",
    aliases: ["decision", "diamond", "question"],
    handler: question
  },
  {
    semanticName: "Prepare Conditional",
    name: "Hexagon",
    shortName: "hex",
    description: "Preparation or condition step",
    aliases: ["hexagon", "prepare"],
    handler: hexagon
  },
  {
    semanticName: "Data Input/Output",
    name: "Lean Right",
    shortName: "lean-r",
    description: "Represents input or output",
    aliases: ["lean-right", "in-out"],
    internalAliases: ["lean_right"],
    handler: lean_right
  },
  {
    semanticName: "Data Input/Output",
    name: "Lean Left",
    shortName: "lean-l",
    description: "Represents output or input",
    aliases: ["lean-left", "out-in"],
    internalAliases: ["lean_left"],
    handler: lean_left
  },
  {
    semanticName: "Priority Action",
    name: "Trapezoid Base Bottom",
    shortName: "trap-b",
    description: "Priority action",
    aliases: ["priority", "trapezoid-bottom", "trapezoid"],
    handler: trapezoid
  },
  {
    semanticName: "Manual Operation",
    name: "Trapezoid Base Top",
    shortName: "trap-t",
    description: "Represents a manual task",
    aliases: ["manual", "trapezoid-top", "inv-trapezoid"],
    internalAliases: ["inv_trapezoid"],
    handler: inv_trapezoid
  },
  {
    semanticName: "Stop",
    name: "Double Circle",
    shortName: "dbl-circ",
    description: "Represents a stop point",
    aliases: ["double-circle"],
    internalAliases: ["doublecircle"],
    handler: doublecircle
  },
  {
    semanticName: "Text Block",
    name: "Text Block",
    shortName: "text",
    description: "Text block",
    handler: text
  },
  {
    semanticName: "Card",
    name: "Notched Rectangle",
    shortName: "notch-rect",
    description: "Represents a card",
    aliases: ["card", "notched-rectangle"],
    handler: card
  },
  {
    semanticName: "Lined/Shaded Process",
    name: "Lined Rectangle",
    shortName: "lin-rect",
    description: "Lined process shape",
    aliases: ["lined-rectangle", "lined-process", "lin-proc", "shaded-process"],
    handler: shadedProcess
  },
  {
    semanticName: "Start",
    name: "Small Circle",
    shortName: "sm-circ",
    description: "Small starting point",
    aliases: ["start", "small-circle"],
    internalAliases: ["stateStart"],
    handler: stateStart
  },
  {
    semanticName: "Stop",
    name: "Framed Circle",
    shortName: "fr-circ",
    description: "Stop point",
    aliases: ["stop", "framed-circle"],
    internalAliases: ["stateEnd"],
    handler: stateEnd
  },
  {
    semanticName: "Fork/Join",
    name: "Filled Rectangle",
    shortName: "fork",
    description: "Fork or join in process flow",
    aliases: ["join"],
    internalAliases: ["forkJoin"],
    handler: forkJoin
  },
  {
    semanticName: "Collate",
    name: "Hourglass",
    shortName: "hourglass",
    description: "Represents a collate operation",
    aliases: ["hourglass", "collate"],
    handler: hourglass
  },
  {
    semanticName: "Comment",
    name: "Curly Brace",
    shortName: "brace",
    description: "Adds a comment",
    aliases: ["comment", "brace-l"],
    handler: curlyBraceLeft
  },
  {
    semanticName: "Comment Right",
    name: "Curly Brace",
    shortName: "brace-r",
    description: "Adds a comment",
    handler: curlyBraceRight
  },
  {
    semanticName: "Comment with braces on both sides",
    name: "Curly Braces",
    shortName: "braces",
    description: "Adds a comment",
    handler: curlyBraces
  },
  {
    semanticName: "Com Link",
    name: "Lightning Bolt",
    shortName: "bolt",
    description: "Communication link",
    aliases: ["com-link", "lightning-bolt"],
    handler: lightningBolt
  },
  {
    semanticName: "Document",
    name: "Document",
    shortName: "doc",
    description: "Represents a document",
    aliases: ["doc", "document"],
    handler: waveEdgedRectangle
  },
  {
    semanticName: "Delay",
    name: "Half-Rounded Rectangle",
    shortName: "delay",
    description: "Represents a delay",
    aliases: ["half-rounded-rectangle"],
    handler: halfRoundedRectangle
  },
  {
    semanticName: "Direct Access Storage",
    name: "Horizontal Cylinder",
    shortName: "h-cyl",
    description: "Direct access storage",
    aliases: ["das", "horizontal-cylinder"],
    handler: tiltedCylinder
  },
  {
    semanticName: "Disk Storage",
    name: "Lined Cylinder",
    shortName: "lin-cyl",
    description: "Disk storage",
    aliases: ["disk", "lined-cylinder"],
    handler: linedCylinder
  },
  {
    semanticName: "Display",
    name: "Curved Trapezoid",
    shortName: "curv-trap",
    description: "Represents a display",
    aliases: ["curved-trapezoid", "display"],
    handler: curvedTrapezoid
  },
  {
    semanticName: "Divided Process",
    name: "Divided Rectangle",
    shortName: "div-rect",
    description: "Divided process shape",
    aliases: ["div-proc", "divided-rectangle", "divided-process"],
    handler: dividedRectangle
  },
  {
    semanticName: "Extract",
    name: "Triangle",
    shortName: "tri",
    description: "Extraction process",
    aliases: ["extract", "triangle"],
    handler: triangle
  },
  {
    semanticName: "Internal Storage",
    name: "Window Pane",
    shortName: "win-pane",
    description: "Internal storage",
    aliases: ["internal-storage", "window-pane"],
    handler: windowPane
  },
  {
    semanticName: "Junction",
    name: "Filled Circle",
    shortName: "f-circ",
    description: "Junction point",
    aliases: ["junction", "filled-circle"],
    handler: filledCircle
  },
  {
    semanticName: "Loop Limit",
    name: "Trapezoidal Pentagon",
    shortName: "notch-pent",
    description: "Loop limit step",
    aliases: ["loop-limit", "notched-pentagon"],
    handler: trapezoidalPentagon
  },
  {
    semanticName: "Manual File",
    name: "Flipped Triangle",
    shortName: "flip-tri",
    description: "Manual file operation",
    aliases: ["manual-file", "flipped-triangle"],
    handler: flippedTriangle
  },
  {
    semanticName: "Manual Input",
    name: "Sloped Rectangle",
    shortName: "sl-rect",
    description: "Manual input step",
    aliases: ["manual-input", "sloped-rectangle"],
    handler: slopedRect
  },
  {
    semanticName: "Multi-Document",
    name: "Stacked Document",
    shortName: "docs",
    description: "Multiple documents",
    aliases: ["documents", "st-doc", "stacked-document"],
    handler: multiWaveEdgedRectangle
  },
  {
    semanticName: "Multi-Process",
    name: "Stacked Rectangle",
    shortName: "st-rect",
    description: "Multiple processes",
    aliases: ["procs", "processes", "stacked-rectangle"],
    handler: multiRect
  },
  {
    semanticName: "Stored Data",
    name: "Bow Tie Rectangle",
    shortName: "bow-rect",
    description: "Stored data",
    aliases: ["stored-data", "bow-tie-rectangle"],
    handler: bowTieRect
  },
  {
    semanticName: "Summary",
    name: "Crossed Circle",
    shortName: "cross-circ",
    description: "Summary",
    aliases: ["summary", "crossed-circle"],
    handler: crossedCircle
  },
  {
    semanticName: "Tagged Document",
    name: "Tagged Document",
    shortName: "tag-doc",
    description: "Tagged document",
    aliases: ["tag-doc", "tagged-document"],
    handler: taggedWaveEdgedRectangle
  },
  {
    semanticName: "Tagged Process",
    name: "Tagged Rectangle",
    shortName: "tag-rect",
    description: "Tagged process",
    aliases: ["tagged-rectangle", "tag-proc", "tagged-process"],
    handler: taggedRect
  },
  {
    semanticName: "Paper Tape",
    name: "Flag",
    shortName: "flag",
    description: "Paper tape",
    aliases: ["paper-tape"],
    handler: waveRectangle
  },
  {
    semanticName: "Odd",
    name: "Odd",
    shortName: "odd",
    description: "Odd shape",
    internalAliases: ["rect_left_inv_arrow"],
    handler: rect_left_inv_arrow
  },
  {
    semanticName: "Lined Document",
    name: "Lined Document",
    shortName: "lin-doc",
    description: "Lined document",
    aliases: ["lined-document"],
    handler: linedWaveEdgedRect
  }
];
var generateShapeMap = /* @__PURE__ */ __name(() => {
  const undocumentedShapes = {
    // States
    state,
    choice,
    note,
    // Rectangles
    rectWithTitle,
    labelRect,
    // Icons
    iconSquare,
    iconCircle,
    icon,
    iconRounded,
    imageSquare,
    anchor,
    // Kanban diagram
    kanbanItem,
    // class diagram
    classBox,
    // er diagram
    erBox,
    // Requirement diagram
    requirementBox
  };
  const entries = [
    ...Object.entries(undocumentedShapes),
    ...shapesDefs.flatMap((shape) => {
      const aliases = [
        shape.shortName,
        ..."aliases" in shape ? shape.aliases : [],
        ..."internalAliases" in shape ? shape.internalAliases : []
      ];
      return aliases.map((alias) => [alias, shape.handler]);
    })
  ];
  return Object.fromEntries(entries);
}, "generateShapeMap");
var shapes2 = generateShapeMap();
function isValidShape(shape) {
  return shape in shapes2;
}
__name(isValidShape, "isValidShape");

// src/rendering-util/rendering-elements/nodes.ts
var nodeElems = /* @__PURE__ */ new Map();
async function insertNode(elem, node, renderOptions) {
  let newEl;
  let el;
  if (node.shape === "rect") {
    if (node.rx && node.ry) {
      node.shape = "roundedRect";
    } else {
      node.shape = "squareRect";
    }
  }
  const shapeHandler = node.shape ? shapes2[node.shape] : void 0;
  if (!shapeHandler) {
    throw new Error(`No such shape: ${node.shape}. Please check your syntax.`);
  }
  if (node.link) {
    let target;
    if (renderOptions.config.securityLevel === "sandbox") {
      target = "_top";
    } else if (node.linkTarget) {
      target = node.linkTarget || "_blank";
    }
    newEl = elem.insert("svg:a").attr("xlink:href", node.link).attr("target", target ?? null);
    el = await shapeHandler(newEl, node, renderOptions);
  } else {
    el = await shapeHandler(elem, node, renderOptions);
    newEl = el;
  }
  if (node.tooltip) {
    el.attr("title", node.tooltip);
  }
  nodeElems.set(node.id, newEl);
  if (node.haveCallback) {
    newEl.attr("class", newEl.attr("class") + " clickable");
  }
  return newEl;
}
__name(insertNode, "insertNode");
var setNodeElem = /* @__PURE__ */ __name((elem, node) => {
  nodeElems.set(node.id, elem);
}, "setNodeElem");
var clear2 = /* @__PURE__ */ __name(() => {
  nodeElems.clear();
}, "clear");
var positionNode = /* @__PURE__ */ __name((node) => {
  const el = nodeElems.get(node.id);
  log.trace(
    "Transforming node",
    node.diff,
    node,
    "translate(" + (node.x - node.width / 2 - 5) + ", " + node.width / 2 + ")"
  );
  const padding = 8;
  const diff = node.diff || 0;
  if (node.clusterNode) {
    el.attr(
      "transform",
      "translate(" + (node.x + diff - node.width / 2) + ", " + (node.y - node.height / 2 - padding) + ")"
    );
  } else {
    el.attr("transform", "translate(" + node.x + ", " + node.y + ")");
  }
  return diff;
}, "positionNode");

// src/rendering-util/rendering-elements/edgeMarker.ts
var addEdgeMarkers = /* @__PURE__ */ __name((svgPath, edge, url, id, diagramType, strokeColor) => {
  if (edge.arrowTypeStart) {
    addEdgeMarker(svgPath, "start", edge.arrowTypeStart, url, id, diagramType, strokeColor);
  }
  if (edge.arrowTypeEnd) {
    addEdgeMarker(svgPath, "end", edge.arrowTypeEnd, url, id, diagramType, strokeColor);
  }
}, "addEdgeMarkers");
var arrowTypesMap = {
  arrow_cross: { type: "cross", fill: false },
  arrow_point: { type: "point", fill: true },
  arrow_barb: { type: "barb", fill: true },
  arrow_circle: { type: "circle", fill: false },
  aggregation: { type: "aggregation", fill: false },
  extension: { type: "extension", fill: false },
  composition: { type: "composition", fill: true },
  dependency: { type: "dependency", fill: true },
  lollipop: { type: "lollipop", fill: false },
  only_one: { type: "onlyOne", fill: false },
  zero_or_one: { type: "zeroOrOne", fill: false },
  one_or_more: { type: "oneOrMore", fill: false },
  zero_or_more: { type: "zeroOrMore", fill: false },
  requirement_arrow: { type: "requirement_arrow", fill: false },
  requirement_contains: { type: "requirement_contains", fill: false }
};
var addEdgeMarker = /* @__PURE__ */ __name((svgPath, position, arrowType, url, id, diagramType, strokeColor) => {
  const arrowTypeInfo = arrowTypesMap[arrowType];
  if (!arrowTypeInfo) {
    log.warn(`Unknown arrow type: ${arrowType}`);
    return;
  }
  const endMarkerType = arrowTypeInfo.type;
  const suffix = position === "start" ? "Start" : "End";
  const originalMarkerId = `${id}_${diagramType}-${endMarkerType}${suffix}`;
  if (strokeColor && strokeColor.trim() !== "") {
    const colorId = strokeColor.replace(/[^\dA-Za-z]/g, "_");
    const coloredMarkerId = `${originalMarkerId}_${colorId}`;
    if (!document.getElementById(coloredMarkerId)) {
      const originalMarker = document.getElementById(originalMarkerId);
      if (originalMarker) {
        const coloredMarker = originalMarker.cloneNode(true);
        coloredMarker.id = coloredMarkerId;
        const paths = coloredMarker.querySelectorAll("path, circle, line");
        paths.forEach((path) => {
          path.setAttribute("stroke", strokeColor);
          if (arrowTypeInfo.fill) {
            path.setAttribute("fill", strokeColor);
          }
        });
        originalMarker.parentNode?.appendChild(coloredMarker);
      }
    }
    svgPath.attr(`marker-${position}`, `url(${url}#${coloredMarkerId})`);
  } else {
    svgPath.attr(`marker-${position}`, `url(${url}#${originalMarkerId})`);
  }
}, "addEdgeMarker");

// src/rendering-util/rendering-elements/edges.js
var edgeLabels = /* @__PURE__ */ new Map();
var terminalLabels = /* @__PURE__ */ new Map();
var clear = /* @__PURE__ */ __name(() => {
  edgeLabels.clear();
  terminalLabels.clear();
}, "clear");
var getLabelStyles = /* @__PURE__ */ __name((styleArray) => {
  let styles = styleArray ? styleArray.reduce((acc, style) => acc + ";" + style, "") : "";
  return styles;
}, "getLabelStyles");
var insertEdgeLabel = /* @__PURE__ */ __name(async (elem, edge) => {
  let useHtmlLabels = evaluate(getConfig2().flowchart.htmlLabels);
  const labelElement = await createText(elem, edge.label, {
    style: getLabelStyles(edge.labelStyle),
    useHtmlLabels,
    addSvgBackground: true,
    isNode: false
  });
  log.info("abc82", edge, edge.labelType);
  const edgeLabel = elem.insert("g").attr("class", "edgeLabel");
  const label = edgeLabel.insert("g").attr("class", "label");
  label.node().appendChild(labelElement);
  let bbox = labelElement.getBBox();
  if (useHtmlLabels) {
    const div = labelElement.children[0];
    const dv = select(labelElement);
    bbox = div.getBoundingClientRect();
    dv.attr("width", bbox.width);
    dv.attr("height", bbox.height);
  }
  label.attr("transform", "translate(" + -bbox.width / 2 + ", " + -bbox.height / 2 + ")");
  edgeLabels.set(edge.id, edgeLabel);
  edge.width = bbox.width;
  edge.height = bbox.height;
  let fo;
  if (edge.startLabelLeft) {
    const startLabelElement = await createLabel_default(
      edge.startLabelLeft,
      getLabelStyles(edge.labelStyle)
    );
    const startEdgeLabelLeft = elem.insert("g").attr("class", "edgeTerminals");
    const inner = startEdgeLabelLeft.insert("g").attr("class", "inner");
    fo = inner.node().appendChild(startLabelElement);
    const slBox = startLabelElement.getBBox();
    inner.attr("transform", "translate(" + -slBox.width / 2 + ", " + -slBox.height / 2 + ")");
    if (!terminalLabels.get(edge.id)) {
      terminalLabels.set(edge.id, {});
    }
    terminalLabels.get(edge.id).startLeft = startEdgeLabelLeft;
    setTerminalWidth(fo, edge.startLabelLeft);
  }
  if (edge.startLabelRight) {
    const startLabelElement = await createLabel_default(
      edge.startLabelRight,
      getLabelStyles(edge.labelStyle)
    );
    const startEdgeLabelRight = elem.insert("g").attr("class", "edgeTerminals");
    const inner = startEdgeLabelRight.insert("g").attr("class", "inner");
    fo = startEdgeLabelRight.node().appendChild(startLabelElement);
    inner.node().appendChild(startLabelElement);
    const slBox = startLabelElement.getBBox();
    inner.attr("transform", "translate(" + -slBox.width / 2 + ", " + -slBox.height / 2 + ")");
    if (!terminalLabels.get(edge.id)) {
      terminalLabels.set(edge.id, {});
    }
    terminalLabels.get(edge.id).startRight = startEdgeLabelRight;
    setTerminalWidth(fo, edge.startLabelRight);
  }
  if (edge.endLabelLeft) {
    const endLabelElement = await createLabel_default(edge.endLabelLeft, getLabelStyles(edge.labelStyle));
    const endEdgeLabelLeft = elem.insert("g").attr("class", "edgeTerminals");
    const inner = endEdgeLabelLeft.insert("g").attr("class", "inner");
    fo = inner.node().appendChild(endLabelElement);
    const slBox = endLabelElement.getBBox();
    inner.attr("transform", "translate(" + -slBox.width / 2 + ", " + -slBox.height / 2 + ")");
    endEdgeLabelLeft.node().appendChild(endLabelElement);
    if (!terminalLabels.get(edge.id)) {
      terminalLabels.set(edge.id, {});
    }
    terminalLabels.get(edge.id).endLeft = endEdgeLabelLeft;
    setTerminalWidth(fo, edge.endLabelLeft);
  }
  if (edge.endLabelRight) {
    const endLabelElement = await createLabel_default(edge.endLabelRight, getLabelStyles(edge.labelStyle));
    const endEdgeLabelRight = elem.insert("g").attr("class", "edgeTerminals");
    const inner = endEdgeLabelRight.insert("g").attr("class", "inner");
    fo = inner.node().appendChild(endLabelElement);
    const slBox = endLabelElement.getBBox();
    inner.attr("transform", "translate(" + -slBox.width / 2 + ", " + -slBox.height / 2 + ")");
    endEdgeLabelRight.node().appendChild(endLabelElement);
    if (!terminalLabels.get(edge.id)) {
      terminalLabels.set(edge.id, {});
    }
    terminalLabels.get(edge.id).endRight = endEdgeLabelRight;
    setTerminalWidth(fo, edge.endLabelRight);
  }
  return labelElement;
}, "insertEdgeLabel");
function setTerminalWidth(fo, value) {
  if (getConfig2().flowchart.htmlLabels && fo) {
    fo.style.width = value.length * 9 + "px";
    fo.style.height = "12px";
  }
}
__name(setTerminalWidth, "setTerminalWidth");
var positionEdgeLabel = /* @__PURE__ */ __name((edge, paths) => {
  log.debug("Moving label abc88 ", edge.id, edge.label, edgeLabels.get(edge.id), paths);
  let path = paths.updatedPath ? paths.updatedPath : paths.originalPath;
  const siteConfig = getConfig2();
  const { subGraphTitleTotalMargin } = getSubGraphTitleMargins(siteConfig);
  if (edge.label) {
    const el = edgeLabels.get(edge.id);
    let x = edge.x;
    let y = edge.y;
    if (path) {
      const pos = utils_default.calcLabelPosition(path);
      log.debug(
        "Moving label " + edge.label + " from (",
        x,
        ",",
        y,
        ") to (",
        pos.x,
        ",",
        pos.y,
        ") abc88"
      );
      if (paths.updatedPath) {
        x = pos.x;
        y = pos.y;
      }
    }
    el.attr("transform", `translate(${x}, ${y + subGraphTitleTotalMargin / 2})`);
  }
  if (edge.startLabelLeft) {
    const el = terminalLabels.get(edge.id).startLeft;
    let x = edge.x;
    let y = edge.y;
    if (path) {
      const pos = utils_default.calcTerminalLabelPosition(edge.arrowTypeStart ? 10 : 0, "start_left", path);
      x = pos.x;
      y = pos.y;
    }
    el.attr("transform", `translate(${x}, ${y})`);
  }
  if (edge.startLabelRight) {
    const el = terminalLabels.get(edge.id).startRight;
    let x = edge.x;
    let y = edge.y;
    if (path) {
      const pos = utils_default.calcTerminalLabelPosition(
        edge.arrowTypeStart ? 10 : 0,
        "start_right",
        path
      );
      x = pos.x;
      y = pos.y;
    }
    el.attr("transform", `translate(${x}, ${y})`);
  }
  if (edge.endLabelLeft) {
    const el = terminalLabels.get(edge.id).endLeft;
    let x = edge.x;
    let y = edge.y;
    if (path) {
      const pos = utils_default.calcTerminalLabelPosition(edge.arrowTypeEnd ? 10 : 0, "end_left", path);
      x = pos.x;
      y = pos.y;
    }
    el.attr("transform", `translate(${x}, ${y})`);
  }
  if (edge.endLabelRight) {
    const el = terminalLabels.get(edge.id).endRight;
    let x = edge.x;
    let y = edge.y;
    if (path) {
      const pos = utils_default.calcTerminalLabelPosition(edge.arrowTypeEnd ? 10 : 0, "end_right", path);
      x = pos.x;
      y = pos.y;
    }
    el.attr("transform", `translate(${x}, ${y})`);
  }
}, "positionEdgeLabel");
var outsideNode = /* @__PURE__ */ __name((node, point2) => {
  const x = node.x;
  const y = node.y;
  const dx = Math.abs(point2.x - x);
  const dy = Math.abs(point2.y - y);
  const w = node.width / 2;
  const h = node.height / 2;
  return dx >= w || dy >= h;
}, "outsideNode");
var intersection = /* @__PURE__ */ __name((node, outsidePoint, insidePoint) => {
  log.debug(`intersection calc abc89:
  outsidePoint: ${JSON.stringify(outsidePoint)}
  insidePoint : ${JSON.stringify(insidePoint)}
  node        : x:${node.x} y:${node.y} w:${node.width} h:${node.height}`);
  const x = node.x;
  const y = node.y;
  const dx = Math.abs(x - insidePoint.x);
  const w = node.width / 2;
  let r = insidePoint.x < outsidePoint.x ? w - dx : w + dx;
  const h = node.height / 2;
  const Q = Math.abs(outsidePoint.y - insidePoint.y);
  const R = Math.abs(outsidePoint.x - insidePoint.x);
  if (Math.abs(y - outsidePoint.y) * w > Math.abs(x - outsidePoint.x) * h) {
    let q = insidePoint.y < outsidePoint.y ? outsidePoint.y - h - y : y - h - outsidePoint.y;
    r = R * q / Q;
    const res = {
      x: insidePoint.x < outsidePoint.x ? insidePoint.x + r : insidePoint.x - R + r,
      y: insidePoint.y < outsidePoint.y ? insidePoint.y + Q - q : insidePoint.y - Q + q
    };
    if (r === 0) {
      res.x = outsidePoint.x;
      res.y = outsidePoint.y;
    }
    if (R === 0) {
      res.x = outsidePoint.x;
    }
    if (Q === 0) {
      res.y = outsidePoint.y;
    }
    log.debug(`abc89 top/bottom calc, Q ${Q}, q ${q}, R ${R}, r ${r}`, res);
    return res;
  } else {
    if (insidePoint.x < outsidePoint.x) {
      r = outsidePoint.x - w - x;
    } else {
      r = x - w - outsidePoint.x;
    }
    let q = Q * r / R;
    let _x = insidePoint.x < outsidePoint.x ? insidePoint.x + R - r : insidePoint.x - R + r;
    let _y = insidePoint.y < outsidePoint.y ? insidePoint.y + q : insidePoint.y - q;
    log.debug(`sides calc abc89, Q ${Q}, q ${q}, R ${R}, r ${r}`, { _x, _y });
    if (r === 0) {
      _x = outsidePoint.x;
      _y = outsidePoint.y;
    }
    if (R === 0) {
      _x = outsidePoint.x;
    }
    if (Q === 0) {
      _y = outsidePoint.y;
    }
    return { x: _x, y: _y };
  }
}, "intersection");
var cutPathAtIntersect = /* @__PURE__ */ __name((_points, boundaryNode) => {
  log.warn("abc88 cutPathAtIntersect", _points, boundaryNode);
  let points = [];
  let lastPointOutside = _points[0];
  let isInside = false;
  _points.forEach((point2) => {
    log.info("abc88 checking point", point2, boundaryNode);
    if (!outsideNode(boundaryNode, point2) && !isInside) {
      const inter = intersection(boundaryNode, lastPointOutside, point2);
      log.debug("abc88 inside", point2, lastPointOutside, inter);
      log.debug("abc88 intersection", inter, boundaryNode);
      let pointPresent = false;
      points.forEach((p) => {
        pointPresent = pointPresent || p.x === inter.x && p.y === inter.y;
      });
      if (!points.some((e) => e.x === inter.x && e.y === inter.y)) {
        points.push(inter);
      } else {
        log.warn("abc88 no intersect", inter, points);
      }
      isInside = true;
    } else {
      log.warn("abc88 outside", point2, lastPointOutside);
      lastPointOutside = point2;
      if (!isInside) {
        points.push(point2);
      }
    }
  });
  log.debug("returning points", points);
  return points;
}, "cutPathAtIntersect");
function extractCornerPoints(points) {
  const cornerPoints = [];
  const cornerPointPositions = [];
  for (let i = 1; i < points.length - 1; i++) {
    const prev = points[i - 1];
    const curr = points[i];
    const next = points[i + 1];
    if (prev.x === curr.x && curr.y === next.y && Math.abs(curr.x - next.x) > 5 && Math.abs(curr.y - prev.y) > 5) {
      cornerPoints.push(curr);
      cornerPointPositions.push(i);
    } else if (prev.y === curr.y && curr.x === next.x && Math.abs(curr.x - prev.x) > 5 && Math.abs(curr.y - next.y) > 5) {
      cornerPoints.push(curr);
      cornerPointPositions.push(i);
    }
  }
  return { cornerPoints, cornerPointPositions };
}
__name(extractCornerPoints, "extractCornerPoints");
var findAdjacentPoint = /* @__PURE__ */ __name(function(pointA, pointB, distance) {
  const xDiff = pointB.x - pointA.x;
  const yDiff = pointB.y - pointA.y;
  const length = Math.sqrt(xDiff * xDiff + yDiff * yDiff);
  const ratio = distance / length;
  return { x: pointB.x - ratio * xDiff, y: pointB.y - ratio * yDiff };
}, "findAdjacentPoint");
var fixCorners = /* @__PURE__ */ __name(function(lineData) {
  const { cornerPointPositions } = extractCornerPoints(lineData);
  const newLineData = [];
  for (let i = 0; i < lineData.length; i++) {
    if (cornerPointPositions.includes(i)) {
      const prevPoint = lineData[i - 1];
      const nextPoint = lineData[i + 1];
      const cornerPoint = lineData[i];
      const newPrevPoint = findAdjacentPoint(prevPoint, cornerPoint, 5);
      const newNextPoint = findAdjacentPoint(nextPoint, cornerPoint, 5);
      const xDiff = newNextPoint.x - newPrevPoint.x;
      const yDiff = newNextPoint.y - newPrevPoint.y;
      newLineData.push(newPrevPoint);
      const a = Math.sqrt(2) * 2;
      let newCornerPoint = { x: cornerPoint.x, y: cornerPoint.y };
      if (Math.abs(nextPoint.x - prevPoint.x) > 10 && Math.abs(nextPoint.y - prevPoint.y) >= 10) {
        log.debug(
          "Corner point fixing",
          Math.abs(nextPoint.x - prevPoint.x),
          Math.abs(nextPoint.y - prevPoint.y)
        );
        const r = 5;
        if (cornerPoint.x === newPrevPoint.x) {
          newCornerPoint = {
            x: xDiff < 0 ? newPrevPoint.x - r + a : newPrevPoint.x + r - a,
            y: yDiff < 0 ? newPrevPoint.y - a : newPrevPoint.y + a
          };
        } else {
          newCornerPoint = {
            x: xDiff < 0 ? newPrevPoint.x - a : newPrevPoint.x + a,
            y: yDiff < 0 ? newPrevPoint.y - r + a : newPrevPoint.y + r - a
          };
        }
      } else {
        log.debug(
          "Corner point skipping fixing",
          Math.abs(nextPoint.x - prevPoint.x),
          Math.abs(nextPoint.y - prevPoint.y)
        );
      }
      newLineData.push(newCornerPoint, newNextPoint);
    } else {
      newLineData.push(lineData[i]);
    }
  }
  return newLineData;
}, "fixCorners");
var insertEdge = /* @__PURE__ */ __name(function(elem, edge, clusterDb, diagramType, startNode, endNode, id) {
  const { handDrawnSeed } = getConfig2();
  let points = edge.points;
  let pointsHasChanged = false;
  const tail = startNode;
  var head = endNode;
  const edgeClassStyles = [];
  for (const key in edge.cssCompiledStyles) {
    if (isLabelStyle(key)) {
      continue;
    }
    edgeClassStyles.push(edge.cssCompiledStyles[key]);
  }
  if (head.intersect && tail.intersect) {
    points = points.slice(1, edge.points.length - 1);
    points.unshift(tail.intersect(points[0]));
    log.debug(
      "Last point APA12",
      edge.start,
      "-->",
      edge.end,
      points[points.length - 1],
      head,
      head.intersect(points[points.length - 1])
    );
    points.push(head.intersect(points[points.length - 1]));
  }
  if (edge.toCluster) {
    log.info("to cluster abc88", clusterDb.get(edge.toCluster));
    points = cutPathAtIntersect(edge.points, clusterDb.get(edge.toCluster).node);
    pointsHasChanged = true;
  }
  if (edge.fromCluster) {
    log.debug(
      "from cluster abc88",
      clusterDb.get(edge.fromCluster),
      JSON.stringify(points, null, 2)
    );
    points = cutPathAtIntersect(points.reverse(), clusterDb.get(edge.fromCluster).node).reverse();
    pointsHasChanged = true;
  }
  let lineData = points.filter((p) => !Number.isNaN(p.y));
  lineData = fixCorners(lineData);
  let curve = curveBasis;
  curve = curveLinear;
  switch (edge.curve) {
    case "linear":
      curve = curveLinear;
      break;
    case "basis":
      curve = curveBasis;
      break;
    case "cardinal":
      curve = curveCardinal;
      break;
    case "bumpX":
      curve = bumpX;
      break;
    case "bumpY":
      curve = bumpY;
      break;
    case "catmullRom":
      curve = curveCatmullRom;
      break;
    case "monotoneX":
      curve = monotoneX;
      break;
    case "monotoneY":
      curve = monotoneY;
      break;
    case "natural":
      curve = curveNatural;
      break;
    case "step":
      curve = curveStep;
      break;
    case "stepAfter":
      curve = stepAfter;
      break;
    case "stepBefore":
      curve = stepBefore;
      break;
    default:
      curve = curveBasis;
  }
  const { x, y } = getLineFunctionsWithOffset(edge);
  const lineFunction = line$1().x(x).y(y).curve(curve);
  let strokeClasses;
  switch (edge.thickness) {
    case "normal":
      strokeClasses = "edge-thickness-normal";
      break;
    case "thick":
      strokeClasses = "edge-thickness-thick";
      break;
    case "invisible":
      strokeClasses = "edge-thickness-invisible";
      break;
    default:
      strokeClasses = "edge-thickness-normal";
  }
  switch (edge.pattern) {
    case "solid":
      strokeClasses += " edge-pattern-solid";
      break;
    case "dotted":
      strokeClasses += " edge-pattern-dotted";
      break;
    case "dashed":
      strokeClasses += " edge-pattern-dashed";
      break;
    default:
      strokeClasses += " edge-pattern-solid";
  }
  let svgPath;
  let linePath = lineFunction(lineData);
  const edgeStyles = Array.isArray(edge.style) ? edge.style : edge.style ? [edge.style] : [];
  let strokeColor = edgeStyles.find((style) => style?.startsWith("stroke:"));
  if (edge.look === "handDrawn") {
    const rc = at.svg(elem);
    Object.assign([], lineData);
    const svgPathNode = rc.path(linePath, {
      roughness: 0.3,
      seed: handDrawnSeed
    });
    strokeClasses += " transition";
    svgPath = select(svgPathNode).select("path").attr("id", edge.id).attr("class", " " + strokeClasses + (edge.classes ? " " + edge.classes : "")).attr("style", edgeStyles ? edgeStyles.reduce((acc, style) => acc + ";" + style, "") : "");
    let d = svgPath.attr("d");
    svgPath.attr("d", d);
    elem.node().appendChild(svgPath.node());
  } else {
    const stylesFromClasses = edgeClassStyles.join(";");
    const styles = edgeStyles ? edgeStyles.reduce((acc, style) => acc + style + ";", "") : "";
    let animationClass = "";
    if (edge.animate) {
      animationClass = " edge-animation-fast";
    }
    if (edge.animation) {
      animationClass = " edge-animation-" + edge.animation;
    }
    const pathStyle = stylesFromClasses ? stylesFromClasses + ";" + styles + ";" : styles;
    svgPath = elem.append("path").attr("d", linePath).attr("id", edge.id).attr(
      "class",
      " " + strokeClasses + (edge.classes ? " " + edge.classes : "") + (animationClass ?? "")
    ).attr("style", pathStyle);
    strokeColor = pathStyle.match(/stroke:([^;]+)/)?.[1];
  }
  let url = "";
  if (getConfig2().flowchart.arrowMarkerAbsolute || getConfig2().state.arrowMarkerAbsolute) {
    url = getUrl(true);
  }
  log.info("arrowTypeStart", edge.arrowTypeStart);
  log.info("arrowTypeEnd", edge.arrowTypeEnd);
  addEdgeMarkers(svgPath, edge, url, id, diagramType, strokeColor);
  const midIndex = Math.floor(points.length / 2);
  const point2 = points[midIndex];
  if (!utils_default.isLabelCoordinateInPath(point2, svgPath.attr("d"))) {
    pointsHasChanged = true;
  }
  let paths = {};
  if (pointsHasChanged) {
    paths.updatedPath = points;
  }
  paths.originalPath = edge.points;
  return paths;
}, "insertEdge");

// src/rendering-util/rendering-elements/markers.js
var insertMarkers = /* @__PURE__ */ __name((elem, markerArray, type, id) => {
  markerArray.forEach((markerName) => {
    markers[markerName](elem, type, id);
  });
}, "insertMarkers");
var extension = /* @__PURE__ */ __name((elem, type, id) => {
  log.trace("Making markers for ", id);
  elem.append("defs").append("marker").attr("id", id + "_" + type + "-extensionStart").attr("class", "marker extension " + type).attr("refX", 18).attr("refY", 7).attr("markerWidth", 190).attr("markerHeight", 240).attr("orient", "auto").append("path").attr("d", "M 1,7 L18,13 V 1 Z");
  elem.append("defs").append("marker").attr("id", id + "_" + type + "-extensionEnd").attr("class", "marker extension " + type).attr("refX", 1).attr("refY", 7).attr("markerWidth", 20).attr("markerHeight", 28).attr("orient", "auto").append("path").attr("d", "M 1,1 V 13 L18,7 Z");
}, "extension");
var composition = /* @__PURE__ */ __name((elem, type, id) => {
  elem.append("defs").append("marker").attr("id", id + "_" + type + "-compositionStart").attr("class", "marker composition " + type).attr("refX", 18).attr("refY", 7).attr("markerWidth", 190).attr("markerHeight", 240).attr("orient", "auto").append("path").attr("d", "M 18,7 L9,13 L1,7 L9,1 Z");
  elem.append("defs").append("marker").attr("id", id + "_" + type + "-compositionEnd").attr("class", "marker composition " + type).attr("refX", 1).attr("refY", 7).attr("markerWidth", 20).attr("markerHeight", 28).attr("orient", "auto").append("path").attr("d", "M 18,7 L9,13 L1,7 L9,1 Z");
}, "composition");
var aggregation = /* @__PURE__ */ __name((elem, type, id) => {
  elem.append("defs").append("marker").attr("id", id + "_" + type + "-aggregationStart").attr("class", "marker aggregation " + type).attr("refX", 18).attr("refY", 7).attr("markerWidth", 190).attr("markerHeight", 240).attr("orient", "auto").append("path").attr("d", "M 18,7 L9,13 L1,7 L9,1 Z");
  elem.append("defs").append("marker").attr("id", id + "_" + type + "-aggregationEnd").attr("class", "marker aggregation " + type).attr("refX", 1).attr("refY", 7).attr("markerWidth", 20).attr("markerHeight", 28).attr("orient", "auto").append("path").attr("d", "M 18,7 L9,13 L1,7 L9,1 Z");
}, "aggregation");
var dependency = /* @__PURE__ */ __name((elem, type, id) => {
  elem.append("defs").append("marker").attr("id", id + "_" + type + "-dependencyStart").attr("class", "marker dependency " + type).attr("refX", 6).attr("refY", 7).attr("markerWidth", 190).attr("markerHeight", 240).attr("orient", "auto").append("path").attr("d", "M 5,7 L9,13 L1,7 L9,1 Z");
  elem.append("defs").append("marker").attr("id", id + "_" + type + "-dependencyEnd").attr("class", "marker dependency " + type).attr("refX", 13).attr("refY", 7).attr("markerWidth", 20).attr("markerHeight", 28).attr("orient", "auto").append("path").attr("d", "M 18,7 L9,13 L14,7 L9,1 Z");
}, "dependency");
var lollipop = /* @__PURE__ */ __name((elem, type, id) => {
  elem.append("defs").append("marker").attr("id", id + "_" + type + "-lollipopStart").attr("class", "marker lollipop " + type).attr("refX", 13).attr("refY", 7).attr("markerWidth", 190).attr("markerHeight", 240).attr("orient", "auto").append("circle").attr("stroke", "black").attr("fill", "transparent").attr("cx", 7).attr("cy", 7).attr("r", 6);
  elem.append("defs").append("marker").attr("id", id + "_" + type + "-lollipopEnd").attr("class", "marker lollipop " + type).attr("refX", 1).attr("refY", 7).attr("markerWidth", 190).attr("markerHeight", 240).attr("orient", "auto").append("circle").attr("stroke", "black").attr("fill", "transparent").attr("cx", 7).attr("cy", 7).attr("r", 6);
}, "lollipop");
var point = /* @__PURE__ */ __name((elem, type, id) => {
  elem.append("marker").attr("id", id + "_" + type + "-pointEnd").attr("class", "marker " + type).attr("viewBox", "0 0 10 10").attr("refX", 5).attr("refY", 5).attr("markerUnits", "userSpaceOnUse").attr("markerWidth", 8).attr("markerHeight", 8).attr("orient", "auto").append("path").attr("d", "M 0 0 L 10 5 L 0 10 z").attr("class", "arrowMarkerPath").style("stroke-width", 1).style("stroke-dasharray", "1,0");
  elem.append("marker").attr("id", id + "_" + type + "-pointStart").attr("class", "marker " + type).attr("viewBox", "0 0 10 10").attr("refX", 4.5).attr("refY", 5).attr("markerUnits", "userSpaceOnUse").attr("markerWidth", 8).attr("markerHeight", 8).attr("orient", "auto").append("path").attr("d", "M 0 5 L 10 10 L 10 0 z").attr("class", "arrowMarkerPath").style("stroke-width", 1).style("stroke-dasharray", "1,0");
}, "point");
var circle = /* @__PURE__ */ __name((elem, type, id) => {
  elem.append("marker").attr("id", id + "_" + type + "-circleEnd").attr("class", "marker " + type).attr("viewBox", "0 0 10 10").attr("refX", 11).attr("refY", 5).attr("markerUnits", "userSpaceOnUse").attr("markerWidth", 11).attr("markerHeight", 11).attr("orient", "auto").append("circle").attr("cx", "5").attr("cy", "5").attr("r", "5").attr("class", "arrowMarkerPath").style("stroke-width", 1).style("stroke-dasharray", "1,0");
  elem.append("marker").attr("id", id + "_" + type + "-circleStart").attr("class", "marker " + type).attr("viewBox", "0 0 10 10").attr("refX", -1).attr("refY", 5).attr("markerUnits", "userSpaceOnUse").attr("markerWidth", 11).attr("markerHeight", 11).attr("orient", "auto").append("circle").attr("cx", "5").attr("cy", "5").attr("r", "5").attr("class", "arrowMarkerPath").style("stroke-width", 1).style("stroke-dasharray", "1,0");
}, "circle");
var cross = /* @__PURE__ */ __name((elem, type, id) => {
  elem.append("marker").attr("id", id + "_" + type + "-crossEnd").attr("class", "marker cross " + type).attr("viewBox", "0 0 11 11").attr("refX", 12).attr("refY", 5.2).attr("markerUnits", "userSpaceOnUse").attr("markerWidth", 11).attr("markerHeight", 11).attr("orient", "auto").append("path").attr("d", "M 1,1 l 9,9 M 10,1 l -9,9").attr("class", "arrowMarkerPath").style("stroke-width", 2).style("stroke-dasharray", "1,0");
  elem.append("marker").attr("id", id + "_" + type + "-crossStart").attr("class", "marker cross " + type).attr("viewBox", "0 0 11 11").attr("refX", -1).attr("refY", 5.2).attr("markerUnits", "userSpaceOnUse").attr("markerWidth", 11).attr("markerHeight", 11).attr("orient", "auto").append("path").attr("d", "M 1,1 l 9,9 M 10,1 l -9,9").attr("class", "arrowMarkerPath").style("stroke-width", 2).style("stroke-dasharray", "1,0");
}, "cross");
var barb = /* @__PURE__ */ __name((elem, type, id) => {
  elem.append("defs").append("marker").attr("id", id + "_" + type + "-barbEnd").attr("refX", 19).attr("refY", 7).attr("markerWidth", 20).attr("markerHeight", 14).attr("markerUnits", "userSpaceOnUse").attr("orient", "auto").append("path").attr("d", "M 19,7 L9,13 L14,7 L9,1 Z");
}, "barb");
var only_one = /* @__PURE__ */ __name((elem, type, id) => {
  elem.append("defs").append("marker").attr("id", id + "_" + type + "-onlyOneStart").attr("class", "marker onlyOne " + type).attr("refX", 0).attr("refY", 9).attr("markerWidth", 18).attr("markerHeight", 18).attr("orient", "auto").append("path").attr("d", "M9,0 L9,18 M15,0 L15,18");
  elem.append("defs").append("marker").attr("id", id + "_" + type + "-onlyOneEnd").attr("class", "marker onlyOne " + type).attr("refX", 18).attr("refY", 9).attr("markerWidth", 18).attr("markerHeight", 18).attr("orient", "auto").append("path").attr("d", "M3,0 L3,18 M9,0 L9,18");
}, "only_one");
var zero_or_one = /* @__PURE__ */ __name((elem, type, id) => {
  const startMarker = elem.append("defs").append("marker").attr("id", id + "_" + type + "-zeroOrOneStart").attr("class", "marker zeroOrOne " + type).attr("refX", 0).attr("refY", 9).attr("markerWidth", 30).attr("markerHeight", 18).attr("orient", "auto");
  startMarker.append("circle").attr("fill", "white").attr("cx", 21).attr("cy", 9).attr("r", 6);
  startMarker.append("path").attr("d", "M9,0 L9,18");
  const endMarker = elem.append("defs").append("marker").attr("id", id + "_" + type + "-zeroOrOneEnd").attr("class", "marker zeroOrOne " + type).attr("refX", 30).attr("refY", 9).attr("markerWidth", 30).attr("markerHeight", 18).attr("orient", "auto");
  endMarker.append("circle").attr("fill", "white").attr("cx", 9).attr("cy", 9).attr("r", 6);
  endMarker.append("path").attr("d", "M21,0 L21,18");
}, "zero_or_one");
var one_or_more = /* @__PURE__ */ __name((elem, type, id) => {
  elem.append("defs").append("marker").attr("id", id + "_" + type + "-oneOrMoreStart").attr("class", "marker oneOrMore " + type).attr("refX", 18).attr("refY", 18).attr("markerWidth", 45).attr("markerHeight", 36).attr("orient", "auto").append("path").attr("d", "M0,18 Q 18,0 36,18 Q 18,36 0,18 M42,9 L42,27");
  elem.append("defs").append("marker").attr("id", id + "_" + type + "-oneOrMoreEnd").attr("class", "marker oneOrMore " + type).attr("refX", 27).attr("refY", 18).attr("markerWidth", 45).attr("markerHeight", 36).attr("orient", "auto").append("path").attr("d", "M3,9 L3,27 M9,18 Q27,0 45,18 Q27,36 9,18");
}, "one_or_more");
var zero_or_more = /* @__PURE__ */ __name((elem, type, id) => {
  const startMarker = elem.append("defs").append("marker").attr("id", id + "_" + type + "-zeroOrMoreStart").attr("class", "marker zeroOrMore " + type).attr("refX", 18).attr("refY", 18).attr("markerWidth", 57).attr("markerHeight", 36).attr("orient", "auto");
  startMarker.append("circle").attr("fill", "white").attr("cx", 48).attr("cy", 18).attr("r", 6);
  startMarker.append("path").attr("d", "M0,18 Q18,0 36,18 Q18,36 0,18");
  const endMarker = elem.append("defs").append("marker").attr("id", id + "_" + type + "-zeroOrMoreEnd").attr("class", "marker zeroOrMore " + type).attr("refX", 39).attr("refY", 18).attr("markerWidth", 57).attr("markerHeight", 36).attr("orient", "auto");
  endMarker.append("circle").attr("fill", "white").attr("cx", 9).attr("cy", 18).attr("r", 6);
  endMarker.append("path").attr("d", "M21,18 Q39,0 57,18 Q39,36 21,18");
}, "zero_or_more");
var requirement_arrow = /* @__PURE__ */ __name((elem, type, id) => {
  elem.append("defs").append("marker").attr("id", id + "_" + type + "-requirement_arrowEnd").attr("refX", 20).attr("refY", 10).attr("markerWidth", 20).attr("markerHeight", 20).attr("orient", "auto").append("path").attr(
    "d",
    `M0,0
      L20,10
      M20,10
      L0,20`
  );
}, "requirement_arrow");
var requirement_contains = /* @__PURE__ */ __name((elem, type, id) => {
  const containsNode = elem.append("defs").append("marker").attr("id", id + "_" + type + "-requirement_containsStart").attr("refX", 0).attr("refY", 10).attr("markerWidth", 20).attr("markerHeight", 20).attr("orient", "auto").append("g");
  containsNode.append("circle").attr("cx", 10).attr("cy", 10).attr("r", 9).attr("fill", "none");
  containsNode.append("line").attr("x1", 1).attr("x2", 19).attr("y1", 10).attr("y2", 10);
  containsNode.append("line").attr("y1", 1).attr("y2", 19).attr("x1", 10).attr("x2", 10);
}, "requirement_contains");
var markers = {
  extension,
  composition,
  aggregation,
  dependency,
  lollipop,
  point,
  circle,
  cross,
  barb,
  only_one,
  zero_or_one,
  one_or_more,
  zero_or_more,
  requirement_arrow,
  requirement_contains
};
var markers_default = insertMarkers;

// src/internals.ts
var internalHelpers = {
  common: common_default,
  getConfig,
  insertCluster,
  insertEdge,
  insertEdgeLabel,
  insertMarkers: markers_default,
  insertNode,
  interpolateToCurve,
  labelHelper,
  log,
  positionEdgeLabel
};

// src/rendering-util/render.ts
var layoutAlgorithms = {};
var registerLayoutLoaders = /* @__PURE__ */ __name((loaders) => {
  for (const loader of loaders) {
    layoutAlgorithms[loader.name] = loader;
  }
}, "registerLayoutLoaders");
var registerDefaultLayoutLoaders = /* @__PURE__ */ __name(() => {
  registerLayoutLoaders([
    {
      name: "dagre",
      loader: /* @__PURE__ */ __name(async () => await __vitePreload(() => import('./dagre-2BBEFEWP-BpOF0skn.js'),true              ?__vite__mapDeps([0,1,2,3,4,5,6,7,8,9]):void 0), "loader")
    }
  ]);
}, "registerDefaultLayoutLoaders");
registerDefaultLayoutLoaders();
var render$1 = /* @__PURE__ */ __name(async (data4Layout, svg) => {
  if (!(data4Layout.layoutAlgorithm in layoutAlgorithms)) {
    throw new Error(`Unknown layout algorithm: ${data4Layout.layoutAlgorithm}`);
  }
  const layoutDefinition = layoutAlgorithms[data4Layout.layoutAlgorithm];
  const layoutRenderer = await layoutDefinition.loader();
  return layoutRenderer.render(data4Layout, svg, internalHelpers, {
    algorithm: layoutDefinition.algorithm
  });
}, "render");
var getRegisteredLayoutAlgorithm = /* @__PURE__ */ __name((algorithm = "", { fallback = "dagre" } = {}) => {
  if (algorithm in layoutAlgorithms) {
    return algorithm;
  }
  if (fallback in layoutAlgorithms) {
    log.warn(`Layout algorithm ${algorithm} is not registered. Using ${fallback} as fallback.`);
    return fallback;
  }
  throw new Error(`Both layout algorithms ${algorithm} and ${fallback} are not registered.`);
}, "getRegisteredLayoutAlgorithm");

// package.json
var package_default = {
  name: "mermaid",
  version: "11.10.1",
  description: "Markdown-ish syntax for generating flowcharts, mindmaps, sequence diagrams, class diagrams, gantt charts, git graphs and more.",
  type: "module",
  module: "./dist/mermaid.core.mjs",
  types: "./dist/mermaid.d.ts",
  exports: {
    ".": {
      types: "./dist/mermaid.d.ts",
      import: "./dist/mermaid.core.mjs",
      default: "./dist/mermaid.core.mjs"
    },
    "./*": "./*"
  },
  keywords: [
    "diagram",
    "markdown",
    "flowchart",
    "sequence diagram",
    "gantt",
    "class diagram",
    "git graph",
    "mindmap",
    "packet diagram",
    "c4 diagram",
    "er diagram",
    "pie chart",
    "pie diagram",
    "quadrant chart",
    "requirement diagram",
    "graph"
  ],
  scripts: {
    clean: "rimraf dist",
    dev: "pnpm -w dev",
    "docs:code": "typedoc src/defaultConfig.ts src/config.ts src/mermaid.ts && prettier --write ./src/docs/config/setup",
    "docs:build": "rimraf ../../docs && pnpm docs:code && pnpm docs:spellcheck && tsx scripts/docs.cli.mts",
    "docs:verify": "pnpm docs:code && pnpm docs:spellcheck && tsx scripts/docs.cli.mts --verify",
    "docs:pre:vitepress": "pnpm --filter ./src/docs prefetch && rimraf src/vitepress && pnpm docs:code && tsx scripts/docs.cli.mts --vitepress && pnpm --filter ./src/vitepress install --no-frozen-lockfile --ignore-scripts",
    "docs:build:vitepress": "pnpm docs:pre:vitepress && (cd src/vitepress && pnpm run build) && cpy --flat src/docs/landing/ ./src/vitepress/.vitepress/dist/landing",
    "docs:dev": 'pnpm docs:pre:vitepress && concurrently "pnpm --filter ./src/vitepress dev" "tsx scripts/docs.cli.mts --watch --vitepress"',
    "docs:dev:docker": 'pnpm docs:pre:vitepress && concurrently "pnpm --filter ./src/vitepress dev:docker" "tsx scripts/docs.cli.mts --watch --vitepress"',
    "docs:serve": "pnpm docs:build:vitepress && vitepress serve src/vitepress",
    "docs:spellcheck": 'cspell "src/docs/**/*.md"',
    "docs:release-version": "tsx scripts/update-release-version.mts",
    "docs:verify-version": "tsx scripts/update-release-version.mts --verify",
    "types:build-config": "tsx scripts/create-types-from-json-schema.mts",
    "types:verify-config": "tsx scripts/create-types-from-json-schema.mts --verify",
    checkCircle: "npx madge --circular ./src",
    prepublishOnly: "pnpm docs:verify-version"
  },
  repository: {
    type: "git",
    url: "https://github.com/mermaid-js/mermaid"
  },
  author: "Knut Sveidqvist",
  license: "MIT",
  standard: {
    ignore: [
      "**/parser/*.js",
      "dist/**/*.js",
      "cypress/**/*.js"
    ],
    globals: [
      "page"
    ]
  },
  dependencies: {
    "@braintree/sanitize-url": "^7.0.4",
    "@iconify/utils": "^2.1.33",
    "@mermaid-js/parser": "workspace:^",
    "@types/d3": "^7.4.3",
    cytoscape: "^3.29.3",
    "cytoscape-cose-bilkent": "^4.1.0",
    "cytoscape-fcose": "^2.2.0",
    d3: "^7.9.0",
    "d3-sankey": "^0.12.3",
    "dagre-d3-es": "7.0.11",
    dayjs: "^1.11.13",
    dompurify: "^3.2.5",
    katex: "^0.16.22",
    khroma: "^2.1.0",
    "lodash-es": "^4.17.21",
    marked: "^16.0.0",
    roughjs: "^4.6.6",
    stylis: "^4.3.6",
    "ts-dedent": "^2.2.0",
    uuid: "^11.1.0"
  },
  devDependencies: {
    "@adobe/jsonschema2md": "^8.0.2",
    "@iconify/types": "^2.0.0",
    "@types/cytoscape": "^3.21.9",
    "@types/cytoscape-fcose": "^2.2.4",
    "@types/d3-sankey": "^0.12.4",
    "@types/d3-scale": "^4.0.9",
    "@types/d3-scale-chromatic": "^3.1.0",
    "@types/d3-selection": "^3.0.11",
    "@types/d3-shape": "^3.1.7",
    "@types/jsdom": "^21.1.7",
    "@types/katex": "^0.16.7",
    "@types/lodash-es": "^4.17.12",
    "@types/micromatch": "^4.0.9",
    "@types/stylis": "^4.2.7",
    "@types/uuid": "^10.0.0",
    ajv: "^8.17.1",
    canvas: "^3.1.0",
    chokidar: "3.6.0",
    concurrently: "^9.1.2",
    "csstree-validator": "^4.0.1",
    globby: "^14.0.2",
    jison: "^0.4.18",
    "js-base64": "^3.7.7",
    jsdom: "^26.1.0",
    "json-schema-to-typescript": "^15.0.4",
    micromatch: "^4.0.8",
    "path-browserify": "^1.0.1",
    prettier: "^3.5.2",
    remark: "^15.0.1",
    "remark-frontmatter": "^5.0.0",
    "remark-gfm": "^4.0.1",
    rimraf: "^6.0.1",
    "start-server-and-test": "^2.0.10",
    "type-fest": "^4.35.0",
    typedoc: "^0.27.8",
    "typedoc-plugin-markdown": "^4.4.2",
    typescript: "~5.7.3",
    "unist-util-flatmap": "^1.0.0",
    "unist-util-visit": "^5.0.0",
    vitepress: "^1.0.2",
    "vitepress-plugin-search": "1.0.4-alpha.22"
  },
  files: [
    "dist/",
    "README.md"
  ],
  publishConfig: {
    access: "public"
  }
};

var selectSvgElement = /* @__PURE__ */ __name((id) => {
  const { securityLevel } = getConfig2();
  let root = select("body");
  if (securityLevel === "sandbox") {
    const sandboxElement = select(`#i${id}`);
    const doc = sandboxElement.node()?.contentDocument ?? document;
    root = select(doc.body);
  }
  const svg = root.select(`#${id}`);
  return svg;
}, "selectSvgElement");

var COMMENT = 'comm';
var RULESET = 'rule';
var DECLARATION = 'decl';
var IMPORT = '@import';
var NAMESPACE = '@namespace';
var KEYFRAMES = '@keyframes';
var LAYER = '@layer';

/**
 * @param {number}
 * @return {number}
 */
var abs = Math.abs;

/**
 * @param {number}
 * @return {string}
 */
var from = String.fromCharCode;

/**
 * @param {string} value
 * @return {string}
 */
function trim (value) {
	return value.trim()
}

/**
 * @param {string} value
 * @param {(string|RegExp)} pattern
 * @param {string} replacement
 * @return {string}
 */
function replace (value, pattern, replacement) {
	return value.replace(pattern, replacement)
}

/**
 * @param {string} value
 * @param {string} search
 * @param {number} position
 * @return {number}
 */
function indexof (value, search, position) {
	return value.indexOf(search, position)
}

/**
 * @param {string} value
 * @param {number} index
 * @return {number}
 */
function charat (value, index) {
	return value.charCodeAt(index) | 0
}

/**
 * @param {string} value
 * @param {number} begin
 * @param {number} end
 * @return {string}
 */
function substr (value, begin, end) {
	return value.slice(begin, end)
}

/**
 * @param {string} value
 * @return {number}
 */
function strlen (value) {
	return value.length
}

/**
 * @param {any[]} value
 * @return {number}
 */
function sizeof (value) {
	return value.length
}

/**
 * @param {any} value
 * @param {any[]} array
 * @return {any}
 */
function append (value, array) {
	return array.push(value), value
}

var line = 1;
var column = 1;
var length = 0;
var position = 0;
var character = 0;
var characters = '';

/**
 * @param {string} value
 * @param {object | null} root
 * @param {object | null} parent
 * @param {string} type
 * @param {string[] | string} props
 * @param {object[] | string} children
 * @param {object[]} siblings
 * @param {number} length
 */
function node (value, root, parent, type, props, children, length, siblings) {
	return {value: value, root: root, parent: parent, type: type, props: props, children: children, line: line, column: column, length: length, return: '', siblings: siblings}
}

/**
 * @return {number}
 */
function char () {
	return character
}

/**
 * @return {number}
 */
function prev () {
	character = position > 0 ? charat(characters, --position) : 0;

	if (column--, character === 10)
		column = 1, line--;

	return character
}

/**
 * @return {number}
 */
function next () {
	character = position < length ? charat(characters, position++) : 0;

	if (column++, character === 10)
		column = 1, line++;

	return character
}

/**
 * @return {number}
 */
function peek () {
	return charat(characters, position)
}

/**
 * @return {number}
 */
function caret () {
	return position
}

/**
 * @param {number} begin
 * @param {number} end
 * @return {string}
 */
function slice (begin, end) {
	return substr(characters, begin, end)
}

/**
 * @param {number} type
 * @return {number}
 */
function token (type) {
	switch (type) {
		// \0 \t \n \r \s whitespace token
		case 0: case 9: case 10: case 13: case 32:
			return 5
		// ! + , / > @ ~ isolate token
		case 33: case 43: case 44: case 47: case 62: case 64: case 126:
		// ; { } breakpoint token
		case 59: case 123: case 125:
			return 4
		// : accompanied token
		case 58:
			return 3
		// " ' ( [ opening delimit token
		case 34: case 39: case 40: case 91:
			return 2
		// ) ] closing delimit token
		case 41: case 93:
			return 1
	}

	return 0
}

/**
 * @param {string} value
 * @return {any[]}
 */
function alloc (value) {
	return line = column = 1, length = strlen(characters = value), position = 0, []
}

/**
 * @param {any} value
 * @return {any}
 */
function dealloc (value) {
	return characters = '', value
}

/**
 * @param {number} type
 * @return {string}
 */
function delimit (type) {
	return trim(slice(position - 1, delimiter(type === 91 ? type + 2 : type === 40 ? type + 1 : type)))
}

/**
 * @param {number} type
 * @return {string}
 */
function whitespace (type) {
	while (character = peek())
		if (character < 33)
			next();
		else
			break

	return token(type) > 2 || token(character) > 3 ? '' : ' '
}

/**
 * @param {number} index
 * @param {number} count
 * @return {string}
 */
function escaping (index, count) {
	while (--count && next())
		// not 0-9 A-F a-f
		if (character < 48 || character > 102 || (character > 57 && character < 65) || (character > 70 && character < 97))
			break

	return slice(index, caret() + (count < 6 && peek() == 32 && next() == 32))
}

/**
 * @param {number} type
 * @return {number}
 */
function delimiter (type) {
	while (next())
		switch (character) {
			// ] ) " '
			case type:
				return position
			// " '
			case 34: case 39:
				if (type !== 34 && type !== 39)
					delimiter(character);
				break
			// (
			case 40:
				if (type === 41)
					delimiter(type);
				break
			// \
			case 92:
				next();
				break
		}

	return position
}

/**
 * @param {number} type
 * @param {number} index
 * @return {number}
 */
function commenter (type, index) {
	while (next())
		// //
		if (type + character === 47 + 10)
			break
		// /*
		else if (type + character === 42 + 42 && peek() === 47)
			break

	return '/*' + slice(index, position - 1) + '*' + from(type === 47 ? type : next())
}

/**
 * @param {number} index
 * @return {string}
 */
function identifier (index) {
	while (!token(peek()))
		next();

	return slice(index, position)
}

/**
 * @param {string} value
 * @return {object[]}
 */
function compile (value) {
	return dealloc(parse$1('', null, null, null, [''], value = alloc(value), 0, [0], value))
}

/**
 * @param {string} value
 * @param {object} root
 * @param {object?} parent
 * @param {string[]} rule
 * @param {string[]} rules
 * @param {string[]} rulesets
 * @param {number[]} pseudo
 * @param {number[]} points
 * @param {string[]} declarations
 * @return {object}
 */
function parse$1 (value, root, parent, rule, rules, rulesets, pseudo, points, declarations) {
	var index = 0;
	var offset = 0;
	var length = pseudo;
	var atrule = 0;
	var property = 0;
	var previous = 0;
	var variable = 1;
	var scanning = 1;
	var ampersand = 1;
	var character = 0;
	var type = '';
	var props = rules;
	var children = rulesets;
	var reference = rule;
	var characters = type;

	while (scanning)
		switch (previous = character, character = next()) {
			// (
			case 40:
				if (previous != 108 && charat(characters, length - 1) == 58) {
					if (indexof(characters += replace(delimit(character), '&', '&\f'), '&\f', abs(index ? points[index - 1] : 0)) != -1)
						ampersand = -1;
					break
				}
			// " ' [
			case 34: case 39: case 91:
				characters += delimit(character);
				break
			// \t \n \r \s
			case 9: case 10: case 13: case 32:
				characters += whitespace(previous);
				break
			// \
			case 92:
				characters += escaping(caret() - 1, 7);
				continue
			// /
			case 47:
				switch (peek()) {
					case 42: case 47:
						append(comment(commenter(next(), caret()), root, parent, declarations), declarations);
						if ((token(previous || 1) == 5 || token(peek() || 1) == 5) && strlen(characters) && substr(characters, -1, void 0) !== ' ') characters += ' ';
						break
					default:
						characters += '/';
				}
				break
			// {
			case 123 * variable:
				points[index++] = strlen(characters) * ampersand;
			// } ; \0
			case 125 * variable: case 59: case 0:
				switch (character) {
					// \0 }
					case 0: case 125: scanning = 0;
					// ;
					case 59 + offset: if (ampersand == -1) characters = replace(characters, /\f/g, '');
						if (property > 0 && (strlen(characters) - length || (variable === 0 && previous === 47)))
							append(property > 32 ? declaration(characters + ';', rule, parent, length - 1, declarations) : declaration(replace(characters, ' ', '') + ';', rule, parent, length - 2, declarations), declarations);
						break
					// @ ;
					case 59: characters += ';';
					// { rule/at-rule
					default:
						append(reference = ruleset(characters, root, parent, index, offset, rules, points, type, props = [], children = [], length, rulesets), rulesets);

						if (character === 123)
							if (offset === 0)
								parse$1(characters, root, reference, reference, props, rulesets, length, points, children);
							else {
								switch (atrule) {
									// c(ontainer)
									case 99:
										if (charat(characters, 3) === 110) break
									// l(ayer)
									case 108:
										if (charat(characters, 2) === 97) break
									default:
										offset = 0;
									// d(ocument) m(edia) s(upports)
									case 100: case 109: case 115:
								}
								if (offset) parse$1(value, reference, reference, rule && append(ruleset(value, reference, reference, 0, 0, rules, points, type, rules, props = [], length, children), children), rules, children, length, points, rule ? props : children);
								else parse$1(characters, reference, reference, reference, [''], children, 0, points, children);
							}
				}

				index = offset = property = 0, variable = ampersand = 1, type = characters = '', length = pseudo;
				break
			// :
			case 58:
				length = 1 + strlen(characters), property = previous;
			default:
				if (variable < 1)
					if (character == 123)
						--variable;
					else if (character == 125 && variable++ == 0 && prev() == 125)
						continue

				switch (characters += from(character), character * variable) {
					// &
					case 38:
						ampersand = offset > 0 ? 1 : (characters += '\f', -1);
						break
					// ,
					case 44:
						points[index++] = (strlen(characters) - 1) * ampersand, ampersand = 1;
						break
					// @
					case 64:
						// -
						if (peek() === 45)
							characters += delimit(next());

						atrule = peek(), offset = length = strlen(type = characters += identifier(caret())), character++;
						break
					// -
					case 45:
						if (previous === 45 && strlen(characters) == 2)
							variable = 0;
				}
		}

	return rulesets
}

/**
 * @param {string} value
 * @param {object} root
 * @param {object?} parent
 * @param {number} index
 * @param {number} offset
 * @param {string[]} rules
 * @param {number[]} points
 * @param {string} type
 * @param {string[]} props
 * @param {string[]} children
 * @param {number} length
 * @param {object[]} siblings
 * @return {object}
 */
function ruleset (value, root, parent, index, offset, rules, points, type, props, children, length, siblings) {
	var post = offset - 1;
	var rule = offset === 0 ? rules : [''];
	var size = sizeof(rule);

	for (var i = 0, j = 0, k = 0; i < index; ++i)
		for (var x = 0, y = substr(value, post + 1, post = abs(j = points[i])), z = value; x < size; ++x)
			if (z = trim(j > 0 ? rule[x] + ' ' + y : replace(y, /&\f/g, rule[x])))
				props[k++] = z;

	return node(value, root, parent, offset === 0 ? RULESET : type, props, children, length, siblings)
}

/**
 * @param {number} value
 * @param {object} root
 * @param {object?} parent
 * @param {object[]} siblings
 * @return {object}
 */
function comment (value, root, parent, siblings) {
	return node(value, root, parent, COMMENT, from(char()), substr(value, 2, -2), 0, siblings)
}

/**
 * @param {string} value
 * @param {object} root
 * @param {object?} parent
 * @param {number} length
 * @param {object[]} siblings
 * @return {object}
 */
function declaration (value, root, parent, length, siblings) {
	return node(value, root, parent, DECLARATION, substr(value, 0, length), substr(value, length + 1, -1), length, siblings)
}

/**
 * @param {object[]} children
 * @param {function} callback
 * @return {string}
 */
function serialize (children, callback) {
	var output = '';

	for (var i = 0; i < children.length; i++)
		output += callback(children[i], i, children, callback) || '';

	return output
}

/**
 * @param {object} element
 * @param {number} index
 * @param {object[]} children
 * @param {function} callback
 * @return {string}
 */
function stringify (element, index, children, callback) {
	switch (element.type) {
		case LAYER: if (element.children.length) break
		case IMPORT: case NAMESPACE: case DECLARATION: return element.return = element.return || element.value
		case COMMENT: return ''
		case KEYFRAMES: return element.return = element.value + '{' + serialize(element.children, callback) + '}'
		case RULESET: if (!strlen(element.value = element.props.join(','))) return ''
	}

	return strlen(children = serialize(element.children, callback)) ? element.return = element.value + '{' + children + '}' : ''
}

/* Built-in method references for those with the same name as other `lodash` methods. */
var nativeKeys = overArg(Object.keys, Object);

/** Used for built-in method references. */
var objectProto$1 = Object.prototype;

/** Used to check objects for own properties. */
var hasOwnProperty$1 = objectProto$1.hasOwnProperty;

/**
 * The base implementation of `_.keys` which doesn't treat sparse arrays as dense.
 *
 * @private
 * @param {Object} object The object to query.
 * @returns {Array} Returns the array of property names.
 */
function baseKeys(object) {
  if (!isPrototype(object)) {
    return nativeKeys(object);
  }
  var result = [];
  for (var key in Object(object)) {
    if (hasOwnProperty$1.call(object, key) && key != 'constructor') {
      result.push(key);
    }
  }
  return result;
}

/* Built-in method references that are verified to be native. */
var DataView = getNative(root, 'DataView');

/* Built-in method references that are verified to be native. */
var Promise$1 = getNative(root, 'Promise');

/* Built-in method references that are verified to be native. */
var Set$1 = getNative(root, 'Set');

/* Built-in method references that are verified to be native. */
var WeakMap$1 = getNative(root, 'WeakMap');

/** `Object#toString` result references. */
var mapTag$1 = '[object Map]',
    objectTag = '[object Object]',
    promiseTag = '[object Promise]',
    setTag$1 = '[object Set]',
    weakMapTag = '[object WeakMap]';

var dataViewTag = '[object DataView]';

/** Used to detect maps, sets, and weakmaps. */
var dataViewCtorString = toSource(DataView),
    mapCtorString = toSource(Map$1),
    promiseCtorString = toSource(Promise$1),
    setCtorString = toSource(Set$1),
    weakMapCtorString = toSource(WeakMap$1);

/**
 * Gets the `toStringTag` of `value`.
 *
 * @private
 * @param {*} value The value to query.
 * @returns {string} Returns the `toStringTag`.
 */
var getTag = baseGetTag;

// Fallback for data views, maps, sets, and weak maps in IE 11 and promises in Node.js < 6.
if ((DataView && getTag(new DataView(new ArrayBuffer(1))) != dataViewTag) ||
    (Map$1 && getTag(new Map$1) != mapTag$1) ||
    (Promise$1 && getTag(Promise$1.resolve()) != promiseTag) ||
    (Set$1 && getTag(new Set$1) != setTag$1) ||
    (WeakMap$1 && getTag(new WeakMap$1) != weakMapTag)) {
  getTag = function(value) {
    var result = baseGetTag(value),
        Ctor = result == objectTag ? value.constructor : undefined,
        ctorString = Ctor ? toSource(Ctor) : '';

    if (ctorString) {
      switch (ctorString) {
        case dataViewCtorString: return dataViewTag;
        case mapCtorString: return mapTag$1;
        case promiseCtorString: return promiseTag;
        case setCtorString: return setTag$1;
        case weakMapCtorString: return weakMapTag;
      }
    }
    return result;
  };
}

/** `Object#toString` result references. */
var mapTag = '[object Map]',
    setTag = '[object Set]';

/** Used for built-in method references. */
var objectProto = Object.prototype;

/** Used to check objects for own properties. */
var hasOwnProperty = objectProto.hasOwnProperty;

/**
 * Checks if `value` is an empty object, collection, map, or set.
 *
 * Objects are considered empty if they have no own enumerable string keyed
 * properties.
 *
 * Array-like values such as `arguments` objects, arrays, buffers, strings, or
 * jQuery-like collections are considered empty if they have a `length` of `0`.
 * Similarly, maps and sets are considered empty if they have a `size` of `0`.
 *
 * @static
 * @memberOf _
 * @since 0.1.0
 * @category Lang
 * @param {*} value The value to check.
 * @returns {boolean} Returns `true` if `value` is empty, else `false`.
 * @example
 *
 * _.isEmpty(null);
 * // => true
 *
 * _.isEmpty(true);
 * // => true
 *
 * _.isEmpty(1);
 * // => true
 *
 * _.isEmpty([1, 2, 3]);
 * // => false
 *
 * _.isEmpty({ 'a': 1 });
 * // => false
 */
function isEmpty(value) {
  if (value == null) {
    return true;
  }
  if (isArrayLike(value) &&
      (isArray(value) || typeof value == 'string' || typeof value.splice == 'function' ||
        isBuffer(value) || isTypedArray(value) || isArguments(value))) {
    return !value.length;
  }
  var tag = getTag(value);
  if (tag == mapTag || tag == setTag) {
    return !value.size;
  }
  if (isPrototype(value)) {
    return !baseKeys(value).length;
  }
  for (var key in value) {
    if (hasOwnProperty.call(value, key)) {
      return false;
    }
  }
  return true;
}

// src/diagrams/c4/c4Detector.ts
var id = "c4";
var detector = /* @__PURE__ */ __name((txt) => {
  return /^\s*C4Context|C4Container|C4Component|C4Dynamic|C4Deployment/.test(txt);
}, "detector");
var loader = /* @__PURE__ */ __name(async () => {
  const { diagram: diagram2 } = await __vitePreload(async () => { const { diagram: diagram2 } = await import('./c4Diagram-AAMF2YG6-GtbPM5hH.js');return { diagram: diagram2 }},true              ?__vite__mapDeps([10,11,6,7,8,9]):void 0);
  return { id, diagram: diagram2 };
}, "loader");
var plugin = {
  id,
  detector,
  loader
};
var c4Detector_default = plugin;

// src/diagrams/flowchart/flowDetector.ts
var id2 = "flowchart";
var detector2 = /* @__PURE__ */ __name((txt, config) => {
  if (config?.flowchart?.defaultRenderer === "dagre-wrapper" || config?.flowchart?.defaultRenderer === "elk") {
    return false;
  }
  return /^\s*graph/.test(txt);
}, "detector");
var loader2 = /* @__PURE__ */ __name(async () => {
  const { diagram: diagram2 } = await __vitePreload(async () => { const { diagram: diagram2 } = await import('./flowDiagram-THRYKUMA-DgLyuWgA.js');return { diagram: diagram2 }},true              ?__vite__mapDeps([12,13,14,15,16,6,7,8,9]):void 0);
  return { id: id2, diagram: diagram2 };
}, "loader");
var plugin2 = {
  id: id2,
  detector: detector2,
  loader: loader2
};
var flowDetector_default = plugin2;

// src/diagrams/flowchart/flowDetector-v2.ts
var id3 = "flowchart-v2";
var detector3 = /* @__PURE__ */ __name((txt, config) => {
  if (config?.flowchart?.defaultRenderer === "dagre-d3") {
    return false;
  }
  if (config?.flowchart?.defaultRenderer === "elk") {
    config.layout = "elk";
  }
  if (/^\s*graph/.test(txt) && config?.flowchart?.defaultRenderer === "dagre-wrapper") {
    return true;
  }
  return /^\s*flowchart/.test(txt);
}, "detector");
var loader3 = /* @__PURE__ */ __name(async () => {
  const { diagram: diagram2 } = await __vitePreload(async () => { const { diagram: diagram2 } = await import('./flowDiagram-THRYKUMA-DgLyuWgA.js');return { diagram: diagram2 }},true              ?__vite__mapDeps([12,13,14,15,16,6,7,8,9]):void 0);
  return { id: id3, diagram: diagram2 };
}, "loader");
var plugin3 = {
  id: id3,
  detector: detector3,
  loader: loader3
};
var flowDetector_v2_default = plugin3;

// src/diagrams/er/erDetector.ts
var id4 = "er";
var detector4 = /* @__PURE__ */ __name((txt) => {
  return /^\s*erDiagram/.test(txt);
}, "detector");
var loader4 = /* @__PURE__ */ __name(async () => {
  const { diagram: diagram2 } = await __vitePreload(async () => { const { diagram: diagram2 } = await import('./erDiagram-HZWUO2LU-BMWITxVT.js');return { diagram: diagram2 }},true              ?__vite__mapDeps([17,14,15,16,6,7,8,9]):void 0);
  return { id: id4, diagram: diagram2 };
}, "loader");
var plugin4 = {
  id: id4,
  detector: detector4,
  loader: loader4
};
var erDetector_default = plugin4;

// src/diagrams/git/gitGraphDetector.ts
var id5 = "gitGraph";
var detector5 = /* @__PURE__ */ __name((txt) => {
  return /^\s*gitGraph/.test(txt);
}, "detector");
var loader5 = /* @__PURE__ */ __name(async () => {
  const { diagram: diagram2 } = await __vitePreload(async () => { const { diagram: diagram2 } = await import('./gitGraphDiagram-OJR772UL-CB-vYJbH.js');return { diagram: diagram2 }},true              ?__vite__mapDeps([18,19,20,21,2,4,5,6,7,8,9]):void 0);
  return { id: id5, diagram: diagram2 };
}, "loader");
var plugin5 = {
  id: id5,
  detector: detector5,
  loader: loader5
};
var gitGraphDetector_default = plugin5;

// src/diagrams/gantt/ganttDetector.ts
var id6 = "gantt";
var detector6 = /* @__PURE__ */ __name((txt) => {
  return /^\s*gantt/.test(txt);
}, "detector");
var loader6 = /* @__PURE__ */ __name(async () => {
  const { diagram: diagram2 } = await __vitePreload(async () => { const { diagram: diagram2 } = await import('./ganttDiagram-WV7ZQ7D5-B-W60t5T.js');return { diagram: diagram2 }},true              ?__vite__mapDeps([22,6,23,24,25,7,8,9]):void 0);
  return { id: id6, diagram: diagram2 };
}, "loader");
var plugin6 = {
  id: id6,
  detector: detector6,
  loader: loader6
};
var ganttDetector_default = plugin6;

// src/diagrams/info/infoDetector.ts
var id7 = "info";
var detector7 = /* @__PURE__ */ __name((txt) => {
  return /^\s*info/.test(txt);
}, "detector");
var loader7 = /* @__PURE__ */ __name(async () => {
  const { diagram: diagram2 } = await __vitePreload(async () => { const { diagram: diagram2 } = await import('./infoDiagram-DDUCL6P7-twrf9TCL.js');return { diagram: diagram2 }},true              ?__vite__mapDeps([26,21,2,4,5,6,7,8,9]):void 0);
  return { id: id7, diagram: diagram2 };
}, "loader");
var info = {
  id: id7,
  detector: detector7,
  loader: loader7
};

// src/diagrams/pie/pieDetector.ts
var id8 = "pie";
var detector8 = /* @__PURE__ */ __name((txt) => {
  return /^\s*pie/.test(txt);
}, "detector");
var loader8 = /* @__PURE__ */ __name(async () => {
  const { diagram: diagram2 } = await __vitePreload(async () => { const { diagram: diagram2 } = await import('./pieDiagram-DBDJKBY4-CPEP0oyh.js');return { diagram: diagram2 }},true              ?__vite__mapDeps([27,19,21,2,4,5,28,29,24,6,7,8,9]):void 0);
  return { id: id8, diagram: diagram2 };
}, "loader");
var pie = {
  id: id8,
  detector: detector8,
  loader: loader8
};

// src/diagrams/quadrant-chart/quadrantDetector.ts
var id9 = "quadrantChart";
var detector9 = /* @__PURE__ */ __name((txt) => {
  return /^\s*quadrantChart/.test(txt);
}, "detector");
var loader9 = /* @__PURE__ */ __name(async () => {
  const { diagram: diagram2 } = await __vitePreload(async () => { const { diagram: diagram2 } = await import('./quadrantDiagram-YPSRARAO-BcMz3duU.js');return { diagram: diagram2 }},true              ?__vite__mapDeps([30,23,24,25,6,7,8,9]):void 0);
  return { id: id9, diagram: diagram2 };
}, "loader");
var plugin7 = {
  id: id9,
  detector: detector9,
  loader: loader9
};
var quadrantDetector_default = plugin7;

// src/diagrams/xychart/xychartDetector.ts
var id10 = "xychart";
var detector10 = /* @__PURE__ */ __name((txt) => {
  return /^\s*xychart(-beta)?/.test(txt);
}, "detector");
var loader10 = /* @__PURE__ */ __name(async () => {
  const { diagram: diagram2 } = await __vitePreload(async () => { const { diagram: diagram2 } = await import('./xychartDiagram-FDP5SA34-Clf4Ocy3.js');return { diagram: diagram2 }},true              ?__vite__mapDeps([31,24,29,23,25,6,7,8,9]):void 0);
  return { id: id10, diagram: diagram2 };
}, "loader");
var plugin8 = {
  id: id10,
  detector: detector10,
  loader: loader10
};
var xychartDetector_default = plugin8;

// src/diagrams/requirement/requirementDetector.ts
var id11 = "requirement";
var detector11 = /* @__PURE__ */ __name((txt) => {
  return /^\s*requirement(Diagram)?/.test(txt);
}, "detector");
var loader11 = /* @__PURE__ */ __name(async () => {
  const { diagram: diagram2 } = await __vitePreload(async () => { const { diagram: diagram2 } = await import('./requirementDiagram-EGVEC5DT-YwObr2ur.js');return { diagram: diagram2 }},true              ?__vite__mapDeps([32,14,15,6,7,8,9]):void 0);
  return { id: id11, diagram: diagram2 };
}, "loader");
var plugin9 = {
  id: id11,
  detector: detector11,
  loader: loader11
};
var requirementDetector_default = plugin9;

// src/diagrams/sequence/sequenceDetector.ts
var id12 = "sequence";
var detector12 = /* @__PURE__ */ __name((txt) => {
  return /^\s*sequenceDiagram/.test(txt);
}, "detector");
var loader12 = /* @__PURE__ */ __name(async () => {
  const { diagram: diagram2 } = await __vitePreload(async () => { const { diagram: diagram2 } = await import('./sequenceDiagram-4MX5Z3NR-D5_lL7Fz.js');return { diagram: diagram2 }},true              ?__vite__mapDeps([33,11,20,6,7,8,9]):void 0);
  return { id: id12, diagram: diagram2 };
}, "loader");
var plugin10 = {
  id: id12,
  detector: detector12,
  loader: loader12
};
var sequenceDetector_default = plugin10;

// src/diagrams/class/classDetector.ts
var id13 = "class";
var detector13 = /* @__PURE__ */ __name((txt, config) => {
  if (config?.class?.defaultRenderer === "dagre-wrapper") {
    return false;
  }
  return /^\s*classDiagram/.test(txt);
}, "detector");
var loader13 = /* @__PURE__ */ __name(async () => {
  const { diagram: diagram2 } = await __vitePreload(async () => { const { diagram: diagram2 } = await import('./classDiagram-3BZAVTQC-B7Zc7RLJ.js');return { diagram: diagram2 }},true              ?__vite__mapDeps([34,35,13,14,15,6,7,8,9]):void 0);
  return { id: id13, diagram: diagram2 };
}, "loader");
var plugin11 = {
  id: id13,
  detector: detector13,
  loader: loader13
};
var classDetector_default = plugin11;

// src/diagrams/class/classDetector-V2.ts
var id14 = "classDiagram";
var detector14 = /* @__PURE__ */ __name((txt, config) => {
  if (/^\s*classDiagram/.test(txt) && config?.class?.defaultRenderer === "dagre-wrapper") {
    return true;
  }
  return /^\s*classDiagram-v2/.test(txt);
}, "detector");
var loader14 = /* @__PURE__ */ __name(async () => {
  const { diagram: diagram2 } = await __vitePreload(async () => { const { diagram: diagram2 } = await import('./classDiagram-v2-QTMF73CY-BB9lJ347.js');return { diagram: diagram2 }},true              ?__vite__mapDeps([36,35,13,14,15,6,7,8,9]):void 0);
  return { id: id14, diagram: diagram2 };
}, "loader");
var plugin12 = {
  id: id14,
  detector: detector14,
  loader: loader14
};
var classDetector_V2_default = plugin12;

// src/diagrams/state/stateDetector.ts
var id15 = "state";
var detector15 = /* @__PURE__ */ __name((txt, config) => {
  if (config?.state?.defaultRenderer === "dagre-wrapper") {
    return false;
  }
  return /^\s*stateDiagram/.test(txt);
}, "detector");
var loader15 = /* @__PURE__ */ __name(async () => {
  const { diagram: diagram2 } = await __vitePreload(async () => { const { diagram: diagram2 } = await import('./stateDiagram-UUKSUZ4H-BozWq8CR.js');return { diagram: diagram2 }},true              ?__vite__mapDeps([37,38,14,15,1,2,3,4,6,7,8,9]):void 0);
  return { id: id15, diagram: diagram2 };
}, "loader");
var plugin13 = {
  id: id15,
  detector: detector15,
  loader: loader15
};
var stateDetector_default = plugin13;

// src/diagrams/state/stateDetector-V2.ts
var id16 = "stateDiagram";
var detector16 = /* @__PURE__ */ __name((txt, config) => {
  if (/^\s*stateDiagram-v2/.test(txt)) {
    return true;
  }
  if (/^\s*stateDiagram/.test(txt) && config?.state?.defaultRenderer === "dagre-wrapper") {
    return true;
  }
  return false;
}, "detector");
var loader16 = /* @__PURE__ */ __name(async () => {
  const { diagram: diagram2 } = await __vitePreload(async () => { const { diagram: diagram2 } = await import('./stateDiagram-v2-EYPG3UTE-BGW6BVNP.js');return { diagram: diagram2 }},true              ?__vite__mapDeps([39,38,14,15,6,7,8,9]):void 0);
  return { id: id16, diagram: diagram2 };
}, "loader");
var plugin14 = {
  id: id16,
  detector: detector16,
  loader: loader16
};
var stateDetector_V2_default = plugin14;

// src/diagrams/user-journey/journeyDetector.ts
var id17 = "journey";
var detector17 = /* @__PURE__ */ __name((txt) => {
  return /^\s*journey/.test(txt);
}, "detector");
var loader17 = /* @__PURE__ */ __name(async () => {
  const { diagram: diagram2 } = await __vitePreload(async () => { const { diagram: diagram2 } = await import('./journeyDiagram-FFXJYRFH-IjGi2LKK.js');return { diagram: diagram2 }},true              ?__vite__mapDeps([40,11,13,28,6,7,8,9]):void 0);
  return { id: id17, diagram: diagram2 };
}, "loader");
var plugin15 = {
  id: id17,
  detector: detector17,
  loader: loader17
};
var journeyDetector_default = plugin15;

// src/diagrams/error/errorRenderer.ts
var draw = /* @__PURE__ */ __name((_text, id28, version) => {
  log.debug("rendering svg for syntax error\n");
  const svg = selectSvgElement(id28);
  const g = svg.append("g");
  svg.attr("viewBox", "0 0 2412 512");
  configureSvgSize(svg, 100, 512, true);
  g.append("path").attr("class", "error-icon").attr(
    "d",
    "m411.313,123.313c6.25-6.25 6.25-16.375 0-22.625s-16.375-6.25-22.625,0l-32,32-9.375,9.375-20.688-20.688c-12.484-12.5-32.766-12.5-45.25,0l-16,16c-1.261,1.261-2.304,2.648-3.31,4.051-21.739-8.561-45.324-13.426-70.065-13.426-105.867,0-192,86.133-192,192s86.133,192 192,192 192-86.133 192-192c0-24.741-4.864-48.327-13.426-70.065 1.402-1.007 2.79-2.049 4.051-3.31l16-16c12.5-12.492 12.5-32.758 0-45.25l-20.688-20.688 9.375-9.375 32.001-31.999zm-219.313,100.687c-52.938,0-96,43.063-96,96 0,8.836-7.164,16-16,16s-16-7.164-16-16c0-70.578 57.422-128 128-128 8.836,0 16,7.164 16,16s-7.164,16-16,16z"
  );
  g.append("path").attr("class", "error-icon").attr(
    "d",
    "m459.02,148.98c-6.25-6.25-16.375-6.25-22.625,0s-6.25,16.375 0,22.625l16,16c3.125,3.125 7.219,4.688 11.313,4.688 4.094,0 8.188-1.563 11.313-4.688 6.25-6.25 6.25-16.375 0-22.625l-16.001-16z"
  );
  g.append("path").attr("class", "error-icon").attr(
    "d",
    "m340.395,75.605c3.125,3.125 7.219,4.688 11.313,4.688 4.094,0 8.188-1.563 11.313-4.688 6.25-6.25 6.25-16.375 0-22.625l-16-16c-6.25-6.25-16.375-6.25-22.625,0s-6.25,16.375 0,22.625l15.999,16z"
  );
  g.append("path").attr("class", "error-icon").attr(
    "d",
    "m400,64c8.844,0 16-7.164 16-16v-32c0-8.836-7.156-16-16-16-8.844,0-16,7.164-16,16v32c0,8.836 7.156,16 16,16z"
  );
  g.append("path").attr("class", "error-icon").attr(
    "d",
    "m496,96.586h-32c-8.844,0-16,7.164-16,16 0,8.836 7.156,16 16,16h32c8.844,0 16-7.164 16-16 0-8.836-7.156-16-16-16z"
  );
  g.append("path").attr("class", "error-icon").attr(
    "d",
    "m436.98,75.605c3.125,3.125 7.219,4.688 11.313,4.688 4.094,0 8.188-1.563 11.313-4.688l32-32c6.25-6.25 6.25-16.375 0-22.625s-16.375-6.25-22.625,0l-32,32c-6.251,6.25-6.251,16.375-0.001,22.625z"
  );
  g.append("text").attr("class", "error-text").attr("x", 1440).attr("y", 250).attr("font-size", "150px").style("text-anchor", "middle").text("Syntax error in text");
  g.append("text").attr("class", "error-text").attr("x", 1250).attr("y", 400).attr("font-size", "100px").style("text-anchor", "middle").text(`mermaid version ${version}`);
}, "draw");
var renderer = { draw };
var errorRenderer_default = renderer;

// src/diagrams/error/errorDiagram.ts
var diagram = {
  db: {},
  renderer,
  parser: {
    parse: /* @__PURE__ */ __name(() => {
      return;
    }, "parse")
  }
};
var errorDiagram_default = diagram;

// src/diagrams/flowchart/elk/detector.ts
var id18 = "flowchart-elk";
var detector18 = /* @__PURE__ */ __name((txt, config = {}) => {
  if (
    // If diagram explicitly states flowchart-elk
    /^\s*flowchart-elk/.test(txt) || // If a flowchart/graph diagram has their default renderer set to elk
    /^\s*(flowchart|graph)/.test(txt) && config?.flowchart?.defaultRenderer === "elk"
  ) {
    config.layout = "elk";
    return true;
  }
  return false;
}, "detector");
var loader18 = /* @__PURE__ */ __name(async () => {
  const { diagram: diagram2 } = await __vitePreload(async () => { const { diagram: diagram2 } = await import('./flowDiagram-THRYKUMA-DgLyuWgA.js');return { diagram: diagram2 }},true              ?__vite__mapDeps([12,13,14,15,16,6,7,8,9]):void 0);
  return { id: id18, diagram: diagram2 };
}, "loader");
var plugin16 = {
  id: id18,
  detector: detector18,
  loader: loader18
};
var detector_default = plugin16;

// src/diagrams/timeline/detector.ts
var id19 = "timeline";
var detector19 = /* @__PURE__ */ __name((txt) => {
  return /^\s*timeline/.test(txt);
}, "detector");
var loader19 = /* @__PURE__ */ __name(async () => {
  const { diagram: diagram2 } = await __vitePreload(async () => { const { diagram: diagram2 } = await import('./timeline-definition-3HZDQTIS-BUzYPNGr.js');return { diagram: diagram2 }},true              ?__vite__mapDeps([41,28,6,7,8,9]):void 0);
  return { id: id19, diagram: diagram2 };
}, "loader");
var plugin17 = {
  id: id19,
  detector: detector19,
  loader: loader19
};
var detector_default2 = plugin17;

// src/diagrams/mindmap/detector.ts
var id20 = "mindmap";
var detector20 = /* @__PURE__ */ __name((txt) => {
  return /^\s*mindmap/.test(txt);
}, "detector");
var loader20 = /* @__PURE__ */ __name(async () => {
  const { diagram: diagram2 } = await __vitePreload(async () => { const { diagram: diagram2 } = await import('./mindmap-definition-LNHGMQRG-RawWWEnU.js');return { diagram: diagram2 }},true              ?__vite__mapDeps([42,43,6,7,8,9]):void 0);
  return { id: id20, diagram: diagram2 };
}, "loader");
var plugin18 = {
  id: id20,
  detector: detector20,
  loader: loader20
};
var detector_default3 = plugin18;

// src/diagrams/kanban/detector.ts
var id21 = "kanban";
var detector21 = /* @__PURE__ */ __name((txt) => {
  return /^\s*kanban/.test(txt);
}, "detector");
var loader21 = /* @__PURE__ */ __name(async () => {
  const { diagram: diagram2 } = await __vitePreload(async () => { const { diagram: diagram2 } = await import('./kanban-definition-KOZQBZVT-BJ8xaYjA.js');return { diagram: diagram2 }},true              ?__vite__mapDeps([44,13,6,7,8,9]):void 0);
  return { id: id21, diagram: diagram2 };
}, "loader");
var plugin19 = {
  id: id21,
  detector: detector21,
  loader: loader21
};
var detector_default4 = plugin19;

// src/diagrams/sankey/sankeyDetector.ts
var id22 = "sankey";
var detector22 = /* @__PURE__ */ __name((txt) => {
  return /^\s*sankey(-beta)?/.test(txt);
}, "detector");
var loader22 = /* @__PURE__ */ __name(async () => {
  const { diagram: diagram2 } = await __vitePreload(async () => { const { diagram: diagram2 } = await import('./sankeyDiagram-HRAUVNP4-BDeioNPw.js');return { diagram: diagram2 }},true              ?__vite__mapDeps([45,29,24,6,7,8,9]):void 0);
  return { id: id22, diagram: diagram2 };
}, "loader");
var plugin20 = {
  id: id22,
  detector: detector22,
  loader: loader22
};
var sankeyDetector_default = plugin20;

// src/diagrams/packet/detector.ts
var id23 = "packet";
var detector23 = /* @__PURE__ */ __name((txt) => {
  return /^\s*packet(-beta)?/.test(txt);
}, "detector");
var loader23 = /* @__PURE__ */ __name(async () => {
  const { diagram: diagram2 } = await __vitePreload(async () => { const { diagram: diagram2 } = await import('./diagram-GUPCWM2R-pB1OL14D.js');return { diagram: diagram2 }},true              ?__vite__mapDeps([46,19,21,2,4,5,6,7,8,9]):void 0);
  return { id: id23, diagram: diagram2 };
}, "loader");
var packet = {
  id: id23,
  detector: detector23,
  loader: loader23
};

// src/diagrams/radar/detector.ts
var id24 = "radar";
var detector24 = /* @__PURE__ */ __name((txt) => {
  return /^\s*radar-beta/.test(txt);
}, "detector");
var loader24 = /* @__PURE__ */ __name(async () => {
  const { diagram: diagram2 } = await __vitePreload(async () => { const { diagram: diagram2 } = await import('./diagram-RP2FKANI-C4L0vT45.js');return { diagram: diagram2 }},true              ?__vite__mapDeps([47,19,21,2,4,5,6,7,8,9]):void 0);
  return { id: id24, diagram: diagram2 };
}, "loader");
var radar = {
  id: id24,
  detector: detector24,
  loader: loader24
};

// src/diagrams/block/blockDetector.ts
var id25 = "block";
var detector25 = /* @__PURE__ */ __name((txt) => {
  return /^\s*block(-beta)?/.test(txt);
}, "detector");
var loader25 = /* @__PURE__ */ __name(async () => {
  const { diagram: diagram2 } = await __vitePreload(async () => { const { diagram: diagram2 } = await import('./blockDiagram-ZYB65J3Q-lB6y7uq8.js');return { diagram: diagram2 }},true              ?__vite__mapDeps([48,13,5,2,1,16,6,7,8,9]):void 0);
  return { id: id25, diagram: diagram2 };
}, "loader");
var plugin21 = {
  id: id25,
  detector: detector25,
  loader: loader25
};
var blockDetector_default = plugin21;

// src/diagrams/architecture/architectureDetector.ts
var id26 = "architecture";
var detector26 = /* @__PURE__ */ __name((txt) => {
  return /^\s*architecture/.test(txt);
}, "detector");
var loader26 = /* @__PURE__ */ __name(async () => {
  const { diagram: diagram2 } = await __vitePreload(async () => { const { diagram: diagram2 } = await import('./architectureDiagram-KFL7JDKH-LHehzboI.js');return { diagram: diagram2 }},true              ?__vite__mapDeps([49,19,21,2,4,5,43,6,7,8,9]):void 0);
  return { id: id26, diagram: diagram2 };
}, "loader");
var architecture = {
  id: id26,
  detector: detector26,
  loader: loader26
};
var architectureDetector_default = architecture;

// src/diagrams/treemap/detector.ts
var id27 = "treemap";
var detector27 = /* @__PURE__ */ __name((txt) => {
  return /^\s*treemap/.test(txt);
}, "detector");
var loader27 = /* @__PURE__ */ __name(async () => {
  const { diagram: diagram2 } = await __vitePreload(async () => { const { diagram: diagram2 } = await import('./diagram-4IRLE6MV-Cvf_Eytc.js');return { diagram: diagram2 }},true              ?__vite__mapDeps([50,15,19,21,2,4,5,25,29,24,6,7,8,9]):void 0);
  return { id: id27, diagram: diagram2 };
}, "loader");
var treemap = {
  id: id27,
  detector: detector27,
  loader: loader27
};

// src/diagram-api/diagram-orchestration.ts
var hasLoadedDiagrams = false;
var addDiagrams = /* @__PURE__ */ __name(() => {
  if (hasLoadedDiagrams) {
    return;
  }
  hasLoadedDiagrams = true;
  registerDiagram("error", errorDiagram_default, (text) => {
    return text.toLowerCase().trim() === "error";
  });
  registerDiagram(
    "---",
    // --- diagram type may appear if YAML front-matter is not parsed correctly
    {
      db: {
        clear: /* @__PURE__ */ __name(() => {
        }, "clear")
      },
      styles: {},
      // should never be used
      renderer: {
        draw: /* @__PURE__ */ __name(() => {
        }, "draw")
      },
      parser: {
        parse: /* @__PURE__ */ __name(() => {
          throw new Error(
            "Diagrams beginning with --- are not valid. If you were trying to use a YAML front-matter, please ensure that you've correctly opened and closed the YAML front-matter with un-indented `---` blocks"
          );
        }, "parse")
      },
      init: /* @__PURE__ */ __name(() => null, "init")
      // no op
    },
    (text) => {
      return text.toLowerCase().trimStart().startsWith("---");
    }
  );
  {
    registerLazyLoadedDiagrams(detector_default, detector_default3, architectureDetector_default);
  }
  registerLazyLoadedDiagrams(
    c4Detector_default,
    detector_default4,
    classDetector_V2_default,
    classDetector_default,
    erDetector_default,
    ganttDetector_default,
    info,
    pie,
    requirementDetector_default,
    sequenceDetector_default,
    flowDetector_v2_default,
    flowDetector_default,
    detector_default2,
    gitGraphDetector_default,
    stateDetector_V2_default,
    stateDetector_default,
    journeyDetector_default,
    quadrantDetector_default,
    sankeyDetector_default,
    packet,
    xychartDetector_default,
    blockDetector_default,
    radar,
    treemap
  );
}, "addDiagrams");

// src/diagram-api/loadDiagram.ts
var loadRegisteredDiagrams = /* @__PURE__ */ __name(async () => {
  log.debug(`Loading registered diagrams`);
  const results = await Promise.allSettled(
    Object.entries(detectors).map(async ([key, { detector: detector28, loader: loader28 }]) => {
      if (!loader28) {
        return;
      }
      try {
        getDiagram(key);
      } catch {
        try {
          const { diagram: diagram2, id: id28 } = await loader28();
          registerDiagram(id28, diagram2, detector28);
        } catch (err) {
          log.error(`Failed to load external diagram with key ${key}. Removing from detectors.`);
          delete detectors[key];
          throw err;
        }
      }
    })
  );
  const failed = results.filter((result) => result.status === "rejected");
  if (failed.length > 0) {
    log.error(`Failed to load ${failed.length} external diagrams`);
    for (const res of failed) {
      log.error(res);
    }
    throw new Error(`Failed to load ${failed.length} external diagrams`);
  }
}, "loadRegisteredDiagrams");

// src/accessibility.ts
var SVG_ROLE = "graphics-document document";
function setA11yDiagramInfo(svg, diagramType) {
  svg.attr("role", SVG_ROLE);
  if (diagramType !== "") {
    svg.attr("aria-roledescription", diagramType);
  }
}
__name(setA11yDiagramInfo, "setA11yDiagramInfo");
function addSVGa11yTitleDescription(svg, a11yTitle, a11yDesc, baseId) {
  if (svg.insert === void 0) {
    return;
  }
  if (a11yDesc) {
    const descId = `chart-desc-${baseId}`;
    svg.attr("aria-describedby", descId);
    svg.insert("desc", ":first-child").attr("id", descId).text(a11yDesc);
  }
  if (a11yTitle) {
    const titleId = `chart-title-${baseId}`;
    svg.attr("aria-labelledby", titleId);
    svg.insert("title", ":first-child").attr("id", titleId).text(a11yTitle);
  }
}
__name(addSVGa11yTitleDescription, "addSVGa11yTitleDescription");

// src/Diagram.ts
var Diagram = class _Diagram {
  constructor(type, text, db, parser, renderer2) {
    this.type = type;
    this.text = text;
    this.db = db;
    this.parser = parser;
    this.renderer = renderer2;
  }
  static {
    __name(this, "Diagram");
  }
  static async fromText(text, metadata = {}) {
    const config = getConfig();
    const type = detectType$1(text, config);
    text = encodeEntities(text) + "\n";
    try {
      getDiagram(type);
    } catch {
      const loader28 = getDiagramLoader(type);
      if (!loader28) {
        throw new UnknownDiagramError(`Diagram ${type} not found.`);
      }
      const { id: id28, diagram: diagram2 } = await loader28();
      registerDiagram(id28, diagram2);
    }
    const { db, parser, renderer: renderer2, init: init2 } = getDiagram(type);
    if (parser.parser) {
      parser.parser.yy = db;
    }
    db.clear?.();
    init2?.(config);
    if (metadata.title) {
      db.setDiagramTitle?.(metadata.title);
    }
    await parser.parse(text);
    return new _Diagram(type, text, db, parser, renderer2);
  }
  async render(id28, version) {
    await this.renderer.draw(this.text, id28, version, this);
  }
  getParser() {
    return this.parser;
  }
  getType() {
    return this.type;
  }
};

// src/interactionDb.ts
var interactionFunctions = [];
var attachFunctions = /* @__PURE__ */ __name(() => {
  interactionFunctions.forEach((f) => {
    f();
  });
  interactionFunctions = [];
}, "attachFunctions");

// src/diagram-api/comments.ts
var cleanupComments = /* @__PURE__ */ __name((text) => {
  return text.replace(/^\s*%%(?!{)[^\n]+\n?/gm, "").trimStart();
}, "cleanupComments");

// src/diagram-api/frontmatter.ts
function extractFrontMatter(text) {
  const matches = text.match(frontMatterRegex);
  if (!matches) {
    return {
      text,
      metadata: {}
    };
  }
  let parsed = load(matches[1], {
    // To support config, we need JSON schema.
    // https://www.yaml.org/spec/1.2/spec.html#id2803231
    schema: JSON_SCHEMA
  }) ?? {};
  parsed = typeof parsed === "object" && !Array.isArray(parsed) ? parsed : {};
  const metadata = {};
  if (parsed.displayMode) {
    metadata.displayMode = parsed.displayMode.toString();
  }
  if (parsed.title) {
    metadata.title = parsed.title.toString();
  }
  if (parsed.config) {
    metadata.config = parsed.config;
  }
  return {
    text: text.slice(matches[0].length),
    metadata
  };
}
__name(extractFrontMatter, "extractFrontMatter");

// src/preprocess.ts
var cleanupText = /* @__PURE__ */ __name((code) => {
  return code.replace(/\r\n?/g, "\n").replace(
    /<(\w+)([^>]*)>/g,
    (match, tag, attributes) => "<" + tag + attributes.replace(/="([^"]*)"/g, "='$1'") + ">"
  );
}, "cleanupText");
var processFrontmatter = /* @__PURE__ */ __name((code) => {
  const { text, metadata } = extractFrontMatter(code);
  const { displayMode, title, config = {} } = metadata;
  if (displayMode) {
    if (!config.gantt) {
      config.gantt = {};
    }
    config.gantt.displayMode = displayMode;
  }
  return { title, config, text };
}, "processFrontmatter");
var processDirectives = /* @__PURE__ */ __name((code) => {
  const initDirective = utils_default.detectInit(code) ?? {};
  const wrapDirectives = utils_default.detectDirective(code, "wrap");
  if (Array.isArray(wrapDirectives)) {
    initDirective.wrap = wrapDirectives.some(({ type }) => type === "wrap");
  } else if (wrapDirectives?.type === "wrap") {
    initDirective.wrap = true;
  }
  return {
    text: removeDirectives(code),
    directive: initDirective
  };
}, "processDirectives");
function preprocessDiagram(code) {
  const cleanedCode = cleanupText(code);
  const frontMatterResult = processFrontmatter(cleanedCode);
  const directiveResult = processDirectives(frontMatterResult.text);
  const config = cleanAndMerge(frontMatterResult.config, directiveResult.directive);
  code = cleanupComments(directiveResult.text);
  return {
    code,
    title: frontMatterResult.title,
    config
  };
}
__name(preprocessDiagram, "preprocessDiagram");

// src/utils/base64.ts
function toBase64(str) {
  const utf8Bytes = new TextEncoder().encode(str);
  const utf8Str = Array.from(utf8Bytes, (byte) => String.fromCodePoint(byte)).join("");
  return btoa(utf8Str);
}
__name(toBase64, "toBase64");

// src/mermaidAPI.ts
var MAX_TEXTLENGTH = 5e4;
var MAX_TEXTLENGTH_EXCEEDED_MSG = "graph TB;a[Maximum text size in diagram exceeded];style a fill:#faa";
var SECURITY_LVL_SANDBOX = "sandbox";
var SECURITY_LVL_LOOSE = "loose";
var XMLNS_SVG_STD = "http://www.w3.org/2000/svg";
var XMLNS_XLINK_STD = "http://www.w3.org/1999/xlink";
var XMLNS_XHTML_STD = "http://www.w3.org/1999/xhtml";
var IFRAME_WIDTH = "100%";
var IFRAME_HEIGHT = "100%";
var IFRAME_STYLES = "border:0;margin:0;";
var IFRAME_BODY_STYLE = "margin:0";
var IFRAME_SANDBOX_OPTS = "allow-top-navigation-by-user-activation allow-popups";
var IFRAME_NOT_SUPPORTED_MSG = 'The "iframe" tag is not supported by your browser.';
var DOMPURIFY_TAGS = ["foreignobject"];
var DOMPURIFY_ATTR = ["dominant-baseline"];
function processAndSetConfigs(text) {
  const processed = preprocessDiagram(text);
  reset();
  addDirective(processed.config ?? {});
  return processed;
}
__name(processAndSetConfigs, "processAndSetConfigs");
async function parse(text, parseOptions) {
  addDiagrams();
  try {
    const { code, config } = processAndSetConfigs(text);
    const diagram2 = await getDiagramFromText(code);
    return { diagramType: diagram2.type, config };
  } catch (error) {
    if (parseOptions?.suppressErrors) {
      return false;
    }
    throw error;
  }
}
__name(parse, "parse");
var cssImportantStyles = /* @__PURE__ */ __name((cssClass, element, cssClasses = []) => {
  return `
.${cssClass} ${element} { ${cssClasses.join(" !important; ")} !important; }`;
}, "cssImportantStyles");
var createCssStyles = /* @__PURE__ */ __name((config, classDefs = /* @__PURE__ */ new Map()) => {
  let cssStyles = "";
  if (config.themeCSS !== void 0) {
    cssStyles += `
${config.themeCSS}`;
  }
  if (config.fontFamily !== void 0) {
    cssStyles += `
:root { --mermaid-font-family: ${config.fontFamily}}`;
  }
  if (config.altFontFamily !== void 0) {
    cssStyles += `
:root { --mermaid-alt-font-family: ${config.altFontFamily}}`;
  }
  if (classDefs instanceof Map) {
    const htmlLabels = config.htmlLabels ?? config.flowchart?.htmlLabels;
    const cssHtmlElements = ["> *", "span"];
    const cssShapeElements = ["rect", "polygon", "ellipse", "circle", "path"];
    const cssElements = htmlLabels ? cssHtmlElements : cssShapeElements;
    classDefs.forEach((styleClassDef) => {
      if (!isEmpty(styleClassDef.styles)) {
        cssElements.forEach((cssElement) => {
          cssStyles += cssImportantStyles(styleClassDef.id, cssElement, styleClassDef.styles);
        });
      }
      if (!isEmpty(styleClassDef.textStyles)) {
        cssStyles += cssImportantStyles(
          styleClassDef.id,
          "tspan",
          (styleClassDef?.textStyles || []).map((s) => s.replace("color", "fill"))
        );
      }
    });
  }
  return cssStyles;
}, "createCssStyles");
var createUserStyles = /* @__PURE__ */ __name((config, graphType, classDefs, svgId) => {
  const userCSSstyles = createCssStyles(config, classDefs);
  const allStyles = styles_default(graphType, userCSSstyles, config.themeVariables);
  return serialize(compile(`${svgId}{${allStyles}}`), stringify);
}, "createUserStyles");
var cleanUpSvgCode = /* @__PURE__ */ __name((svgCode = "", inSandboxMode, useArrowMarkerUrls) => {
  let cleanedUpSvg = svgCode;
  if (!useArrowMarkerUrls && !inSandboxMode) {
    cleanedUpSvg = cleanedUpSvg.replace(
      /marker-end="url\([\d+./:=?A-Za-z-]*?#/g,
      'marker-end="url(#'
    );
  }
  cleanedUpSvg = decodeEntities(cleanedUpSvg);
  cleanedUpSvg = cleanedUpSvg.replace(/<br>/g, "<br/>");
  return cleanedUpSvg;
}, "cleanUpSvgCode");
var putIntoIFrame = /* @__PURE__ */ __name((svgCode = "", svgElement) => {
  const height = svgElement?.viewBox?.baseVal?.height ? svgElement.viewBox.baseVal.height + "px" : IFRAME_HEIGHT;
  const base64encodedSrc = toBase64(`<body style="${IFRAME_BODY_STYLE}">${svgCode}</body>`);
  return `<iframe style="width:${IFRAME_WIDTH};height:${height};${IFRAME_STYLES}" src="data:text/html;charset=UTF-8;base64,${base64encodedSrc}" sandbox="${IFRAME_SANDBOX_OPTS}">
  ${IFRAME_NOT_SUPPORTED_MSG}
</iframe>`;
}, "putIntoIFrame");
var appendDivSvgG = /* @__PURE__ */ __name((parentRoot, id28, enclosingDivId, divStyle, svgXlink) => {
  const enclosingDiv = parentRoot.append("div");
  enclosingDiv.attr("id", enclosingDivId);
  if (divStyle) {
    enclosingDiv.attr("style", divStyle);
  }
  const svgNode = enclosingDiv.append("svg").attr("id", id28).attr("width", "100%").attr("xmlns", XMLNS_SVG_STD);
  if (svgXlink) {
    svgNode.attr("xmlns:xlink", svgXlink);
  }
  svgNode.append("g");
  return parentRoot;
}, "appendDivSvgG");
function sandboxedIframe(parentNode, iFrameId) {
  return parentNode.append("iframe").attr("id", iFrameId).attr("style", "width: 100%; height: 100%;").attr("sandbox", "");
}
__name(sandboxedIframe, "sandboxedIframe");
var removeExistingElements = /* @__PURE__ */ __name((doc, id28, divId, iFrameId) => {
  doc.getElementById(id28)?.remove();
  doc.getElementById(divId)?.remove();
  doc.getElementById(iFrameId)?.remove();
}, "removeExistingElements");
var render = /* @__PURE__ */ __name(async function(id28, text, svgContainingElement) {
  addDiagrams();
  const processed = processAndSetConfigs(text);
  text = processed.code;
  const config = getConfig();
  log.debug(config);
  if (text.length > (config?.maxTextSize ?? MAX_TEXTLENGTH)) {
    text = MAX_TEXTLENGTH_EXCEEDED_MSG;
  }
  const idSelector = "#" + id28;
  const iFrameID = "i" + id28;
  const iFrameID_selector = "#" + iFrameID;
  const enclosingDivID = "d" + id28;
  const enclosingDivID_selector = "#" + enclosingDivID;
  const removeTempElements = /* @__PURE__ */ __name(() => {
    const tmpElementSelector = isSandboxed ? iFrameID_selector : enclosingDivID_selector;
    const node = select(tmpElementSelector).node();
    if (node && "remove" in node) {
      node.remove();
    }
  }, "removeTempElements");
  let root = select("body");
  const isSandboxed = config.securityLevel === SECURITY_LVL_SANDBOX;
  const isLooseSecurityLevel = config.securityLevel === SECURITY_LVL_LOOSE;
  const fontFamily = config.fontFamily;
  if (svgContainingElement !== void 0) {
    if (svgContainingElement) {
      svgContainingElement.innerHTML = "";
    }
    if (isSandboxed) {
      const iframe = sandboxedIframe(select(svgContainingElement), iFrameID);
      root = select(iframe.nodes()[0].contentDocument.body);
      root.node().style.margin = 0;
    } else {
      root = select(svgContainingElement);
    }
    appendDivSvgG(root, id28, enclosingDivID, `font-family: ${fontFamily}`, XMLNS_XLINK_STD);
  } else {
    removeExistingElements(document, id28, enclosingDivID, iFrameID);
    if (isSandboxed) {
      const iframe = sandboxedIframe(select("body"), iFrameID);
      root = select(iframe.nodes()[0].contentDocument.body);
      root.node().style.margin = 0;
    } else {
      root = select("body");
    }
    appendDivSvgG(root, id28, enclosingDivID);
  }
  let diag;
  let parseEncounteredException;
  try {
    diag = await Diagram.fromText(text, { title: processed.title });
  } catch (error) {
    if (config.suppressErrorRendering) {
      removeTempElements();
      throw error;
    }
    diag = await Diagram.fromText("error");
    parseEncounteredException = error;
  }
  const element = root.select(enclosingDivID_selector).node();
  const diagramType = diag.type;
  const svg = element.firstChild;
  const firstChild = svg.firstChild;
  const diagramClassDefs = diag.renderer.getClasses?.(text, diag);
  const rules = createUserStyles(config, diagramType, diagramClassDefs, idSelector);
  const style1 = document.createElement("style");
  style1.innerHTML = rules;
  svg.insertBefore(style1, firstChild);
  try {
    await diag.renderer.draw(text, id28, package_default.version, diag);
  } catch (e) {
    if (config.suppressErrorRendering) {
      removeTempElements();
    } else {
      errorRenderer_default.draw(text, id28, package_default.version);
    }
    throw e;
  }
  const svgNode = root.select(`${enclosingDivID_selector} svg`);
  const a11yTitle = diag.db.getAccTitle?.();
  const a11yDescr = diag.db.getAccDescription?.();
  addA11yInfo(diagramType, svgNode, a11yTitle, a11yDescr);
  root.select(`[id="${id28}"]`).selectAll("foreignobject > *").attr("xmlns", XMLNS_XHTML_STD);
  let svgCode = root.select(enclosingDivID_selector).node().innerHTML;
  log.debug("config.arrowMarkerAbsolute", config.arrowMarkerAbsolute);
  svgCode = cleanUpSvgCode(svgCode, isSandboxed, evaluate(config.arrowMarkerAbsolute));
  if (isSandboxed) {
    const svgEl = root.select(enclosingDivID_selector + " svg").node();
    svgCode = putIntoIFrame(svgCode, svgEl);
  } else if (!isLooseSecurityLevel) {
    svgCode = purify.sanitize(svgCode, {
      ADD_TAGS: DOMPURIFY_TAGS,
      ADD_ATTR: DOMPURIFY_ATTR,
      HTML_INTEGRATION_POINTS: { foreignobject: true }
    });
  }
  attachFunctions();
  if (parseEncounteredException) {
    throw parseEncounteredException;
  }
  removeTempElements();
  return {
    diagramType,
    svg: svgCode,
    bindFunctions: diag.db.bindFunctions
  };
}, "render");
function initialize(userOptions = {}) {
  const options = assignWithDepth_default({}, userOptions);
  if (options?.fontFamily && !options.themeVariables?.fontFamily) {
    if (!options.themeVariables) {
      options.themeVariables = {};
    }
    options.themeVariables.fontFamily = options.fontFamily;
  }
  saveConfigFromInitialize(options);
  if (options?.theme && options.theme in themes_default) {
    options.themeVariables = themes_default[options.theme].getThemeVariables(
      options.themeVariables
    );
  } else if (options) {
    options.themeVariables = themes_default.default.getThemeVariables(options.themeVariables);
  }
  const config = typeof options === "object" ? setSiteConfig(options) : getSiteConfig();
  setLogLevel(config.logLevel);
  addDiagrams();
}
__name(initialize, "initialize");
var getDiagramFromText = /* @__PURE__ */ __name((text, metadata = {}) => {
  const { code } = preprocessDiagram(text);
  return Diagram.fromText(code, metadata);
}, "getDiagramFromText");
function addA11yInfo(diagramType, svgNode, a11yTitle, a11yDescr) {
  setA11yDiagramInfo(svgNode, diagramType);
  addSVGa11yTitleDescription(svgNode, a11yTitle, a11yDescr, svgNode.attr("id"));
}
__name(addA11yInfo, "addA11yInfo");
var mermaidAPI = Object.freeze({
  render,
  parse,
  getDiagramFromText,
  initialize,
  getConfig,
  setConfig,
  getSiteConfig,
  updateSiteConfig,
  reset: /* @__PURE__ */ __name(() => {
    reset();
  }, "reset"),
  globalReset: /* @__PURE__ */ __name(() => {
    reset(defaultConfig);
  }, "globalReset"),
  defaultConfig
});
setLogLevel(getConfig().logLevel);
reset(getConfig());

// src/mermaid.ts
var handleError = /* @__PURE__ */ __name((error, errors, parseError) => {
  log.warn(error);
  if (isDetailedError(error)) {
    if (parseError) {
      parseError(error.str, error.hash);
    }
    errors.push({ ...error, message: error.str, error });
  } else {
    if (parseError) {
      parseError(error);
    }
    if (error instanceof Error) {
      errors.push({
        str: error.message,
        message: error.message,
        hash: error.name,
        error
      });
    }
  }
}, "handleError");
var run = /* @__PURE__ */ __name(async function(options = {
  querySelector: ".mermaid"
}) {
  try {
    await runThrowsErrors(options);
  } catch (e) {
    if (isDetailedError(e)) {
      log.error(e.str);
    }
    if (mermaid.parseError) {
      mermaid.parseError(e);
    }
    if (!options.suppressErrors) {
      log.error("Use the suppressErrors option to suppress these errors");
      throw e;
    }
  }
}, "run");
var runThrowsErrors = /* @__PURE__ */ __name(async function({ postRenderCallback, querySelector, nodes } = {
  querySelector: ".mermaid"
}) {
  const conf = mermaidAPI.getConfig();
  log.debug(`${!postRenderCallback ? "No " : ""}Callback function found`);
  let nodesToProcess;
  if (nodes) {
    nodesToProcess = nodes;
  } else if (querySelector) {
    nodesToProcess = document.querySelectorAll(querySelector);
  } else {
    throw new Error("Nodes and querySelector are both undefined");
  }
  log.debug(`Found ${nodesToProcess.length} diagrams`);
  if (conf?.startOnLoad !== void 0) {
    log.debug("Start On Load: " + conf?.startOnLoad);
    mermaidAPI.updateSiteConfig({ startOnLoad: conf?.startOnLoad });
  }
  const idGenerator = new utils_default.InitIDGenerator(conf.deterministicIds, conf.deterministicIDSeed);
  let txt;
  const errors = [];
  for (const element of Array.from(nodesToProcess)) {
    log.info("Rendering diagram: " + element.id);
    if (element.getAttribute("data-processed")) {
      continue;
    }
    element.setAttribute("data-processed", "true");
    const id28 = `mermaid-${idGenerator.next()}`;
    txt = element.innerHTML;
    txt = dedent(utils_default.entityDecode(txt)).trim().replace(/<br\s*\/?>/gi, "<br/>");
    const init2 = utils_default.detectInit(txt);
    if (init2) {
      log.debug("Detected early reinit: ", init2);
    }
    try {
      const { svg, bindFunctions } = await render2(id28, txt, element);
      element.innerHTML = svg;
      if (postRenderCallback) {
        await postRenderCallback(id28);
      }
      if (bindFunctions) {
        bindFunctions(element);
      }
    } catch (error) {
      handleError(error, errors, mermaid.parseError);
    }
  }
  if (errors.length > 0) {
    throw errors[0];
  }
}, "runThrowsErrors");
var initialize2 = /* @__PURE__ */ __name(function(config) {
  mermaidAPI.initialize(config);
}, "initialize");
var init = /* @__PURE__ */ __name(async function(config, nodes, callback) {
  log.warn("mermaid.init is deprecated. Please use run instead.");
  if (config) {
    initialize2(config);
  }
  const runOptions = { postRenderCallback: callback, querySelector: ".mermaid" };
  if (typeof nodes === "string") {
    runOptions.querySelector = nodes;
  } else if (nodes) {
    if (nodes instanceof HTMLElement) {
      runOptions.nodes = [nodes];
    } else {
      runOptions.nodes = nodes;
    }
  }
  await run(runOptions);
}, "init");
var registerExternalDiagrams = /* @__PURE__ */ __name(async (diagrams, {
  lazyLoad = true
} = {}) => {
  addDiagrams();
  registerLazyLoadedDiagrams(...diagrams);
  if (lazyLoad === false) {
    await loadRegisteredDiagrams();
  }
}, "registerExternalDiagrams");
var contentLoaded = /* @__PURE__ */ __name(function() {
  if (mermaid.startOnLoad) {
    const { startOnLoad } = mermaidAPI.getConfig();
    if (startOnLoad) {
      mermaid.run().catch((err) => log.error("Mermaid failed to initialize", err));
    }
  }
}, "contentLoaded");
if (typeof document !== "undefined") {
  window.addEventListener("load", contentLoaded, false);
}
var setParseErrorHandler = /* @__PURE__ */ __name(function(parseErrorHandler) {
  mermaid.parseError = parseErrorHandler;
}, "setParseErrorHandler");
var executionQueue = [];
var executionQueueRunning = false;
var executeQueue = /* @__PURE__ */ __name(async () => {
  if (executionQueueRunning) {
    return;
  }
  executionQueueRunning = true;
  while (executionQueue.length > 0) {
    const f = executionQueue.shift();
    if (f) {
      try {
        await f();
      } catch (e) {
        log.error("Error executing queue", e);
      }
    }
  }
  executionQueueRunning = false;
}, "executeQueue");
var parse2 = /* @__PURE__ */ __name(async (text, parseOptions) => {
  return new Promise((resolve, reject) => {
    const performCall = /* @__PURE__ */ __name(() => new Promise((res, rej) => {
      mermaidAPI.parse(text, parseOptions).then(
        (r) => {
          res(r);
          resolve(r);
        },
        (e) => {
          log.error("Error parsing", e);
          mermaid.parseError?.(e);
          rej(e);
          reject(e);
        }
      );
    }), "performCall");
    executionQueue.push(performCall);
    executeQueue().catch(reject);
  });
}, "parse");
var render2 = /* @__PURE__ */ __name((id28, text, container) => {
  return new Promise((resolve, reject) => {
    const performCall = /* @__PURE__ */ __name(() => new Promise((res, rej) => {
      mermaidAPI.render(id28, text, container).then(
        (r) => {
          res(r);
          resolve(r);
        },
        (e) => {
          log.error("Error parsing", e);
          mermaid.parseError?.(e);
          rej(e);
          reject(e);
        }
      );
    }), "performCall");
    executionQueue.push(performCall);
    executeQueue().catch(reject);
  });
}, "render");
var getRegisteredDiagramsMetadata = /* @__PURE__ */ __name(() => {
  return Object.keys(detectors).map((id28) => ({
    id: id28
  }));
}, "getRegisteredDiagramsMetadata");
var mermaid = {
  startOnLoad: true,
  mermaidAPI,
  parse: parse2,
  render: render2,
  init,
  run,
  registerExternalDiagrams,
  registerLayoutLoaders,
  initialize: initialize2,
  parseError: void 0,
  contentLoaded,
  setParseErrorHandler,
  detectType: detectType$1,
  registerIconPacks,
  getRegisteredDiagramsMetadata
};
var mermaid_default = mermaid;
/*! Check if previously processed */
/*!
 * Wait for document loaded before starting the execution
 */

const MermaidDiagram = ({ chart, className = "" }) => {
  const [error, setError] = reactExports.useState(null);
  const [svgContent, setSvgContent] = reactExports.useState("");
  reactExports.useEffect(() => {
    mermaid_default.initialize({
      startOnLoad: false,
      theme: "default",
      themeVariables: {
        // Use VS Code theme colors for consistency
        primaryColor: "#007acc",
        primaryTextColor: "#cccccc",
        primaryBorderColor: "#007acc",
        lineColor: "#cccccc",
        secondaryColor: "#1e1e1e",
        tertiaryColor: "#252526",
        errorBkgColor: "#f48771",
        errorTextColor: "#ffffff",
        warningBkgColor: "#cca700",
        warningTextColor: "#ffffff",
        infoBkgColor: "#007acc",
        infoTextColor: "#ffffff",
        noteBkgColor: "#252526",
        noteTextColor: "#cccccc",
        noteBorderColor: "#007acc",
        successBkgColor: "#4caf50",
        successTextColor: "#ffffff",
        failureBkgColor: "#f44336",
        failureTextColor: "#ffffff",
        darkMode: true
      }
    });
  }, []);
  reactExports.useEffect(() => {
    if (!chart) return;
    const renderDiagram = async () => {
      try {
        setError(null);
        const { svg } = await mermaid_default.render(`mermaid-${Date.now()}`, chart);
        setSvgContent(svg);
      } catch (err) {
        console.error("Error rendering Mermaid diagram:", err);
        setError(err instanceof Error ? err.message : "Failed to render diagram");
      }
    };
    renderDiagram();
  }, [chart]);
  if (error) {
    return /* @__PURE__ */ jsxDevRuntimeExports.jsxDEV("div", { className: `mermaid-error ${className}`.trim(), children: /* @__PURE__ */ jsxDevRuntimeExports.jsxDEV("div", { className: "bg-red-100 border border-red-400 text-red-700 px-4 py-3 rounded", children: [
      /* @__PURE__ */ jsxDevRuntimeExports.jsxDEV("strong", { children: "Diagram Error:" }, void 0, false, {
        fileName: "/workspace/personal-blog/src/components/MermaidDiagram/MermaidDiagram.tsx",
        lineNumber: 67,
        columnNumber: 21
      }, undefined),
      " ",
      error,
      /* @__PURE__ */ jsxDevRuntimeExports.jsxDEV("details", { className: "mt-2", children: [
        /* @__PURE__ */ jsxDevRuntimeExports.jsxDEV("summary", { className: "cursor-pointer text-sm", children: "Show Mermaid Code" }, void 0, false, {
          fileName: "/workspace/personal-blog/src/components/MermaidDiagram/MermaidDiagram.tsx",
          lineNumber: 69,
          columnNumber: 25
        }, undefined),
        /* @__PURE__ */ jsxDevRuntimeExports.jsxDEV("pre", { className: "mt-2 text-xs bg-red-50 p-2 rounded overflow-x-auto", children: /* @__PURE__ */ jsxDevRuntimeExports.jsxDEV("code", { children: chart }, void 0, false, {
          fileName: "/workspace/personal-blog/src/components/MermaidDiagram/MermaidDiagram.tsx",
          lineNumber: 71,
          columnNumber: 29
        }, undefined) }, void 0, false, {
          fileName: "/workspace/personal-blog/src/components/MermaidDiagram/MermaidDiagram.tsx",
          lineNumber: 70,
          columnNumber: 25
        }, undefined)
      ] }, void 0, true, {
        fileName: "/workspace/personal-blog/src/components/MermaidDiagram/MermaidDiagram.tsx",
        lineNumber: 68,
        columnNumber: 21
      }, undefined)
    ] }, void 0, true, {
      fileName: "/workspace/personal-blog/src/components/MermaidDiagram/MermaidDiagram.tsx",
      lineNumber: 66,
      columnNumber: 17
    }, undefined) }, void 0, false, {
      fileName: "/workspace/personal-blog/src/components/MermaidDiagram/MermaidDiagram.tsx",
      lineNumber: 65,
      columnNumber: 13
    }, undefined);
  }
  if (!svgContent) {
    return /* @__PURE__ */ jsxDevRuntimeExports.jsxDEV("div", { className: `mermaid-container ${className}`.trim(), children: /* @__PURE__ */ jsxDevRuntimeExports.jsxDEV("div", { className: "text-center text-gray-500", children: "Rendering diagram..." }, void 0, false, {
      fileName: "/workspace/personal-blog/src/components/MermaidDiagram/MermaidDiagram.tsx",
      lineNumber: 82,
      columnNumber: 17
    }, undefined) }, void 0, false, {
      fileName: "/workspace/personal-blog/src/components/MermaidDiagram/MermaidDiagram.tsx",
      lineNumber: 81,
      columnNumber: 13
    }, undefined);
  }
  return /* @__PURE__ */ jsxDevRuntimeExports.jsxDEV("div", { className: `mermaid-container ${className}`.trim(), children: /* @__PURE__ */ jsxDevRuntimeExports.jsxDEV(
    "div",
    {
      dangerouslySetInnerHTML: { __html: svgContent },
      style: { textAlign: "center" }
    },
    void 0,
    false,
    {
      fileName: "/workspace/personal-blog/src/components/MermaidDiagram/MermaidDiagram.tsx",
      lineNumber: 89,
      columnNumber: 13
    },
    undefined
  ) }, void 0, false, {
    fileName: "/workspace/personal-blog/src/components/MermaidDiagram/MermaidDiagram.tsx",
    lineNumber: 88,
    columnNumber: 9
  }, undefined);
};

const MarkdownRenderer = ({
  content,
  className = "",
  options = {},
  loadingState,
  loadingStateData,
  emptyContentMessage = "No content to display"
}) => {
  const {
    highlightCode = true
  } = options;
  const plugins = reactExports.useMemo(() => {
    const pluginList = [remarkGfm];
    return pluginList;
  }, []);
  const rehypePlugins = reactExports.useMemo(() => {
    const rehypeList = [];
    if (highlightCode) {
      rehypeList.push(rehypeHighlight);
    }
    return rehypeList;
  }, [highlightCode]);
  if (loadingState === "loading") {
    return /* @__PURE__ */ jsxDevRuntimeExports.jsxDEV("div", { className: `markdown-renderer loading ${className}`.trim(), children: /* @__PURE__ */ jsxDevRuntimeExports.jsxDEV("div", { className: "loading-spinner", children: "Loading..." }, void 0, false, {
      fileName: "/workspace/personal-blog/src/components/MarkdownRenderer/MarkdownRenderer.tsx",
      lineNumber: 57,
      columnNumber: 17
    }, undefined) }, void 0, false, {
      fileName: "/workspace/personal-blog/src/components/MarkdownRenderer/MarkdownRenderer.tsx",
      lineNumber: 56,
      columnNumber: 13
    }, undefined);
  }
  if (loadingState === "error") {
    return /* @__PURE__ */ jsxDevRuntimeExports.jsxDEV("div", { className: `markdown-renderer error ${className}`.trim(), children: /* @__PURE__ */ jsxDevRuntimeExports.jsxDEV("div", { className: "error-message", children: [
      /* @__PURE__ */ jsxDevRuntimeExports.jsxDEV("p", { children: "Error loading content" }, void 0, false, {
        fileName: "/workspace/personal-blog/src/components/MarkdownRenderer/MarkdownRenderer.tsx",
        lineNumber: 67,
        columnNumber: 21
      }, undefined),
      loadingStateData?.error && /* @__PURE__ */ jsxDevRuntimeExports.jsxDEV("p", { children: [
        "Details: ",
        loadingStateData.error
      ] }, void 0, true, {
        fileName: "/workspace/personal-blog/src/components/MarkdownRenderer/MarkdownRenderer.tsx",
        lineNumber: 69,
        columnNumber: 25
      }, undefined)
    ] }, void 0, true, {
      fileName: "/workspace/personal-blog/src/components/MarkdownRenderer/MarkdownRenderer.tsx",
      lineNumber: 66,
      columnNumber: 17
    }, undefined) }, void 0, false, {
      fileName: "/workspace/personal-blog/src/components/MarkdownRenderer/MarkdownRenderer.tsx",
      lineNumber: 65,
      columnNumber: 13
    }, undefined);
  }
  if (!content || content.trim().length === 0) {
    return /* @__PURE__ */ jsxDevRuntimeExports.jsxDEV("div", { className: `markdown-renderer empty ${className}`.trim(), children: /* @__PURE__ */ jsxDevRuntimeExports.jsxDEV("p", { children: emptyContentMessage }, void 0, false, {
      fileName: "/workspace/personal-blog/src/components/MarkdownRenderer/MarkdownRenderer.tsx",
      lineNumber: 80,
      columnNumber: 17
    }, undefined) }, void 0, false, {
      fileName: "/workspace/personal-blog/src/components/MarkdownRenderer/MarkdownRenderer.tsx",
      lineNumber: 79,
      columnNumber: 13
    }, undefined);
  }
  return /* @__PURE__ */ jsxDevRuntimeExports.jsxDEV("div", { className: `markdown-renderer ${className}`.trim(), children: /* @__PURE__ */ jsxDevRuntimeExports.jsxDEV("div", { className: "markdown-content", children: /* @__PURE__ */ jsxDevRuntimeExports.jsxDEV(
    Markdown,
    {
      remarkPlugins: plugins,
      rehypePlugins,
      components: {
        // Custom component overrides for better styling
        h1: ({ children, ...props }) => /* @__PURE__ */ jsxDevRuntimeExports.jsxDEV("h1", { className: "text-3xl font-bold mb-4", ...props, children }, void 0, false, {
          fileName: "/workspace/personal-blog/src/components/MarkdownRenderer/MarkdownRenderer.tsx",
          lineNumber: 94,
          columnNumber: 29
        }, undefined),
        h2: ({ children, ...props }) => /* @__PURE__ */ jsxDevRuntimeExports.jsxDEV("h2", { className: "text-2xl font-bold mb-3", ...props, children }, void 0, false, {
          fileName: "/workspace/personal-blog/src/components/MarkdownRenderer/MarkdownRenderer.tsx",
          lineNumber: 99,
          columnNumber: 29
        }, undefined),
        h3: ({ children, ...props }) => /* @__PURE__ */ jsxDevRuntimeExports.jsxDEV("h3", { className: "text-xl font-bold mb-2", ...props, children }, void 0, false, {
          fileName: "/workspace/personal-blog/src/components/MarkdownRenderer/MarkdownRenderer.tsx",
          lineNumber: 104,
          columnNumber: 29
        }, undefined),
        h4: ({ children, ...props }) => /* @__PURE__ */ jsxDevRuntimeExports.jsxDEV("h4", { className: "text-lg font-semibold mb-2", ...props, children }, void 0, false, {
          fileName: "/workspace/personal-blog/src/components/MarkdownRenderer/MarkdownRenderer.tsx",
          lineNumber: 109,
          columnNumber: 29
        }, undefined),
        h5: ({ children, ...props }) => /* @__PURE__ */ jsxDevRuntimeExports.jsxDEV("h5", { className: "text-base font-semibold mb-2", ...props, children }, void 0, false, {
          fileName: "/workspace/personal-blog/src/components/MarkdownRenderer/MarkdownRenderer.tsx",
          lineNumber: 114,
          columnNumber: 29
        }, undefined),
        h6: ({ children, ...props }) => /* @__PURE__ */ jsxDevRuntimeExports.jsxDEV("h6", { className: "text-sm font-semibold mb-2", ...props, children }, void 0, false, {
          fileName: "/workspace/personal-blog/src/components/MarkdownRenderer/MarkdownRenderer.tsx",
          lineNumber: 119,
          columnNumber: 29
        }, undefined),
        p: ({ children, ...props }) => /* @__PURE__ */ jsxDevRuntimeExports.jsxDEV("p", { className: "mb-4 leading-relaxed", ...props, children }, void 0, false, {
          fileName: "/workspace/personal-blog/src/components/MarkdownRenderer/MarkdownRenderer.tsx",
          lineNumber: 124,
          columnNumber: 29
        }, undefined),
        code: ({ className: className2, children, ...props }) => {
          if (className2 && className2.includes("language-mermaid")) {
            return /* @__PURE__ */ jsxDevRuntimeExports.jsxDEV(
              MermaidDiagram,
              {
                chart: String(children),
                className: "my-6"
              },
              void 0,
              false,
              {
                fileName: "/workspace/personal-blog/src/components/MarkdownRenderer/MarkdownRenderer.tsx",
                lineNumber: 132,
                columnNumber: 37
              },
              undefined
            );
          }
          if (!className2) {
            return /* @__PURE__ */ jsxDevRuntimeExports.jsxDEV(
              "code",
              {
                className: "bg-vs-editor-surface text-vs-editor-text px-1.5 py-0.5 rounded text-sm font-mono border border-vs-editor-border",
                ...props,
                children
              },
              void 0,
              false,
              {
                fileName: "/workspace/personal-blog/src/components/MarkdownRenderer/MarkdownRenderer.tsx",
                lineNumber: 143,
                columnNumber: 37
              },
              undefined
            );
          }
          return /* @__PURE__ */ jsxDevRuntimeExports.jsxDEV(
            "code",
            {
              className: className2,
              ...props,
              children
            },
            void 0,
            false,
            {
              fileName: "/workspace/personal-blog/src/components/MarkdownRenderer/MarkdownRenderer.tsx",
              lineNumber: 154,
              columnNumber: 33
            },
            undefined
          );
        },
        pre: ({ children, ...props }) => /* @__PURE__ */ jsxDevRuntimeExports.jsxDEV("pre", { className: "bg-vs-editor-bg p-4 rounded-lg overflow-x-auto mb-4 border border-vs-editor-border", ...props, children }, void 0, false, {
          fileName: "/workspace/personal-blog/src/components/MarkdownRenderer/MarkdownRenderer.tsx",
          lineNumber: 163,
          columnNumber: 29
        }, undefined),
        blockquote: ({ children, ...props }) => /* @__PURE__ */ jsxDevRuntimeExports.jsxDEV("blockquote", { className: "border-l-4 border-vs-editor-border pl-4 italic mb-4 text-vs-editor-text2", ...props, children }, void 0, false, {
          fileName: "/workspace/personal-blog/src/components/MarkdownRenderer/MarkdownRenderer.tsx",
          lineNumber: 168,
          columnNumber: 29
        }, undefined),
        ul: ({ children, ...props }) => /* @__PURE__ */ jsxDevRuntimeExports.jsxDEV("ul", { className: "list-disc list-inside mb-4 space-y-1", ...props, children }, void 0, false, {
          fileName: "/workspace/personal-blog/src/components/MarkdownRenderer/MarkdownRenderer.tsx",
          lineNumber: 173,
          columnNumber: 29
        }, undefined),
        ol: ({ children, ...props }) => /* @__PURE__ */ jsxDevRuntimeExports.jsxDEV("ol", { className: "list-decimal list-inside mb-4 space-y-1", ...props, children }, void 0, false, {
          fileName: "/workspace/personal-blog/src/components/MarkdownRenderer/MarkdownRenderer.tsx",
          lineNumber: 178,
          columnNumber: 29
        }, undefined),
        li: ({ children, ...props }) => /* @__PURE__ */ jsxDevRuntimeExports.jsxDEV("li", { className: "ml-4", ...props, children }, void 0, false, {
          fileName: "/workspace/personal-blog/src/components/MarkdownRenderer/MarkdownRenderer.tsx",
          lineNumber: 183,
          columnNumber: 29
        }, undefined),
        a: ({ href, children, ...props }) => /* @__PURE__ */ jsxDevRuntimeExports.jsxDEV(
          "a",
          {
            href,
            className: "text-crystal-blue-400 hover:text-crystal-blue-300 underline",
            target: "_blank",
            rel: "noopener noreferrer",
            ...props,
            children
          },
          void 0,
          false,
          {
            fileName: "/workspace/personal-blog/src/components/MarkdownRenderer/MarkdownRenderer.tsx",
            lineNumber: 188,
            columnNumber: 29
          },
          undefined
        ),
        img: ({ src, alt, ...props }) => /* @__PURE__ */ jsxDevRuntimeExports.jsxDEV(
          "img",
          {
            src,
            alt,
            className: "max-w-full h-auto rounded-lg shadow-md mb-4",
            loading: "lazy",
            ...props
          },
          void 0,
          false,
          {
            fileName: "/workspace/personal-blog/src/components/MarkdownRenderer/MarkdownRenderer.tsx",
            lineNumber: 199,
            columnNumber: 29
          },
          undefined
        ),
        table: ({ children, ...props }) => /* @__PURE__ */ jsxDevRuntimeExports.jsxDEV("div", { className: "overflow-x-auto mb-4", children: /* @__PURE__ */ jsxDevRuntimeExports.jsxDEV("table", { className: "min-w-full border-collapse border border-vs-editor-border", ...props, children }, void 0, false, {
          fileName: "/workspace/personal-blog/src/components/MarkdownRenderer/MarkdownRenderer.tsx",
          lineNumber: 209,
          columnNumber: 33
        }, undefined) }, void 0, false, {
          fileName: "/workspace/personal-blog/src/components/MarkdownRenderer/MarkdownRenderer.tsx",
          lineNumber: 208,
          columnNumber: 29
        }, undefined),
        th: ({ children, ...props }) => /* @__PURE__ */ jsxDevRuntimeExports.jsxDEV("th", { className: "border border-vs-editor-border px-4 py-2 bg-vs-editor-surface font-semibold", ...props, children }, void 0, false, {
          fileName: "/workspace/personal-blog/src/components/MarkdownRenderer/MarkdownRenderer.tsx",
          lineNumber: 215,
          columnNumber: 29
        }, undefined),
        td: ({ children, ...props }) => /* @__PURE__ */ jsxDevRuntimeExports.jsxDEV("td", { className: "border border-vs-editor-border px-4 py-2", ...props, children }, void 0, false, {
          fileName: "/workspace/personal-blog/src/components/MarkdownRenderer/MarkdownRenderer.tsx",
          lineNumber: 220,
          columnNumber: 29
        }, undefined),
        hr: () => /* @__PURE__ */ jsxDevRuntimeExports.jsxDEV("hr", { className: "border-t border-vs-editor-border my-6" }, void 0, false, {
          fileName: "/workspace/personal-blog/src/components/MarkdownRenderer/MarkdownRenderer.tsx",
          lineNumber: 225,
          columnNumber: 29
        }, undefined)
      },
      children: content
    },
    void 0,
    false,
    {
      fileName: "/workspace/personal-blog/src/components/MarkdownRenderer/MarkdownRenderer.tsx",
      lineNumber: 88,
      columnNumber: 17
    },
    undefined
  ) }, void 0, false, {
    fileName: "/workspace/personal-blog/src/components/MarkdownRenderer/MarkdownRenderer.tsx",
    lineNumber: 87,
    columnNumber: 13
  }, undefined) }, void 0, false, {
    fileName: "/workspace/personal-blog/src/components/MarkdownRenderer/MarkdownRenderer.tsx",
    lineNumber: 86,
    columnNumber: 9
  }, undefined);
};

const ErrorPage = ({
  error,
  errorType = "generic",
  title,
  message,
  showHomeButton = true,
  showBackButton = true,
  className = ""
}) => {
  const navigate = useNavigate();
  const errorDetails = error;
  const errorMessage = message || (errorDetails instanceof Error ? errorDetails.message : String(errorDetails));
  const getErrorContent = () => {
    switch (errorType) {
      case "not-found":
        return {
          title: title || "Page Not Found",
          message: message || "The page you're looking for doesn't exist.",
          icon: "🔍",
          suggestions: [
            "Check the URL for typos",
            "Use the navigation menu to find what you need",
            "Try searching for content"
          ]
        };
      case "content-error":
        return {
          title: title || "Content Error",
          message: message || "There was a problem loading the requested content.",
          icon: "📄",
          suggestions: [
            "Try refreshing the page",
            "Check your internet connection"
          ]
        };
      case "network-error":
        return {
          title: title || "Network Error",
          message: message || "Unable to connect to the server.",
          icon: "🌐",
          suggestions: [
            "Check your internet connection",
            "Try again in a few moments",
            "Check if the service is available"
          ]
        };
      case "malformed-content":
        return {
          title: title || "Content Format Error",
          message: message || "The requested content has formatting issues.",
          icon: "⚠️",
          suggestions: [
            "Try refreshing the page",
            "Report this issue to support",
            "Try accessing other content"
          ]
        };
      default:
        return {
          title: title || "Something Went Wrong",
          message: message || "An unexpected error occurred.",
          icon: "❌",
          suggestions: [
            "Try refreshing the page",
            "Clear your browser cache"
          ]
        };
    }
  };
  const errorContent = getErrorContent();
  const handleGoHome = () => {
    navigate("/");
  };
  const handleGoBack = () => {
    navigate(-1);
  };
  return /* @__PURE__ */ jsxDevRuntimeExports.jsxDEV("div", { className: `min-h-screen bg-vs-editor-bg flex items-center justify-center px-4 ${className}`, children: /* @__PURE__ */ jsxDevRuntimeExports.jsxDEV("div", { className: "max-w-md w-full bg-vs-editor-surface rounded-lg shadow-lg p-8 text-center", children: [
    /* @__PURE__ */ jsxDevRuntimeExports.jsxDEV("div", { className: "text-6xl mb-4", children: errorContent.icon }, void 0, false, {
      fileName: "/workspace/personal-blog/src/pages/ErrorPage/ErrorPage.tsx",
      lineNumber: 102,
      columnNumber: 17
    }, undefined),
    /* @__PURE__ */ jsxDevRuntimeExports.jsxDEV("h1", { className: "text-2xl font-bold text-vs-editor-text mb-4", children: errorContent.title }, void 0, false, {
      fileName: "/workspace/personal-blog/src/pages/ErrorPage/ErrorPage.tsx",
      lineNumber: 105,
      columnNumber: 17
    }, undefined),
    /* @__PURE__ */ jsxDevRuntimeExports.jsxDEV("p", { className: "text-vs-editor-text2 mb-6", children: errorContent.message }, void 0, false, {
      fileName: "/workspace/personal-blog/src/pages/ErrorPage/ErrorPage.tsx",
      lineNumber: 110,
      columnNumber: 17
    }, undefined),
    errorMessage && errorMessage !== errorContent.message && /* @__PURE__ */ jsxDevRuntimeExports.jsxDEV("div", { className: "bg-vs-editor-surface2 rounded-lg p-4 mb-6 text-left", children: [
      /* @__PURE__ */ jsxDevRuntimeExports.jsxDEV("p", { className: "text-sm text-vs-editor-text font-medium mb-2", children: "Error Details:" }, void 0, false, {
        fileName: "/workspace/personal-blog/src/pages/ErrorPage/ErrorPage.tsx",
        lineNumber: 117,
        columnNumber: 25
      }, undefined),
      /* @__PURE__ */ jsxDevRuntimeExports.jsxDEV("p", { className: "text-sm text-vs-editor-text2 font-mono break-words", children: errorMessage }, void 0, false, {
        fileName: "/workspace/personal-blog/src/pages/ErrorPage/ErrorPage.tsx",
        lineNumber: 118,
        columnNumber: 25
      }, undefined)
    ] }, void 0, true, {
      fileName: "/workspace/personal-blog/src/pages/ErrorPage/ErrorPage.tsx",
      lineNumber: 116,
      columnNumber: 21
    }, undefined),
    /* @__PURE__ */ jsxDevRuntimeExports.jsxDEV("div", { className: "mb-8", children: [
      /* @__PURE__ */ jsxDevRuntimeExports.jsxDEV("h3", { className: "text-sm font-medium text-vs-editor-text mb-3", children: "Try these solutions:" }, void 0, false, {
        fileName: "/workspace/personal-blog/src/pages/ErrorPage/ErrorPage.tsx",
        lineNumber: 126,
        columnNumber: 21
      }, undefined),
      /* @__PURE__ */ jsxDevRuntimeExports.jsxDEV("ul", { className: "text-sm text-vs-editor-text2 space-y-1", children: errorContent.suggestions.map((suggestion, index) => /* @__PURE__ */ jsxDevRuntimeExports.jsxDEV("li", { className: "flex items-center justify-center", children: [
        /* @__PURE__ */ jsxDevRuntimeExports.jsxDEV("span", { className: "text-crystal-blue-400 mr-2", children: "•" }, void 0, false, {
          fileName: "/workspace/personal-blog/src/pages/ErrorPage/ErrorPage.tsx",
          lineNumber: 130,
          columnNumber: 33
        }, undefined),
        suggestion
      ] }, index, true, {
        fileName: "/workspace/personal-blog/src/pages/ErrorPage/ErrorPage.tsx",
        lineNumber: 129,
        columnNumber: 29
      }, undefined)) }, void 0, false, {
        fileName: "/workspace/personal-blog/src/pages/ErrorPage/ErrorPage.tsx",
        lineNumber: 127,
        columnNumber: 21
      }, undefined)
    ] }, void 0, true, {
      fileName: "/workspace/personal-blog/src/pages/ErrorPage/ErrorPage.tsx",
      lineNumber: 125,
      columnNumber: 17
    }, undefined),
    /* @__PURE__ */ jsxDevRuntimeExports.jsxDEV("div", { className: "flex flex-col sm:flex-row gap-3 justify-center", children: [
      showBackButton && /* @__PURE__ */ jsxDevRuntimeExports.jsxDEV(
        "button",
        {
          onClick: handleGoBack,
          className: "px-4 py-2 bg-vs-editor-surface2 text-vs-editor-text rounded-lg hover:bg-vs-editor-hover transition-colors",
          children: "Go Back"
        },
        void 0,
        false,
        {
          fileName: "/workspace/personal-blog/src/pages/ErrorPage/ErrorPage.tsx",
          lineNumber: 140,
          columnNumber: 25
        },
        undefined
      ),
      showHomeButton && /* @__PURE__ */ jsxDevRuntimeExports.jsxDEV(
        "button",
        {
          onClick: handleGoHome,
          className: "px-4 py-2 bg-crystal-blue-600 text-white rounded-lg hover:bg-crystal-blue-700 transition-colors",
          children: "Go Home"
        },
        void 0,
        false,
        {
          fileName: "/workspace/personal-blog/src/pages/ErrorPage/ErrorPage.tsx",
          lineNumber: 148,
          columnNumber: 25
        },
        undefined
      )
    ] }, void 0, true, {
      fileName: "/workspace/personal-blog/src/pages/ErrorPage/ErrorPage.tsx",
      lineNumber: 138,
      columnNumber: 17
    }, undefined)
  ] }, void 0, true, {
    fileName: "/workspace/personal-blog/src/pages/ErrorPage/ErrorPage.tsx",
    lineNumber: 100,
    columnNumber: 13
  }, undefined) }, void 0, false, {
    fileName: "/workspace/personal-blog/src/pages/ErrorPage/ErrorPage.tsx",
    lineNumber: 99,
    columnNumber: 9
  }, undefined);
};

const Contact = () => {
  const handleEmailClick = () => {
    window.location.href = "mailto:jordanyu1992@gmail.com";
  };
  const handleGithubClick = () => {
    window.open("https://github.com/stymphalian", "_blank");
  };
  const handleLinkedinClick = () => {
    window.open("https://linkedin.com/in/jordanu92", "_blank");
  };
  return /* @__PURE__ */ jsxDevRuntimeExports.jsxDEV("div", { className: "min-h-screen bg-vs-editor-bg pt-16", children: /* @__PURE__ */ jsxDevRuntimeExports.jsxDEV("div", { className: "container mx-auto px-4 py-4", children: [
    /* @__PURE__ */ jsxDevRuntimeExports.jsxDEV("div", { className: "text-center mb-4 md:mb-6", children: [
      /* @__PURE__ */ jsxDevRuntimeExports.jsxDEV("h1", { className: "heading-1 mb-2 md:mb-3 text-3xl md:text-4xl lg:text-5xl", children: "Get In Touch" }, void 0, false, {
        fileName: "/workspace/personal-blog/src/pages/Contact/Contact.tsx",
        lineNumber: 21,
        columnNumber: 11
      }, undefined),
      /* @__PURE__ */ jsxDevRuntimeExports.jsxDEV("p", { className: "body-text max-w-2xl mx-auto px-4 text-sm md:text-base", children: "I'm always interested in hearing about new opportunities, interesting projects, or just want to say hello. Feel free to reach out!" }, void 0, false, {
        fileName: "/workspace/personal-blog/src/pages/Contact/Contact.tsx",
        lineNumber: 22,
        columnNumber: 11
      }, undefined)
    ] }, void 0, true, {
      fileName: "/workspace/personal-blog/src/pages/Contact/Contact.tsx",
      lineNumber: 20,
      columnNumber: 9
    }, undefined),
    /* @__PURE__ */ jsxDevRuntimeExports.jsxDEV("div", { className: "max-w-4xl mx-auto px-4", children: /* @__PURE__ */ jsxDevRuntimeExports.jsxDEV("div", { className: "grid grid-cols-1 lg:grid-cols-2 gap-3 md:gap-4", children: [
      /* @__PURE__ */ jsxDevRuntimeExports.jsxDEV("div", { className: "bg-vs-editor-surface/80 backdrop-blur-sm rounded-lg p-3 md:p-4 border border-vs-editor-border hover:border-crystal-blue-500 transition-all duration-300 hover:shadow-lg hover:shadow-crystal-blue-500/20", children: [
        /* @__PURE__ */ jsxDevRuntimeExports.jsxDEV("h2", { className: "heading-2 mb-2 md:mb-3 text-center text-xl md:text-2xl", children: "Personal Contact" }, void 0, false, {
          fileName: "/workspace/personal-blog/src/pages/Contact/Contact.tsx",
          lineNumber: 33,
          columnNumber: 15
        }, undefined),
        /* @__PURE__ */ jsxDevRuntimeExports.jsxDEV("div", { className: "space-y-1.5 md:space-y-2", children: [
          /* @__PURE__ */ jsxDevRuntimeExports.jsxDEV(
            "button",
            {
              onClick: handleEmailClick,
              className: "flex items-center space-x-3 w-full p-1.5 md:p-2.5 rounded-lg hover:bg-vs-editor-hover hover:scale-[1.02] transition-all duration-200 group cursor-pointer",
              title: "Click to send email",
              children: [
                /* @__PURE__ */ jsxDevRuntimeExports.jsxDEV(Mail, { className: "w-4 h-4 md:w-5 md:h-5 text-blue-400 flex-shrink-0 group-hover:scale-110 transition-transform duration-200" }, void 0, false, {
                  fileName: "/workspace/personal-blog/src/pages/Contact/Contact.tsx",
                  lineNumber: 40,
                  columnNumber: 19
                }, undefined),
                /* @__PURE__ */ jsxDevRuntimeExports.jsxDEV("span", { className: "body-text group-hover:text-blue-300 transition-colors duration-200 text-sm md:text-base truncate", children: "jordanyu1992@gmail.com" }, void 0, false, {
                  fileName: "/workspace/personal-blog/src/pages/Contact/Contact.tsx",
                  lineNumber: 41,
                  columnNumber: 19
                }, undefined),
                /* @__PURE__ */ jsxDevRuntimeExports.jsxDEV("div", { className: "ml-auto opacity-0 group-hover:opacity-100 transition-opacity duration-200", children: /* @__PURE__ */ jsxDevRuntimeExports.jsxDEV(Mail, { className: "w-3 h-3 text-blue-400" }, void 0, false, {
                  fileName: "/workspace/personal-blog/src/pages/Contact/Contact.tsx",
                  lineNumber: 45,
                  columnNumber: 21
                }, undefined) }, void 0, false, {
                  fileName: "/workspace/personal-blog/src/pages/Contact/Contact.tsx",
                  lineNumber: 44,
                  columnNumber: 19
                }, undefined)
              ]
            },
            void 0,
            true,
            {
              fileName: "/workspace/personal-blog/src/pages/Contact/Contact.tsx",
              lineNumber: 35,
              columnNumber: 17
            },
            undefined
          ),
          /* @__PURE__ */ jsxDevRuntimeExports.jsxDEV("div", { className: "flex items-center space-x-3 p-1.5 md:p-2.5 rounded-lg hover:bg-vs-editor-hover transition-colors duration-200", children: [
            /* @__PURE__ */ jsxDevRuntimeExports.jsxDEV(MapPin, { className: "w-4 h-4 md:w-5 md:h-5 text-red-400 flex-shrink-0" }, void 0, false, {
              fileName: "/workspace/personal-blog/src/pages/Contact/Contact.tsx",
              lineNumber: 49,
              columnNumber: 19
            }, undefined),
            /* @__PURE__ */ jsxDevRuntimeExports.jsxDEV("span", { className: "body-text text-sm md:text-base", children: "Canada" }, void 0, false, {
              fileName: "/workspace/personal-blog/src/pages/Contact/Contact.tsx",
              lineNumber: 50,
              columnNumber: 19
            }, undefined)
          ] }, void 0, true, {
            fileName: "/workspace/personal-blog/src/pages/Contact/Contact.tsx",
            lineNumber: 48,
            columnNumber: 17
          }, undefined)
        ] }, void 0, true, {
          fileName: "/workspace/personal-blog/src/pages/Contact/Contact.tsx",
          lineNumber: 34,
          columnNumber: 15
        }, undefined)
      ] }, void 0, true, {
        fileName: "/workspace/personal-blog/src/pages/Contact/Contact.tsx",
        lineNumber: 32,
        columnNumber: 13
      }, undefined),
      /* @__PURE__ */ jsxDevRuntimeExports.jsxDEV("div", { className: "bg-vs-editor-surface/80 backdrop-blur-sm rounded-lg p-3 md:p-4 border border-vs-editor-border hover:border-crystal-blue-500 transition-all duration-300 hover:shadow-lg hover:shadow-crystal-blue-500/20", children: [
        /* @__PURE__ */ jsxDevRuntimeExports.jsxDEV("h2", { className: "heading-2 mb-2 md:mb-3 text-center text-xl md:text-2xl", children: "Professional Links" }, void 0, false, {
          fileName: "/workspace/personal-blog/src/pages/Contact/Contact.tsx",
          lineNumber: 57,
          columnNumber: 15
        }, undefined),
        /* @__PURE__ */ jsxDevRuntimeExports.jsxDEV("div", { className: "space-y-1.5 md:space-y-2", children: [
          /* @__PURE__ */ jsxDevRuntimeExports.jsxDEV(
            "button",
            {
              onClick: handleGithubClick,
              className: "flex items-center space-x-3 w-full p-1.5 md:p-2.5 rounded-lg hover:bg-vs-editor-hover hover:scale-[1.02] transition-all duration-200 group cursor-pointer",
              title: "Click to visit GitHub profile",
              children: [
                /* @__PURE__ */ jsxDevRuntimeExports.jsxDEV(Github, { className: "w-4 h-4 md:w-5 md:h-5 text-gray-300 flex-shrink-0 group-hover:scale-110 transition-transform duration-200" }, void 0, false, {
                  fileName: "/workspace/personal-blog/src/pages/Contact/Contact.tsx",
                  lineNumber: 64,
                  columnNumber: 19
                }, undefined),
                /* @__PURE__ */ jsxDevRuntimeExports.jsxDEV("span", { className: "body-text group-hover:text-gray-200 transition-colors duration-200 text-sm md:text-base truncate", children: "github.com/stymphalian" }, void 0, false, {
                  fileName: "/workspace/personal-blog/src/pages/Contact/Contact.tsx",
                  lineNumber: 65,
                  columnNumber: 19
                }, undefined),
                /* @__PURE__ */ jsxDevRuntimeExports.jsxDEV("div", { className: "ml-auto opacity-0 group-hover:opacity-100 transition-opacity duration-200", children: /* @__PURE__ */ jsxDevRuntimeExports.jsxDEV(Github, { className: "w-3 h-3 text-gray-300" }, void 0, false, {
                  fileName: "/workspace/personal-blog/src/pages/Contact/Contact.tsx",
                  lineNumber: 69,
                  columnNumber: 21
                }, undefined) }, void 0, false, {
                  fileName: "/workspace/personal-blog/src/pages/Contact/Contact.tsx",
                  lineNumber: 68,
                  columnNumber: 19
                }, undefined)
              ]
            },
            void 0,
            true,
            {
              fileName: "/workspace/personal-blog/src/pages/Contact/Contact.tsx",
              lineNumber: 59,
              columnNumber: 17
            },
            undefined
          ),
          /* @__PURE__ */ jsxDevRuntimeExports.jsxDEV(
            "button",
            {
              onClick: handleLinkedinClick,
              className: "flex items-center space-x-3 w-full p-1.5 md:p-2.5 rounded-lg hover:bg-vs-editor-hover hover:scale-[1.02] transition-all duration-200 group cursor-pointer",
              title: "Click to visit LinkedIn profile",
              children: [
                /* @__PURE__ */ jsxDevRuntimeExports.jsxDEV(Linkedin, { className: "w-4 h-4 md:w-5 md:h-5 text-blue-500 flex-shrink-0 group-hover:scale-110 transition-transform duration-200" }, void 0, false, {
                  fileName: "/workspace/personal-blog/src/pages/Contact/Contact.tsx",
                  lineNumber: 77,
                  columnNumber: 19
                }, undefined),
                /* @__PURE__ */ jsxDevRuntimeExports.jsxDEV("span", { className: "body-text group-hover:text-blue-400 transition-colors duration-200 text-sm md:text-base truncate", children: "linkedin.com/in/jordanu92" }, void 0, false, {
                  fileName: "/workspace/personal-blog/src/pages/Contact/Contact.tsx",
                  lineNumber: 78,
                  columnNumber: 19
                }, undefined),
                /* @__PURE__ */ jsxDevRuntimeExports.jsxDEV("div", { className: "ml-auto opacity-0 group-hover:opacity-100 transition-opacity duration-200", children: /* @__PURE__ */ jsxDevRuntimeExports.jsxDEV(Linkedin, { className: "w-3 h-3 text-blue-500" }, void 0, false, {
                  fileName: "/workspace/personal-blog/src/pages/Contact/Contact.tsx",
                  lineNumber: 82,
                  columnNumber: 21
                }, undefined) }, void 0, false, {
                  fileName: "/workspace/personal-blog/src/pages/Contact/Contact.tsx",
                  lineNumber: 81,
                  columnNumber: 19
                }, undefined)
              ]
            },
            void 0,
            true,
            {
              fileName: "/workspace/personal-blog/src/pages/Contact/Contact.tsx",
              lineNumber: 72,
              columnNumber: 17
            },
            undefined
          )
        ] }, void 0, true, {
          fileName: "/workspace/personal-blog/src/pages/Contact/Contact.tsx",
          lineNumber: 58,
          columnNumber: 15
        }, undefined)
      ] }, void 0, true, {
        fileName: "/workspace/personal-blog/src/pages/Contact/Contact.tsx",
        lineNumber: 56,
        columnNumber: 13
      }, undefined)
    ] }, void 0, true, {
      fileName: "/workspace/personal-blog/src/pages/Contact/Contact.tsx",
      lineNumber: 30,
      columnNumber: 11
    }, undefined) }, void 0, false, {
      fileName: "/workspace/personal-blog/src/pages/Contact/Contact.tsx",
      lineNumber: 28,
      columnNumber: 9
    }, undefined)
  ] }, void 0, true, {
    fileName: "/workspace/personal-blog/src/pages/Contact/Contact.tsx",
    lineNumber: 19,
    columnNumber: 7
  }, undefined) }, void 0, false, {
    fileName: "/workspace/personal-blog/src/pages/Contact/Contact.tsx",
    lineNumber: 18,
    columnNumber: 5
  }, undefined);
};

const Headshot = ({
  src,
  alt,
  fallbackEmoji = "👨‍💻",
  size = "lg",
  className = ""
}) => {
  const [imageLoaded, setImageLoaded] = reactExports.useState(false);
  const [imageError, setImageError] = reactExports.useState(false);
  const sizeClasses = {
    sm: "w-24 h-24 text-3xl",
    md: "w-32 h-32 text-4xl",
    lg: "w-48 h-48 text-6xl",
    xl: "w-64 h-64 text-8xl"
  };
  const handleImageLoad = () => {
    setImageLoaded(true);
    setImageError(false);
  };
  const handleImageError = () => {
    setImageError(true);
    setImageLoaded(false);
  };
  const showFallback = !src || imageError || !imageLoaded;
  return /* @__PURE__ */ jsxDevRuntimeExports.jsxDEV("div", { className: `relative ${sizeClasses[size]} ${className}`, children: [
    /* @__PURE__ */ jsxDevRuntimeExports.jsxDEV("div", { className: `absolute inset-0 rounded-full bg-gradient-to-br from-blue-400 to-purple-600 flex items-center justify-center shadow-lg transition-opacity duration-300 ${showFallback ? "opacity-100" : "opacity-0"}`, children: /* @__PURE__ */ jsxDevRuntimeExports.jsxDEV("div", { className: "text-white font-bold", children: fallbackEmoji }, void 0, false, {
      fileName: "/workspace/personal-blog/src/components/Headshot/Headshot.tsx",
      lineNumber: 47,
      columnNumber: 9
    }, undefined) }, void 0, false, {
      fileName: "/workspace/personal-blog/src/components/Headshot/Headshot.tsx",
      lineNumber: 44,
      columnNumber: 7
    }, undefined),
    src && /* @__PURE__ */ jsxDevRuntimeExports.jsxDEV(
      "img",
      {
        src,
        alt,
        className: `absolute inset-0 w-full h-full rounded-full object-cover shadow-lg transition-opacity duration-300 ${imageLoaded ? "opacity-100" : "opacity-0"}`,
        onLoad: handleImageLoad,
        onError: handleImageError,
        loading: "lazy"
      },
      void 0,
      false,
      {
        fileName: "/workspace/personal-blog/src/components/Headshot/Headshot.tsx",
        lineNumber: 52,
        columnNumber: 9
      },
      undefined
    ),
    src && !imageLoaded && !imageError && /* @__PURE__ */ jsxDevRuntimeExports.jsxDEV("div", { className: "absolute inset-0 rounded-full bg-gray-200 flex items-center justify-center shadow-lg", children: /* @__PURE__ */ jsxDevRuntimeExports.jsxDEV("div", { className: "animate-spin rounded-full h-8 w-8 border-b-2 border-blue-600" }, void 0, false, {
      fileName: "/workspace/personal-blog/src/components/Headshot/Headshot.tsx",
      lineNumber: 67,
      columnNumber: 11
    }, undefined) }, void 0, false, {
      fileName: "/workspace/personal-blog/src/components/Headshot/Headshot.tsx",
      lineNumber: 66,
      columnNumber: 9
    }, undefined)
  ] }, void 0, true, {
    fileName: "/workspace/personal-blog/src/components/Headshot/Headshot.tsx",
    lineNumber: 42,
    columnNumber: 5
  }, undefined);
};

const Layout = ({
  children,
  className = "",
  maxWidth = "2xl",
  padding = "lg",
  showPageTitle = false,
  pageTitle = "",
  pageDescription = ""
}) => {
  const maxWidthClasses = {
    sm: "max-w-sm",
    md: "max-w-md",
    lg: "max-w-lg",
    xl: "max-w-xl",
    "2xl": "max-w-2xl",
    "4xl": "max-w-4xl",
    "6xl": "max-w-6xl",
    "7xl": "max-w-7xl",
    full: "max-w-full"
  };
  const paddingClasses = {
    none: "",
    sm: "px-4 py-6",
    md: "px-6 py-8",
    lg: "px-8 py-12",
    xl: "px-12 py-16"
  };
  return /* @__PURE__ */ jsxDevRuntimeExports.jsxDEV("div", { className: `min-h-screen bg-vs-editor-bg pt-16 ${className}`, children: [
    showPageTitle && /* @__PURE__ */ jsxDevRuntimeExports.jsxDEV("div", { className: "bg-vs-editor-surface border-b border-vs-editor-border shadow-sm", children: /* @__PURE__ */ jsxDevRuntimeExports.jsxDEV("div", { className: `mx-auto ${maxWidthClasses[maxWidth]} ${paddingClasses[padding]}`, children: /* @__PURE__ */ jsxDevRuntimeExports.jsxDEV("div", { className: "text-center", children: [
      /* @__PURE__ */ jsxDevRuntimeExports.jsxDEV("h1", { className: "text-3xl md:text-4xl font-bold text-vs-editor-text mb-2", children: pageTitle }, void 0, false, {
        fileName: "/workspace/personal-blog/src/components/Layout/Layout.tsx",
        lineNumber: 49,
        columnNumber: 15
      }, undefined),
      pageDescription && /* @__PURE__ */ jsxDevRuntimeExports.jsxDEV("p", { className: "text-lg text-vs-editor-text2 max-w-2xl mx-auto", children: pageDescription }, void 0, false, {
        fileName: "/workspace/personal-blog/src/components/Layout/Layout.tsx",
        lineNumber: 53,
        columnNumber: 17
      }, undefined)
    ] }, void 0, true, {
      fileName: "/workspace/personal-blog/src/components/Layout/Layout.tsx",
      lineNumber: 48,
      columnNumber: 13
    }, undefined) }, void 0, false, {
      fileName: "/workspace/personal-blog/src/components/Layout/Layout.tsx",
      lineNumber: 47,
      columnNumber: 11
    }, undefined) }, void 0, false, {
      fileName: "/workspace/personal-blog/src/components/Layout/Layout.tsx",
      lineNumber: 46,
      columnNumber: 9
    }, undefined),
    /* @__PURE__ */ jsxDevRuntimeExports.jsxDEV("main", { className: `mx-auto ${maxWidthClasses[maxWidth]} ${paddingClasses[padding]}`, children: /* @__PURE__ */ jsxDevRuntimeExports.jsxDEV("div", { className: "bg-vs-editor-surface rounded-lg shadow-sm border border-vs-editor-border overflow-hidden", children: /* @__PURE__ */ jsxDevRuntimeExports.jsxDEV("div", { className: "p-6 md:p-8", children }, void 0, false, {
      fileName: "/workspace/personal-blog/src/components/Layout/Layout.tsx",
      lineNumber: 66,
      columnNumber: 11
    }, undefined) }, void 0, false, {
      fileName: "/workspace/personal-blog/src/components/Layout/Layout.tsx",
      lineNumber: 64,
      columnNumber: 9
    }, undefined) }, void 0, false, {
      fileName: "/workspace/personal-blog/src/components/Layout/Layout.tsx",
      lineNumber: 63,
      columnNumber: 7
    }, undefined),
    /* @__PURE__ */ jsxDevRuntimeExports.jsxDEV("footer", { className: "bg-vs-editor-surface border-t border-vs-editor-border mt-16", children: /* @__PURE__ */ jsxDevRuntimeExports.jsxDEV("div", { className: `mx-auto ${maxWidthClasses[maxWidth]} ${paddingClasses[padding]}`, children: /* @__PURE__ */ jsxDevRuntimeExports.jsxDEV("div", { className: "text-center py-8", children: /* @__PURE__ */ jsxDevRuntimeExports.jsxDEV("p", { className: "text-vs-editor-text2 text-sm", children: "2025. Built with React & Tailwind & Cursor" }, void 0, false, {
      fileName: "/workspace/personal-blog/src/components/Layout/Layout.tsx",
      lineNumber: 76,
      columnNumber: 13
    }, undefined) }, void 0, false, {
      fileName: "/workspace/personal-blog/src/components/Layout/Layout.tsx",
      lineNumber: 75,
      columnNumber: 11
    }, undefined) }, void 0, false, {
      fileName: "/workspace/personal-blog/src/components/Layout/Layout.tsx",
      lineNumber: 74,
      columnNumber: 9
    }, undefined) }, void 0, false, {
      fileName: "/workspace/personal-blog/src/components/Layout/Layout.tsx",
      lineNumber: 73,
      columnNumber: 7
    }, undefined)
  ] }, void 0, true, {
    fileName: "/workspace/personal-blog/src/components/Layout/Layout.tsx",
    lineNumber: 43,
    columnNumber: 5
  }, undefined);
};

const ProjectCarousel = ({
  projects,
  autoPlay = true,
  autoPlayInterval = 5e3
}) => {
  const [currentIndex, setCurrentIndex] = reactExports.useState(0);
  const [isAutoPlaying, setIsAutoPlaying] = reactExports.useState(autoPlay);
  const navigate = useNavigate();
  reactExports.useEffect(() => {
    if (!isAutoPlaying || projects.length <= 1) return;
    const interval = setInterval(() => {
      setCurrentIndex((prevIndex) => (prevIndex + 1) % projects.length);
    }, autoPlayInterval);
    return () => clearInterval(interval);
  }, [isAutoPlaying, autoPlayInterval, projects.length]);
  const handleMouseEnter = () => setIsAutoPlaying(false);
  const handleMouseLeave = () => setIsAutoPlaying(autoPlay);
  const goToSlide = (index) => {
    setCurrentIndex(index);
  };
  const handleViewDetails = () => {
    const currentProject2 = projects[currentIndex];
    navigate(`/projects/${currentProject2.id}`);
  };
  if (!projects || projects.length === 0) {
    return /* @__PURE__ */ jsxDevRuntimeExports.jsxDEV("div", { className: "text-center py-12", children: /* @__PURE__ */ jsxDevRuntimeExports.jsxDEV("p", { className: "text-gray-500", children: "No projects to display" }, void 0, false, {
      fileName: "/workspace/personal-blog/src/components/ProjectCarousel/ProjectCarousel.tsx",
      lineNumber: 61,
      columnNumber: 9
    }, undefined) }, void 0, false, {
      fileName: "/workspace/personal-blog/src/components/ProjectCarousel/ProjectCarousel.tsx",
      lineNumber: 60,
      columnNumber: 7
    }, undefined);
  }
  const currentProject = projects[currentIndex];
  return /* @__PURE__ */ jsxDevRuntimeExports.jsxDEV(
    "div",
    {
      className: "relative w-full max-w-4xl mx-auto",
      onMouseEnter: handleMouseEnter,
      onMouseLeave: handleMouseLeave,
      children: [
        /* @__PURE__ */ jsxDevRuntimeExports.jsxDEV("div", { className: "relative bg-vs-editor-surface rounded-xl overflow-hidden shadow-lg border border-vs-editor-border", children: [
          /* @__PURE__ */ jsxDevRuntimeExports.jsxDEV("div", { className: "px-6 py-4 bg-vs-editor-surface border-b border-vs-editor-border", children: [
            /* @__PURE__ */ jsxDevRuntimeExports.jsxDEV("h2", { className: "text-2xl md:text-3xl font-bold text-vs-editor-text mb-2", children: currentProject.title }, void 0, false, {
              fileName: "/workspace/personal-blog/src/components/ProjectCarousel/ProjectCarousel.tsx",
              lineNumber: 78,
              columnNumber: 11
            }, undefined),
            /* @__PURE__ */ jsxDevRuntimeExports.jsxDEV("p", { className: "text-lg text-vs-editor-text2 px-4 py-2 bg-vs-editor-surface2/80 backdrop-blur-sm rounded-lg border border-vs-editor-border", children: currentProject.shortDescription }, void 0, false, {
              fileName: "/workspace/personal-blog/src/components/ProjectCarousel/ProjectCarousel.tsx",
              lineNumber: 81,
              columnNumber: 11
            }, undefined)
          ] }, void 0, true, {
            fileName: "/workspace/personal-blog/src/components/ProjectCarousel/ProjectCarousel.tsx",
            lineNumber: 77,
            columnNumber: 9
          }, undefined),
          /* @__PURE__ */ jsxDevRuntimeExports.jsxDEV("div", { className: "relative h-64 md:h-80 bg-gradient-to-br from-vs-editor-surface to-vs-editor-surface2", children: [
            currentProject.image && /* @__PURE__ */ jsxDevRuntimeExports.jsxDEV(
              "img",
              {
                src: currentProject.image,
                alt: currentProject.title,
                className: "w-full h-full object-cover"
              },
              void 0,
              false,
              {
                fileName: "/workspace/personal-blog/src/components/ProjectCarousel/ProjectCarousel.tsx",
                lineNumber: 87,
                columnNumber: 13
              },
              undefined
            ),
            /* @__PURE__ */ jsxDevRuntimeExports.jsxDEV("div", { className: "absolute inset-0 bg-gradient-to-t from-black/60 via-transparent to-transparent" }, void 0, false, {
              fileName: "/workspace/personal-blog/src/components/ProjectCarousel/ProjectCarousel.tsx",
              lineNumber: 95,
              columnNumber: 11
            }, undefined),
            /* @__PURE__ */ jsxDevRuntimeExports.jsxDEV("div", { className: "absolute bottom-0 left-0 right-0 p-6 text-white", children: [
              /* @__PURE__ */ jsxDevRuntimeExports.jsxDEV("div", { className: "flex flex-wrap gap-2 mb-4", children: currentProject.techStack.map((tech, index) => /* @__PURE__ */ jsxDevRuntimeExports.jsxDEV(
                "span",
                {
                  className: "px-3 py-1 bg-white/20 backdrop-blur-sm rounded-full text-sm font-medium",
                  children: tech
                },
                index,
                false,
                {
                  fileName: "/workspace/personal-blog/src/components/ProjectCarousel/ProjectCarousel.tsx",
                  lineNumber: 103,
                  columnNumber: 17
                },
                undefined
              )) }, void 0, false, {
                fileName: "/workspace/personal-blog/src/components/ProjectCarousel/ProjectCarousel.tsx",
                lineNumber: 101,
                columnNumber: 13
              }, undefined),
              /* @__PURE__ */ jsxDevRuntimeExports.jsxDEV("div", { className: "flex flex-wrap gap-3", children: [
                currentProject.showDetails && /* @__PURE__ */ jsxDevRuntimeExports.jsxDEV(
                  "button",
                  {
                    onClick: handleViewDetails,
                    className: "inline-flex items-center gap-2 px-4 py-2 bg-green-600 hover:bg-green-700 rounded-lg transition-colors duration-200",
                    children: [
                      /* @__PURE__ */ jsxDevRuntimeExports.jsxDEV(Eye, { className: "w-4 h-4" }, void 0, false, {
                        fileName: "/workspace/personal-blog/src/components/ProjectCarousel/ProjectCarousel.tsx",
                        lineNumber: 120,
                        columnNumber: 19
                      }, undefined),
                      "View Details"
                    ]
                  },
                  void 0,
                  true,
                  {
                    fileName: "/workspace/personal-blog/src/components/ProjectCarousel/ProjectCarousel.tsx",
                    lineNumber: 116,
                    columnNumber: 17
                  },
                  undefined
                ),
                currentProject.liveDemo && /* @__PURE__ */ jsxDevRuntimeExports.jsxDEV(
                  "a",
                  {
                    href: currentProject.liveDemo,
                    target: "_blank",
                    rel: "noopener noreferrer",
                    className: "inline-flex items-center gap-2 px-4 py-2 bg-blue-600 hover:bg-blue-700 rounded-lg transition-colors duration-200",
                    children: [
                      /* @__PURE__ */ jsxDevRuntimeExports.jsxDEV(ExternalLink, { className: "w-4 h-4" }, void 0, false, {
                        fileName: "/workspace/personal-blog/src/components/ProjectCarousel/ProjectCarousel.tsx",
                        lineNumber: 133,
                        columnNumber: 19
                      }, undefined),
                      "Live Demo"
                    ]
                  },
                  void 0,
                  true,
                  {
                    fileName: "/workspace/personal-blog/src/components/ProjectCarousel/ProjectCarousel.tsx",
                    lineNumber: 127,
                    columnNumber: 17
                  },
                  undefined
                ),
                currentProject.githubRepo && /* @__PURE__ */ jsxDevRuntimeExports.jsxDEV(
                  "a",
                  {
                    href: currentProject.githubRepo,
                    target: "_blank",
                    rel: "noopener noreferrer",
                    className: "inline-flex items-center gap-2 px-4 py-2 bg-gray-800 hover:bg-gray-900 rounded-lg transition-colors duration-200",
                    children: [
                      /* @__PURE__ */ jsxDevRuntimeExports.jsxDEV(Github, { className: "w-4 h-4" }, void 0, false, {
                        fileName: "/workspace/personal-blog/src/components/ProjectCarousel/ProjectCarousel.tsx",
                        lineNumber: 146,
                        columnNumber: 19
                      }, undefined),
                      "View Code"
                    ]
                  },
                  void 0,
                  true,
                  {
                    fileName: "/workspace/personal-blog/src/components/ProjectCarousel/ProjectCarousel.tsx",
                    lineNumber: 140,
                    columnNumber: 17
                  },
                  undefined
                )
              ] }, void 0, true, {
                fileName: "/workspace/personal-blog/src/components/ProjectCarousel/ProjectCarousel.tsx",
                lineNumber: 113,
                columnNumber: 13
              }, undefined)
            ] }, void 0, true, {
              fileName: "/workspace/personal-blog/src/components/ProjectCarousel/ProjectCarousel.tsx",
              lineNumber: 98,
              columnNumber: 11
            }, undefined)
          ] }, void 0, true, {
            fileName: "/workspace/personal-blog/src/components/ProjectCarousel/ProjectCarousel.tsx",
            lineNumber: 85,
            columnNumber: 9
          }, undefined),
          /* @__PURE__ */ jsxDevRuntimeExports.jsxDEV("div", { className: "p-6", children: [
            /* @__PURE__ */ jsxDevRuntimeExports.jsxDEV("p", { className: "text-vs-editor-text2 leading-relaxed", children: currentProject.description }, void 0, false, {
              fileName: "/workspace/personal-blog/src/components/ProjectCarousel/ProjectCarousel.tsx",
              lineNumber: 156,
              columnNumber: 11
            }, undefined),
            /* @__PURE__ */ jsxDevRuntimeExports.jsxDEV("div", { className: "mt-4 text-sm text-vs-editor-text3", children: [
              "Featured • ",
              new Date(currentProject.date).toLocaleDateString()
            ] }, void 0, true, {
              fileName: "/workspace/personal-blog/src/components/ProjectCarousel/ProjectCarousel.tsx",
              lineNumber: 157,
              columnNumber: 11
            }, undefined)
          ] }, void 0, true, {
            fileName: "/workspace/personal-blog/src/components/ProjectCarousel/ProjectCarousel.tsx",
            lineNumber: 155,
            columnNumber: 9
          }, undefined)
        ] }, void 0, true, {
          fileName: "/workspace/personal-blog/src/components/ProjectCarousel/ProjectCarousel.tsx",
          lineNumber: 75,
          columnNumber: 7
        }, undefined),
        projects.length > 1 && /* @__PURE__ */ jsxDevRuntimeExports.jsxDEV("div", { className: "flex justify-center mt-6 space-x-2", children: projects.map((_, index) => /* @__PURE__ */ jsxDevRuntimeExports.jsxDEV(
          "button",
          {
            onClick: () => goToSlide(index),
            className: `w-3 h-3 rounded-full transition-all duration-200 ${index === currentIndex ? "bg-crystal-blue-500 scale-125" : "bg-vs-editor-border hover:bg-vs-editor-text2"}`,
            "aria-label": `Go to project ${index + 1}`
          },
          index,
          false,
          {
            fileName: "/workspace/personal-blog/src/components/ProjectCarousel/ProjectCarousel.tsx",
            lineNumber: 167,
            columnNumber: 13
          },
          undefined
        )) }, void 0, false, {
          fileName: "/workspace/personal-blog/src/components/ProjectCarousel/ProjectCarousel.tsx",
          lineNumber: 165,
          columnNumber: 9
        }, undefined)
      ]
    },
    void 0,
    true,
    {
      fileName: "/workspace/personal-blog/src/components/ProjectCarousel/ProjectCarousel.tsx",
      lineNumber: 69,
      columnNumber: 5
    },
    undefined
  );
};

const projects = [
  {
    id: "ak-chibi-bot",
    slug: "ak-chibi-bot",
    title: "Arknights Chibi Twitch Bot",
    description: "A twitch bot and browser source overlay to show Arknight chibis walking on your stream. Viewers can issue !chibi chat commands to choose their own operator, change skins and play different animations.",
    shortDescription: "Twitch Bot and Browser Overlay for Arknights Chibis",
    image: "/images/ak-chibi-bot/banner.png",
    techStack: ["React", "Spine", "Twitch API", "Golang"],
    tags: ["React", "Spine", "Twitch API", "Golang"],
    featured: true,
    date: "2024-06-10",
    liveDemo: "https://akchibibot.stymphalian.top",
    githubRepo: "https://github.com/stymphalian/ak_chibi_bot",
    showDetails: true,
    images: [
      {
        type: "image",
        src: "/images/ak-chibi-bot/banner.png",
        alt: "Arknights Chibi Bot",
        caption: "Arknights Chibi Twith Bot and Overlay"
      }
    ],
    videos: [
      // {
      //   type: 'video',
      //   src: 'https://www.youtube.com/embed/demo-video-id',
      //   alt: 'Project walkthrough',
      //   caption: 'Video demonstration of key features',
      //   thumbnail: '/placeholder-project-3.jpg'
      // }
    ]
  }
];
const loadProjectContent = async (slug) => {
  try {
    const content = await loadContent(`/content/projects/${slug}.txt`, "project");
    return content;
  } catch (error) {
    console.error(`Failed to load project content for slug: ${slug}`, error);
    return null;
  }
};
const getFeaturedProjects = () => {
  return projects.filter((project) => project.featured);
};
const getProjectById = (id) => {
  return projects.find((project) => project.id === id);
};

const Home = () => {
  const navigate = useNavigate();
  const featuredProjects = getFeaturedProjects();
  const [isVisible, setIsVisible] = reactExports.useState(false);
  reactExports.useEffect(() => {
    const timer = setTimeout(() => setIsVisible(true), 100);
    return () => clearTimeout(timer);
  }, []);
  return /* @__PURE__ */ jsxDevRuntimeExports.jsxDEV(
    Layout,
    {
      showPageTitle: false,
      pageTitle: "Welcome to My Portfolio",
      pageDescription: "Senior Software Developer with 8+ years of backend experience",
      maxWidth: "7xl",
      padding: "md",
      children: /* @__PURE__ */ jsxDevRuntimeExports.jsxDEV("div", { className: `space-y-8 md:space-y-12 lg:space-y-16 transition-all duration-1000 ${isVisible ? "opacity-100 translate-y-0" : "opacity-0 translate-y-8"}`, children: [
        /* @__PURE__ */ jsxDevRuntimeExports.jsxDEV("div", { className: `flex flex-col lg:flex-row items-center lg:items-start gap-6 md:gap-8 lg:gap-12 transition-all duration-700 delay-200 ${isVisible ? "opacity-100 translate-y-0" : "opacity-0 translate-y-12"}`, children: [
          /* @__PURE__ */ jsxDevRuntimeExports.jsxDEV("div", { className: "flex-shrink-0 order-2 lg:order-1 group", children: /* @__PURE__ */ jsxDevRuntimeExports.jsxDEV(
            Headshot,
            {
              src: "/headshot.jpg",
              alt: "Professional headshot",
              size: "lg",
              className: "w-40 h-40 sm:w-48 sm:h-48 md:w-56 md:h-56 lg:w-64 lg:h-64 transition-all duration-500 group-hover:scale-105 group-hover:shadow-2xl"
            },
            void 0,
            false,
            {
              fileName: "/workspace/personal-blog/src/pages/Home/Home.tsx",
              lineNumber: 34,
              columnNumber: 13
            },
            undefined
          ) }, void 0, false, {
            fileName: "/workspace/personal-blog/src/pages/Home/Home.tsx",
            lineNumber: 33,
            columnNumber: 11
          }, undefined),
          /* @__PURE__ */ jsxDevRuntimeExports.jsxDEV("div", { className: "flex-1 text-center lg:text-left order-1 lg:order-2", children: [
            /* @__PURE__ */ jsxDevRuntimeExports.jsxDEV("h1", { className: `text-2xl sm:text-3xl md:text-4xl lg:text-5xl font-bold text-vs-editor-text mb-3 md:mb-4 leading-tight transition-all duration-700 delay-300 ${isVisible ? "opacity-100 translate-y-0" : "opacity-0 translate-y-8"}`, children: [
              "Hi, I'm ",
              /* @__PURE__ */ jsxDevRuntimeExports.jsxDEV("span", { className: "text-crystal-blue-400 animate-pulse", children: "Jordan Yu" }, void 0, false, {
                fileName: "/workspace/personal-blog/src/pages/Home/Home.tsx",
                lineNumber: 46,
                columnNumber: 23
              }, undefined)
            ] }, void 0, true, {
              fileName: "/workspace/personal-blog/src/pages/Home/Home.tsx",
              lineNumber: 44,
              columnNumber: 13
            }, undefined),
            /* @__PURE__ */ jsxDevRuntimeExports.jsxDEV("h2", { className: `text-lg sm:text-xl md:text-2xl lg:text-3xl font-semibold text-vs-editor-text2 mb-3 md:mb-4 transition-all duration-700 delay-400 ${isVisible ? "opacity-100 translate-y-0" : "opacity-0 translate-y-8"}`, children: "Senior Software Developer" }, void 0, false, {
              fileName: "/workspace/personal-blog/src/pages/Home/Home.tsx",
              lineNumber: 48,
              columnNumber: 13
            }, undefined),
            /* @__PURE__ */ jsxDevRuntimeExports.jsxDEV("p", { className: `text-base sm:text-lg md:text-xl text-vs-editor-text2 max-w-3xl mx-auto lg:mx-0 leading-relaxed mb-4 md:mb-6 transition-all duration-700 delay-500 ${isVisible ? "opacity-100 translate-y-0" : "opacity-0 translate-y-8"}`, children: "This my own little spot on the internet where I can share some of my projects and write about interesting things I have worked on. I'm software engineer by trade, but in my heart I'm a gamer, nerd and I love learning about new things and technology. Some of my interests are graphics, competitive programming, and running. Thanks for dropping by!" }, void 0, false, {
              fileName: "/workspace/personal-blog/src/pages/Home/Home.tsx",
              lineNumber: 52,
              columnNumber: 13
            }, undefined),
            /* @__PURE__ */ jsxDevRuntimeExports.jsxDEV("div", { className: `flex flex-col sm:flex-row gap-3 md:gap-4 justify-center lg:justify-start transition-all duration-700 delay-600 ${isVisible ? "opacity-100 translate-y-0" : "opacity-0 translate-y-8"}`, children: [
              /* @__PURE__ */ jsxDevRuntimeExports.jsxDEV(
                "button",
                {
                  onClick: () => navigate("/projects"),
                  className: "bg-crystal-blue-600 text-white px-6 md:px-8 py-2 md:py-3 rounded-lg hover:bg-crystal-blue-700 transition-all duration-300 transform hover:scale-105 hover:-translate-y-1 shadow-lg text-sm md:text-base font-medium active:scale-95",
                  children: "View My Work"
                },
                void 0,
                false,
                {
                  fileName: "/workspace/personal-blog/src/pages/Home/Home.tsx",
                  lineNumber: 62,
                  columnNumber: 15
                },
                undefined
              ),
              /* @__PURE__ */ jsxDevRuntimeExports.jsxDEV(
                "button",
                {
                  onClick: () => {
                    const link = document.createElement("a");
                    link.href = "/resume.pdf";
                    link.download = "Jordan_Resume.pdf";
                    document.body.appendChild(link);
                    link.click();
                    document.body.removeChild(link);
                  },
                  className: "border-2 border-crystal-blue-600 text-crystal-blue-400 px-6 md:px-8 py-2 md:py-3 rounded-lg hover:bg-crystal-blue-700 hover:text-white transition-all duration-300 transform hover:scale-105 hover:-translate-y-1 text-sm md:text-base font-medium active:scale-95",
                  children: "Download Resume"
                },
                void 0,
                false,
                {
                  fileName: "/workspace/personal-blog/src/pages/Home/Home.tsx",
                  lineNumber: 68,
                  columnNumber: 15
                },
                undefined
              )
            ] }, void 0, true, {
              fileName: "/workspace/personal-blog/src/pages/Home/Home.tsx",
              lineNumber: 60,
              columnNumber: 13
            }, undefined)
          ] }, void 0, true, {
            fileName: "/workspace/personal-blog/src/pages/Home/Home.tsx",
            lineNumber: 43,
            columnNumber: 11
          }, undefined)
        ] }, void 0, true, {
          fileName: "/workspace/personal-blog/src/pages/Home/Home.tsx",
          lineNumber: 30,
          columnNumber: 9
        }, undefined),
        /* @__PURE__ */ jsxDevRuntimeExports.jsxDEV("div", { className: `bg-gradient-to-r from-vs-editor-surface to-vs-editor-surface2 rounded-xl p-4 md:p-6 lg:p-8 shadow-sm transition-all duration-700 delay-700 ${isVisible ? "opacity-100 translate-y-0" : "opacity-0 translate-y-12"}`, children: [
          /* @__PURE__ */ jsxDevRuntimeExports.jsxDEV("h3", { className: "text-xl md:text-2xl lg:text-3xl font-bold text-vs-editor-text mb-4 md:mb-6 text-center", children: "Technical Expertise" }, void 0, false, {
            fileName: "/workspace/personal-blog/src/pages/Home/Home.tsx",
            lineNumber: 88,
            columnNumber: 11
          }, undefined),
          /* @__PURE__ */ jsxDevRuntimeExports.jsxDEV("div", { className: "grid grid-cols-1 sm:grid-cols-2 lg:grid-cols-4 gap-4 md:gap-6", children: [
            { icon: "⚙️", title: "Backend", color: "green", skills: ["Java & Go", "Python & PHP", "REST/RPC APIs", "Microservices"] },
            { icon: "☁️", title: "Infrastructure", color: "blue", skills: ["AWS & GCP", "Kubernetes", "Docker", "Borg/Spanner"] },
            { icon: "🗄️", title: "Databases", color: "purple", skills: ["SQL & NoSQL", "Bigtable", "Spanner", "Data Modeling"] },
            { icon: "🔧", title: "Tools & DevOps", color: "orange", skills: ["Git & Bazel", "CI/CD", "Monitoring", "Testing"] }
          ].map((skill, index) => /* @__PURE__ */ jsxDevRuntimeExports.jsxDEV(
            "div",
            {
              className: `bg-vs-editor-surface rounded-xl p-4 md:p-6 shadow-md hover:shadow-2xl transition-all duration-500 transform hover:-translate-y-2 hover:scale-105 border-l-4 border-${skill.color}-500 group ${isVisible ? "opacity-100 translate-y-0" : "opacity-0 translate-y-8"}`,
              style: { transitionDelay: `${800 + index * 100}ms` },
              children: [
                /* @__PURE__ */ jsxDevRuntimeExports.jsxDEV("div", { className: `text-${skill.color}-600 text-xl md:text-2xl lg:text-3xl mb-2 md:mb-3 transition-transform duration-300 group-hover:scale-110`, children: skill.icon }, void 0, false, {
                  fileName: "/workspace/personal-blog/src/pages/Home/Home.tsx",
                  lineNumber: 102,
                  columnNumber: 17
                }, undefined),
                /* @__PURE__ */ jsxDevRuntimeExports.jsxDEV("div", { className: `text-${skill.color}-600 font-bold text-base md:text-lg mb-2 transition-colors duration-300 group-hover:text-${skill.color}-700`, children: skill.title }, void 0, false, {
                  fileName: "/workspace/personal-blog/src/pages/Home/Home.tsx",
                  lineNumber: 105,
                  columnNumber: 17
                }, undefined),
                /* @__PURE__ */ jsxDevRuntimeExports.jsxDEV("div", { className: "text-xs md:text-sm text-vs-editor-text2 space-y-1", children: skill.skills.map((skillItem, skillIndex) => /* @__PURE__ */ jsxDevRuntimeExports.jsxDEV(
                  "div",
                  {
                    className: "transition-all duration-300 group-hover:text-vs-editor-text group-hover:translate-x-1",
                    style: { transitionDelay: `${skillIndex * 50}ms` },
                    children: skillItem
                  },
                  skillIndex,
                  false,
                  {
                    fileName: "/workspace/personal-blog/src/pages/Home/Home.tsx",
                    lineNumber: 110,
                    columnNumber: 21
                  },
                  undefined
                )) }, void 0, false, {
                  fileName: "/workspace/personal-blog/src/pages/Home/Home.tsx",
                  lineNumber: 108,
                  columnNumber: 17
                }, undefined)
              ]
            },
            skill.title,
            true,
            {
              fileName: "/workspace/personal-blog/src/pages/Home/Home.tsx",
              lineNumber: 96,
              columnNumber: 15
            },
            undefined
          )) }, void 0, false, {
            fileName: "/workspace/personal-blog/src/pages/Home/Home.tsx",
            lineNumber: 89,
            columnNumber: 11
          }, undefined)
        ] }, void 0, true, {
          fileName: "/workspace/personal-blog/src/pages/Home/Home.tsx",
          lineNumber: 86,
          columnNumber: 9
        }, undefined),
        /* @__PURE__ */ jsxDevRuntimeExports.jsxDEV("div", { className: `bg-vs-editor-surface rounded-xl p-4 md:p-6 lg:p-8 shadow-lg border border-vs-editor-border transition-all duration-700 delay-1000 ${isVisible ? "opacity-100 translate-y-0" : "opacity-0 translate-y-12"}`, children: [
          /* @__PURE__ */ jsxDevRuntimeExports.jsxDEV("h3", { className: "text-xl md:text-2xl lg:text-3xl font-bold text-vs-editor-text mb-4 md:mb-6 text-center", children: "Featured Projects" }, void 0, false, {
            fileName: "/workspace/personal-blog/src/pages/Home/Home.tsx",
            lineNumber: 127,
            columnNumber: 11
          }, undefined),
          /* @__PURE__ */ jsxDevRuntimeExports.jsxDEV("p", { className: "text-sm md:text-base lg:text-lg text-vs-editor-text2 mb-6 md:mb-8 text-center max-w-3xl mx-auto", children: "Here are some of my recent personal projects that demonstrate some of my skills and programming interests." }, void 0, false, {
            fileName: "/workspace/personal-blog/src/pages/Home/Home.tsx",
            lineNumber: 128,
            columnNumber: 11
          }, undefined),
          /* @__PURE__ */ jsxDevRuntimeExports.jsxDEV("div", { className: "transition-all duration-700 delay-1100", children: /* @__PURE__ */ jsxDevRuntimeExports.jsxDEV(ProjectCarousel, { projects: featuredProjects }, void 0, false, {
            fileName: "/workspace/personal-blog/src/pages/Home/Home.tsx",
            lineNumber: 132,
            columnNumber: 13
          }, undefined) }, void 0, false, {
            fileName: "/workspace/personal-blog/src/pages/Home/Home.tsx",
            lineNumber: 131,
            columnNumber: 11
          }, undefined),
          /* @__PURE__ */ jsxDevRuntimeExports.jsxDEV("div", { className: "text-center mt-6 md:mt-8", children: /* @__PURE__ */ jsxDevRuntimeExports.jsxDEV(
            "button",
            {
              onClick: () => navigate("/projects"),
              className: "bg-crystal-blue-600 text-white px-6 md:px-8 py-2 md:py-3 rounded-lg hover:bg-crystal-blue-700 transition-all duration-300 transform hover:scale-105 hover:-translate-y-1 shadow-lg text-sm md:text-base font-medium active:scale-95",
              children: "View All Projects"
            },
            void 0,
            false,
            {
              fileName: "/workspace/personal-blog/src/pages/Home/Home.tsx",
              lineNumber: 135,
              columnNumber: 13
            },
            undefined
          ) }, void 0, false, {
            fileName: "/workspace/personal-blog/src/pages/Home/Home.tsx",
            lineNumber: 134,
            columnNumber: 11
          }, undefined)
        ] }, void 0, true, {
          fileName: "/workspace/personal-blog/src/pages/Home/Home.tsx",
          lineNumber: 125,
          columnNumber: 9
        }, undefined),
        /* @__PURE__ */ jsxDevRuntimeExports.jsxDEV("div", { className: `grid grid-cols-1 lg:grid-cols-2 gap-6 md:gap-8 transition-all duration-700 delay-1200 ${isVisible ? "opacity-100 translate-y-0" : "opacity-0 translate-y-12"}`, children: [
          /* @__PURE__ */ jsxDevRuntimeExports.jsxDEV("div", { className: "bg-gradient-to-br from-vs-editor-surface to-vs-editor-surface2 rounded-xl p-4 md:p-6 shadow-sm hover:shadow-lg transition-all duration-500 transform hover:-translate-y-1 group", children: [
            /* @__PURE__ */ jsxDevRuntimeExports.jsxDEV("h3", { className: "text-lg md:text-xl font-bold text-vs-editor-text mb-3 md:mb-4 group-hover:text-crystal-blue-400 transition-colors duration-300", children: "Professional Experience" }, void 0, false, {
              fileName: "/workspace/personal-blog/src/pages/Home/Home.tsx",
              lineNumber: 148,
              columnNumber: 13
            }, undefined),
            /* @__PURE__ */ jsxDevRuntimeExports.jsxDEV("div", { className: "space-y-3 md:space-y-4", children: [
              { title: "Senior Backend Software Engineer", company: "Course Hero", period: "2021-2023", description: "Payments Infrastructure - Migrated legacy platform to Recurly affecting 2M+ users, automated 500K+ transaction processing" },
              { title: "Senior Software Engineer", company: "Google", period: "2018-2020", description: "Dialogflow/Google Assistant - Developed NLP backend services, Java APIs processing 1M+ model edits daily, GCP to Borg migration" },
              { title: "Software Engineer", company: "Google", period: "2015-2018", description: "Tools & Infrastructure - Built testing infrastructure for Ads spam filtering, maintained 10+ services, mentored 3 interns" }
            ].map((exp, index) => /* @__PURE__ */ jsxDevRuntimeExports.jsxDEV(
              "div",
              {
                className: "border-l-4 border-blue-500 pl-3 md:pl-4 transition-all duration-300 hover:border-blue-600 hover:pl-5",
                style: { transitionDelay: `${index * 100}ms` },
                children: [
                  /* @__PURE__ */ jsxDevRuntimeExports.jsxDEV("div", { className: "font-semibold text-vs-editor-text text-sm md:text-base group-hover:text-crystal-blue-300 transition-colors duration-300", children: exp.title }, void 0, false, {
                    fileName: "/workspace/personal-blog/src/pages/Home/Home.tsx",
                    lineNumber: 160,
                    columnNumber: 19
                  }, undefined),
                  /* @__PURE__ */ jsxDevRuntimeExports.jsxDEV("div", { className: "text-xs md:text-sm text-vs-editor-text2", children: [
                    exp.company,
                    " • ",
                    exp.period
                  ] }, void 0, true, {
                    fileName: "/workspace/personal-blog/src/pages/Home/Home.tsx",
                    lineNumber: 161,
                    columnNumber: 19
                  }, undefined),
                  /* @__PURE__ */ jsxDevRuntimeExports.jsxDEV("div", { className: "text-xs md:text-sm text-vs-editor-text3 mt-1 group-hover:text-vs-editor-text transition-colors duration-300", children: exp.description }, void 0, false, {
                    fileName: "/workspace/personal-blog/src/pages/Home/Home.tsx",
                    lineNumber: 162,
                    columnNumber: 19
                  }, undefined)
                ]
              },
              exp.title,
              true,
              {
                fileName: "/workspace/personal-blog/src/pages/Home/Home.tsx",
                lineNumber: 155,
                columnNumber: 17
              },
              undefined
            )) }, void 0, false, {
              fileName: "/workspace/personal-blog/src/pages/Home/Home.tsx",
              lineNumber: 149,
              columnNumber: 13
            }, undefined)
          ] }, void 0, true, {
            fileName: "/workspace/personal-blog/src/pages/Home/Home.tsx",
            lineNumber: 147,
            columnNumber: 11
          }, undefined),
          /* @__PURE__ */ jsxDevRuntimeExports.jsxDEV("div", { className: "bg-gradient-to-br from-vs-editor-surface to-vs-editor-surface2 rounded-xl p-4 md:p-6 shadow-sm hover:shadow-lg transition-all duration-500 transform hover:-translate-y-1 group", children: [
            /* @__PURE__ */ jsxDevRuntimeExports.jsxDEV("h3", { className: "text-lg md:text-xl font-bold text-vs-editor-text mb-3 md:mb-4 group-hover:text-green-400 transition-colors duration-300", children: "Education & Background" }, void 0, false, {
              fileName: "/workspace/personal-blog/src/pages/Home/Home.tsx",
              lineNumber: 169,
              columnNumber: 13
            }, undefined),
            /* @__PURE__ */ jsxDevRuntimeExports.jsxDEV("div", { className: "space-y-3 md:space-y-4", children: [
              { title: "Bachelor of Software Engineering", institution: "University of Victoria", period: "2011-2015", description: "Computer Networks, Architecture, Databases, Algorithms, Software Development Methods" },
              { title: "Technical Skills", institution: "Professional Experience", period: "8+ years", description: "Languages: Python, Go, Java, PHP, C/C++, JavaScript. Infrastructure: AWS, GCP, Kubernetes, Docker" }
            ].map((edu, index) => /* @__PURE__ */ jsxDevRuntimeExports.jsxDEV(
              "div",
              {
                className: "border-l-4 border-green-500 pl-3 md:pl-4 transition-all duration-300 hover:border-green-600 hover:pl-5",
                style: { transitionDelay: `${index * 100}ms` },
                children: [
                  /* @__PURE__ */ jsxDevRuntimeExports.jsxDEV("div", { className: "font-semibold text-vs-editor-text text-sm md:text-base group-hover:text-green-400 transition-colors duration-300", children: edu.title }, void 0, false, {
                    fileName: "/workspace/personal-blog/src/pages/Home/Home.tsx",
                    lineNumber: 180,
                    columnNumber: 19
                  }, undefined),
                  /* @__PURE__ */ jsxDevRuntimeExports.jsxDEV("div", { className: "text-xs md:text-sm text-vs-editor-text2", children: [
                    edu.institution,
                    " • ",
                    edu.period
                  ] }, void 0, true, {
                    fileName: "/workspace/personal-blog/src/pages/Home/Home.tsx",
                    lineNumber: 181,
                    columnNumber: 19
                  }, undefined),
                  /* @__PURE__ */ jsxDevRuntimeExports.jsxDEV("div", { className: "text-xs md:text-sm text-vs-editor-text3 mt-1 group-hover:text-vs-editor-text transition-colors duration-300", children: edu.description }, void 0, false, {
                    fileName: "/workspace/personal-blog/src/pages/Home/Home.tsx",
                    lineNumber: 182,
                    columnNumber: 19
                  }, undefined)
                ]
              },
              edu.title,
              true,
              {
                fileName: "/workspace/personal-blog/src/pages/Home/Home.tsx",
                lineNumber: 175,
                columnNumber: 17
              },
              undefined
            )) }, void 0, false, {
              fileName: "/workspace/personal-blog/src/pages/Home/Home.tsx",
              lineNumber: 170,
              columnNumber: 13
            }, undefined)
          ] }, void 0, true, {
            fileName: "/workspace/personal-blog/src/pages/Home/Home.tsx",
            lineNumber: 168,
            columnNumber: 11
          }, undefined)
        ] }, void 0, true, {
          fileName: "/workspace/personal-blog/src/pages/Home/Home.tsx",
          lineNumber: 145,
          columnNumber: 9
        }, undefined)
      ] }, void 0, true, {
        fileName: "/workspace/personal-blog/src/pages/Home/Home.tsx",
        lineNumber: 27,
        columnNumber: 7
      }, undefined)
    },
    void 0,
    false,
    {
      fileName: "/workspace/personal-blog/src/pages/Home/Home.tsx",
      lineNumber: 20,
      columnNumber: 5
    },
    undefined
  );
};

const Breadcrumb = ({ items, className = "" }) => {
  return /* @__PURE__ */ jsxDevRuntimeExports.jsxDEV("nav", { className: `flex items-center space-x-1 sm:space-x-2 text-xs sm:text-sm ${className}`, "aria-label": "Breadcrumb", children: [
    /* @__PURE__ */ jsxDevRuntimeExports.jsxDEV(
      Link,
      {
        to: "/",
        className: "flex items-center text-vs-editor-text2 hover:text-vs-editor-text transition-colors p-1",
        "aria-label": "Go to home page",
        children: /* @__PURE__ */ jsxDevRuntimeExports.jsxDEV(House, { className: "w-3 h-3 sm:w-4 sm:h-4" }, void 0, false, {
          fileName: "/workspace/personal-blog/src/components/Breadcrumb/Breadcrumb.tsx",
          lineNumber: 24,
          columnNumber: 9
        }, undefined)
      },
      void 0,
      false,
      {
        fileName: "/workspace/personal-blog/src/components/Breadcrumb/Breadcrumb.tsx",
        lineNumber: 19,
        columnNumber: 7
      },
      undefined
    ),
    items.map((item, index) => /* @__PURE__ */ jsxDevRuntimeExports.jsxDEV(React.Fragment, { children: [
      /* @__PURE__ */ jsxDevRuntimeExports.jsxDEV(ChevronRight, { className: "w-3 h-3 sm:w-4 sm:h-4 text-vs-editor-text2", "data-testid": "chevron-right" }, void 0, false, {
        fileName: "/workspace/personal-blog/src/components/Breadcrumb/Breadcrumb.tsx",
        lineNumber: 29,
        columnNumber: 11
      }, undefined),
      item.isCurrent ? /* @__PURE__ */ jsxDevRuntimeExports.jsxDEV("span", { className: "text-vs-editor-text font-medium px-1", "aria-current": "page", children: item.label }, void 0, false, {
        fileName: "/workspace/personal-blog/src/components/Breadcrumb/Breadcrumb.tsx",
        lineNumber: 31,
        columnNumber: 13
      }, undefined) : item.path ? /* @__PURE__ */ jsxDevRuntimeExports.jsxDEV(
        Link,
        {
          to: item.path,
          className: "text-vs-editor-text2 hover:text-vs-editor-text transition-colors px-1",
          children: item.label
        },
        void 0,
        false,
        {
          fileName: "/workspace/personal-blog/src/components/Breadcrumb/Breadcrumb.tsx",
          lineNumber: 35,
          columnNumber: 13
        },
        undefined
      ) : /* @__PURE__ */ jsxDevRuntimeExports.jsxDEV("span", { className: "text-vs-editor-text2 px-1", children: item.label }, void 0, false, {
        fileName: "/workspace/personal-blog/src/components/Breadcrumb/Breadcrumb.tsx",
        lineNumber: 42,
        columnNumber: 13
      }, undefined)
    ] }, index, true, {
      fileName: "/workspace/personal-blog/src/components/Breadcrumb/Breadcrumb.tsx",
      lineNumber: 28,
      columnNumber: 9
    }, undefined))
  ] }, void 0, true, {
    fileName: "/workspace/personal-blog/src/components/Breadcrumb/Breadcrumb.tsx",
    lineNumber: 18,
    columnNumber: 5
  }, undefined);
};

const MediaGallery = ({ images = [], videos = [] }) => {
  const [selectedMedia, setSelectedMedia] = reactExports.useState(null);
  const [isModalOpen, setIsModalOpen] = reactExports.useState(false);
  const allMedia = [...images, ...videos];
  if (allMedia.length === 0) {
    return null;
  }
  return /* @__PURE__ */ jsxDevRuntimeExports.jsxDEV("div", { className: "mb-6 sm:mb-8", children: [
    /* @__PURE__ */ jsxDevRuntimeExports.jsxDEV("h3", { className: "text-lg sm:text-xl font-semibold mb-3 sm:mb-4 text-vs-editor-text", children: "Project Media" }, void 0, false, {
      fileName: "/workspace/personal-blog/src/components/MediaGallery/MediaGallery.tsx",
      lineNumber: 21,
      columnNumber: 13
    }, undefined),
    /* @__PURE__ */ jsxDevRuntimeExports.jsxDEV("div", { className: "grid grid-cols-1 sm:grid-cols-2 lg:grid-cols-3 gap-3 sm:gap-4", children: allMedia.map((media, index) => /* @__PURE__ */ jsxDevRuntimeExports.jsxDEV("div", { className: "relative group cursor-pointer", children: [
      media.type === "image" ? /* @__PURE__ */ jsxDevRuntimeExports.jsxDEV(
        "img",
        {
          src: media.src,
          alt: media.alt || "Project media",
          className: "w-full h-32 sm:h-40 lg:h-48 object-cover rounded-lg shadow-md group-hover:shadow-lg transition-shadow",
          onClick: () => {
            setSelectedMedia(media);
            setIsModalOpen(true);
          }
        },
        void 0,
        false,
        {
          fileName: "/workspace/personal-blog/src/components/MediaGallery/MediaGallery.tsx",
          lineNumber: 26,
          columnNumber: 29
        },
        undefined
      ) : /* @__PURE__ */ jsxDevRuntimeExports.jsxDEV(
        "div",
        {
          className: "relative cursor-pointer",
          onClick: () => {
            setSelectedMedia(media);
            setIsModalOpen(true);
          },
          children: [
            /* @__PURE__ */ jsxDevRuntimeExports.jsxDEV(
              "img",
              {
                src: media.thumbnail || media.src,
                alt: media.alt || "Video thumbnail",
                className: "w-full h-32 sm:h-40 lg:h-48 object-cover rounded-lg shadow-md group-hover:shadow-lg transition-shadow"
              },
              void 0,
              false,
              {
                fileName: "/workspace/personal-blog/src/components/MediaGallery/MediaGallery.tsx",
                lineNumber: 43,
                columnNumber: 33
              },
              undefined
            ),
            /* @__PURE__ */ jsxDevRuntimeExports.jsxDEV("div", { className: "absolute inset-0 flex items-center justify-center bg-black bg-opacity-30 rounded-lg", children: /* @__PURE__ */ jsxDevRuntimeExports.jsxDEV("div", { className: "w-12 h-12 sm:w-14 sm:h-14 lg:w-16 lg:h-16 bg-white bg-opacity-90 rounded-full flex items-center justify-center", children: /* @__PURE__ */ jsxDevRuntimeExports.jsxDEV("svg", { className: "w-6 h-6 sm:w-7 sm:h-7 lg:w-8 lg:h-8 text-gray-800 ml-0.5 sm:ml-1", fill: "currentColor", viewBox: "0 0 20 20", children: /* @__PURE__ */ jsxDevRuntimeExports.jsxDEV("path", { fillRule: "evenodd", d: "M10 18a8 8 0 100-16 8 8 0 000 16zM9.664l-3-2z", clipRule: "evenodd" }, void 0, false, {
              fileName: "/workspace/personal-blog/src/components/MediaGallery/MediaGallery.tsx",
              lineNumber: 51,
              columnNumber: 45
            }, undefined) }, void 0, false, {
              fileName: "/workspace/personal-blog/src/components/MediaGallery/MediaGallery.tsx",
              lineNumber: 50,
              columnNumber: 41
            }, undefined) }, void 0, false, {
              fileName: "/workspace/personal-blog/src/components/MediaGallery/MediaGallery.tsx",
              lineNumber: 49,
              columnNumber: 37
            }, undefined) }, void 0, false, {
              fileName: "/workspace/personal-blog/src/components/MediaGallery/MediaGallery.tsx",
              lineNumber: 48,
              columnNumber: 33
            }, undefined)
          ]
        },
        void 0,
        true,
        {
          fileName: "/workspace/personal-blog/src/components/MediaGallery/MediaGallery.tsx",
          lineNumber: 36,
          columnNumber: 29
        },
        undefined
      ),
      media.caption && /* @__PURE__ */ jsxDevRuntimeExports.jsxDEV("p", { className: "mt-2 text-xs sm:text-sm text-vs-editor-text2 text-center px-1", children: media.caption }, void 0, false, {
        fileName: "/workspace/personal-blog/src/components/MediaGallery/MediaGallery.tsx",
        lineNumber: 58,
        columnNumber: 29
      }, undefined)
    ] }, index, true, {
      fileName: "/workspace/personal-blog/src/components/MediaGallery/MediaGallery.tsx",
      lineNumber: 24,
      columnNumber: 21
    }, undefined)) }, void 0, false, {
      fileName: "/workspace/personal-blog/src/components/MediaGallery/MediaGallery.tsx",
      lineNumber: 22,
      columnNumber: 13
    }, undefined),
    isModalOpen && selectedMedia && /* @__PURE__ */ jsxDevRuntimeExports.jsxDEV("div", { className: "fixed inset-0 bg-black bg-opacity-75 flex items-center justify-center z-50 p-2 sm:p-4", children: /* @__PURE__ */ jsxDevRuntimeExports.jsxDEV("div", { className: "relative max-w-full max-h-full w-full sm:max-w-2xl lg:max-w-4xl", children: [
      /* @__PURE__ */ jsxDevRuntimeExports.jsxDEV(
        "button",
        {
          onClick: () => setIsModalOpen(false),
          className: "absolute top-2 sm:top-4 right-2 sm:right-4 text-white text-xl sm:text-2xl hover:text-vs-editor-text2 transition-colors z-10 bg-black bg-opacity-50 rounded-full w-8 h-8 sm:w-10 sm:h-10 flex items-center justify-center",
          children: "×"
        },
        void 0,
        false,
        {
          fileName: "/workspace/personal-blog/src/components/MediaGallery/MediaGallery.tsx",
          lineNumber: 68,
          columnNumber: 25
        },
        undefined
      ),
      selectedMedia.type === "image" ? /* @__PURE__ */ jsxDevRuntimeExports.jsxDEV(
        "img",
        {
          src: selectedMedia.src,
          alt: selectedMedia.alt || "Project media",
          className: "max-w-full max-h-full object-contain rounded-lg"
        },
        void 0,
        false,
        {
          fileName: "/workspace/personal-blog/src/components/MediaGallery/MediaGallery.tsx",
          lineNumber: 75,
          columnNumber: 29
        },
        undefined
      ) : /* @__PURE__ */ jsxDevRuntimeExports.jsxDEV(
        "iframe",
        {
          src: selectedMedia.src,
          title: selectedMedia.alt || "Project video",
          className: "w-full h-64 sm:h-80 lg:h-96 rounded-lg",
          allowFullScreen: true
        },
        void 0,
        false,
        {
          fileName: "/workspace/personal-blog/src/components/MediaGallery/MediaGallery.tsx",
          lineNumber: 81,
          columnNumber: 29
        },
        undefined
      ),
      selectedMedia.caption && /* @__PURE__ */ jsxDevRuntimeExports.jsxDEV("p", { className: "mt-2 sm:mt-4 text-white text-center text-sm sm:text-base lg:text-lg px-2", children: selectedMedia.caption }, void 0, false, {
        fileName: "/workspace/personal-blog/src/components/MediaGallery/MediaGallery.tsx",
        lineNumber: 89,
        columnNumber: 29
      }, undefined)
    ] }, void 0, true, {
      fileName: "/workspace/personal-blog/src/components/MediaGallery/MediaGallery.tsx",
      lineNumber: 67,
      columnNumber: 21
    }, undefined) }, void 0, false, {
      fileName: "/workspace/personal-blog/src/components/MediaGallery/MediaGallery.tsx",
      lineNumber: 66,
      columnNumber: 17
    }, undefined)
  ] }, void 0, true, {
    fileName: "/workspace/personal-blog/src/components/MediaGallery/MediaGallery.tsx",
    lineNumber: 20,
    columnNumber: 9
  }, undefined);
};

const ProjectDetail = () => {
  const { projectId } = useParams();
  const navigate = useNavigate();
  const [content, setContent] = reactExports.useState(null);
  const [loadingState, setLoadingState] = reactExports.useState("loading");
  const [error, setError] = reactExports.useState(null);
  reactExports.useEffect(() => {
    window.scrollTo(0, 0);
  }, [projectId]);
  reactExports.useEffect(() => {
    const loadContent = async () => {
      if (!projectId) {
        setLoadingState("error");
        setError("No project ID provided");
        return;
      }
      try {
        setLoadingState("loading");
        const projectContent = await loadProjectContent(projectId);
        if (projectContent) {
          setContent(projectContent);
          setLoadingState("loaded");
        } else {
          setLoadingState("error");
          setError("Content not found");
        }
      } catch (err) {
        setLoadingState("error");
        setError(err instanceof Error ? err.message : "Failed to load content");
      }
    };
    loadContent();
  }, [projectId]);
  const project = projectId ? getProjectById(projectId) : void 0;
  if (loadingState === "error" && error) {
    console.error(`Failed to load project content for ID "${projectId}":`, error);
    return /* @__PURE__ */ jsxDevRuntimeExports.jsxDEV(
      ErrorPage,
      {
        errorType: "content-error",
        title: "Content Loading Error",
        message: "The project exists but its content could not be loaded.",
        error,
        showBackButton: true,
        showHomeButton: true
      },
      void 0,
      false,
      {
        fileName: "/workspace/personal-blog/src/pages/ProjectDetail/ProjectDetail.tsx",
        lineNumber: 60,
        columnNumber: 13
      },
      undefined
    );
  }
  if (!project) {
    console.warn(`Project with ID "${projectId}" not found in metadata`);
    return /* @__PURE__ */ jsxDevRuntimeExports.jsxDEV(
      ErrorPage,
      {
        errorType: "not-found",
        title: "Project Not Found",
        message: "The project you're looking for doesn't exist.",
        showBackButton: true,
        showHomeButton: true
      },
      void 0,
      false,
      {
        fileName: "/workspace/personal-blog/src/pages/ProjectDetail/ProjectDetail.tsx",
        lineNumber: 74,
        columnNumber: 13
      },
      undefined
    );
  }
  const breadcrumbItems = [
    { label: "Projects", path: "/projects" },
    { label: project.title, isCurrent: true }
  ];
  const calculateReadTime = (markdownContent) => {
    const words = markdownContent.replace(/<[^>]*>/g, "").split(/\s+/).filter((word) => word.length > 0);
    const wpm = 100;
    const minutes = Math.ceil(words.length / wpm);
    return minutes;
  };
  return /* @__PURE__ */ jsxDevRuntimeExports.jsxDEV(Layout, { maxWidth: "full", padding: "lg", children: /* @__PURE__ */ jsxDevRuntimeExports.jsxDEV("div", { className: "w-full px-4 sm:px-6 lg:px-8 py-4 sm:py-6 lg:py-8", children: /* @__PURE__ */ jsxDevRuntimeExports.jsxDEV("div", { className: "w-full max-w-7xl mx-auto", children: [
    /* @__PURE__ */ jsxDevRuntimeExports.jsxDEV(Breadcrumb, { items: breadcrumbItems, className: "mb-4 sm:mb-6" }, void 0, false, {
      fileName: "/workspace/personal-blog/src/pages/ProjectDetail/ProjectDetail.tsx",
      lineNumber: 102,
      columnNumber: 21
    }, undefined),
    /* @__PURE__ */ jsxDevRuntimeExports.jsxDEV("div", { className: "flex flex-col sm:flex-row sm:items-center sm:justify-between gap-4 mb-6 sm:mb-8", children: [
      /* @__PURE__ */ jsxDevRuntimeExports.jsxDEV(
        "button",
        {
          onClick: () => navigate("/projects"),
          className: "flex items-center text-crystal-blue-400 hover:text-crystal-blue-300 transition-colors font-medium text-sm sm:text-base",
          children: [
            /* @__PURE__ */ jsxDevRuntimeExports.jsxDEV("svg", { className: "w-4 h-4 mr-2", fill: "none", stroke: "currentColor", viewBox: "0 0 24 24", children: /* @__PURE__ */ jsxDevRuntimeExports.jsxDEV("path", { strokeLinecap: "round", strokeLinejoin: "round", strokeWidth: 2, d: "M15 19l-7-7 7-7" }, void 0, false, {
              fileName: "/workspace/personal-blog/src/pages/ProjectDetail/ProjectDetail.tsx",
              lineNumber: 111,
              columnNumber: 33
            }, undefined) }, void 0, false, {
              fileName: "/workspace/personal-blog/src/pages/ProjectDetail/ProjectDetail.tsx",
              lineNumber: 110,
              columnNumber: 29
            }, undefined),
            "Back to Projects"
          ]
        },
        void 0,
        true,
        {
          fileName: "/workspace/personal-blog/src/pages/ProjectDetail/ProjectDetail.tsx",
          lineNumber: 106,
          columnNumber: 25
        },
        undefined
      ),
      /* @__PURE__ */ jsxDevRuntimeExports.jsxDEV("div", { className: "flex flex-col sm:flex-row gap-2 sm:gap-3", children: [
        project.liveDemo && /* @__PURE__ */ jsxDevRuntimeExports.jsxDEV(
          "a",
          {
            href: project.liveDemo,
            target: "_blank",
            rel: "noopener noreferrer",
            className: "px-3 sm:px-4 py-2 bg-crystal-blue-600 text-white rounded-lg hover:bg-crystal-blue-700 transition-colors text-xs sm:text-sm text-center",
            children: "View Live Demo"
          },
          void 0,
          false,
          {
            fileName: "/workspace/personal-blog/src/pages/ProjectDetail/ProjectDetail.tsx",
            lineNumber: 119,
            columnNumber: 33
          },
          undefined
        ),
        project.githubRepo && /* @__PURE__ */ jsxDevRuntimeExports.jsxDEV(
          "a",
          {
            href: project.githubRepo,
            target: "_blank",
            rel: "noopener noreferrer",
            className: "px-3 sm:px-4 py-2 bg-gray-800 text-white rounded-lg hover:bg-gray-900 transition-colors text-xs sm:text-sm text-center",
            children: "View on GitHub"
          },
          void 0,
          false,
          {
            fileName: "/workspace/personal-blog/src/pages/ProjectDetail/ProjectDetail.tsx",
            lineNumber: 129,
            columnNumber: 33
          },
          undefined
        )
      ] }, void 0, true, {
        fileName: "/workspace/personal-blog/src/pages/ProjectDetail/ProjectDetail.tsx",
        lineNumber: 117,
        columnNumber: 25
      }, undefined)
    ] }, void 0, true, {
      fileName: "/workspace/personal-blog/src/pages/ProjectDetail/ProjectDetail.tsx",
      lineNumber: 105,
      columnNumber: 21
    }, undefined),
    /* @__PURE__ */ jsxDevRuntimeExports.jsxDEV("div", { className: "mb-6 sm:mb-8", children: [
      /* @__PURE__ */ jsxDevRuntimeExports.jsxDEV("h1", { className: "heading-1 mb-3 sm:mb-4 text-lg sm:text-2xl lg:text-3xl", children: project.title }, void 0, false, {
        fileName: "/workspace/personal-blog/src/pages/ProjectDetail/ProjectDetail.tsx",
        lineNumber: 143,
        columnNumber: 25
      }, undefined),
      /* @__PURE__ */ jsxDevRuntimeExports.jsxDEV("p", { className: "body-text text-vs-editor-text2 mb-4 sm:mb-6 text-sm sm:text-base leading-relaxed", children: project.description }, void 0, false, {
        fileName: "/workspace/personal-blog/src/pages/ProjectDetail/ProjectDetail.tsx",
        lineNumber: 144,
        columnNumber: 25
      }, undefined),
      /* @__PURE__ */ jsxDevRuntimeExports.jsxDEV("div", { className: "flex flex-wrap items-center gap-4 mb-4 sm:mb-6", children: [
        /* @__PURE__ */ jsxDevRuntimeExports.jsxDEV("div", { className: "flex flex-wrap gap-2", children: project.tags?.map((tag) => /* @__PURE__ */ jsxDevRuntimeExports.jsxDEV(
          "span",
          {
            className: "inline-flex items-center px-3 py-1 rounded-full text-xs font-medium bg-vs-editor-surface2 text-vs-editor-text2",
            children: [
              /* @__PURE__ */ jsxDevRuntimeExports.jsxDEV(Tag, { className: "w-3 h-3 mr-1" }, void 0, false, {
                fileName: "/workspace/personal-blog/src/pages/ProjectDetail/ProjectDetail.tsx",
                lineNumber: 155,
                columnNumber: 41
              }, undefined),
              tag
            ]
          },
          tag,
          true,
          {
            fileName: "/workspace/personal-blog/src/pages/ProjectDetail/ProjectDetail.tsx",
            lineNumber: 151,
            columnNumber: 37
          },
          undefined
        )) }, void 0, false, {
          fileName: "/workspace/personal-blog/src/pages/ProjectDetail/ProjectDetail.tsx",
          lineNumber: 149,
          columnNumber: 29
        }, undefined),
        /* @__PURE__ */ jsxDevRuntimeExports.jsxDEV("div", { className: "flex items-center gap-4 text-xs sm:text-sm text-vs-editor-text3", children: [
          /* @__PURE__ */ jsxDevRuntimeExports.jsxDEV("div", { className: "flex items-center", children: [
            /* @__PURE__ */ jsxDevRuntimeExports.jsxDEV(Clock, { className: "w-4 h-4 mr-1" }, void 0, false, {
              fileName: "/workspace/personal-blog/src/pages/ProjectDetail/ProjectDetail.tsx",
              lineNumber: 164,
              columnNumber: 37
            }, undefined),
            content?.content ? calculateReadTime(content.content) : "Loading...",
            " min read"
          ] }, void 0, true, {
            fileName: "/workspace/personal-blog/src/pages/ProjectDetail/ProjectDetail.tsx",
            lineNumber: 163,
            columnNumber: 33
          }, undefined),
          content?.content && /* @__PURE__ */ jsxDevRuntimeExports.jsxDEV("div", { className: "flex items-center", children: [
            /* @__PURE__ */ jsxDevRuntimeExports.jsxDEV("span", { className: "mr-1", children: "📝" }, void 0, false, {
              fileName: "/workspace/personal-blog/src/pages/ProjectDetail/ProjectDetail.tsx",
              lineNumber: 169,
              columnNumber: 41
            }, undefined),
            content.content.trim().split(/\s+/).filter((word) => word.length > 0).length,
            " words"
          ] }, void 0, true, {
            fileName: "/workspace/personal-blog/src/pages/ProjectDetail/ProjectDetail.tsx",
            lineNumber: 168,
            columnNumber: 37
          }, undefined)
        ] }, void 0, true, {
          fileName: "/workspace/personal-blog/src/pages/ProjectDetail/ProjectDetail.tsx",
          lineNumber: 162,
          columnNumber: 29
        }, undefined)
      ] }, void 0, true, {
        fileName: "/workspace/personal-blog/src/pages/ProjectDetail/ProjectDetail.tsx",
        lineNumber: 147,
        columnNumber: 25
      }, undefined),
      /* @__PURE__ */ jsxDevRuntimeExports.jsxDEV("div", { className: "mb-6", children: /* @__PURE__ */ jsxDevRuntimeExports.jsxDEV(
        "img",
        {
          src: project.image,
          alt: project.title,
          className: "w-full h-48 sm:h-56 lg:h-64 object-cover rounded-lg shadow-md"
        },
        void 0,
        false,
        {
          fileName: "/workspace/personal-blog/src/pages/ProjectDetail/ProjectDetail.tsx",
          lineNumber: 178,
          columnNumber: 29
        },
        undefined
      ) }, void 0, false, {
        fileName: "/workspace/personal-blog/src/pages/ProjectDetail/ProjectDetail.tsx",
        lineNumber: 177,
        columnNumber: 25
      }, undefined)
    ] }, void 0, true, {
      fileName: "/workspace/personal-blog/src/pages/ProjectDetail/ProjectDetail.tsx",
      lineNumber: 142,
      columnNumber: 21
    }, undefined),
    /* @__PURE__ */ jsxDevRuntimeExports.jsxDEV(MediaGallery, { images: project.images, videos: project.videos }, void 0, false, {
      fileName: "/workspace/personal-blog/src/pages/ProjectDetail/ProjectDetail.tsx",
      lineNumber: 187,
      columnNumber: 21
    }, undefined),
    /* @__PURE__ */ jsxDevRuntimeExports.jsxDEV("div", { className: "prose prose-sm sm:prose-base lg:prose-lg max-w-none mt-6 sm:mt-8", children: /* @__PURE__ */ jsxDevRuntimeExports.jsxDEV(
      MarkdownRenderer,
      {
        content: content?.content || "",
        loadingState,
        loadingStateData: { error },
        className: "prose-headings:text-vs-editor-text prose-p:text-vs-editor-text2 prose-strong:text-vs-editor-text",
        options: {
          highlightCode: true,
          breaks: true
        },
        emptyContentMessage: "Project content is being loaded...",
        onError: (err) => {
          setError(err.message);
          setLoadingState("error");
        }
      },
      void 0,
      false,
      {
        fileName: "/workspace/personal-blog/src/pages/ProjectDetail/ProjectDetail.tsx",
        lineNumber: 191,
        columnNumber: 25
      },
      undefined
    ) }, void 0, false, {
      fileName: "/workspace/personal-blog/src/pages/ProjectDetail/ProjectDetail.tsx",
      lineNumber: 190,
      columnNumber: 21
    }, undefined)
  ] }, void 0, true, {
    fileName: "/workspace/personal-blog/src/pages/ProjectDetail/ProjectDetail.tsx",
    lineNumber: 100,
    columnNumber: 17
  }, undefined) }, void 0, false, {
    fileName: "/workspace/personal-blog/src/pages/ProjectDetail/ProjectDetail.tsx",
    lineNumber: 99,
    columnNumber: 13
  }, undefined) }, void 0, false, {
    fileName: "/workspace/personal-blog/src/pages/ProjectDetail/ProjectDetail.tsx",
    lineNumber: 98,
    columnNumber: 9
  }, undefined);
};

const ProjectCard = ({
  project,
  onViewDetails,
  className = ""
}) => {
  const handleViewDetails = () => {
    if (onViewDetails) {
      onViewDetails(project.id);
    }
  };
  return /* @__PURE__ */ jsxDevRuntimeExports.jsxDEV(
    "div",
    {
      "data-testid": "project-card",
      className: `bg-vs-editor-surface rounded-lg shadow-lg overflow-hidden hover:shadow-xl transition-shadow duration-300 border border-vs-editor-border ${className}`,
      children: /* @__PURE__ */ jsxDevRuntimeExports.jsxDEV("div", { className: "flex flex-col lg:flex-row", children: [
        /* @__PURE__ */ jsxDevRuntimeExports.jsxDEV("div", { className: "w-full lg:w-1/3 aspect-video lg:aspect-square bg-vs-editor-surface2 overflow-hidden", children: [
          /* @__PURE__ */ jsxDevRuntimeExports.jsxDEV(
            "img",
            {
              src: project.image,
              alt: project.title,
              className: "w-full h-full object-cover hover:scale-105 transition-transform duration-300",
              onError: (e) => {
                const target = e.target;
                target.style.display = "none";
                target.nextElementSibling?.classList.remove("hidden");
              }
            },
            void 0,
            false,
            {
              fileName: "/workspace/personal-blog/src/components/ProjectCard/ProjectCard.tsx",
              lineNumber: 29,
              columnNumber: 11
            },
            undefined
          ),
          /* @__PURE__ */ jsxDevRuntimeExports.jsxDEV("div", { className: "hidden w-full h-full flex items-center justify-center text-2xl sm:text-4xl text-vs-editor-text2 bg-vs-editor-surface2", children: "🚀" }, void 0, false, {
            fileName: "/workspace/personal-blog/src/components/ProjectCard/ProjectCard.tsx",
            lineNumber: 39,
            columnNumber: 11
          }, undefined)
        ] }, void 0, true, {
          fileName: "/workspace/personal-blog/src/components/ProjectCard/ProjectCard.tsx",
          lineNumber: 28,
          columnNumber: 9
        }, undefined),
        /* @__PURE__ */ jsxDevRuntimeExports.jsxDEV("div", { className: "p-4 sm:p-6 flex-1 flex flex-col justify-between", children: [
          /* @__PURE__ */ jsxDevRuntimeExports.jsxDEV("div", { children: [
            /* @__PURE__ */ jsxDevRuntimeExports.jsxDEV("h3", { className: "text-lg sm:text-xl font-semibold text-vs-editor-text mb-2 sm:mb-3 leading-tight", children: project.title }, void 0, false, {
              fileName: "/workspace/personal-blog/src/components/ProjectCard/ProjectCard.tsx",
              lineNumber: 47,
              columnNumber: 13
            }, undefined),
            /* @__PURE__ */ jsxDevRuntimeExports.jsxDEV("p", { className: "text-vs-editor-text2 mb-3 sm:mb-4 text-sm sm:text-base overflow-hidden leading-relaxed", style: {
              display: "-webkit-box",
              WebkitLineClamp: 3,
              WebkitBoxOrient: "vertical"
            }, children: project.description }, void 0, false, {
              fileName: "/workspace/personal-blog/src/components/ProjectCard/ProjectCard.tsx",
              lineNumber: 50,
              columnNumber: 13
            }, undefined),
            /* @__PURE__ */ jsxDevRuntimeExports.jsxDEV("div", { className: "mb-3 sm:mb-4", children: /* @__PURE__ */ jsxDevRuntimeExports.jsxDEV("div", { className: "flex flex-wrap gap-1.5 sm:gap-2", children: project.techStack.map((tech) => /* @__PURE__ */ jsxDevRuntimeExports.jsxDEV(
              "span",
              {
                className: "px-2 sm:px-3 py-1 bg-crystal-blue-500/20 text-crystal-blue-400 text-xs sm:text-sm rounded-full font-medium",
                children: tech
              },
              tech,
              false,
              {
                fileName: "/workspace/personal-blog/src/components/ProjectCard/ProjectCard.tsx",
                lineNumber: 62,
                columnNumber: 19
              },
              undefined
            )) }, void 0, false, {
              fileName: "/workspace/personal-blog/src/components/ProjectCard/ProjectCard.tsx",
              lineNumber: 60,
              columnNumber: 15
            }, undefined) }, void 0, false, {
              fileName: "/workspace/personal-blog/src/components/ProjectCard/ProjectCard.tsx",
              lineNumber: 59,
              columnNumber: 13
            }, undefined)
          ] }, void 0, true, {
            fileName: "/workspace/personal-blog/src/components/ProjectCard/ProjectCard.tsx",
            lineNumber: 46,
            columnNumber: 11
          }, undefined),
          /* @__PURE__ */ jsxDevRuntimeExports.jsxDEV("div", { className: "flex flex-col sm:flex-row sm:justify-between sm:items-center gap-3 sm:gap-4 pt-2 sm:pt-0", children: [
            /* @__PURE__ */ jsxDevRuntimeExports.jsxDEV("span", { className: "text-xs sm:text-sm text-vs-editor-text3 flex items-center", children: [
              /* @__PURE__ */ jsxDevRuntimeExports.jsxDEV("svg", { className: "w-3 h-3 sm:w-4 sm:h-4 mr-1.5 sm:mr-2", fill: "none", stroke: "currentColor", viewBox: "0 0 24 24", children: /* @__PURE__ */ jsxDevRuntimeExports.jsxDEV("path", { strokeLinecap: "round", strokeLinejoin: "round", strokeWidth: 2, d: "M8 7V3m8 4V3m-9 8h10M5 21h14a2 2 0 002-2V7a2 2 0 00-2-2H5a2 2 0 00-2 2v12a2 2 0 002 2z" }, void 0, false, {
                fileName: "/workspace/personal-blog/src/components/ProjectCard/ProjectCard.tsx",
                lineNumber: 77,
                columnNumber: 17
              }, undefined) }, void 0, false, {
                fileName: "/workspace/personal-blog/src/components/ProjectCard/ProjectCard.tsx",
                lineNumber: 76,
                columnNumber: 15
              }, undefined),
              new Date(project.date).toLocaleDateString("en-US", {
                year: "numeric",
                month: "long"
              })
            ] }, void 0, true, {
              fileName: "/workspace/personal-blog/src/components/ProjectCard/ProjectCard.tsx",
              lineNumber: 75,
              columnNumber: 13
            }, undefined),
            project.showDetails && /* @__PURE__ */ jsxDevRuntimeExports.jsxDEV(
              "button",
              {
                onClick: handleViewDetails,
                className: "px-3 sm:px-4 py-2 bg-crystal-blue-600 text-white rounded-lg hover:bg-crystal-blue-700 transition-colors duration-200 text-xs sm:text-sm font-medium w-full sm:w-auto",
                children: "View Details"
              },
              void 0,
              false,
              {
                fileName: "/workspace/personal-blog/src/components/ProjectCard/ProjectCard.tsx",
                lineNumber: 85,
                columnNumber: 15
              },
              undefined
            )
          ] }, void 0, true, {
            fileName: "/workspace/personal-blog/src/components/ProjectCard/ProjectCard.tsx",
            lineNumber: 74,
            columnNumber: 11
          }, undefined)
        ] }, void 0, true, {
          fileName: "/workspace/personal-blog/src/components/ProjectCard/ProjectCard.tsx",
          lineNumber: 45,
          columnNumber: 9
        }, undefined)
      ] }, void 0, true, {
        fileName: "/workspace/personal-blog/src/components/ProjectCard/ProjectCard.tsx",
        lineNumber: 26,
        columnNumber: 7
      }, undefined)
    },
    void 0,
    false,
    {
      fileName: "/workspace/personal-blog/src/components/ProjectCard/ProjectCard.tsx",
      lineNumber: 22,
      columnNumber: 5
    },
    undefined
  );
};

const Projects = () => {
  const navigate = useNavigate();
  return /* @__PURE__ */ jsxDevRuntimeExports.jsxDEV(Layout, { maxWidth: "full", padding: "lg", children: /* @__PURE__ */ jsxDevRuntimeExports.jsxDEV("div", { className: "w-full px-4 sm:px-6 lg:px-8 py-4 sm:py-6 lg:py-8", children: [
    /* @__PURE__ */ jsxDevRuntimeExports.jsxDEV("div", { className: "text-center mb-8 sm:mb-12", children: [
      /* @__PURE__ */ jsxDevRuntimeExports.jsxDEV("h1", { className: "heading-1 mb-4 sm:mb-6 text-2xl sm:text-3xl lg:text-4xl", children: "My Projects" }, void 0, false, {
        fileName: "/workspace/personal-blog/src/pages/Projects/Projects.tsx",
        lineNumber: 14,
        columnNumber: 11
      }, undefined),
      /* @__PURE__ */ jsxDevRuntimeExports.jsxDEV("p", { className: "body-text max-w-3xl mx-auto text-sm sm:text-base leading-relaxed px-2", children: "A collection of random projects that I've worked on. I'm usually trying to learn something new when I build something so the technologies and scope is a mix of what I want to learn." }, void 0, false, {
        fileName: "/workspace/personal-blog/src/pages/Projects/Projects.tsx",
        lineNumber: 15,
        columnNumber: 11
      }, undefined)
    ] }, void 0, true, {
      fileName: "/workspace/personal-blog/src/pages/Projects/Projects.tsx",
      lineNumber: 13,
      columnNumber: 9
    }, undefined),
    /* @__PURE__ */ jsxDevRuntimeExports.jsxDEV("div", { className: "space-y-4 sm:space-y-6 w-full max-w-7xl mx-auto", children: projects.map((project) => /* @__PURE__ */ jsxDevRuntimeExports.jsxDEV(
      ProjectCard,
      {
        project,
        onViewDetails: (projectId) => {
          navigate(`/projects/${projectId}`);
        }
      },
      project.id,
      false,
      {
        fileName: "/workspace/personal-blog/src/pages/Projects/Projects.tsx",
        lineNumber: 23,
        columnNumber: 13
      },
      undefined
    )) }, void 0, false, {
      fileName: "/workspace/personal-blog/src/pages/Projects/Projects.tsx",
      lineNumber: 21,
      columnNumber: 9
    }, undefined)
  ] }, void 0, true, {
    fileName: "/workspace/personal-blog/src/pages/Projects/Projects.tsx",
    lineNumber: 12,
    columnNumber: 7
  }, undefined) }, void 0, false, {
    fileName: "/workspace/personal-blog/src/pages/Projects/Projects.tsx",
    lineNumber: 11,
    columnNumber: 5
  }, undefined);
};

const ScrollToTop = () => {
  const { pathname } = useLocation();
  reactExports.useEffect(() => {
    window.scrollTo(0, 0);
    const handleBeforeUnload = () => {
      sessionStorage.setItem("scrollPosition", window.scrollY.toString());
    };
    const handleLoad = () => {
      const savedPosition = sessionStorage.getItem("scrollPosition");
      if (savedPosition) {
        window.scrollTo(0, parseInt(savedPosition));
        sessionStorage.removeItem("scrollPosition");
      }
    };
    window.addEventListener("beforeunload", handleBeforeUnload);
    window.addEventListener("load", handleLoad);
    return () => {
      window.removeEventListener("beforeunload", handleBeforeUnload);
      window.removeEventListener("load", handleLoad);
    };
  }, [pathname]);
  return null;
};
function App() {
  return /* @__PURE__ */ jsxDevRuntimeExports.jsxDEV(BrowserRouter, { children: /* @__PURE__ */ jsxDevRuntimeExports.jsxDEV("div", { className: "min-h-screen bg-vs-editor-bg", children: [
    /* @__PURE__ */ jsxDevRuntimeExports.jsxDEV(Navigation, {}, void 0, false, {
      fileName: "/workspace/personal-blog/src/App.tsx",
      lineNumber: 44,
      columnNumber: 9
    }, this),
    /* @__PURE__ */ jsxDevRuntimeExports.jsxDEV(ScrollToTop, {}, void 0, false, {
      fileName: "/workspace/personal-blog/src/App.tsx",
      lineNumber: 45,
      columnNumber: 9
    }, this),
    /* @__PURE__ */ jsxDevRuntimeExports.jsxDEV(Routes, { children: [
      /* @__PURE__ */ jsxDevRuntimeExports.jsxDEV(Route, { path: "/", element: /* @__PURE__ */ jsxDevRuntimeExports.jsxDEV(Home, {}, void 0, false, {
        fileName: "/workspace/personal-blog/src/App.tsx",
        lineNumber: 47,
        columnNumber: 36
      }, this) }, void 0, false, {
        fileName: "/workspace/personal-blog/src/App.tsx",
        lineNumber: 47,
        columnNumber: 11
      }, this),
      /* @__PURE__ */ jsxDevRuntimeExports.jsxDEV(Route, { path: "/projects", element: /* @__PURE__ */ jsxDevRuntimeExports.jsxDEV(Projects, {}, void 0, false, {
        fileName: "/workspace/personal-blog/src/App.tsx",
        lineNumber: 48,
        columnNumber: 44
      }, this) }, void 0, false, {
        fileName: "/workspace/personal-blog/src/App.tsx",
        lineNumber: 48,
        columnNumber: 11
      }, this),
      /* @__PURE__ */ jsxDevRuntimeExports.jsxDEV(Route, { path: "/projects/:projectId", element: /* @__PURE__ */ jsxDevRuntimeExports.jsxDEV(ProjectDetail, {}, void 0, false, {
        fileName: "/workspace/personal-blog/src/App.tsx",
        lineNumber: 49,
        columnNumber: 55
      }, this) }, void 0, false, {
        fileName: "/workspace/personal-blog/src/App.tsx",
        lineNumber: 49,
        columnNumber: 11
      }, this),
      /* @__PURE__ */ jsxDevRuntimeExports.jsxDEV(Route, { path: "/contact", element: /* @__PURE__ */ jsxDevRuntimeExports.jsxDEV(Contact, {}, void 0, false, {
        fileName: "/workspace/personal-blog/src/App.tsx",
        lineNumber: 52,
        columnNumber: 43
      }, this) }, void 0, false, {
        fileName: "/workspace/personal-blog/src/App.tsx",
        lineNumber: 52,
        columnNumber: 11
      }, this),
      /* @__PURE__ */ jsxDevRuntimeExports.jsxDEV(Route, { path: "*", element: /* @__PURE__ */ jsxDevRuntimeExports.jsxDEV(ErrorPage, { errorType: "not-found" }, void 0, false, {
        fileName: "/workspace/personal-blog/src/App.tsx",
        lineNumber: 53,
        columnNumber: 36
      }, this) }, void 0, false, {
        fileName: "/workspace/personal-blog/src/App.tsx",
        lineNumber: 53,
        columnNumber: 11
      }, this)
    ] }, void 0, true, {
      fileName: "/workspace/personal-blog/src/App.tsx",
      lineNumber: 46,
      columnNumber: 9
    }, this)
  ] }, void 0, true, {
    fileName: "/workspace/personal-blog/src/App.tsx",
    lineNumber: 43,
    columnNumber: 7
  }, this) }, void 0, false, {
    fileName: "/workspace/personal-blog/src/App.tsx",
    lineNumber: 42,
    columnNumber: 5
  }, this);
}

clientExports.createRoot(document.getElementById("root")).render(
  /* @__PURE__ */ jsxDevRuntimeExports.jsxDEV(reactExports.StrictMode, { children: /* @__PURE__ */ jsxDevRuntimeExports.jsxDEV(App, {}, void 0, false, {
    fileName: "/workspace/personal-blog/src/main.tsx",
    lineNumber: 8,
    columnNumber: 5
  }, undefined) }, void 0, false, {
    fileName: "/workspace/personal-blog/src/main.tsx",
    lineNumber: 7,
    columnNumber: 3
  }, undefined)
);

export { commonDb_exports as $, rgba$1 as A, __export as B, setupGraphViewbox2 as C, cleanAndMerge as D, getConfig as E, defaultConfig_default as F, random as G, selectSvgElement as H, package_default as I, JSON_SCHEMA as J, getThemeVariables3 as K, hasKatex as L, calculateMathMLDimensions as M, parseFontSize as N, getUrl as O, renderKatexSanitized as P, parseGenericTypes as Q, line$1 as R, curveBasis as S, generateId as T, lineBreakRegex as U, setupGraphViewbox as V, isDark as W, lighten as X, darken as Y, ZERO_WIDTH_SPACE as Z, __name as _, getAccTitle as a, rgbConvert as a$, withPath as a0, halfPi as a1, epsilon as a2, tau as a3, cos as a4, sin as a5, min as a6, abs$1 as a7, constant$1 as a8, pi as a9, baseRest as aA, isArrayLikeObject as aB, constant as aC, isFunction as aD, isEmpty as aE, computeDimensionOfText as aF, array as aG, getIconSVG as aH, registerIconPacks as aI, unknownIcon as aJ, constant$2 as aK, interpolateNumber as aL, interpolateRgb as aM, interpolateString as aN, color as aO, isObject as aP, isIterateeCall as aQ, keysIn as aR, eq as aS, isArrayLike as aT, isArray as aU, identity as aV, isIndex as aW, assignValue as aX, styles2String as aY, isLabelStyle as aZ, Rgb as a_, sqrt as aa, atan2 as ab, asin as ac, acos as ad, max as ae, insertCluster as af, insertNode as ag, positionNode as ah, getLineFunctionsWithOffset as ai, evaluate as aj, createText as ak, getSubGraphTitleMargins as al, replaceIconSubstring as am, decodeEntities as an, getStylesFromArray as ao, Utils as ap, Color$1 as aq, markers_default as ar, clear2 as as, clear as at, clear$1 as au, updateNodeBounds as av, setNodeElem as aw, insertEdge as ax, positionEdgeLabel as ay, insertEdgeLabel as az, setAccTitle as b, define as b0, extend as b1, Color as b2, nogamma as b3, hue as b4, dayjs2 as b5, setToString as b6, overRest as b7, baseFor as b8, baseAssignValue as b9, isPrototype as bA, __vitePreload as bB, baseUnary as ba, merge as bb, isObjectLike as bc, baseGetTag as bd, Symbol$1 as be, arrayLikeKeys as bf, baseKeys as bg, memoize as bh, isArguments as bi, copyObject as bj, getPrototype as bk, cloneArrayBuffer as bl, cloneTypedArray as bm, getTag as bn, nodeUtil as bo, copyArray as bp, isBuffer as bq, cloneBuffer as br, initCloneObject as bs, Stack as bt, MapCache as bu, Uint8Array$1 as bv, isTypedArray as bw, isLength as bx, Set$1 as by, createAssigner as bz, getConfig2 as c, select as d, configureSvgSize as e, assignWithDepth_default as f, getAccDescription as g, calculateTextWidth as h, sanitizeText as i, distExports as j, common_default as k, log as l, calculateTextHeight as m, setConfig2 as n, getRegisteredLayoutAlgorithm as o, setDiagramTitle as p, getDiagramTitle as q, render$1 as r, setAccDescription as s, load as t, utils_default as u, isValidShape as v, wrapLabel as w, getEdgeId as x, clear$2 as y, defaultConfig2 as z };
//# sourceMappingURL=index-CwRyABEE.js.map
